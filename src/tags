!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
AARGLIST	structs.h	/^#define AARGLIST(/;"	d
ABBREV	vim.h	/^#define ABBREV	/;"	d
ABBR_OFF	keymap.h	/^#define ABBR_OFF	/;"	d
ABS	gui_at_fs.c	/^# undef ABS$/;"	d	file:
ABS	gui_at_fs.c	/^#define ABS(/;"	d	file:
ACTION_EXPAND	vim.h	/^# define ACTION_EXPAND	/;"	d
ACTION_GOTO	vim.h	/^#define ACTION_GOTO	/;"	d
ACTION_SHOW	vim.h	/^#define ACTION_SHOW	/;"	d
ACTION_SHOW_ALL	vim.h	/^#define ACTION_SHOW_ALL	/;"	d
ACTION_SPLIT	vim.h	/^#define ACTION_SPLIT	/;"	d
ADD_ICON	gui_gtk.c	/^#   define ADD_ICON(/;"	d	file:
ADD_ICON	gui_gtk.c	/^#   undef ADD_ICON$/;"	d	file:
ADD_NL	regexp.c	/^#define ADD_NL	/;"	d	file:
ADVANCE_REGINPUT	regexp.c	/^#define ADVANCE_REGINPUT(/;"	d	file:
AFT_CAPLONG	spell.c	/^#define AFT_CAPLONG	/;"	d	file:
AFT_CHAR	spell.c	/^#define AFT_CHAR	/;"	d	file:
AFT_LONG	spell.c	/^#define AFT_LONG	/;"	d	file:
AFT_NUM	spell.c	/^#define AFT_NUM	/;"	d	file:
AH_KEY_LEN	spell.c	/^# define AH_KEY_LEN /;"	d	file:
AKEYLEN	eval.c	/^#define AKEYLEN /;"	d	file:
ALEF	farsi.h	/^#define ALEF	/;"	d
ALEF_	farsi.h	/^#define ALEF_	/;"	d
ALEF_A	farsi.h	/^#define ALEF_A	/;"	d
ALEF_D_H	farsi.h	/^#define ALEF_D_H	/;"	d
ALEF_U_H	farsi.h	/^#define ALEF_U_H	/;"	d
ALEF_U_H_	farsi.h	/^#define ALEF_U_H_	/;"	d
ALIGN_LONG	structs.h	/^# define ALIGN_LONG	/;"	d
ALIGN_MASK	structs.h	/^#define ALIGN_MASK /;"	d
ALIGN_SIZE	structs.h	/^# define ALIGN_SIZE /;"	d
ALIST	structs.h	/^# define ALIST(/;"	d
ALL_BUILTIN_TCAPS	feature.h	/^#  define ALL_BUILTIN_TCAPS$/;"	d
ALPHA	regexp.c	/^#define ALPHA	/;"	d	file:
ALT_INPUT_LOCK_OFF	vim.h	/^# define ALT_INPUT_LOCK_OFF	/;"	d
ALT_INPUT_LOCK_ON	vim.h	/^# define ALT_INPUT_LOCK_ON	/;"	d
ALT_X_INPUT	feature.h	/^# define ALT_X_INPUT$/;"	d
ALWAYS_USE_GUI	gui.h	/^# define ALWAYS_USE_GUI$/;"	d
AL_ADD	ex_cmds2.c	/^#define AL_ADD	/;"	d	file:
AL_DEL	ex_cmds2.c	/^#define AL_DEL	/;"	d	file:
AL_SET	ex_cmds2.c	/^#define AL_SET	/;"	d	file:
ANY	regexp.c	/^#define ANY	/;"	d	file:
ANYBUT	regexp.c	/^#define ANYBUT	/;"	d	file:
ANYOF	regexp.c	/^#define ANYOF	/;"	d	file:
APPENDBIN	vim.h	/^# define APPENDBIN /;"	d
ARABIC_CHAR	arabic.h	/^#define ARABIC_CHAR(/;"	d
ARGCOUNT	structs.h	/^#define ARGCOUNT	/;"	d
ARGLIST	structs.h	/^#define ARGLIST	/;"	d
ARGOPT	ex_cmds.h	/^#define ARGOPT	/;"	d
ARGTYPE_EDIT	main.c	/^#define ARGTYPE_EDIT	/;"	d	file:
ARGTYPE_EDIT_WAIT	main.c	/^#define ARGTYPE_EDIT_WAIT	/;"	d	file:
ARGTYPE_OTHER	main.c	/^#define ARGTYPE_OTHER	/;"	d	file:
ARGTYPE_SEND	main.c	/^#define ARGTYPE_SEND	/;"	d	file:
ARG_BACKGROUND	gui_gtk_x11.c	/^#define ARG_BACKGROUND	/;"	d	file:
ARG_COMPAT_LONG	gui_gtk_x11.c	/^#define ARG_COMPAT_LONG	/;"	d	file:
ARG_FONT	gui_gtk_x11.c	/^#define ARG_FONT	/;"	d	file:
ARG_FOREGROUND	gui_gtk_x11.c	/^#define ARG_FOREGROUND	/;"	d	file:
ARG_FOR_GTK	gui_gtk_x11.c	/^#define ARG_FOR_GTK	/;"	d	file:
ARG_GEOMETRY	gui_gtk_x11.c	/^#define ARG_GEOMETRY	/;"	d	file:
ARG_HAS_VALUE	gui_gtk_x11.c	/^#define ARG_HAS_VALUE	/;"	d	file:
ARG_ICONIC	gui_gtk_x11.c	/^#define ARG_ICONIC	/;"	d	file:
ARG_INDEX_MASK	gui_gtk_x11.c	/^#define ARG_INDEX_MASK	/;"	d	file:
ARG_KEEP	gui_gtk_x11.c	/^#define ARG_KEEP	/;"	d	file:
ARG_MENUFONT	gui_gtk_x11.c	/^#define ARG_MENUFONT	/;"	d	file:
ARG_NEEDS_GUI	gui_gtk_x11.c	/^#define ARG_NEEDS_GUI	/;"	d	file:
ARG_NETBEANS	gui_gtk_x11.c	/^#define ARG_NETBEANS	/;"	d	file:
ARG_NOREVERSE	gui_gtk_x11.c	/^#define ARG_NOREVERSE	/;"	d	file:
ARG_REVERSE	gui_gtk_x11.c	/^#define ARG_REVERSE	/;"	d	file:
ARG_ROLE	gui_gtk_x11.c	/^#define ARG_ROLE	/;"	d	file:
ARG_XRM	gui_gtk_x11.c	/^#define ARG_XRM	/;"	d	file:
ASCII_ISALNUM	macros.h	/^# define ASCII_ISALNUM(/;"	d
ASCII_ISALPHA	macros.h	/^# define ASCII_ISALPHA(/;"	d
ASCII_ISLOWER	macros.h	/^# define ASCII_ISLOWER(/;"	d
ASCII_ISUPPER	macros.h	/^# define ASCII_ISUPPER(/;"	d
ASKMORE	vim.h	/^#define ASKMORE	/;"	d
ASSERT	nbdebug.h	/^# define ASSERT(/;"	d
ASSERT	nbdebug.h	/^#define ASSERT(/;"	d
ASSERT	workshop.h	/^#  define ASSERT(/;"	d
ASSERT	wsdebug.h	/^# define ASSERT(/;"	d
ASSERT	wsdebug.h	/^#define ASSERT(/;"	d
ATC_FROM_TERM	term.c	/^#define ATC_FROM_TERM /;"	d	file:
ATTR_OFF	syntax.c	/^#define ATTR_OFF /;"	d	file:
AT_CURSOR	farsi.h	/^#define AT_CURSOR /;"	d
AT_MAX	gui_at_sb.c	/^#define AT_MAX(/;"	d	file:
AT_MIN	gui_at_sb.c	/^#define AT_MIN(/;"	d	file:
AUGROUP_ALL	fileio.c	/^# define AUGROUP_ALL	/;"	d	file:
AUGROUP_DEFAULT	fileio.c	/^# define AUGROUP_DEFAULT /;"	d	file:
AUGROUP_ERROR	fileio.c	/^# define AUGROUP_ERROR	/;"	d	file:
AUGROUP_NAME	fileio.c	/^#define AUGROUP_NAME(/;"	d	file:
AUTOLOAD_CHAR	eval.c	/^#define AUTOLOAD_CHAR /;"	d	file:
AUTOMATA_CORRECT	hangulin.c	/^#define AUTOMATA_CORRECT	/;"	d	file:
AUTOMATA_CORRECT_NEW	hangulin.c	/^#define AUTOMATA_CORRECT_NEW	/;"	d	file:
AUTOMATA_ERROR	hangulin.c	/^#define AUTOMATA_ERROR	/;"	d	file:
AUTOMATA_NEW	hangulin.c	/^#define AUTOMATA_NEW	/;"	d	file:
AUTOMATA_NULL	hangulin.c	/^#define AUTOMATA_NULL	/;"	d	file:
AUTOMATA_SPECIAL	hangulin.c	/^#define AUTOMATA_SPECIAL	/;"	d	file:
AYN	farsi.h	/^#define AYN	/;"	d
AYN_	farsi.h	/^#define AYN_	/;"	d
A_firstc_laa	arabic.c	/^A_firstc_laa(c, c1)$/;"	f	file:
A_is_a	arabic.c	/^A_is_a(cur_c)$/;"	f	file:
A_is_f	arabic.c	/^A_is_f(cur_c)$/;"	f	file:
A_is_formb	arabic.c	/^A_is_formb(c)$/;"	f	file:
A_is_harakat	arabic.c	/^A_is_harakat(c)$/;"	f	file:
A_is_iso	arabic.c	/^A_is_iso(c)$/;"	f	file:
A_is_ok	arabic.c	/^A_is_ok(c)$/;"	f	file:
A_is_s	arabic.c	/^A_is_s(cur_c)$/;"	f	file:
A_is_special	arabic.c	/^A_is_special(c)$/;"	f	file:
A_is_valid	arabic.c	/^A_is_valid(c)$/;"	f	file:
Add	if_cscope.h	/^typedef enum { Add, Find, Help, Kill, Reset, Show } csid_e;$/;"	e	enum:__anon69
AllocBotShadowGC	gui_at_sb.c	/^AllocBotShadowGC(w)$/;"	f	file:
AllocTopShadowGC	gui_at_sb.c	/^AllocTopShadowGC(w)$/;"	f	file:
AppendCharToRedobuff	getchar.c	/^AppendCharToRedobuff(c)$/;"	f
AppendNumberToRedobuff	getchar.c	/^AppendNumberToRedobuff(n)$/;"	f
AppendPropCarefully	if_xcmdsrv.c	/^AppendPropCarefully(dpy, window, property, value, length)$/;"	f	file:
AppendToRedobuff	getchar.c	/^AppendToRedobuff(s)$/;"	f
AppendToRedobuffLit	getchar.c	/^AppendToRedobuffLit(str, len)$/;"	f
Apply_Info	if_mzsch.c	/^} Apply_Info;$/;"	t	typeref:struct:__anon26	file:
AutoCmd	fileio.c	/^typedef struct AutoCmd$/;"	s	file:
AutoCmd	fileio.c	/^} AutoCmd;$/;"	t	typeref:struct:AutoCmd	file:
AutoPat	fileio.c	/^typedef struct AutoPat$/;"	s	file:
AutoPat	fileio.c	/^} AutoPat;$/;"	t	typeref:struct:AutoPat	file:
AutoPatCmd	fileio.c	/^typedef struct AutoPatCmd$/;"	s	file:
AutoPatCmd	fileio.c	/^} AutoPatCmd;$/;"	t	typeref:struct:AutoPatCmd	file:
B0_DIRTY	memline.c	/^#define B0_DIRTY	/;"	d	file:
B0_FF_MASK	memline.c	/^#define B0_FF_MASK	/;"	d	file:
B0_FNAME_SIZE	memline.c	/^#define B0_FNAME_SIZE	/;"	d	file:
B0_FNAME_SIZE_ORG	memline.c	/^#define B0_FNAME_SIZE_ORG	/;"	d	file:
B0_HAS_FENC	memline.c	/^#define B0_HAS_FENC	/;"	d	file:
B0_HNAME_SIZE	memline.c	/^#define B0_HNAME_SIZE	/;"	d	file:
B0_MAGIC_CHAR	memline.c	/^#define B0_MAGIC_CHAR	/;"	d	file:
B0_MAGIC_INT	memline.c	/^#define B0_MAGIC_INT	/;"	d	file:
B0_MAGIC_LONG	memline.c	/^#define B0_MAGIC_LONG	/;"	d	file:
B0_MAGIC_SHORT	memline.c	/^#define B0_MAGIC_SHORT	/;"	d	file:
B0_SAME_DIR	memline.c	/^#define B0_SAME_DIR	/;"	d	file:
B0_UNAME_SIZE	memline.c	/^#define B0_UNAME_SIZE	/;"	d	file:
BACK	regexp.c	/^#define BACK	/;"	d	file:
BACKGROUND	gui_x11_pm.h	/^#define BACKGROUND	/;"	d
BACKPOS_INITIAL	regexp.c	/^#define BACKPOS_INITIAL	/;"	d	file:
BACKREF	regexp.c	/^#define BACKREF	/;"	d	file:
BACKSPACE_CHAR	edit.c	/^#define BACKSPACE_CHAR	/;"	d	file:
BACKSPACE_LINE	edit.c	/^#define BACKSPACE_LINE	/;"	d	file:
BACKSPACE_WORD	edit.c	/^#define BACKSPACE_WORD	/;"	d	file:
BACKSPACE_WORD_NOT_SPACE	edit.c	/^#define BACKSPACE_WORD_NOT_SPACE /;"	d	file:
BACKWARD	vim.h	/^#define BACKWARD	/;"	d
BACKWARD_FILE	vim.h	/^#define BACKWARD_FILE	/;"	d
BAD_DROP	vim.h	/^#define BAD_DROP	/;"	d
BAD_KEEP	vim.h	/^#define BAD_KEEP	/;"	d
BAD_REPLACE	vim.h	/^#define BAD_REPLACE	/;"	d
BANG	ex_cmds.h	/^#define BANG	/;"	d
BASENAMELEN	os_unix.h	/^#define BASENAMELEN	/;"	d
BC	term.c	/^char *UP, *BC, PC;$/;"	v
BC	termlib.c	/^char	*UP = 0, *BC = 0;     \/* Pointers to UP and BC strings from database *\/$/;"	v
BCO_ALWAYS	vim.h	/^#define BCO_ALWAYS	/;"	d
BCO_ENTER	vim.h	/^#define BCO_ENTER	/;"	d
BCO_NOHELP	vim.h	/^#define BCO_NOHELP	/;"	d
BE	farsi.h	/^#define BE	/;"	d
BEHIND	regexp.c	/^#define BEHIND	/;"	d	file:
BELL	ascii.h	/^#define BELL	/;"	d
BEVAL_NETBEANS	globals.h	/^#  define BEVAL_NETBEANS	/;"	d
BEVAL_WORKSHOP	globals.h	/^#  define BEVAL_WORKSHOP	/;"	d
BF_CHECK_RO	vim.h	/^#define BF_CHECK_RO	/;"	d
BF_DUMMY	vim.h	/^#define BF_DUMMY	/;"	d
BF_NEVERLOADED	vim.h	/^#define BF_NEVERLOADED	/;"	d
BF_NEW	vim.h	/^#define BF_NEW	/;"	d
BF_NEW_W	vim.h	/^#define BF_NEW_W	/;"	d
BF_NOTEDITED	vim.h	/^#define BF_NOTEDITED	/;"	d
BF_PRESERVED	vim.h	/^#define BF_PRESERVED	/;"	d
BF_READERR	vim.h	/^#define BF_READERR	/;"	d
BF_RECOVERED	vim.h	/^#define BF_RECOVERED	/;"	d
BF_WRITE_MASK	vim.h	/^#define BF_WRITE_MASK	/;"	d
BHPOS	regexp.c	/^#define BHPOS	/;"	d	file:
BH_DIRTY	structs.h	/^#define BH_DIRTY /;"	d
BH_LOCKED	structs.h	/^#define BH_LOCKED /;"	d
BINARY_FILE_IO	os_unix.h	/^# define BINARY_FILE_IO$/;"	d
BKC_AUTO	option.h	/^# define BKC_AUTO	/;"	d
BKC_BREAKHARDLINK	option.h	/^# define BKC_BREAKHARDLINK	/;"	d
BKC_BREAKSYMLINK	option.h	/^# define BKC_BREAKSYMLINK	/;"	d
BKC_NO	option.h	/^# define BKC_NO	/;"	d
BKC_YES	option.h	/^# define BKC_YES	/;"	d
BLINK_NONE	gui_gtk_x11.c	/^#define BLINK_NONE /;"	d	file:
BLINK_NONE	gui_x11.c	/^#define BLINK_NONE /;"	d	file:
BLINK_OFF	gui_gtk_x11.c	/^#define BLINK_OFF /;"	d	file:
BLINK_OFF	gui_x11.c	/^#define BLINK_OFF /;"	d	file:
BLINK_ON	gui_gtk_x11.c	/^#define BLINK_ON /;"	d	file:
BLINK_ON	gui_x11.c	/^#define BLINK_ON /;"	d	file:
BLN_CURBUF	vim.h	/^#define BLN_CURBUF	/;"	d
BLN_DUMMY	vim.h	/^#define BLN_DUMMY	/;"	d
BLN_LISTED	vim.h	/^#define BLN_LISTED	/;"	d
BLOCK0_ID0	memline.c	/^#define BLOCK0_ID0 /;"	d	file:
BLOCK0_ID1	memline.c	/^#define BLOCK0_ID1 /;"	d	file:
BL_FIX	vim.h	/^#define BL_FIX	/;"	d
BL_SOL	vim.h	/^#define BL_SOL	/;"	d
BL_WHITE	vim.h	/^#define BL_WHITE	/;"	d
BOL	regexp.c	/^#define BOL	/;"	d	file:
BOTTOM_SHADOW	gui_x11_pm.h	/^#define BOTTOM_SHADOW	/;"	d
BOW	regexp.c	/^#define BOW	/;"	d	file:
BRACE_AT_END	misc1.c	/^#define BRACE_AT_END	/;"	d	file:
BRACE_AT_START	misc1.c	/^#define BRACE_AT_START	/;"	d	file:
BRACE_COMPLEX	regexp.c	/^#define BRACE_COMPLEX	/;"	d	file:
BRACE_IN_COL0	misc1.c	/^#define BRACE_IN_COL0	/;"	d	file:
BRACE_LIMITS	regexp.c	/^#define BRACE_LIMITS	/;"	d	file:
BRACE_SIMPLE	regexp.c	/^#define BRACE_SIMPLE	/;"	d	file:
BRANCH	regexp.c	/^#define BRANCH	/;"	d	file:
BREAKCHECK_SKIP	misc1.c	/^#  define BREAKCHECK_SKIP /;"	d	file:
BREAKP	ex_cmds2.c	/^#define BREAKP(/;"	d	file:
BROWSE_DIR	vim.h	/^# define BROWSE_DIR /;"	d
BROWSE_FILTER_ALL_FILES	vim.h	/^#  define BROWSE_FILTER_ALL_FILES /;"	d
BROWSE_FILTER_DEFAULT	vim.h	/^#  define BROWSE_FILTER_DEFAULT /;"	d
BROWSE_FILTER_MACROS	vim.h	/^#  define BROWSE_FILTER_MACROS /;"	d
BROWSE_SAVE	vim.h	/^# define BROWSE_SAVE /;"	d
BS	ascii.h	/^#define BS	/;"	d
BS_EOL	option.h	/^#define BS_EOL	/;"	d
BS_INDENT	option.h	/^#define BS_INDENT	/;"	d
BS_START	option.h	/^#define BS_START	/;"	d
BT_EXTRA_KEYS	term.c	/^#define BT_EXTRA_KEYS	/;"	d	file:
BUFFER_SIZE	if_python.c	/^#define BUFFER_SIZE /;"	d	file:
BUFNAME	ex_cmds.h	/^#define BUFNAME	/;"	d
BUFSIZE	fileio.c	/^#define BUFSIZE	/;"	d	file:
BUFUNL	ex_cmds.h	/^#define BUFUNL	/;"	d
BUTTON_MASK	gui_xmebw.c	/^#define	BUTTON_MASK /;"	d	file:
BV_AI	option.h	/^    BV_AI = 0$/;"	e	enum:__anon73
BV_AR	option.h	/^    , BV_AR$/;"	e	enum:__anon73
BV_BEXPR	option.h	/^    , BV_BEXPR$/;"	e	enum:__anon73
BV_BH	option.h	/^    , BV_BH$/;"	e	enum:__anon73
BV_BIN	option.h	/^    , BV_BIN$/;"	e	enum:__anon73
BV_BL	option.h	/^    , BV_BL$/;"	e	enum:__anon73
BV_BOMB	option.h	/^    , BV_BOMB$/;"	e	enum:__anon73
BV_BT	option.h	/^    , BV_BT$/;"	e	enum:__anon73
BV_CFU	option.h	/^    , BV_CFU$/;"	e	enum:__anon73
BV_CI	option.h	/^    , BV_CI$/;"	e	enum:__anon73
BV_CIN	option.h	/^    , BV_CIN$/;"	e	enum:__anon73
BV_CINK	option.h	/^    , BV_CINK$/;"	e	enum:__anon73
BV_CINO	option.h	/^    , BV_CINO$/;"	e	enum:__anon73
BV_CINW	option.h	/^    , BV_CINW$/;"	e	enum:__anon73
BV_CMS	option.h	/^    , BV_CMS$/;"	e	enum:__anon73
BV_COM	option.h	/^    , BV_COM$/;"	e	enum:__anon73
BV_COUNT	option.h	/^    , BV_COUNT	    \/* must be the last one *\/$/;"	e	enum:__anon73
BV_CPT	option.h	/^    , BV_CPT$/;"	e	enum:__anon73
BV_DEF	option.h	/^    , BV_DEF$/;"	e	enum:__anon73
BV_DICT	option.h	/^    , BV_DICT$/;"	e	enum:__anon73
BV_EFM	option.h	/^    , BV_EFM$/;"	e	enum:__anon73
BV_EOL	option.h	/^    , BV_EOL$/;"	e	enum:__anon73
BV_EP	option.h	/^    , BV_EP$/;"	e	enum:__anon73
BV_ET	option.h	/^    , BV_ET$/;"	e	enum:__anon73
BV_FENC	option.h	/^    , BV_FENC$/;"	e	enum:__anon73
BV_FEX	option.h	/^    , BV_FEX$/;"	e	enum:__anon73
BV_FF	option.h	/^    , BV_FF$/;"	e	enum:__anon73
BV_FLP	option.h	/^    , BV_FLP$/;"	e	enum:__anon73
BV_FO	option.h	/^    , BV_FO$/;"	e	enum:__anon73
BV_FT	option.h	/^    , BV_FT$/;"	e	enum:__anon73
BV_GP	option.h	/^    , BV_GP$/;"	e	enum:__anon73
BV_IMI	option.h	/^    , BV_IMI$/;"	e	enum:__anon73
BV_IMS	option.h	/^    , BV_IMS$/;"	e	enum:__anon73
BV_INC	option.h	/^    , BV_INC$/;"	e	enum:__anon73
BV_INDE	option.h	/^    , BV_INDE$/;"	e	enum:__anon73
BV_INDK	option.h	/^    , BV_INDK$/;"	e	enum:__anon73
BV_INEX	option.h	/^    , BV_INEX$/;"	e	enum:__anon73
BV_INF	option.h	/^    , BV_INF$/;"	e	enum:__anon73
BV_ISK	option.h	/^    , BV_ISK$/;"	e	enum:__anon73
BV_KEY	option.h	/^    , BV_KEY$/;"	e	enum:__anon73
BV_KMAP	option.h	/^    , BV_KMAP$/;"	e	enum:__anon73
BV_KP	option.h	/^    , BV_KP$/;"	e	enum:__anon73
BV_LISP	option.h	/^    , BV_LISP$/;"	e	enum:__anon73
BV_MA	option.h	/^    , BV_MA$/;"	e	enum:__anon73
BV_ML	option.h	/^    , BV_ML$/;"	e	enum:__anon73
BV_MOD	option.h	/^    , BV_MOD$/;"	e	enum:__anon73
BV_MP	option.h	/^    , BV_MP$/;"	e	enum:__anon73
BV_MPS	option.h	/^    , BV_MPS$/;"	e	enum:__anon73
BV_NF	option.h	/^    , BV_NF$/;"	e	enum:__anon73
BV_OFT	option.h	/^    , BV_OFT$/;"	e	enum:__anon73
BV_OFU	option.h	/^    , BV_OFU$/;"	e	enum:__anon73
BV_PATH	option.h	/^    , BV_PATH$/;"	e	enum:__anon73
BV_PI	option.h	/^    , BV_PI$/;"	e	enum:__anon73
BV_QE	option.h	/^    , BV_QE$/;"	e	enum:__anon73
BV_RO	option.h	/^    , BV_RO$/;"	e	enum:__anon73
BV_SI	option.h	/^    , BV_SI$/;"	e	enum:__anon73
BV_SMC	option.h	/^    , BV_SMC$/;"	e	enum:__anon73
BV_SN	option.h	/^    , BV_SN$/;"	e	enum:__anon73
BV_SPC	option.h	/^    , BV_SPC$/;"	e	enum:__anon73
BV_SPF	option.h	/^    , BV_SPF$/;"	e	enum:__anon73
BV_SPL	option.h	/^    , BV_SPL$/;"	e	enum:__anon73
BV_STS	option.h	/^    , BV_STS$/;"	e	enum:__anon73
BV_SUA	option.h	/^    , BV_SUA$/;"	e	enum:__anon73
BV_SW	option.h	/^    , BV_SW$/;"	e	enum:__anon73
BV_SWF	option.h	/^    , BV_SWF$/;"	e	enum:__anon73
BV_SYN	option.h	/^    , BV_SYN$/;"	e	enum:__anon73
BV_TAGS	option.h	/^    , BV_TAGS$/;"	e	enum:__anon73
BV_TS	option.h	/^    , BV_TS$/;"	e	enum:__anon73
BV_TSR	option.h	/^    , BV_TSR$/;"	e	enum:__anon73
BV_TW	option.h	/^    , BV_TW$/;"	e	enum:__anon73
BV_TX	option.h	/^    , BV_TX$/;"	e	enum:__anon73
BV_WM	option.h	/^    , BV_WM$/;"	e	enum:__anon73
BY_FLAGS	spell.c	/^#define BY_FLAGS	/;"	d	file:
BY_FLAGS2	spell.c	/^#define BY_FLAGS2	/;"	d	file:
BY_INDEX	spell.c	/^#define BY_INDEX	/;"	d	file:
BY_NOFLAGS	spell.c	/^#define BY_NOFLAGS	/;"	d	file:
BY_SPECIAL	spell.c	/^#define BY_SPECIAL /;"	d	file:
B_IMODE_IM	structs.h	/^# define B_IMODE_IM /;"	d
B_IMODE_LAST	structs.h	/^# define B_IMODE_LAST /;"	d
B_IMODE_LMAP	structs.h	/^#define B_IMODE_LMAP /;"	d
B_IMODE_NONE	structs.h	/^#define B_IMODE_NONE /;"	d
B_IMODE_USE_INSERT	structs.h	/^#define B_IMODE_USE_INSERT /;"	d
B_SPELL	structs.h	/^# define B_SPELL(/;"	d
BalloonEval	gui_beval.h	/^} BalloonEval;$/;"	t	typeref:struct:BalloonEvalStruct
BalloonEval	proto.h	/^#   define BalloonEval /;"	d
BalloonEvalStruct	gui_beval.h	/^typedef struct BalloonEvalStruct$/;"	s
BeState	gui_beval.h	/^} BeState;$/;"	t	typeref:enum:__anon66
BorderHighlight	gui_xmebw.c	/^BorderHighlight(Widget w)$/;"	f	file:
BorderUnhighlight	gui_xmebw.c	/^BorderUnhighlight(Widget w)$/;"	f	file:
BufListAsSeq	if_python.c	/^static PySequenceMethods BufListAsSeq = {$/;"	v	file:
BufListItem	if_python.c	/^BufListItem(PyObject *self, PyInt n)$/;"	f	file:
BufListLength	if_python.c	/^BufListLength(PyObject *self)$/;"	f	file:
BufListObject	if_python.c	/^BufListObject;$/;"	t	typeref:struct:__anon33	file:
BufListType	if_python.c	/^static PyTypeObject BufListType = {$/;"	v	file:
BufferAppend	if_python.c	/^BufferAppend(PyObject *self, PyObject *args)$/;"	f	file:
BufferAsSeq	if_python.c	/^static PySequenceMethods BufferAsSeq = {$/;"	v	file:
BufferAssItem	if_python.c	/^BufferAssItem(PyObject *self, PyInt n, PyObject *val)$/;"	f	file:
BufferAssSlice	if_python.c	/^BufferAssSlice(PyObject *self, PyInt lo, PyInt hi, PyObject *val)$/;"	f	file:
BufferDestructor	if_python.c	/^BufferDestructor(PyObject *self)$/;"	f	file:
BufferGetattr	if_python.c	/^BufferGetattr(PyObject *self, char *name)$/;"	f	file:
BufferItem	if_python.c	/^BufferItem(PyObject *self, PyInt n)$/;"	f	file:
BufferLength	if_python.c	/^BufferLength(PyObject *self)$/;"	f	file:
BufferMark	if_python.c	/^BufferMark(PyObject *self, PyObject *args)$/;"	f	file:
BufferMethods	if_python.c	/^static struct PyMethodDef BufferMethods[] = {$/;"	v	typeref:struct:PyMethodDef	file:
BufferNew	if_python.c	/^BufferNew(buf_T *buf)$/;"	f	file:
BufferObject	if_python.c	/^BufferObject;$/;"	t	typeref:struct:__anon31	file:
BufferRange	if_python.c	/^BufferRange(PyObject *self, PyObject *args)$/;"	f	file:
BufferRepr	if_python.c	/^BufferRepr(PyObject *self)$/;"	f	file:
BufferSlice	if_python.c	/^BufferSlice(PyObject *self, PyInt lo, PyInt hi)$/;"	f	file:
BufferType	if_python.c	/^static PyTypeObject BufferType = {$/;"	v	file:
BufferType_Check	if_python.c	/^#define BufferType_Check(/;"	d	file:
ButtonData	gui_gtk.c	/^} ButtonData;$/;"	t	typeref:struct:_ButtonData	file:
CAR	ascii.h	/^#define CAR	/;"	d
CARDINAL	gui_x11.c	/^# define CARDINAL /;"	d	file:
CASE_INSENSITIVE_FILENAME	os_unix.h	/^# define CASE_INSENSITIVE_FILENAME$/;"	d
CA_COMMAND_BUSY	structs.h	/^#define CA_COMMAND_BUSY	/;"	d
CA_NO_ADJ_OP_END	structs.h	/^#define CA_NO_ADJ_OP_END /;"	d
CBUFLEN	misc1.c	/^#define CBUFLEN /;"	d	file:
CENT	syntax.c	/^# define CENT(/;"	d	file:
CF_UPPER	spell.c	/^#define CF_UPPER	/;"	d	file:
CF_WORD	spell.c	/^#define CF_WORD	/;"	d	file:
CHARSIZE	macros.h	/^#define CHARSIZE(/;"	d
CHAR_CELLS	screen.c	/^# define CHAR_CELLS /;"	d	file:
CHAR_CLASS	ui.c	/^#define CHAR_CLASS(/;"	d	file:
CHE	farsi.h	/^#define CHE	/;"	d
CHECK	memline.c	/^#define CHECK(/;"	d	file:
CHECK_CMDWIN	window.c	/^# define CHECK_CMDWIN /;"	d	file:
CHECK_DOUBLE_CLICK	vim.h	/^#  define CHECK_DOUBLE_CLICK /;"	d
CHECK_INODE	os_unix.h	/^#define CHECK_INODE	/;"	d
CHECK_INODE	vim.h	/^# undef	    CHECK_INODE$/;"	d
CHECK_PATH	vim.h	/^#define CHECK_PATH	/;"	d
CLASS_ALNUM	regexp.c	/^#define CLASS_ALNUM /;"	d	file:
CLASS_ALPHA	regexp.c	/^#define CLASS_ALPHA /;"	d	file:
CLASS_BACKSPACE	regexp.c	/^#define CLASS_BACKSPACE /;"	d	file:
CLASS_BLANK	regexp.c	/^#define CLASS_BLANK /;"	d	file:
CLASS_CNTRL	regexp.c	/^#define CLASS_CNTRL /;"	d	file:
CLASS_DIGIT	regexp.c	/^#define CLASS_DIGIT /;"	d	file:
CLASS_ESCAPE	regexp.c	/^#define CLASS_ESCAPE /;"	d	file:
CLASS_GRAPH	regexp.c	/^#define CLASS_GRAPH /;"	d	file:
CLASS_LOWER	regexp.c	/^#define CLASS_LOWER /;"	d	file:
CLASS_NONE	regexp.c	/^#define CLASS_NONE /;"	d	file:
CLASS_PRINT	regexp.c	/^#define CLASS_PRINT /;"	d	file:
CLASS_PUNCT	regexp.c	/^#define CLASS_PUNCT /;"	d	file:
CLASS_RETURN	regexp.c	/^#define CLASS_RETURN /;"	d	file:
CLASS_SPACE	regexp.c	/^#define CLASS_SPACE /;"	d	file:
CLASS_TAB	regexp.c	/^#define CLASS_TAB /;"	d	file:
CLASS_UPPER	regexp.c	/^#define CLASS_UPPER /;"	d	file:
CLASS_XDIGIT	regexp.c	/^#define CLASS_XDIGIT /;"	d	file:
CLEAR	vim.h	/^#define CLEAR	/;"	d
CLIP_CLEAR	ui.c	/^#define CLIP_CLEAR	/;"	d	file:
CLIP_SET	ui.c	/^#define CLIP_SET	/;"	d	file:
CLIP_TOGGLE	ui.c	/^#define CLIP_TOGGLE	/;"	d	file:
CLUSTER_ADD	syntax.c	/^#define CLUSTER_ADD	/;"	d	file:
CLUSTER_REPLACE	syntax.c	/^#define CLUSTER_REPLACE	/;"	d	file:
CLUSTER_SUBTRACT	syntax.c	/^#define CLUSTER_SUBTRACT /;"	d	file:
CMDBUFFSIZE	os_unix.h	/^#define CMDBUFFSIZE /;"	d
CMDBUFFSIZE	vim.h	/^# define CMDBUFFSIZE	/;"	d
CMDBUFSIZ	integration.c	/^#define CMDBUFSIZ	/;"	d	file:
CMDLINE	vim.h	/^#define CMDLINE	/;"	d
CMDWIN	ex_cmds.h	/^#define CMDWIN	/;"	d
CMD_CONT	ex_cmds2.c	/^#define CMD_CONT	/;"	d	file:
CMD_FINISH	ex_cmds2.c	/^#define CMD_FINISH	/;"	d	file:
CMD_INTERRUPT	ex_cmds2.c	/^#define CMD_INTERRUPT	/;"	d	file:
CMD_NEXT	ex_cmds2.c	/^#define CMD_NEXT	/;"	d	file:
CMD_QUIT	ex_cmds2.c	/^#define CMD_QUIT	/;"	d	file:
CMD_STEP	ex_cmds2.c	/^#define CMD_STEP	/;"	d	file:
CMP_INTERNAL	option.h	/^# define CMP_INTERNAL	/;"	d
CMP_KEEPASCII	option.h	/^# define CMP_KEEPASCII	/;"	d
CNT	spell.c	/^#define CNT(/;"	d	file:
COL_RULER	option.c	/^#define COL_RULER /;"	d	file:
COMP_CHECKCASE	spell.c	/^#define COMP_CHECKCASE	/;"	d	file:
COMP_CHECKDUP	spell.c	/^#define COMP_CHECKDUP	/;"	d	file:
COMP_CHECKREP	spell.c	/^#define COMP_CHECKREP	/;"	d	file:
COMP_CHECKTRIPLE	spell.c	/^#define COMP_CHECKTRIPLE	/;"	d	file:
COM_ALL	option.h	/^#define COM_ALL	/;"	d
COM_AUTO_END	option.h	/^#define COM_AUTO_END	/;"	d
COM_BLANK	option.h	/^#define COM_BLANK	/;"	d
COM_END	option.h	/^#define COM_END	/;"	d
COM_FIRST	option.h	/^#define COM_FIRST	/;"	d
COM_LEFT	option.h	/^#define COM_LEFT	/;"	d
COM_MAX_LEN	option.h	/^#define COM_MAX_LEN	/;"	d
COM_MIDDLE	option.h	/^#define COM_MIDDLE	/;"	d
COM_NEST	option.h	/^#define COM_NEST	/;"	d
COM_NOBACK	option.h	/^#define COM_NOBACK	/;"	d
COM_RIGHT	option.h	/^#define COM_RIGHT	/;"	d
COM_START	option.h	/^#define COM_START	/;"	d
CONDIT_AFF	spell.c	/^#define CONDIT_AFF	/;"	d	file:
CONDIT_CFIX	spell.c	/^#define CONDIT_CFIX	/;"	d	file:
CONDIT_COMB	spell.c	/^#define CONDIT_COMB	/;"	d	file:
CONDIT_SUF	spell.c	/^#define CONDIT_SUF	/;"	d	file:
CONFIRM	vim.h	/^#define CONFIRM	/;"	d
CONST84	if_tcl.c	/^# define CONST84$/;"	d	file:
CONT_ADDING	globals.h	/^# define CONT_ADDING	/;"	d
CONT_INTRPT	globals.h	/^# define CONT_INTRPT	/;"	d
CONT_LOCAL	globals.h	/^# define CONT_LOCAL	/;"	d
CONT_N_ADDS	globals.h	/^# define CONT_N_ADDS	/;"	d
CONT_SOL	globals.h	/^# define CONT_SOL	/;"	d
CONT_S_IPOS	globals.h	/^# define CONT_S_IPOS	/;"	d
CONV	gui_gtk.c	/^#   define CONV(/;"	d	file:
CONV	gui_gtk.c	/^#undef CONV$/;"	d	file:
CONVERT_FROM_UTF8	gui.h	/^# define CONVERT_FROM_UTF8(/;"	d
CONVERT_FROM_UTF8_FREE	gui.h	/^# define CONVERT_FROM_UTF8_FREE(/;"	d
CONVERT_TO_UTF8	gui.h	/^# define CONVERT_TO_UTF8(/;"	d
CONVERT_TO_UTF8_FREE	gui.h	/^# define CONVERT_TO_UTF8_FREE(/;"	d
CONV_9_TO_UTF8	structs.h	/^#define CONV_9_TO_UTF8	/;"	d
CONV_CODEPAGE	structs.h	/^# define CONV_CODEPAGE	/;"	d
CONV_ICONV	structs.h	/^#define CONV_ICONV	/;"	d
CONV_LATIN1_MAC	structs.h	/^# define CONV_LATIN1_MAC	/;"	d
CONV_MAC_LATIN1	structs.h	/^# define CONV_MAC_LATIN1	/;"	d
CONV_MAC_UTF8	structs.h	/^# define CONV_MAC_UTF8	/;"	d
CONV_NONE	structs.h	/^#define CONV_NONE	/;"	d
CONV_RESTLEN	fileio.c	/^#define CONV_RESTLEN /;"	d	file:
CONV_TO_LATIN1	structs.h	/^#define CONV_TO_LATIN1	/;"	d
CONV_TO_LATIN9	structs.h	/^#define CONV_TO_LATIN9	/;"	d
CONV_TO_UTF8	structs.h	/^#define CONV_TO_UTF8	/;"	d
CONV_UTF8_MAC	structs.h	/^# define CONV_UTF8_MAC	/;"	d
COUNT	ex_cmds.h	/^#define COUNT	/;"	d
CPO_ALL	option.h	/^#define CPO_ALL	/;"	d
CPO_ALTREAD	option.h	/^#define CPO_ALTREAD	/;"	d
CPO_ALTWRITE	option.h	/^#define CPO_ALTWRITE	/;"	d
CPO_BACKSL	option.h	/^#define CPO_BACKSL	/;"	d
CPO_BACKSPACE	option.h	/^#define CPO_BACKSPACE	/;"	d
CPO_BAR	option.h	/^#define CPO_BAR	/;"	d
CPO_BSLASH	option.h	/^#define CPO_BSLASH	/;"	d
CPO_BUFOPT	option.h	/^#define CPO_BUFOPT	/;"	d
CPO_BUFOPTGLOB	option.h	/^#define CPO_BUFOPTGLOB	/;"	d
CPO_CHDIR	option.h	/^#define CPO_CHDIR	/;"	d
CPO_CONCAT	option.h	/^#define CPO_CONCAT	/;"	d
CPO_CW	option.h	/^#define CPO_CW	/;"	d
CPO_DIGRAPH	option.h	/^#define CPO_DIGRAPH	/;"	d
CPO_DOLLAR	option.h	/^#define CPO_DOLLAR	/;"	d
CPO_DOTTAG	option.h	/^#define CPO_DOTTAG	/;"	d
CPO_EMPTYREGION	option.h	/^#define CPO_EMPTYREGION	/;"	d
CPO_ENDOFSENT	option.h	/^#define CPO_ENDOFSENT	/;"	d
CPO_ESC	option.h	/^#define CPO_ESC	/;"	d
CPO_EXECBUF	option.h	/^#define CPO_EXECBUF	/;"	d
CPO_FILTER	option.h	/^#define CPO_FILTER	/;"	d
CPO_FNAMEAPP	option.h	/^#define CPO_FNAMEAPP	/;"	d
CPO_FNAMER	option.h	/^#define CPO_FNAMER	/;"	d
CPO_FNAMEW	option.h	/^#define CPO_FNAMEW	/;"	d
CPO_FWRITE	option.h	/^#define CPO_FWRITE	/;"	d
CPO_GOTO1	option.h	/^#define CPO_GOTO1	/;"	d
CPO_HASH	option.h	/^#define CPO_HASH	/;"	d
CPO_INDENT	option.h	/^#define CPO_INDENT	/;"	d
CPO_INSEND	option.h	/^#define CPO_INSEND	/;"	d
CPO_INTMOD	option.h	/^#define CPO_INTMOD	/;"	d
CPO_JOINCOL	option.h	/^#define CPO_JOINCOL	/;"	d
CPO_JOINSP	option.h	/^#define CPO_JOINSP	/;"	d
CPO_KEEPRO	option.h	/^#define CPO_KEEPRO	/;"	d
CPO_KEYCODE	option.h	/^#define CPO_KEYCODE	/;"	d
CPO_KOFFSET	option.h	/^#define CPO_KOFFSET	/;"	d
CPO_LINEOFF	option.h	/^#define CPO_LINEOFF	/;"	d
CPO_LISP	option.h	/^#define CPO_LISP	/;"	d
CPO_LISTWM	option.h	/^#define CPO_LISTWM	/;"	d
CPO_LITERAL	option.h	/^#define CPO_LITERAL	/;"	d
CPO_MATCH	option.h	/^#define CPO_MATCH	/;"	d
CPO_MATCHBSL	option.h	/^#define CPO_MATCHBSL	/;"	d
CPO_MINUS	option.h	/^#define CPO_MINUS	/;"	d
CPO_NUMCOL	option.h	/^#define CPO_NUMCOL	/;"	d
CPO_OVERNEW	option.h	/^#define CPO_OVERNEW	/;"	d
CPO_PARA	option.h	/^#define CPO_PARA	/;"	d
CPO_PLUS	option.h	/^#define CPO_PLUS	/;"	d
CPO_PRESERVE	option.h	/^#define CPO_PRESERVE	/;"	d
CPO_REDO	option.h	/^#define CPO_REDO	/;"	d
CPO_REGAPPEND	option.h	/^#define CPO_REGAPPEND	/;"	d
CPO_REMMARK	option.h	/^#define CPO_REMMARK	/;"	d
CPO_REPLCNT	option.h	/^#define CPO_REPLCNT	/;"	d
CPO_SEARCH	option.h	/^#define CPO_SEARCH	/;"	d
CPO_SHOWMATCH	option.h	/^#define CPO_SHOWMATCH	/;"	d
CPO_SPECI	option.h	/^#define CPO_SPECI	/;"	d
CPO_STAR	option.h	/^#define CPO_STAR	/;"	d
CPO_SUBPERCENT	option.h	/^#define CPO_SUBPERCENT	/;"	d
CPO_TAGPAT	option.h	/^#define CPO_TAGPAT	/;"	d
CPO_TSIZE	option.h	/^#define CPO_TSIZE	/;"	d
CPO_UNDO	option.h	/^#define CPO_UNDO	/;"	d
CPO_VI	option.h	/^#define CPO_VI	/;"	d
CPO_VIM	option.h	/^#define CPO_VIM	/;"	d
CPO_YANK	option.h	/^#define CPO_YANK	/;"	d
CPT_ABBR	structs.h	/^#define CPT_ABBR /;"	d
CPT_COUNT	structs.h	/^#define CPT_COUNT /;"	d
CPT_INFO	structs.h	/^#define CPT_INFO /;"	d
CPT_KIND	structs.h	/^#define CPT_KIND /;"	d
CPT_MENU	structs.h	/^#define CPT_MENU /;"	d
CP_UTF8	mbyte.c	/^# define CP_UTF8 /;"	d	file:
CRC32	misc2.c	/^#define CRC32(/;"	d	file:
CREATE_DUMMY_FILE	memline.c	/^# define CREATE_DUMMY_FILE$/;"	d	file:
CRV_GET	term.c	/^#  define CRV_GET	/;"	d	file:
CRV_GOT	term.c	/^#  define CRV_GOT	/;"	d	file:
CRV_SENT	term.c	/^#  define CRV_SENT	/;"	d	file:
CRYPT_MAGIC	fileio.c	/^# define CRYPT_MAGIC	/;"	d	file:
CRYPT_MAGIC_LEN	fileio.c	/^# define CRYPT_MAGIC_LEN	/;"	d	file:
CSCOPE_DBFILE	if_cscope.h	/^#define	CSCOPE_DBFILE	/;"	d
CSCOPE_FAILURE	if_cscope.h	/^#define CSCOPE_FAILURE	/;"	d
CSCOPE_MAX_CONNECTIONS	if_cscope.h	/^#define CSCOPE_MAX_CONNECTIONS	/;"	d
CSCOPE_PROMPT	if_cscope.h	/^#define	CSCOPE_PROMPT	/;"	d
CSCOPE_SUCCESS	if_cscope.h	/^#define CSCOPE_SUCCESS	/;"	d
CSF_ACTIVE	structs.h	/^# define CSF_ACTIVE	/;"	d
CSF_CAUGHT	structs.h	/^# define CSF_CAUGHT	/;"	d
CSF_ELSE	structs.h	/^# define CSF_ELSE	/;"	d
CSF_FINALLY	structs.h	/^# define CSF_FINALLY	/;"	d
CSF_FOR	structs.h	/^# define CSF_FOR	/;"	d
CSF_SILENT	structs.h	/^# define CSF_SILENT	/;"	d
CSF_THROWN	structs.h	/^# define CSF_THROWN	/;"	d
CSF_TRUE	structs.h	/^# define CSF_TRUE	/;"	d
CSF_TRY	structs.h	/^# define CSF_TRY	/;"	d
CSF_WHILE	structs.h	/^# define CSF_WHILE	/;"	d
CSI	ascii.h	/^#define CSI	/;"	d
CSI_STR	ascii.h	/^#define CSI_STR	/;"	d
CSL_HAD_CONT	structs.h	/^# define CSL_HAD_CONT	/;"	d
CSL_HAD_ENDLOOP	structs.h	/^# define CSL_HAD_ENDLOOP /;"	d
CSL_HAD_FINA	structs.h	/^# define CSL_HAD_FINA	/;"	d
CSL_HAD_LOOP	structs.h	/^# define CSL_HAD_LOOP	/;"	d
CSQF_CMDS	option.h	/^#  define	CSQF_CMDS /;"	d
CSQF_FLAGS	option.h	/^#  define	CSQF_FLAGS /;"	d
CSREAD_BUFSIZE	if_cscope.c	/^#define	CSREAD_BUFSIZE	/;"	d	file:
CSTACK_LEN	structs.h	/^#define CSTACK_LEN	/;"	d
CSTP_BREAK	structs.h	/^# define CSTP_BREAK	/;"	d
CSTP_CONTINUE	structs.h	/^# define CSTP_CONTINUE	/;"	d
CSTP_ERROR	structs.h	/^# define CSTP_ERROR	/;"	d
CSTP_FINISH	structs.h	/^# define CSTP_FINISH	/;"	d
CSTP_INTERRUPT	structs.h	/^# define CSTP_INTERRUPT	/;"	d
CSTP_NONE	structs.h	/^# define CSTP_NONE	/;"	d
CSTP_RETURN	structs.h	/^# define CSTP_RETURN	/;"	d
CSTP_THROW	structs.h	/^# define CSTP_THROW	/;"	d
CS_B5	hardcopy.c	/^#define CS_B5	/;"	d	file:
CS_CNS_PLANE_1	hardcopy.c	/^#define CS_CNS_PLANE_1 /;"	d	file:
CS_CNS_PLANE_1_2	hardcopy.c	/^#define CS_CNS_PLANE_1_2 /;"	d	file:
CS_CNS_PLANE_2	hardcopy.c	/^#define CS_CNS_PLANE_2 /;"	d	file:
CS_CP932	hardcopy.c	/^#define CS_CP932	/;"	d	file:
CS_DLHKL	hardcopy.c	/^#define CS_DLHKL	/;"	d	file:
CS_DLHKS	hardcopy.c	/^#define CS_DLHKS	/;"	d	file:
CS_ETEN	hardcopy.c	/^#define CS_ETEN	/;"	d	file:
CS_GBK	hardcopy.c	/^#define CS_GBK	/;"	d	file:
CS_GBK2K	hardcopy.c	/^#define CS_GBK2K	/;"	d	file:
CS_GBT_12345_90	hardcopy.c	/^#define CS_GBT_12345_90 /;"	d	file:
CS_GBT_90_MAC	hardcopy.c	/^#define CS_GBT_90_MAC	/;"	d	file:
CS_GB_2312_80	hardcopy.c	/^#define CS_GB_2312_80 /;"	d	file:
CS_HK_GCCS	hardcopy.c	/^#define CS_HK_GCCS	/;"	d	file:
CS_HK_SCS	hardcopy.c	/^#define CS_HK_SCS	/;"	d	file:
CS_HK_SCS_ETEN	hardcopy.c	/^#define CS_HK_SCS_ETEN	/;"	d	file:
CS_JIS_C_1978	hardcopy.c	/^#define CS_JIS_C_1978 /;"	d	file:
CS_JIS_X_1983	hardcopy.c	/^#define CS_JIS_X_1983 /;"	d	file:
CS_JIS_X_1990	hardcopy.c	/^#define CS_JIS_X_1990 /;"	d	file:
CS_KANJITALK6	hardcopy.c	/^#define CS_KANJITALK6	/;"	d	file:
CS_KANJITALK7	hardcopy.c	/^#define CS_KANJITALK7 /;"	d	file:
CS_KR_ISO10646	hardcopy.c	/^#define CS_KR_ISO10646 /;"	d	file:
CS_KR_MAC	hardcopy.c	/^#define CS_KR_MAC	/;"	d	file:
CS_KR_X_1992	hardcopy.c	/^#define CS_KR_X_1992	/;"	d	file:
CS_KR_X_1992_MS	hardcopy.c	/^#define CS_KR_X_1992_MS /;"	d	file:
CS_MSWINDOWS	hardcopy.c	/^#define CS_MSWINDOWS	/;"	d	file:
CS_MTHKL	hardcopy.c	/^#define CS_MTHKL	/;"	d	file:
CS_MTHKS	hardcopy.c	/^#define CS_MTHKS	/;"	d	file:
CS_NEC	hardcopy.c	/^#define CS_NEC	/;"	d	file:
CS_SC_ISO10646	hardcopy.c	/^#define CS_SC_ISO10646 /;"	d	file:
CS_SC_MAC	hardcopy.c	/^#define CS_SC_MAC	/;"	d	file:
CS_TC_ISO10646	hardcopy.c	/^#define CS_TC_ISO10646	/;"	d	file:
CTERM_ATTR_ENTRY	syntax.c	/^#define CTERM_ATTR_ENTRY(/;"	d	file:
CTRL_F_STR	ascii.h	/^#define CTRL_F_STR	/;"	d
CTRL_H_STR	ascii.h	/^#define CTRL_H_STR	/;"	d
CTRL_V_STR	ascii.h	/^#define CTRL_V_STR	/;"	d
CTRL_X_CMDLINE	edit.c	/^#define CTRL_X_CMDLINE	/;"	d	file:
CTRL_X_DICTIONARY	edit.c	/^#define CTRL_X_DICTIONARY	/;"	d	file:
CTRL_X_FILES	edit.c	/^#define CTRL_X_FILES	/;"	d	file:
CTRL_X_FINISHED	edit.c	/^#define CTRL_X_FINISHED	/;"	d	file:
CTRL_X_FUNCTION	edit.c	/^#define CTRL_X_FUNCTION	/;"	d	file:
CTRL_X_LOCAL_MSG	edit.c	/^#define CTRL_X_LOCAL_MSG	/;"	d	file:
CTRL_X_MSG	edit.c	/^#define CTRL_X_MSG(/;"	d	file:
CTRL_X_NOT_DEFINED_YET	edit.c	/^#define CTRL_X_NOT_DEFINED_YET	/;"	d	file:
CTRL_X_OMNI	edit.c	/^#define CTRL_X_OMNI	/;"	d	file:
CTRL_X_PATH_DEFINES	edit.c	/^#define CTRL_X_PATH_DEFINES	/;"	d	file:
CTRL_X_PATH_PATTERNS	edit.c	/^#define CTRL_X_PATH_PATTERNS	/;"	d	file:
CTRL_X_SCROLL	edit.c	/^#define CTRL_X_SCROLL	/;"	d	file:
CTRL_X_SPELL	edit.c	/^#define CTRL_X_SPELL	/;"	d	file:
CTRL_X_TAGS	edit.c	/^#define CTRL_X_TAGS	/;"	d	file:
CTRL_X_THESAURUS	edit.c	/^#define CTRL_X_THESAURUS	/;"	d	file:
CTRL_X_WANT_IDENT	edit.c	/^#define CTRL_X_WANT_IDENT	/;"	d	file:
CTRL_X_WHOLE_LINE	edit.c	/^#define CTRL_X_WHOLE_LINE	/;"	d	file:
CT_CELL_MASK	vim.h	/^#define CT_CELL_MASK	/;"	d
CT_FNAME_CHAR	vim.h	/^#define CT_FNAME_CHAR	/;"	d
CT_ID_CHAR	vim.h	/^#define CT_ID_CHAR	/;"	d
CT_PRINT_CHAR	vim.h	/^#define CT_PRINT_CHAR	/;"	d
CURSOR	regexp.c	/^#define CURSOR	/;"	d	file:
CURSOR_BAR_RIGHT	macros.h	/^# define CURSOR_BAR_RIGHT /;"	d
CURSOR_MOVED	vim.h	/^# define CURSOR_MOVED	/;"	d
CURSOR_SHAPE	feature.h	/^# define CURSOR_SHAPE$/;"	d
CUR_STATE	syntax.c	/^#define CUR_STATE(/;"	d	file:
CV	proto.h	/^# define CV /;"	d
CancelData	gui_gtk.c	/^# define CancelData /;"	d	file:
CancelData	gui_gtk.c	/^} CancelData;$/;"	t	typeref:struct:_CancelData	file:
CharOrd	ascii.h	/^#define CharOrd(/;"	d
CharOrdLow	ascii.h	/^#define CharOrdLow(/;"	d
CharOrdUp	ascii.h	/^#define CharOrdUp(/;"	d
CharOrd__	ascii.h	/^#define CharOrd__(/;"	d
Check	gui_at_sb.c	/^#define Check(/;"	d	file:
Check	gui_at_sb.c	/^#undef Check$/;"	d	file:
CheckBuffer	if_python.c	/^CheckBuffer(BufferObject *this)$/;"	f	file:
CheckWindow	if_python.c	/^CheckWindow(WindowObject *this)$/;"	f	file:
ClassInitialize	gui_at_sb.c	/^ClassInitialize()$/;"	f	file:
Cmd_Info	if_mzsch.c	/^} Cmd_Info;$/;"	t	typeref:struct:__anon25	file:
Columns	globals.h	/^EXTERN long	Columns INIT(= 80);	\/* nr of columns in the screen *\/$/;"	v
CompareEvents	gui_at_sb.c	/^CompareEvents(oldEvent, newEvent)$/;"	f	file:
CreateGC	gui_at_sb.c	/^CreateGC(w)$/;"	f	file:
CtrlChar	ascii.h	/^#define CtrlChar(/;"	d
CtrlCharTable	os_unix.c	/^char CtrlCharTable[]=$/;"	v
CtrlTable	os_unix.c	/^char CtrlTable[] =$/;"	v
Ctrl_A	ascii.h	/^#define Ctrl_A	/;"	d
Ctrl_AT	ascii.h	/^#define Ctrl_AT	/;"	d
Ctrl_B	ascii.h	/^#define Ctrl_B	/;"	d
Ctrl_BSL	ascii.h	/^#define Ctrl_BSL	/;"	d
Ctrl_C	ascii.h	/^#define Ctrl_C	/;"	d
Ctrl_D	ascii.h	/^#define Ctrl_D	/;"	d
Ctrl_E	ascii.h	/^#define Ctrl_E	/;"	d
Ctrl_F	ascii.h	/^#define Ctrl_F	/;"	d
Ctrl_G	ascii.h	/^#define Ctrl_G	/;"	d
Ctrl_H	ascii.h	/^#define Ctrl_H	/;"	d
Ctrl_HAT	ascii.h	/^#define Ctrl_HAT	/;"	d
Ctrl_I	ascii.h	/^#define Ctrl_I	/;"	d
Ctrl_J	ascii.h	/^#define Ctrl_J	/;"	d
Ctrl_K	ascii.h	/^#define Ctrl_K	/;"	d
Ctrl_L	ascii.h	/^#define Ctrl_L	/;"	d
Ctrl_M	ascii.h	/^#define Ctrl_M	/;"	d
Ctrl_N	ascii.h	/^#define Ctrl_N	/;"	d
Ctrl_O	ascii.h	/^#define Ctrl_O	/;"	d
Ctrl_P	ascii.h	/^#define Ctrl_P	/;"	d
Ctrl_Q	ascii.h	/^#define Ctrl_Q	/;"	d
Ctrl_R	ascii.h	/^#define Ctrl_R	/;"	d
Ctrl_RSB	ascii.h	/^#define Ctrl_RSB	/;"	d
Ctrl_S	ascii.h	/^#define Ctrl_S	/;"	d
Ctrl_T	ascii.h	/^#define Ctrl_T	/;"	d
Ctrl_U	ascii.h	/^#define Ctrl_U	/;"	d
Ctrl_V	ascii.h	/^#define Ctrl_V	/;"	d
Ctrl_W	ascii.h	/^#define Ctrl_W	/;"	d
Ctrl_X	ascii.h	/^#define Ctrl_X	/;"	d
Ctrl_Y	ascii.h	/^#define Ctrl_Y	/;"	d
Ctrl_Z	ascii.h	/^#define Ctrl_Z	/;"	d
Ctrl__	ascii.h	/^#define Ctrl__	/;"	d
Ctrl_chr	ascii.h	/^#define Ctrl_chr(/;"	d
CurrentGetattr	if_python.c	/^CurrentGetattr(PyObject *self, char *name)$/;"	f	file:
CurrentObject	if_python.c	/^CurrentObject;$/;"	t	typeref:struct:__anon35	file:
CurrentSetattr	if_python.c	/^CurrentSetattr(PyObject *self, char *name, PyObject *value)$/;"	f	file:
CurrentType	if_python.c	/^static PyTypeObject CurrentType = {$/;"	v	file:
DAL	farsi.h	/^#define DAL	/;"	d
DATA_BL	memline.c	/^typedef struct data_block	DATA_BL;    \/* contents of a data block *\/$/;"	t	typeref:struct:data_block	file:
DATA_ID	memline.c	/^#define DATA_ID	/;"	d	file:
DBCS_2BYTE	globals.h	/^# define DBCS_2BYTE	/;"	d
DBCS_CHS	globals.h	/^# define DBCS_CHS	/;"	d
DBCS_CHSU	globals.h	/^# define DBCS_CHSU	/;"	d
DBCS_CHT	globals.h	/^# define DBCS_CHT	/;"	d
DBCS_CHTU	globals.h	/^# define DBCS_CHTU	/;"	d
DBCS_DEBUG	globals.h	/^# define DBCS_DEBUG	/;"	d
DBCS_JPN	globals.h	/^# define DBCS_JPN	/;"	d
DBCS_JPNU	globals.h	/^# define DBCS_JPNU	/;"	d
DBCS_KOR	globals.h	/^# define DBCS_KOR	/;"	d
DBCS_KORU	globals.h	/^# define DBCS_KORU	/;"	d
DBG_FILE	ex_cmds2.c	/^#define DBG_FILE	/;"	d	file:
DBG_FUNC	ex_cmds2.c	/^#define DBG_FUNC	/;"	d	file:
DB_COUNT	structs.h	/^# define DB_COUNT /;"	d
DB_INDEX_MASK	memline.c	/^#define DB_INDEX_MASK	/;"	d	file:
DB_MARKED	memline.c	/^#define DB_MARKED	/;"	d	file:
DCS	ascii.h	/^#define DCS	/;"	d
DEBUG	regexp.c	/^#undef DEBUG$/;"	d	file:
DEBUG	vim.h	/^#  undef DEBUG$/;"	d
DEBUGGY	ex_cmds2.c	/^#define DEBUGGY(/;"	d	file:
DEFAULT_FONT	gui_gtk_x11.c	/^# define DEFAULT_FONT	/;"	d	file:
DEFAULT_TERM	term.c	/^# define DEFAULT_TERM	/;"	d	file:
DEFAULT_TERM	term.c	/^# undef DEFAULT_TERM$/;"	d	file:
DEL	ascii.h	/^#define DEL	/;"	d
DELETE_WINDOW_IDX	gui_x11.c	/^#define DELETE_WINDOW_IDX /;"	d	file:
DELETION_REGISTER	ops.c	/^#define DELETION_REGISTER	/;"	d	file:
DEL_STR	ascii.h	/^#define DEL_STR	/;"	d
DESC	os_unix.h	/^typedef struct dsc$descriptor   DESC;$/;"	t	typeref:struct:dsc$descriptor
DFLALL	ex_cmds.h	/^#define	DFLALL	/;"	d
DFLT_BDIR	os_unix.h	/^#   define DFLT_BDIR /;"	d
DFLT_BDIR	os_unix.h	/^#  define DFLT_BDIR /;"	d
DFLT_DIR	os_unix.h	/^#   define DFLT_DIR /;"	d
DFLT_DIR	os_unix.h	/^#  define DFLT_DIR /;"	d
DFLT_EFM	option.h	/^#     define DFLT_EFM	/;"	d
DFLT_EFM	option.h	/^#    define DFLT_EFM	/;"	d
DFLT_EFM	option.h	/^#   define DFLT_EFM	/;"	d
DFLT_EFM	option.h	/^#  define DFLT_EFM	/;"	d
DFLT_EFM	option.h	/^# define DFLT_EFM	/;"	d
DFLT_EFM	option.h	/^#define DFLT_EFM	/;"	d
DFLT_ERRORFILE	os_unix.h	/^#define DFLT_ERRORFILE	/;"	d
DFLT_FF	option.h	/^#  define DFLT_FF	/;"	d
DFLT_FF	option.h	/^# define DFLT_FF	/;"	d
DFLT_FFS_VI	option.h	/^#   define DFLT_FFS_VI	/;"	d
DFLT_FFS_VI	option.h	/^#  define DFLT_FFS_VI	/;"	d
DFLT_FFS_VI	option.h	/^# define DFLT_FFS_VI	/;"	d
DFLT_FFS_VIM	option.h	/^#  define DFLT_FFS_VIM	/;"	d
DFLT_FFS_VIM	option.h	/^# define DFLT_FFS_VIM	/;"	d
DFLT_FONT	gui_x11.c	/^#define DFLT_FONT	/;"	d	file:
DFLT_FO_VI	option.h	/^#define DFLT_FO_VI	/;"	d
DFLT_FO_VIM	option.h	/^#define DFLT_FO_VIM	/;"	d
DFLT_GREPFORMAT	option.h	/^#define DFLT_GREPFORMAT	/;"	d
DFLT_HELPFILE	os_unix.h	/^# define DFLT_HELPFILE	/;"	d
DFLT_MAXMEM	os_unix.h	/^#  define DFLT_MAXMEM	/;"	d
DFLT_MAXMEM	os_unix.h	/^#  define DFLT_MAXMEM /;"	d
DFLT_MAXMEMTOT	os_unix.h	/^#  define DFLT_MAXMEMTOT	/;"	d
DFLT_MAXMEMTOT	os_unix.h	/^#  define DFLT_MAXMEMTOT /;"	d
DFLT_MENU_BG_COLOR	gui_x11.c	/^# define DFLT_MENU_BG_COLOR	/;"	d	file:
DFLT_MENU_FG_COLOR	gui_x11.c	/^# define DFLT_MENU_FG_COLOR	/;"	d	file:
DFLT_MENU_FONT	gui_x11.c	/^# define DFLT_MENU_FONT	/;"	d	file:
DFLT_RUNTIMEPATH	os_unix.h	/^#   define DFLT_RUNTIMEPATH	/;"	d
DFLT_RUNTIMEPATH	os_unix.h	/^#  define DFLT_RUNTIMEPATH /;"	d
DFLT_RUNTIMEPATH	os_unix.h	/^# define DFLT_RUNTIMEPATH	/;"	d
DFLT_SCROLL_BG_COLOR	gui_x11.c	/^# define DFLT_SCROLL_BG_COLOR	/;"	d	file:
DFLT_SCROLL_FG_COLOR	gui_x11.c	/^# define DFLT_SCROLL_FG_COLOR	/;"	d	file:
DFLT_TEXTAUTO	option.h	/^#   define DFLT_TEXTAUTO /;"	d
DFLT_TEXTAUTO	option.h	/^#  define DFLT_TEXTAUTO	/;"	d
DFLT_TEXTAUTO	option.h	/^# define DFLT_TEXTAUTO	/;"	d
DFLT_TOOLTIP_BG_COLOR	gui_x11.c	/^# define DFLT_TOOLTIP_BG_COLOR	/;"	d	file:
DFLT_TOOLTIP_FG_COLOR	gui_x11.c	/^# define DFLT_TOOLTIP_FG_COLOR	/;"	d	file:
DFLT_TOOLTIP_FONT	gui_x11.c	/^#define DFLT_TOOLTIP_FONT	/;"	d	file:
DFLT_VDIR	os_unix.h	/^#   define DFLT_VDIR /;"	d
DFLT_VDIR	os_unix.h	/^#  define DFLT_VDIR /;"	d
DI2HIKEY	eval.c	/^#define DI2HIKEY(/;"	d	file:
DICT_EXACT	edit.c	/^#define DICT_EXACT	/;"	d	file:
DICT_FIRST	edit.c	/^#define DICT_FIRST	/;"	d	file:
DICT_MAXNEST	eval.c	/^#define DICT_MAXNEST /;"	d	file:
DID_FOLD	screen.c	/^#define DID_FOLD /;"	d	file:
DID_LINE	screen.c	/^#define DID_LINE /;"	d	file:
DID_NONE	screen.c	/^#define DID_NONE /;"	d	file:
DIFF_FILLER	diff.c	/^#define DIFF_FILLER	/;"	d	file:
DIFF_HORIZONTAL	diff.c	/^#define DIFF_HORIZONTAL	/;"	d	file:
DIFF_ICASE	diff.c	/^#define DIFF_ICASE	/;"	d	file:
DIFF_INSERT	spell.c	/^#define DIFF_INSERT	/;"	d	file:
DIFF_IWHITE	diff.c	/^#define DIFF_IWHITE	/;"	d	file:
DIFF_NONE	spell.c	/^#define DIFF_NONE	/;"	d	file:
DIFF_VERTICAL	diff.c	/^#define DIFF_VERTICAL	/;"	d	file:
DIFF_YES	spell.c	/^#define DIFF_YES	/;"	d	file:
DIGIT	regexp.c	/^#define DIGIT	/;"	d	file:
DI_FLAGS_FIX	structs.h	/^#define DI_FLAGS_FIX	/;"	d
DI_FLAGS_LOCK	structs.h	/^#define DI_FLAGS_LOCK	/;"	d
DI_FLAGS_RO	structs.h	/^#define DI_FLAGS_RO	/;"	d
DI_FLAGS_RO_SBX	structs.h	/^#define DI_FLAGS_RO_SBX /;"	d
DLG_BUTTON_SEP	vim.h	/^#define DLG_BUTTON_SEP	/;"	d
DLG_HOTKEY_CHAR	vim.h	/^#define DLG_HOTKEY_CHAR	/;"	d
DOBUF_CURRENT	vim.h	/^#define DOBUF_CURRENT	/;"	d
DOBUF_DEL	vim.h	/^#define DOBUF_DEL	/;"	d
DOBUF_FIRST	vim.h	/^#define DOBUF_FIRST	/;"	d
DOBUF_GOTO	vim.h	/^#define DOBUF_GOTO	/;"	d
DOBUF_LAST	vim.h	/^#define DOBUF_LAST	/;"	d
DOBUF_MOD	vim.h	/^#define DOBUF_MOD	/;"	d
DOBUF_SPLIT	vim.h	/^#define DOBUF_SPLIT	/;"	d
DOBUF_UNLOAD	vim.h	/^#define DOBUF_UNLOAD	/;"	d
DOBUF_WIPE	vim.h	/^#define DOBUF_WIPE	/;"	d
DOCMD_EXCRESET	vim.h	/^#define DOCMD_EXCRESET	/;"	d
DOCMD_KEEPLINE	vim.h	/^#define DOCMD_KEEPLINE /;"	d
DOCMD_KEYTYPED	vim.h	/^#define DOCMD_KEYTYPED	/;"	d
DOCMD_NOWAIT	vim.h	/^#define DOCMD_NOWAIT	/;"	d
DOCMD_REPEAT	vim.h	/^#define DOCMD_REPEAT	/;"	d
DOCMD_VERBOSE	vim.h	/^#define DOCMD_VERBOSE	/;"	d
DONE_ACTION	fold.c	/^#define DONE_ACTION	/;"	d	file:
DONE_FOLD	fold.c	/^#define DONE_FOLD	/;"	d	file:
DONE_NOTHING	fold.c	/^#define DONE_NOTHING	/;"	d	file:
DOS32	vim.h	/^#  define DOS32$/;"	d
DOSO_GVIMRC	vim.h	/^#define DOSO_GVIMRC	/;"	d
DOSO_NONE	vim.h	/^#define DOSO_NONE	/;"	d
DOSO_VIMRC	vim.h	/^#define DOSO_VIMRC	/;"	d
DOS_MOUSE	feature.h	/^#  define DOS_MOUSE$/;"	d
DO_AUTOCHDIR	macros.h	/^# define DO_AUTOCHDIR /;"	d
DO_AUTOCHDIR	macros.h	/^# define DO_AUTOCHDIR$/;"	d
DO_DECLARE_EXCMD	ex_docmd.c	/^#define DO_DECLARE_EXCMD$/;"	d	file:
DO_INIT	vim.h	/^#  define DO_INIT$/;"	d
DRAW_BOLD	gui.h	/^#define DRAW_BOLD	/;"	d
DRAW_CURSOR	gui.h	/^#define DRAW_CURSOR	/;"	d
DRAW_ITALIC	gui.h	/^# define DRAW_ITALIC	/;"	d
DRAW_TRANSP	gui.h	/^#define DRAW_TRANSP	/;"	d
DRAW_UNDERC	gui.h	/^#define DRAW_UNDERC	/;"	d
DRAW_UNDERL	gui.h	/^#define DRAW_UNDERL	/;"	d
DT_CSCOPE	vim.h	/^#define DT_CSCOPE	/;"	d
DT_FIRST	vim.h	/^#define DT_FIRST	/;"	d
DT_FREE	vim.h	/^#define DT_FREE	/;"	d
DT_HELP	vim.h	/^#define DT_HELP	/;"	d
DT_JUMP	vim.h	/^#define DT_JUMP	/;"	d
DT_LAST	vim.h	/^#define DT_LAST	/;"	d
DT_LTAG	vim.h	/^#define DT_LTAG	/;"	d
DT_NEXT	vim.h	/^#define DT_NEXT	/;"	d
DT_POP	vim.h	/^#define DT_POP	/;"	d
DT_PREV	vim.h	/^#define DT_PREV	/;"	d
DT_SELECT	vim.h	/^#define DT_SELECT	/;"	d
DT_TAG	vim.h	/^#define DT_TAG	/;"	d
DUMPFLAG_ALLCAP	spell.c	/^#define DUMPFLAG_ALLCAP	/;"	d	file:
DUMPFLAG_COUNT	spell.c	/^#define DUMPFLAG_COUNT	/;"	d	file:
DUMPFLAG_ICASE	spell.c	/^#define DUMPFLAG_ICASE	/;"	d	file:
DUMPFLAG_KEEPCASE	spell.c	/^#define DUMPFLAG_KEEPCASE /;"	d	file:
DUMPFLAG_ONECAP	spell.c	/^#define DUMPFLAG_ONECAP	/;"	d	file:
DUM_LEN	getchar.c	/^#define DUM_LEN /;"	d	file:
DYNAMIC_ICONV_DLL	mbyte.c	/^#   define DYNAMIC_ICONV_DLL /;"	d	file:
DYNAMIC_ICONV_DLL_ALT	mbyte.c	/^#   define DYNAMIC_ICONV_DLL_ALT /;"	d	file:
DYNAMIC_MSVCRT_DLL	mbyte.c	/^#   define DYNAMIC_MSVCRT_DLL /;"	d	file:
DYNAMIC_TCL_DLL	if_tcl.c	/^#  define DYNAMIC_TCL_DLL /;"	d	file:
DYNAMIC_TCL_VER	if_tcl.c	/^#  define DYNAMIC_TCL_VER /;"	d	file:
DY_LASTLINE	option.h	/^#define DY_LASTLINE	/;"	d
DY_UHEX	option.h	/^#define DY_UHEX	/;"	d
DeleteAnyLingerer	if_xcmdsrv.c	/^DeleteAnyLingerer(dpy, win)$/;"	f	file:
Destroy	gui_at_sb.c	/^Destroy(w)$/;"	f	file:
Destroy	gui_xmebw.c	/^Destroy(Widget w)$/;"	f	file:
DialogAcceptCB	gui_motif.c	/^DialogAcceptCB(w, client_data, call_data)$/;"	f	file:
DialogCancelCB	gui_motif.c	/^DialogCancelCB(w, client_data, call_data)$/;"	f	file:
DialogInfo	gui_gtk.c	/^} DialogInfo;$/;"	t	typeref:struct:_DialogInfo	file:
Display	proto.h	/^#  define Display /;"	d
DoPythonCommand	if_python.c	/^DoPythonCommand(exarg_T *eap, const char *cmd)$/;"	f	file:
DoRegisterName	if_xcmdsrv.c	/^DoRegisterName(dpy, name)$/;"	f	file:
E2BIG	structs.h	/^#    define E2BIG	/;"	d
EBCDIC_CHAR_ADD	ascii.h	/^#define EBCDIC_CHAR_ADD(/;"	d
EBCDIC_CHAR_ADD_	ascii.h	/^#define EBCDIC_CHAR_ADD_(/;"	d
ECMD_ADDBUF	vim.h	/^#define ECMD_ADDBUF	/;"	d
ECMD_FORCEIT	vim.h	/^#define ECMD_FORCEIT	/;"	d
ECMD_HIDE	vim.h	/^#define ECMD_HIDE	/;"	d
ECMD_LAST	vim.h	/^#define ECMD_LAST	/;"	d
ECMD_LASTL	vim.h	/^#define ECMD_LASTL	/;"	d
ECMD_OLDBUF	vim.h	/^#define ECMD_OLDBUF	/;"	d
ECMD_ONE	vim.h	/^#define ECMD_ONE	/;"	d
ECMD_SET_HELP	vim.h	/^#define ECMD_SET_HELP	/;"	d
ECONNREFUSED	netbeans.c	/^# define ECONNREFUSED /;"	d	file:
EDITCMD	ex_cmds.h	/^#define EDITCMD	/;"	d
EDIT_FILE	main.c	/^#define EDIT_FILE /;"	d	file:
EDIT_NONE	main.c	/^#define EDIT_NONE /;"	d	file:
EDIT_QF	main.c	/^#define EDIT_QF	/;"	d	file:
EDIT_STDIN	main.c	/^#define EDIT_STDIN /;"	d	file:
EDIT_TAG	main.c	/^#define EDIT_TAG /;"	d	file:
EFAULT	structs.h	/^#    define EFAULT	/;"	d
EILSEQ	structs.h	/^#    define EILSEQ	/;"	d
EILSEQ	structs.h	/^#   define EILSEQ /;"	d
EILSEQ	vim.h	/^#   define EILSEQ /;"	d
EINTR	netbeans.c	/^#  undef EINTR$/;"	d	file:
EINTR	netbeans.c	/^# define EINTR /;"	d	file:
EINVAL	structs.h	/^#    define EINVAL	/;"	d
EMSG	vim.h	/^#define EMSG(/;"	d
EMSG2	vim.h	/^#define EMSG2(/;"	d
EMSG3	vim.h	/^#define EMSG3(/;"	d
EMSGN	vim.h	/^#define EMSGN(/;"	d
EMSGU	vim.h	/^#define EMSGU(/;"	d
EMSG_M_RET_NULL	regexp.c	/^#define EMSG_M_RET_NULL(/;"	d	file:
EMSG_ONE_RET_NULL	regexp.c	/^#define EMSG_ONE_RET_NULL /;"	d	file:
EMSG_RET_FAIL	regexp.c	/^#define EMSG_RET_FAIL(/;"	d	file:
EMSG_RET_NULL	regexp.c	/^#define EMSG_RET_NULL(/;"	d	file:
ENABLE_NLS	gui_gtk.c	/^#  define ENABLE_NLS	/;"	d	file:
ENABLE_NLS	gui_gtk_x11.c	/^#  define ENABLE_NLS	/;"	d	file:
ENCODING	gui_xmdlg.c	/^    ENCODING,$/;"	e	enum:ListSpecifier	file:
ENC_2BYTE	vim.h	/^# define ENC_2BYTE	/;"	d
ENC_2WORD	vim.h	/^# define ENC_2WORD	/;"	d
ENC_4BYTE	vim.h	/^# define ENC_4BYTE	/;"	d
ENC_8BIT	vim.h	/^# define ENC_8BIT	/;"	d
ENC_DBCS	vim.h	/^# define ENC_DBCS	/;"	d
ENC_DFLT	option.h	/^# define ENC_DFLT	/;"	d
ENC_ENDIAN_B	vim.h	/^# define ENC_ENDIAN_B	/;"	d
ENC_ENDIAN_L	vim.h	/^# define ENC_ENDIAN_L	/;"	d
ENC_LATIN1	vim.h	/^# define ENC_LATIN1	/;"	d
ENC_LATIN9	vim.h	/^# define ENC_LATIN9	/;"	d
ENC_MACROMAN	vim.h	/^# define ENC_MACROMAN	/;"	d
ENC_UCSBOM	option.h	/^# define ENC_UCSBOM	/;"	d
ENC_UNICODE	vim.h	/^# define ENC_UNICODE	/;"	d
END	regexp.c	/^#define END	/;"	d	file:
END_PAGE_DATA	gui_at_sb.h	/^#define END_PAGE_DATA	/;"	d
ENOENT	structs.h	/^#    define ENOENT	/;"	d
EOL	regexp.c	/^#define EOL	/;"	d	file:
EOL_DOS	option.h	/^#define EOL_DOS	/;"	d
EOL_MAC	option.h	/^#define EOL_MAC	/;"	d
EOL_UNIX	option.h	/^#define EOL_UNIX	/;"	d
EOL_UNKNOWN	option.h	/^#define EOL_UNKNOWN	/;"	d
EOW	regexp.c	/^#define EOW	/;"	d	file:
ERROR_DICT	eval.c	/^#define ERROR_DICT	/;"	d	file:
ERROR_NONE	eval.c	/^#define ERROR_NONE	/;"	d	file:
ERROR_OTHER	eval.c	/^#define ERROR_OTHER	/;"	d	file:
ERROR_SCRIPT	eval.c	/^#define ERROR_SCRIPT	/;"	d	file:
ERROR_TOOFEW	eval.c	/^#define ERROR_TOOFEW	/;"	d	file:
ERROR_TOOMANY	eval.c	/^#define ERROR_TOOMANY	/;"	d	file:
ERROR_UNKNOWN	eval.c	/^#define ERROR_UNKNOWN	/;"	d	file:
ESC	ascii.h	/^#define ESC	/;"	d
ESCAPE_CHARS	ex_docmd.c	/^# define ESCAPE_CHARS /;"	d	file:
ESC_CHG_TO_ENG_MODE	feature.h	/^# define ESC_CHG_TO_ENG_MODE	/;"	d
ESC_STR	ascii.h	/^#define ESC_STR	/;"	d
ESC_STR_nc	ascii.h	/^#define ESC_STR_nc	/;"	d
ET_ERROR	structs.h	/^#define ET_ERROR	/;"	d
ET_INTERRUPT	structs.h	/^#define ET_INTERRUPT	/;"	d
ET_USER	structs.h	/^#define ET_USER	/;"	d
EVAL_OFFSET_X	gui_beval.h	/^#define EVAL_OFFSET_X /;"	d
EVAL_OFFSET_Y	gui_beval.h	/^#define EVAL_OFFSET_Y /;"	d
EVENT_BUFADD	vim.h	/^    EVENT_BUFADD = 0,		\/* after adding a buffer to the buffer list *\/$/;"	e	enum:auto_event
EVENT_BUFDELETE	vim.h	/^    EVENT_BUFDELETE,		\/* deleting a buffer from the buffer list *\/$/;"	e	enum:auto_event
EVENT_BUFENTER	vim.h	/^    EVENT_BUFENTER,		\/* after entering a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFFILEPOST	vim.h	/^    EVENT_BUFFILEPOST,		\/* after renaming a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFFILEPRE	vim.h	/^    EVENT_BUFFILEPRE,		\/* before renaming a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFHIDDEN	vim.h	/^    EVENT_BUFHIDDEN,		\/* just after buffer becomes hidden *\/$/;"	e	enum:auto_event
EVENT_BUFLEAVE	vim.h	/^    EVENT_BUFLEAVE,		\/* before leaving a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFNEW	vim.h	/^    EVENT_BUFNEW,		\/* after creating any buffer *\/$/;"	e	enum:auto_event
EVENT_BUFNEWFILE	vim.h	/^    EVENT_BUFNEWFILE,		\/* when creating a buffer for a new file *\/$/;"	e	enum:auto_event
EVENT_BUFREADCMD	vim.h	/^    EVENT_BUFREADCMD,		\/* read buffer using command *\/$/;"	e	enum:auto_event
EVENT_BUFREADPOST	vim.h	/^    EVENT_BUFREADPOST,		\/* after reading a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFREADPRE	vim.h	/^    EVENT_BUFREADPRE,		\/* before reading a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFUNLOAD	vim.h	/^    EVENT_BUFUNLOAD,		\/* just before unloading a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFWINENTER	vim.h	/^    EVENT_BUFWINENTER,		\/* after showing a buffer in a window *\/$/;"	e	enum:auto_event
EVENT_BUFWINLEAVE	vim.h	/^    EVENT_BUFWINLEAVE,		\/* just after buffer removed from window *\/$/;"	e	enum:auto_event
EVENT_BUFWIPEOUT	vim.h	/^    EVENT_BUFWIPEOUT,		\/* just before really deleting a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFWRITECMD	vim.h	/^    EVENT_BUFWRITECMD,		\/* write buffer using command *\/$/;"	e	enum:auto_event
EVENT_BUFWRITEPOST	vim.h	/^    EVENT_BUFWRITEPOST,		\/* after writing a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFWRITEPRE	vim.h	/^    EVENT_BUFWRITEPRE,		\/* before writing a buffer *\/$/;"	e	enum:auto_event
EVENT_CMDWINENTER	vim.h	/^    EVENT_CMDWINENTER,		\/* after entering the cmdline window *\/$/;"	e	enum:auto_event
EVENT_CMDWINLEAVE	vim.h	/^    EVENT_CMDWINLEAVE,		\/* before leaving the cmdline window *\/$/;"	e	enum:auto_event
EVENT_COLORSCHEME	vim.h	/^    EVENT_COLORSCHEME,		\/* after loading a colorscheme *\/$/;"	e	enum:auto_event
EVENT_CURSORHOLD	vim.h	/^    EVENT_CURSORHOLD,		\/* cursor in same position for a while *\/$/;"	e	enum:auto_event
EVENT_CURSORHOLDI	vim.h	/^    EVENT_CURSORHOLDI,		\/* idem, in Insert mode *\/$/;"	e	enum:auto_event
EVENT_CURSORMOVED	vim.h	/^    EVENT_CURSORMOVED,		\/* cursor was moved *\/$/;"	e	enum:auto_event
EVENT_CURSORMOVEDI	vim.h	/^    EVENT_CURSORMOVEDI,		\/* cursor was moved in Insert mode *\/$/;"	e	enum:auto_event
EVENT_ENCODINGCHANGED	vim.h	/^    EVENT_ENCODINGCHANGED,	\/* after changing the 'encoding' option *\/$/;"	e	enum:auto_event
EVENT_FILEAPPENDCMD	vim.h	/^    EVENT_FILEAPPENDCMD,	\/* append to a file using command *\/$/;"	e	enum:auto_event
EVENT_FILEAPPENDPOST	vim.h	/^    EVENT_FILEAPPENDPOST,	\/* after appending to a file *\/$/;"	e	enum:auto_event
EVENT_FILEAPPENDPRE	vim.h	/^    EVENT_FILEAPPENDPRE,	\/* before appending to a file *\/$/;"	e	enum:auto_event
EVENT_FILECHANGEDRO	vim.h	/^    EVENT_FILECHANGEDRO,	\/* before first change to read-only file *\/$/;"	e	enum:auto_event
EVENT_FILECHANGEDSHELL	vim.h	/^    EVENT_FILECHANGEDSHELL,	\/* after shell command that changed file *\/$/;"	e	enum:auto_event
EVENT_FILECHANGEDSHELLPOST	vim.h	/^    EVENT_FILECHANGEDSHELLPOST,	\/* after (not) reloading changed file *\/$/;"	e	enum:auto_event
EVENT_FILEREADCMD	vim.h	/^    EVENT_FILEREADCMD,		\/* read from a file using command *\/$/;"	e	enum:auto_event
EVENT_FILEREADPOST	vim.h	/^    EVENT_FILEREADPOST,		\/* after reading a file *\/$/;"	e	enum:auto_event
EVENT_FILEREADPRE	vim.h	/^    EVENT_FILEREADPRE,		\/* before reading a file *\/$/;"	e	enum:auto_event
EVENT_FILETYPE	vim.h	/^    EVENT_FILETYPE,		\/* new file type detected (user defined) *\/$/;"	e	enum:auto_event
EVENT_FILEWRITECMD	vim.h	/^    EVENT_FILEWRITECMD,		\/* write to a file using command *\/$/;"	e	enum:auto_event
EVENT_FILEWRITEPOST	vim.h	/^    EVENT_FILEWRITEPOST,	\/* after writing a file *\/$/;"	e	enum:auto_event
EVENT_FILEWRITEPRE	vim.h	/^    EVENT_FILEWRITEPRE,		\/* before writing a file *\/$/;"	e	enum:auto_event
EVENT_FILTERREADPOST	vim.h	/^    EVENT_FILTERREADPOST,	\/* after reading from a filter *\/$/;"	e	enum:auto_event
EVENT_FILTERREADPRE	vim.h	/^    EVENT_FILTERREADPRE,	\/* before reading from a filter *\/$/;"	e	enum:auto_event
EVENT_FILTERWRITEPOST	vim.h	/^    EVENT_FILTERWRITEPOST,	\/* after writing to a filter *\/$/;"	e	enum:auto_event
EVENT_FILTERWRITEPRE	vim.h	/^    EVENT_FILTERWRITEPRE,	\/* before writing to a filter *\/$/;"	e	enum:auto_event
EVENT_FOCUSGAINED	vim.h	/^    EVENT_FOCUSGAINED,		\/* got the focus *\/$/;"	e	enum:auto_event
EVENT_FOCUSLOST	vim.h	/^    EVENT_FOCUSLOST,		\/* lost the focus to another app *\/$/;"	e	enum:auto_event
EVENT_FUNCUNDEFINED	vim.h	/^    EVENT_FUNCUNDEFINED,	\/* if calling a function which doesn't exist *\/$/;"	e	enum:auto_event
EVENT_GUIENTER	vim.h	/^    EVENT_GUIENTER,		\/* after starting the GUI *\/$/;"	e	enum:auto_event
EVENT_GUIFAILED	vim.h	/^    EVENT_GUIFAILED,		\/* after starting the GUI failed *\/$/;"	e	enum:auto_event
EVENT_INSERTCHANGE	vim.h	/^    EVENT_INSERTCHANGE,		\/* when changing Insert\/Replace mode *\/$/;"	e	enum:auto_event
EVENT_INSERTENTER	vim.h	/^    EVENT_INSERTENTER,		\/* when entering Insert mode *\/$/;"	e	enum:auto_event
EVENT_INSERTLEAVE	vim.h	/^    EVENT_INSERTLEAVE,		\/* when leaving Insert mode *\/$/;"	e	enum:auto_event
EVENT_MENUPOPUP	vim.h	/^    EVENT_MENUPOPUP,		\/* just before popup menu is displayed *\/$/;"	e	enum:auto_event
EVENT_QUICKFIXCMDPOST	vim.h	/^    EVENT_QUICKFIXCMDPOST,	\/* after :make, :grep etc *\/$/;"	e	enum:auto_event
EVENT_QUICKFIXCMDPRE	vim.h	/^    EVENT_QUICKFIXCMDPRE,	\/* before :make, :grep etc *\/$/;"	e	enum:auto_event
EVENT_REMOTEREPLY	vim.h	/^    EVENT_REMOTEREPLY,		\/* upon string reception from a remote vim *\/$/;"	e	enum:auto_event
EVENT_SESSIONLOADPOST	vim.h	/^    EVENT_SESSIONLOADPOST,	\/* after loading a session file *\/$/;"	e	enum:auto_event
EVENT_SHELLCMDPOST	vim.h	/^    EVENT_SHELLCMDPOST,		\/* after ":!cmd" *\/$/;"	e	enum:auto_event
EVENT_SHELLFILTERPOST	vim.h	/^    EVENT_SHELLFILTERPOST,	\/* after ":1,2!cmd", ":w !cmd", ":r !cmd". *\/$/;"	e	enum:auto_event
EVENT_SOURCECMD	vim.h	/^    EVENT_SOURCECMD,		\/* sourcing a Vim script using command *\/$/;"	e	enum:auto_event
EVENT_SOURCEPRE	vim.h	/^    EVENT_SOURCEPRE,		\/* before sourcing a Vim script *\/$/;"	e	enum:auto_event
EVENT_SPELLFILEMISSING	vim.h	/^    EVENT_SPELLFILEMISSING,	\/* spell file missing *\/$/;"	e	enum:auto_event
EVENT_STDINREADPOST	vim.h	/^    EVENT_STDINREADPOST,	\/* after reading from stdin *\/$/;"	e	enum:auto_event
EVENT_STDINREADPRE	vim.h	/^    EVENT_STDINREADPRE,		\/* before reading from stdin *\/$/;"	e	enum:auto_event
EVENT_SWAPEXISTS	vim.h	/^    EVENT_SWAPEXISTS,		\/* found existing swap file *\/$/;"	e	enum:auto_event
EVENT_SYNTAX	vim.h	/^    EVENT_SYNTAX,		\/* syntax selected *\/$/;"	e	enum:auto_event
EVENT_TABENTER	vim.h	/^    EVENT_TABENTER,		\/* after entering a tab page *\/$/;"	e	enum:auto_event
EVENT_TABLEAVE	vim.h	/^    EVENT_TABLEAVE,		\/* before leaving a tab page *\/$/;"	e	enum:auto_event
EVENT_TERMCHANGED	vim.h	/^    EVENT_TERMCHANGED,		\/* after changing 'term' *\/$/;"	e	enum:auto_event
EVENT_TERMRESPONSE	vim.h	/^    EVENT_TERMRESPONSE,		\/* after setting "v:termresponse" *\/$/;"	e	enum:auto_event
EVENT_USER	vim.h	/^    EVENT_USER,			\/* user defined autocommand *\/$/;"	e	enum:auto_event
EVENT_VIMENTER	vim.h	/^    EVENT_VIMENTER,		\/* after starting Vim *\/$/;"	e	enum:auto_event
EVENT_VIMLEAVE	vim.h	/^    EVENT_VIMLEAVE,		\/* before exiting Vim *\/$/;"	e	enum:auto_event
EVENT_VIMLEAVEPRE	vim.h	/^    EVENT_VIMLEAVEPRE,		\/* before exiting Vim and writing .viminfo *\/$/;"	e	enum:auto_event
EVENT_VIMRESIZED	vim.h	/^    EVENT_VIMRESIZED,		\/* after Vim window was resized *\/$/;"	e	enum:auto_event
EVENT_WINENTER	vim.h	/^    EVENT_WINENTER,		\/* after entering a window *\/$/;"	e	enum:auto_event
EVENT_WINLEAVE	vim.h	/^    EVENT_WINLEAVE,		\/* before leaving a window *\/$/;"	e	enum:auto_event
EVIM_FILE	os_unix.h	/^# define EVIM_FILE	/;"	d
EW_ADDSLASH	vim.h	/^#define EW_ADDSLASH	/;"	d
EW_DIR	vim.h	/^#define EW_DIR	/;"	d
EW_EXEC	vim.h	/^#define EW_EXEC	/;"	d
EW_FILE	vim.h	/^#define EW_FILE	/;"	d
EW_KEEPALL	vim.h	/^#define EW_KEEPALL	/;"	d
EW_NOTFOUND	vim.h	/^#define EW_NOTFOUND	/;"	d
EW_SILENT	vim.h	/^#define EW_SILENT	/;"	d
EX	ex_cmds.h	/^# define EX(/;"	d
EX	ex_cmds.h	/^# undef EX	/;"	d
EXACTLY	regexp.c	/^#define EXACTLY	/;"	d	file:
EXFLAGS	ex_cmds.h	/^#define EXFLAGS /;"	d
EXFLAG_LIST	ex_cmds.h	/^#define EXFLAG_LIST	/;"	d
EXFLAG_NR	ex_cmds.h	/^#define EXFLAG_NR	/;"	d
EXFLAG_PRINT	ex_cmds.h	/^#define EXFLAG_PRINT	/;"	d
EXMODE_NORMAL	vim.h	/^#define EXMODE_NORMAL	/;"	d
EXMODE_VIM	vim.h	/^#define EXMODE_VIM	/;"	d
EXPAND_AUGROUP	vim.h	/^#define EXPAND_AUGROUP	/;"	d
EXPAND_BOOL_SETTINGS	vim.h	/^#define EXPAND_BOOL_SETTINGS	/;"	d
EXPAND_BUFFERS	vim.h	/^#define EXPAND_BUFFERS	/;"	d
EXPAND_COLORS	vim.h	/^#define EXPAND_COLORS	/;"	d
EXPAND_COMMANDS	vim.h	/^#define EXPAND_COMMANDS	/;"	d
EXPAND_COMPILER	vim.h	/^#define EXPAND_COMPILER	/;"	d
EXPAND_DIRECTORIES	vim.h	/^#define EXPAND_DIRECTORIES	/;"	d
EXPAND_ENV_VARS	vim.h	/^#define EXPAND_ENV_VARS	/;"	d
EXPAND_EVENTS	vim.h	/^#define EXPAND_EVENTS	/;"	d
EXPAND_EXPRESSION	vim.h	/^#define EXPAND_EXPRESSION	/;"	d
EXPAND_FILES	vim.h	/^#define EXPAND_FILES	/;"	d
EXPAND_FUNCTIONS	vim.h	/^#define EXPAND_FUNCTIONS	/;"	d
EXPAND_HELP	vim.h	/^#define EXPAND_HELP	/;"	d
EXPAND_HIGHLIGHT	vim.h	/^#define EXPAND_HIGHLIGHT	/;"	d
EXPAND_LANGUAGE	vim.h	/^#define EXPAND_LANGUAGE	/;"	d
EXPAND_MAPPINGS	vim.h	/^#define EXPAND_MAPPINGS	/;"	d
EXPAND_MENUNAMES	vim.h	/^#define EXPAND_MENUNAMES	/;"	d
EXPAND_MENUS	vim.h	/^#define EXPAND_MENUS	/;"	d
EXPAND_NOTHING	vim.h	/^#define EXPAND_NOTHING	/;"	d
EXPAND_OK	vim.h	/^#define EXPAND_OK	/;"	d
EXPAND_OLD_SETTING	vim.h	/^#define EXPAND_OLD_SETTING	/;"	d
EXPAND_SETTINGS	vim.h	/^#define EXPAND_SETTINGS	/;"	d
EXPAND_SHELLCMD	vim.h	/^#define EXPAND_SHELLCMD	/;"	d
EXPAND_SYNTAX	vim.h	/^#define EXPAND_SYNTAX	/;"	d
EXPAND_TAGS	vim.h	/^#define EXPAND_TAGS	/;"	d
EXPAND_TAGS_LISTFILES	vim.h	/^#define EXPAND_TAGS_LISTFILES	/;"	d
EXPAND_UNSUCCESSFUL	vim.h	/^#define EXPAND_UNSUCCESSFUL	/;"	d
EXPAND_USER_CMD_FLAGS	vim.h	/^#define EXPAND_USER_CMD_FLAGS	/;"	d
EXPAND_USER_COMMANDS	vim.h	/^#define EXPAND_USER_COMMANDS	/;"	d
EXPAND_USER_COMPLETE	vim.h	/^#define EXPAND_USER_COMPLETE	/;"	d
EXPAND_USER_DEFINED	vim.h	/^#define EXPAND_USER_DEFINED	/;"	d
EXPAND_USER_FUNC	vim.h	/^#define EXPAND_USER_FUNC	/;"	d
EXPAND_USER_LIST	vim.h	/^#define EXPAND_USER_LIST	/;"	d
EXPAND_USER_NARGS	vim.h	/^#define EXPAND_USER_NARGS	/;"	d
EXPAND_USER_VARS	vim.h	/^#define EXPAND_USER_VARS	/;"	d
EXPL_ALLOC_INC	os_unix.c	/^# define EXPL_ALLOC_INC	/;"	d	file:
EXP_CASE	syntax.c	/^    EXP_CASE	    \/* expand ":syn case" arguments *\/$/;"	e	enum:__anon59	file:
EXP_SUBCMD	syntax.c	/^    EXP_SUBCMD,	    \/* expand ":syn" sub-commands *\/$/;"	e	enum:__anon59	file:
EXRC_FILE	os_unix.h	/^# define EXRC_FILE	/;"	d
EXTERN	if_ruby.c	/^#undef EXTERN$/;"	d	file:
EXTERN	if_tcl.c	/^#undef EXTERN	/;"	d	file:
EXTERN	main.c	/^#define EXTERN$/;"	d	file:
EXTERN	vim.h	/^# define EXTERN /;"	d
EXTERNCMD	vim.h	/^#define EXTERNCMD	/;"	d
EXTRA	ex_cmds.h	/^#define EXTRA	/;"	d
EXTRASIZE	misc2.c	/^#define EXTRASIZE /;"	d	file:
EXTRA_MARKS	mark.c	/^#define EXTRA_MARKS /;"	d	file:
EndCond	if_xcmdsrv.c	/^typedef int (*EndCond) __ARGS((void *));$/;"	t	file:
EndScroll	gui_at_sb.c	/^EndScroll(w, event, params, num_params)$/;"	f	file:
EnhancedBP_H	gui_xmebwp.h	/^#define EnhancedBP_H$/;"	d
EnhancedB_H	gui_xmebw.h	/^#define EnhancedB_H$/;"	d
Enter	gui_xmebw.c	/^Enter(Widget wid, XEvent *event, String *params, Cardinal *num_params)$/;"	f	file:
Error	if_python.c	/^static OutputObject Error =$/;"	v	file:
EventData	gui_at_sb.c	/^struct EventData$/;"	s	file:
Exec_reg	globals.h	/^EXTERN int Exec_reg INIT(= FALSE);	\/* TRUE when executing a register *\/$/;"	v
ExpandBufnames	buffer.c	/^ExpandBufnames(pat, num_file, file, options)$/;"	f
ExpandCleanup	ex_getln.c	/^ExpandCleanup(xp)$/;"	f
ExpandEscape	ex_getln.c	/^ExpandEscape(xp, str, numfiles, files, options)$/;"	f
ExpandFromContext	ex_getln.c	/^ExpandFromContext(xp, pat, num_file, file, options)$/;"	f	file:
ExpandGeneric	ex_getln.c	/^ExpandGeneric(xp, regmatch, num_file, file, func)$/;"	f
ExpandInit	ex_getln.c	/^ExpandInit(xp)$/;"	f
ExpandMappings	getchar.c	/^ExpandMappings(regmatch, num_file, file)$/;"	f
ExpandOldSetting	option.c	/^ExpandOldSetting(num_file, file)$/;"	f
ExpandOne	ex_getln.c	/^ExpandOne(xp, str, orig, options, mode)$/;"	f
ExpandRTDir	ex_getln.c	/^ExpandRTDir(pat, num_file, file, dirname)$/;"	f	file:
ExpandSettings	option.c	/^ExpandSettings(xp, regmatch, num_file, file)$/;"	f
ExpandUserDefined	ex_getln.c	/^ExpandUserDefined(xp, regmatch, num_file, file)$/;"	f	file:
ExpandUserList	ex_getln.c	/^ExpandUserList(xp, num_file, file)$/;"	f	file:
ExtEdProtocolVersion	netbeans.c	/^static char *ExtEdProtocolVersion = "2.4";$/;"	v	file:
ExtractPosition	gui_at_sb.c	/^ExtractPosition(event, x, y, state)$/;"	f	file:
FAIL	vim.h	/^#define FAIL	/;"	d
FALSE	vim.h	/^# define FALSE	/;"	d
FARSI_0	farsi.h	/^#define FARSI_0	/;"	d
FARSI_1	farsi.h	/^#define FARSI_1	/;"	d
FARSI_2	farsi.h	/^#define FARSI_2	/;"	d
FARSI_3	farsi.h	/^#define FARSI_3	/;"	d
FARSI_4	farsi.h	/^#define FARSI_4	/;"	d
FARSI_5	farsi.h	/^#define FARSI_5	/;"	d
FARSI_6	farsi.h	/^#define FARSI_6	/;"	d
FARSI_7	farsi.h	/^#define FARSI_7	/;"	d
FARSI_8	farsi.h	/^#define FARSI_8	/;"	d
FARSI_9	farsi.h	/^#define FARSI_9	/;"	d
FC_ABORT	eval.c	/^#define FC_ABORT /;"	d	file:
FC_DICT	eval.c	/^#define FC_DICT	/;"	d	file:
FC_RANGE	eval.c	/^#define FC_RANGE /;"	d	file:
FDC_OFF	screen.c	/^# define FDC_OFF /;"	d	file:
FDO_ALL	option.h	/^# define FDO_ALL	/;"	d
FDO_BLOCK	option.h	/^# define FDO_BLOCK	/;"	d
FDO_HOR	option.h	/^# define FDO_HOR	/;"	d
FDO_INSERT	option.h	/^# define FDO_INSERT	/;"	d
FDO_JUMP	option.h	/^# define FDO_JUMP	/;"	d
FDO_MARK	option.h	/^# define FDO_MARK	/;"	d
FDO_PERCENT	option.h	/^# define FDO_PERCENT	/;"	d
FDO_QUICKFIX	option.h	/^# define FDO_QUICKFIX	/;"	d
FDO_SEARCH	option.h	/^# define FDO_SEARCH	/;"	d
FDO_TAG	option.h	/^# define FDO_TAG	/;"	d
FDO_UNDO	option.h	/^# define FDO_UNDO	/;"	d
FD_CLOSED	fold.c	/^#define FD_CLOSED	/;"	d	file:
FD_LEVEL	fold.c	/^#define FD_LEVEL	/;"	d	file:
FD_OPEN	fold.c	/^#define FD_OPEN	/;"	d	file:
FE	farsi.h	/^#define FE	/;"	d
FEAT_ARABIC	feature.h	/^# define FEAT_ARABIC$/;"	d
FEAT_ARP	feature.h	/^# define FEAT_ARP$/;"	d
FEAT_AUTOCHDIR	feature.h	/^# define FEAT_AUTOCHDIR$/;"	d
FEAT_AUTOCMD	feature.h	/^# define FEAT_AUTOCMD$/;"	d
FEAT_BEVAL	feature.h	/^# define FEAT_BEVAL$/;"	d
FEAT_BEVAL_TIP	feature.h	/^# define FEAT_BEVAL_TIP	/;"	d
FEAT_BEVAL_TIP	vim.h	/^#  undef FEAT_BEVAL_TIP$/;"	d
FEAT_BIG	feature.h	/^#  define FEAT_BIG$/;"	d
FEAT_BIG	feature.h	/^# define FEAT_BIG$/;"	d
FEAT_BROWSE	feature.h	/^# define FEAT_BROWSE$/;"	d
FEAT_BYTEOFF	feature.h	/^# define FEAT_BYTEOFF$/;"	d
FEAT_CINDENT	feature.h	/^# define FEAT_CINDENT$/;"	d
FEAT_CLIENTSERVER	feature.h	/^# define FEAT_CLIENTSERVER$/;"	d
FEAT_CLIENTSERVER	vim.h	/^#  undef FEAT_CLIENTSERVER$/;"	d
FEAT_CLIPBOARD	feature.h	/^#  define FEAT_CLIPBOARD$/;"	d
FEAT_CLIPBOARD	feature.h	/^#  undef FEAT_CLIPBOARD	/;"	d
FEAT_CLIPBOARD	vim.h	/^#  define FEAT_CLIPBOARD$/;"	d
FEAT_CMDHIST	feature.h	/^# define FEAT_CMDHIST$/;"	d
FEAT_CMDL_COMPL	feature.h	/^# define FEAT_CMDL_COMPL$/;"	d
FEAT_CMDL_INFO	feature.h	/^#  define FEAT_CMDL_INFO	/;"	d
FEAT_CMDL_INFO	feature.h	/^# define FEAT_CMDL_INFO$/;"	d
FEAT_CMDWIN	feature.h	/^# define FEAT_CMDWIN$/;"	d
FEAT_COMMENTS	feature.h	/^# define FEAT_COMMENTS$/;"	d
FEAT_COMPL_FUNC	feature.h	/^# define FEAT_COMPL_FUNC$/;"	d
FEAT_CON_DIALOG	feature.h	/^#  define FEAT_CON_DIALOG$/;"	d
FEAT_CRYPT	feature.h	/^# define FEAT_CRYPT$/;"	d
FEAT_CSCOPE	feature.h	/^# define FEAT_CSCOPE$/;"	d
FEAT_CW_EDITOR	feature.h	/^# define FEAT_CW_EDITOR$/;"	d
FEAT_DIFF	feature.h	/^# define FEAT_DIFF$/;"	d
FEAT_DIGRAPHS	feature.h	/^# define FEAT_DIGRAPHS$/;"	d
FEAT_DND	feature.h	/^# define FEAT_DND$/;"	d
FEAT_EMACS_TAGS	feature.h	/^# define FEAT_EMACS_TAGS$/;"	d
FEAT_EVAL	feature.h	/^# define FEAT_EVAL$/;"	d
FEAT_EX_EXTRA	feature.h	/^# define FEAT_EX_EXTRA$/;"	d
FEAT_FIND_ID	feature.h	/^#  define FEAT_FIND_ID$/;"	d
FEAT_FKMAP	feature.h	/^# define FEAT_FKMAP$/;"	d
FEAT_FLOAT	feature.h	/^#  define FEAT_FLOAT$/;"	d
FEAT_FOLDING	feature.h	/^# define FEAT_FOLDING$/;"	d
FEAT_FOOTER	feature.h	/^# define FEAT_FOOTER$/;"	d
FEAT_GETTEXT	feature.h	/^# define FEAT_GETTEXT$/;"	d
FEAT_GETTEXT	vim.h	/^#  define FEAT_GETTEXT$/;"	d
FEAT_GUI	vim.h	/^#  define FEAT_GUI$/;"	d
FEAT_GUI_ATHENA	vim.h	/^#  undef FEAT_GUI_ATHENA$/;"	d
FEAT_GUI_DIALOG	feature.h	/^#  define FEAT_GUI_DIALOG$/;"	d
FEAT_GUI_DIALOG	feature.h	/^# define FEAT_GUI_DIALOG$/;"	d
FEAT_GUI_GTK	vim.h	/^#  undef FEAT_GUI_GTK$/;"	d
FEAT_GUI_MAC	vim.h	/^# define FEAT_GUI_MAC$/;"	d
FEAT_GUI_MOTIF	vim.h	/^#  undef FEAT_GUI_MOTIF$/;"	d
FEAT_GUI_MSWIN	vim.h	/^# define FEAT_GUI_MSWIN$/;"	d
FEAT_GUI_TABLINE	feature.h	/^# define FEAT_GUI_TABLINE$/;"	d
FEAT_GUI_TEXTDIALOG	feature.h	/^# define FEAT_GUI_TEXTDIALOG$/;"	d
FEAT_GUI_X11	feature.h	/^# define FEAT_GUI_X11$/;"	d
FEAT_GUI_X11	vim.h	/^#  undef FEAT_GUI_X11$/;"	d
FEAT_INS_EXPAND	feature.h	/^# define FEAT_INS_EXPAND$/;"	d
FEAT_JUMPLIST	feature.h	/^# define FEAT_JUMPLIST$/;"	d
FEAT_KEYMAP	feature.h	/^# define FEAT_KEYMAP$/;"	d
FEAT_LANGMAP	feature.h	/^# define FEAT_LANGMAP$/;"	d
FEAT_LIBCALL	feature.h	/^# define FEAT_LIBCALL$/;"	d
FEAT_LINEBREAK	feature.h	/^# define FEAT_LINEBREAK$/;"	d
FEAT_LISP	feature.h	/^# define FEAT_LISP$/;"	d
FEAT_LISTCMDS	feature.h	/^# define FEAT_LISTCMDS$/;"	d
FEAT_LOCALMAP	feature.h	/^# define FEAT_LOCALMAP$/;"	d
FEAT_MBYTE	feature.h	/^# define FEAT_MBYTE$/;"	d
FEAT_MBYTE_IME	vim.h	/^#  define FEAT_MBYTE_IME$/;"	d
FEAT_MENU	feature.h	/^#  define FEAT_MENU$/;"	d
FEAT_MENU	feature.h	/^# define FEAT_MENU$/;"	d
FEAT_MODIFY_FNAME	feature.h	/^# define FEAT_MODIFY_FNAME$/;"	d
FEAT_MOUSE	feature.h	/^# define FEAT_MOUSE	/;"	d
FEAT_MOUSESHAPE	feature.h	/^#  define FEAT_MOUSESHAPE$/;"	d
FEAT_MOUSE_DEC	feature.h	/^#  define FEAT_MOUSE_DEC$/;"	d
FEAT_MOUSE_GPM	feature.h	/^# define FEAT_MOUSE_GPM$/;"	d
FEAT_MOUSE_NET	feature.h	/^#  define FEAT_MOUSE_NET$/;"	d
FEAT_MOUSE_PTERM	feature.h	/^#  define FEAT_MOUSE_PTERM$/;"	d
FEAT_MOUSE_TTY	feature.h	/^# define FEAT_MOUSE_TTY	/;"	d
FEAT_MOUSE_XTERM	feature.h	/^#  define FEAT_MOUSE_XTERM$/;"	d
FEAT_MULTI_LANG	feature.h	/^# define FEAT_MULTI_LANG$/;"	d
FEAT_NETBEANS_INTG	feature.h	/^# undef FEAT_NETBEANS_INTG$/;"	d
FEAT_NORMAL	feature.h	/^#   define FEAT_NORMAL$/;"	d
FEAT_NORMAL	feature.h	/^# define FEAT_NORMAL$/;"	d
FEAT_PATH_EXTRA	feature.h	/^# define FEAT_PATH_EXTRA$/;"	d
FEAT_POSTSCRIPT	feature.h	/^# define FEAT_POSTSCRIPT$/;"	d
FEAT_PRINTER	feature.h	/^# define FEAT_PRINTER$/;"	d
FEAT_PROFILE	feature.h	/^# define FEAT_PROFILE$/;"	d
FEAT_QUICKFIX	feature.h	/^# define FEAT_QUICKFIX$/;"	d
FEAT_RELTIME	feature.h	/^# define FEAT_RELTIME$/;"	d
FEAT_RIGHTLEFT	feature.h	/^#   define FEAT_RIGHTLEFT$/;"	d
FEAT_RIGHTLEFT	feature.h	/^# define FEAT_RIGHTLEFT$/;"	d
FEAT_SCROLLBIND	feature.h	/^# define FEAT_SCROLLBIND$/;"	d
FEAT_SEARCHPATH	feature.h	/^# define FEAT_SEARCHPATH$/;"	d
FEAT_SEARCH_EXTRA	feature.h	/^# define FEAT_SEARCH_EXTRA$/;"	d
FEAT_SESSION	feature.h	/^# define FEAT_SESSION$/;"	d
FEAT_SIGNS	feature.h	/^# define FEAT_SIGNS$/;"	d
FEAT_SIGN_ICONS	feature.h	/^#  define FEAT_SIGN_ICONS$/;"	d
FEAT_SMALL	feature.h	/^#   define FEAT_SMALL$/;"	d
FEAT_SMALL	feature.h	/^# define FEAT_SMALL$/;"	d
FEAT_SMARTINDENT	feature.h	/^# define FEAT_SMARTINDENT$/;"	d
FEAT_SPELL	feature.h	/^# define FEAT_SPELL$/;"	d
FEAT_STL_OPT	feature.h	/^# define FEAT_STL_OPT$/;"	d
FEAT_SUN_WORKSHOP	feature.h	/^# undef FEAT_SUN_WORKSHOP$/;"	d
FEAT_SYN_HL	feature.h	/^# define FEAT_SYN_HL$/;"	d
FEAT_SYSMOUSE	feature.h	/^# define FEAT_SYSMOUSE$/;"	d
FEAT_TAG_BINS	feature.h	/^# define FEAT_TAG_BINS$/;"	d
FEAT_TAG_OLDSTATIC	feature.h	/^# define FEAT_TAG_OLDSTATIC$/;"	d
FEAT_TEAROFF	feature.h	/^#  define FEAT_TEAROFF$/;"	d
FEAT_TERMRESPONSE	feature.h	/^# define FEAT_TERMRESPONSE$/;"	d
FEAT_TEXTOBJ	feature.h	/^# define FEAT_TEXTOBJ$/;"	d
FEAT_TINY	feature.h	/^# define FEAT_TINY$/;"	d
FEAT_TITLE	feature.h	/^# define FEAT_TITLE$/;"	d
FEAT_TOOLBAR	feature.h	/^# define FEAT_TOOLBAR$/;"	d
FEAT_USR_CMDS	feature.h	/^# define FEAT_USR_CMDS$/;"	d
FEAT_VERTSPLIT	feature.h	/^# define FEAT_VERTSPLIT$/;"	d
FEAT_VIMINFO	feature.h	/^# define FEAT_VIMINFO$/;"	d
FEAT_VIRTUALEDIT	feature.h	/^# define FEAT_VIRTUALEDIT$/;"	d
FEAT_VISUAL	feature.h	/^#   define FEAT_VISUAL$/;"	d
FEAT_VISUAL	feature.h	/^# define FEAT_VISUAL$/;"	d
FEAT_VISUALEXTRA	feature.h	/^#  define FEAT_VISUALEXTRA$/;"	d
FEAT_VREPLACE	feature.h	/^# define FEAT_VREPLACE$/;"	d
FEAT_WAK	option.h	/^#define FEAT_WAK$/;"	d
FEAT_WILDIGN	feature.h	/^# define FEAT_WILDIGN$/;"	d
FEAT_WILDMENU	feature.h	/^# define FEAT_WILDMENU$/;"	d
FEAT_WINDOWS	feature.h	/^# define FEAT_WINDOWS$/;"	d
FEAT_WRITEBACKUP	feature.h	/^# define FEAT_WRITEBACKUP$/;"	d
FEAT_X11	vim.h	/^#  undef FEAT_X11$/;"	d
FEAT_X11	vim.h	/^# define FEAT_X11$/;"	d
FEAT_XCLIPBOARD	feature.h	/^# define FEAT_XCLIPBOARD$/;"	d
FEAT_XCLIPBOARD	vim.h	/^#  undef FEAT_XCLIPBOARD$/;"	d
FEAT_XFONTSET	feature.h	/^#  define FEAT_XFONTSET	/;"	d
FEAT_XFONTSET	feature.h	/^#  define FEAT_XFONTSET$/;"	d
FEAT_XIM	vim.h	/^#  undef FEAT_XIM$/;"	d
FF	ascii.h	/^#define FF	/;"	d
FF	vim.h	/^# undef FF$/;"	d
FF_DOS	option.h	/^#define FF_DOS	/;"	d
FF_MAC	option.h	/^#define FF_MAC	/;"	d
FF_MAX_STAR_STAR_EXPAND	misc2.c	/^#define FF_MAX_STAR_STAR_EXPAND /;"	d	file:
FF_UNIX	option.h	/^#define FF_UNIX	/;"	d
FGETS_SIZE	fileio.c	/^#define FGETS_SIZE /;"	d	file:
FILE1	ex_cmds.h	/^#define FILE1	/;"	d
FILES	ex_cmds.h	/^#define FILES	/;"	d
FILETYPE_FILE	os_unix.h	/^# define FILETYPE_FILE	/;"	d
FILL_X	gui.h	/^# define FILL_X(/;"	d
FILL_Y	gui.h	/^# define FILL_Y(/;"	d
FINDFILE_BOTH	vim.h	/^#define FINDFILE_BOTH	/;"	d
FINDFILE_DIR	vim.h	/^#define FINDFILE_DIR	/;"	d
FINDFILE_FILE	vim.h	/^#define FINDFILE_FILE	/;"	d
FIND_ANY	vim.h	/^#define FIND_ANY	/;"	d
FIND_COMPOUND	spell.c	/^#define FIND_COMPOUND	/;"	d	file:
FIND_DEFINE	vim.h	/^#define FIND_DEFINE	/;"	d
FIND_EVAL	vim.h	/^#define FIND_EVAL	/;"	d
FIND_FOLDWORD	spell.c	/^#define FIND_FOLDWORD	/;"	d	file:
FIND_HELP	if_cscope.h	/^#define FIND_HELP /;"	d
FIND_IDENT	vim.h	/^#define FIND_IDENT	/;"	d
FIND_KEEPCOMPOUND	spell.c	/^#define FIND_KEEPCOMPOUND /;"	d	file:
FIND_KEEPWORD	spell.c	/^#define FIND_KEEPWORD	/;"	d	file:
FIND_PREFIX	spell.c	/^#define FIND_PREFIX	/;"	d	file:
FIND_REPLACE_DIALOG	feature.h	/^# define FIND_REPLACE_DIALOG /;"	d
FIND_STRING	vim.h	/^#define FIND_STRING	/;"	d
FIND_USAGE	if_cscope.h	/^#define	FIND_USAGE /;"	d
FIO_ALL	fileio.c	/^# define FIO_ALL	/;"	d	file:
FIO_CODEPAGE	fileio.c	/^#  define FIO_CODEPAGE	/;"	d	file:
FIO_ENCRYPTED	fileio.c	/^# define FIO_ENCRYPTED	/;"	d	file:
FIO_ENDIAN_L	fileio.c	/^# define FIO_ENDIAN_L	/;"	d	file:
FIO_GET_CP	fileio.c	/^#  define FIO_GET_CP(/;"	d	file:
FIO_LATIN1	fileio.c	/^# define FIO_LATIN1	/;"	d	file:
FIO_MACROMAN	fileio.c	/^#  define FIO_MACROMAN	/;"	d	file:
FIO_NOCONVERT	fileio.c	/^# define FIO_NOCONVERT	/;"	d	file:
FIO_PUT_CP	fileio.c	/^#  define FIO_PUT_CP(/;"	d	file:
FIO_UCS2	fileio.c	/^# define FIO_UCS2	/;"	d	file:
FIO_UCS4	fileio.c	/^# define FIO_UCS4	/;"	d	file:
FIO_UCSBOM	fileio.c	/^# define FIO_UCSBOM	/;"	d	file:
FIO_UTF16	fileio.c	/^# define FIO_UTF16	/;"	d	file:
FIO_UTF8	fileio.c	/^# define FIO_UTF8	/;"	d	file:
FIRST_NL	regexp.c	/^#define FIRST_NL	/;"	d	file:
FIXVAR_CNT	eval.c	/^#define FIXVAR_CNT	/;"	d	file:
FLEN_FIXED	eval.c	/^#define FLEN_FIXED /;"	d	file:
FL_ADJUST_CURSOR	if_tcl.c	/^#define FL_ADJUST_CURSOR	/;"	d	file:
FL_UPDATE_CURBUF	if_tcl.c	/^#define FL_UPDATE_CURBUF	/;"	d	file:
FL_UPDATE_SCREEN	if_tcl.c	/^#define FL_UPDATE_SCREEN	/;"	d	file:
FMT8BIT	gui_at_fs.c	/^# undef FMT8BIT$/;"	d	file:
FMT_PATTERNS	quickfix.c	/^#define FMT_PATTERNS /;"	d	file:
FM_BACKWARD	vim.h	/^#define FM_BACKWARD	/;"	d
FM_BLOCKSTOP	vim.h	/^#define FM_BLOCKSTOP	/;"	d
FM_FORWARD	vim.h	/^#define FM_FORWARD	/;"	d
FM_SKIPCOMM	vim.h	/^#define FM_SKIPCOMM	/;"	d
FNAME	regexp.c	/^#define FNAME	/;"	d	file:
FNAME_EXP	vim.h	/^#define FNAME_EXP	/;"	d
FNAME_HYP	vim.h	/^#define FNAME_HYP	/;"	d
FNAME_INCL	vim.h	/^#define FNAME_INCL	/;"	d
FNAME_MESS	vim.h	/^#define FNAME_MESS	/;"	d
FNAME_REL	vim.h	/^#define FNAME_REL	/;"	d
FNE_CHECK_START	eval.c	/^#define FNE_CHECK_START	/;"	d	file:
FNE_INCL_BR	eval.c	/^#define FNE_INCL_BR	/;"	d	file:
FONTLEN	gui.c	/^#define FONTLEN /;"	d	file:
FONTSET_ALWAYS	gui.h	/^# define FONTSET_ALWAYS$/;"	d
FORCE_BIN	ex_cmds.h	/^#define FORCE_BIN /;"	d
FORCE_NOBIN	ex_cmds.h	/^#define FORCE_NOBIN /;"	d
FOREGROUND	gui_x11_pm.h	/^#define FOREGROUND	/;"	d
FORWARD	vim.h	/^#define FORWARD	/;"	d
FORWARD_FILE	vim.h	/^#define FORWARD_FILE	/;"	d
FOR_ALL_TAB_WINDOWS	globals.h	/^# define FOR_ALL_TAB_WINDOWS(/;"	d
FOR_ALL_TAB_WINDOWS	globals.h	/^#define FOR_ALL_TAB_WINDOWS(/;"	d
FOR_ALL_WINDOWS	globals.h	/^# define FOR_ALL_WINDOWS(/;"	d
FO_ALL	option.h	/^#define FO_ALL	/;"	d
FO_AUTO	option.h	/^#define FO_AUTO	/;"	d
FO_INS_BLANK	option.h	/^#define FO_INS_BLANK	/;"	d
FO_INS_LONG	option.h	/^#define FO_INS_LONG	/;"	d
FO_INS_VI	option.h	/^#define FO_INS_VI	/;"	d
FO_MBYTE_BREAK	option.h	/^#define FO_MBYTE_BREAK	/;"	d
FO_MBYTE_JOIN	option.h	/^#define FO_MBYTE_JOIN	/;"	d
FO_MBYTE_JOIN2	option.h	/^#define FO_MBYTE_JOIN2	/;"	d
FO_ONE_LETTER	option.h	/^#define FO_ONE_LETTER	/;"	d
FO_OPEN_COMS	option.h	/^#define FO_OPEN_COMS	/;"	d
FO_Q_COMS	option.h	/^#define FO_Q_COMS	/;"	d
FO_Q_NUMBER	option.h	/^#define FO_Q_NUMBER	/;"	d
FO_Q_SECOND	option.h	/^#define FO_Q_SECOND	/;"	d
FO_RET_COMS	option.h	/^#define FO_RET_COMS	/;"	d
FO_WHITE_PAR	option.h	/^#define FO_WHITE_PAR	/;"	d
FO_WRAP	option.h	/^#define FO_WRAP	/;"	d
FO_WRAP_COMS	option.h	/^#define FO_WRAP_COMS	/;"	d
FPC_DIFF	vim.h	/^#define FPC_DIFF	/;"	d
FPC_DIFFX	vim.h	/^#define FPC_DIFFX	/;"	d
FPC_NOTX	vim.h	/^#define FPC_NOTX	/;"	d
FPC_SAME	vim.h	/^#define FPC_SAME	/;"	d
FPC_SAMEX	vim.h	/^#define FPC_SAMEX	/;"	d
FRACTION_MULT	window.c	/^#define FRACTION_MULT	/;"	d	file:
FRD_FINDNEXT	gui.h	/^# define FRD_FINDNEXT	/;"	d
FRD_MATCH_CASE	gui.h	/^# define FRD_MATCH_CASE	/;"	d
FRD_REPLACE	gui.h	/^# define FRD_REPLACE	/;"	d
FRD_REPLACEALL	gui.h	/^# define FRD_REPLACEALL	/;"	d
FRD_R_FINDNEXT	gui.h	/^# define FRD_R_FINDNEXT	/;"	d
FRD_TYPE_MASK	gui.h	/^# define FRD_TYPE_MASK /;"	d
FRD_UNDO	gui.h	/^# define FRD_UNDO	/;"	d
FRD_WHOLE_WORD	gui.h	/^# define FRD_WHOLE_WORD	/;"	d
FREAD_SIZE	eval.c	/^#define FREAD_SIZE /;"	d	file:
FREE_FNAME	edit.c	/^#define FREE_FNAME	/;"	d	file:
FR_COL	structs.h	/^#define FR_COL	/;"	d
FR_LEAF	structs.h	/^#define FR_LEAF	/;"	d
FR_ROW	structs.h	/^#define FR_ROW	/;"	d
FTOFF_FILE	os_unix.h	/^# define FTOFF_FILE	/;"	d
FTPLUGIN_FILE	os_unix.h	/^# define FTPLUGIN_FILE	/;"	d
FTPLUGOF_FILE	os_unix.h	/^# define FTPLUGOF_FILE	/;"	d
FUNCARG	eval.c	/^#define FUNCARG(/;"	d	file:
FUNCLINE	eval.c	/^#define FUNCLINE(/;"	d	file:
F_A	hangulin.c	/^#define F_A	/;"	d	file:
F_BCOMMA	farsi.h	/^#define F_BCOMMA	/;"	d
F_BLANK	farsi.h	/^#define F_BLANK	/;"	d
F_BSIZE	memfile.c	/^#  define F_BSIZE /;"	d	file:
F_BSIZE	memfile.c	/^# define F_BSIZE /;"	d	file:
F_BSLASH	farsi.h	/^#define F_BSLASH	/;"	d
F_COMMA	farsi.h	/^#define F_COMMA	/;"	d
F_CURRENCY	farsi.h	/^#define F_CURRENCY	/;"	d
F_DCOLON	farsi.h	/^#define F_DCOLON	/;"	d
F_DIVIDE	farsi.h	/^#define F_DIVIDE	/;"	d
F_EQUALS	farsi.h	/^#define F_EQUALS	/;"	d
F_EXCL	farsi.h	/^#define F_EXCL	/;"	d
F_F	hangulin.c	/^#define F_F	/;"	d	file:
F_GREATER	farsi.h	/^#define F_GREATER	/;"	d
F_HE	farsi.h	/^#define F_HE	/;"	d
F_L	hangulin.c	/^#define F_L	/;"	d	file:
F_LBRACE	farsi.h	/^#define F_LBRACE	/;"	d
F_LBRACK	farsi.h	/^#define F_LBRACK	/;"	d
F_LESS	farsi.h	/^#define F_LESS	/;"	d
F_LPARENT	farsi.h	/^#define F_LPARENT	/;"	d
F_LQUOT	farsi.h	/^#define F_LQUOT	/;"	d
F_M	hangulin.c	/^#define F_M	/;"	d	file:
F_MINUS	farsi.h	/^#define F_MINUS	/;"	d
F_MUL	farsi.h	/^#define F_MUL	/;"	d
F_NULL	hangulin.c	/^#define F_NULL /;"	d	file:
F_PCN	farsi.h	/^#define F_PCN	/;"	d
F_PERCENT	farsi.h	/^#define F_PERCENT	/;"	d
F_PERIOD	farsi.h	/^#define F_PERIOD	/;"	d
F_PIPE	farsi.h	/^#define F_PIPE	/;"	d
F_PLUS	farsi.h	/^#define F_PLUS	/;"	d
F_PSP	farsi.h	/^#define F_PSP	/;"	d
F_QUESTION	farsi.h	/^#define F_QUESTION	/;"	d
F_RBRACE	farsi.h	/^#define F_RBRACE	/;"	d
F_RBRACK	farsi.h	/^#define F_RBRACK	/;"	d
F_RPARENT	farsi.h	/^#define F_RPARENT	/;"	d
F_RQUOT	farsi.h	/^#define F_RQUOT	/;"	d
F_SEMICOLON	farsi.h	/^#define F_SEMICOLON	/;"	d
F_SLASH	farsi.h	/^#define F_SLASH	/;"	d
F_STAR	farsi.h	/^#define F_STAR	/;"	d
F_UNDERLINE	farsi.h	/^#define F_UNDERLINE	/;"	d
F_is_TyB_TyC_TyD	farsi.c	/^F_is_TyB_TyC_TyD(src, offset)$/;"	f	file:
F_is_TyC_TyD	farsi.c	/^F_is_TyC_TyD(c)$/;"	f	file:
F_is_TyE	farsi.c	/^F_is_TyE(c)$/;"	f	file:
F_isalpha	farsi.c	/^F_isalpha(c)$/;"	f
F_ischar	farsi.c	/^F_ischar(c)$/;"	f
F_isdigit	farsi.c	/^F_isdigit(c)$/;"	f
F_isterm	farsi.c	/^F_isterm(c)$/;"	f	file:
FillArea	gui_at_sb.c	/^FillArea(sbw, top, bottom, fill, draw_shadow)$/;"	f	file:
Find	if_cscope.h	/^typedef enum { Add, Find, Help, Kill, Reset, Show } csid_e;$/;"	e	enum:__anon69
FloatInRange	gui_at_sb.c	/^FloatInRange(num, small, big)$/;"	f	file:
FractionLoc	gui_at_sb.c	/^FractionLoc(sbw, x, y)$/;"	f	file:
Free	if_cscope.h	/^    Free,$/;"	e	enum:__anon70
FreeWild	misc1.c	/^FreeWild(count, files)$/;"	f
FullName_save	misc1.c	/^FullName_save(fname, force)$/;"	f
GAF	farsi.h	/^#define GAF	/;"	d
GAP	option.c	/^#define GAP /;"	d	file:
GAP	term.c	/^#define GAP /;"	d	file:
GARGCOUNT	structs.h	/^#define GARGCOUNT	/;"	d
GARGLIST	structs.h	/^#define GARGLIST	/;"	d
GA_CHAR	charset.c	/^#define GA_CHAR(/;"	d	file:
GA_EMPTY	structs.h	/^#define GA_EMPTY /;"	d
GA_PTR	charset.c	/^#define GA_PTR(/;"	d	file:
GC_malloc	if_mzsch.c	/^# define GC_malloc /;"	d	file:
GC_malloc_atomic	if_mzsch.c	/^# define GC_malloc_atomic /;"	d	file:
GETF_ALT	vim.h	/^#define GETF_ALT	/;"	d
GETF_SETMARK	vim.h	/^#define GETF_SETMARK	/;"	d
GETF_SWITCH	vim.h	/^#define GETF_SWITCH	/;"	d
GET_CHARTAB	charset.c	/^#define GET_CHARTAB(/;"	d	file:
GET_LOC_LIST	quickfix.c	/^#define GET_LOC_LIST(/;"	d	file:
GET_X_ATOM	gui_gtk_x11.c	/^# define GET_X_ATOM(/;"	d	file:
GHAF	farsi.h	/^#define GHAF	/;"	d
GHAYN	farsi.h	/^#define GHAYN	/;"	d
GHAYN_	farsi.h	/^#define GHAYN_	/;"	d
GLOBAL_WO	structs.h	/^#define GLOBAL_WO(/;"	d
GOTO_COST	screen.c	/^#define GOTO_COST /;"	d	file:
GO_ALL	option.h	/^#define GO_ALL	/;"	d
GO_ASEL	option.h	/^#define GO_ASEL	/;"	d
GO_ASELML	option.h	/^#define GO_ASELML	/;"	d
GO_BOT	option.h	/^#define GO_BOT	/;"	d
GO_CONDIALOG	option.h	/^#define GO_CONDIALOG	/;"	d
GO_FOOTER	option.h	/^#define GO_FOOTER	/;"	d
GO_FORG	option.h	/^#define GO_FORG	/;"	d
GO_GREY	option.h	/^#define GO_GREY	/;"	d
GO_HORSCROLL	option.h	/^#define GO_HORSCROLL	/;"	d
GO_ICON	option.h	/^#define GO_ICON	/;"	d
GO_LEFT	option.h	/^#define GO_LEFT	/;"	d
GO_MENUS	option.h	/^#define GO_MENUS	/;"	d
GO_NOSYSMENU	option.h	/^#define GO_NOSYSMENU	/;"	d
GO_POINTER	option.h	/^#define GO_POINTER	/;"	d
GO_RIGHT	option.h	/^#define GO_RIGHT	/;"	d
GO_TABLINE	option.h	/^#define GO_TABLINE	/;"	d
GO_TEAROFF	option.h	/^#define GO_TEAROFF	/;"	d
GO_TOOLBAR	option.h	/^#define GO_TOOLBAR	/;"	d
GO_VERTICAL	option.h	/^#define GO_VERTICAL	/;"	d
GO_VLEFT	option.h	/^#define GO_VLEFT	/;"	d
GO_VRIGHT	option.h	/^#define GO_VRIGHT	/;"	d
GPLineEval_EVALUATE	workshop.c	/^    GPLineEval_EVALUATE,		\/* evaluate expression *\/$/;"	e	enum:__anon61	file:
GPLineEval_INDIRECT	workshop.c	/^    GPLineEval_INDIRECT,		\/* evaluate *<expression> *\/$/;"	e	enum:__anon61	file:
GPLineEval_TYPE	workshop.c	/^    GPLineEval_TYPE			\/* type of expression *\/$/;"	e	enum:__anon61	file:
GSList	mbyte.c	/^#  define GSList /;"	d	file:
GTK_FORM	gui_gtk_f.h	/^#define GTK_FORM(/;"	d
GTK_FORM_CLASS	gui_gtk_f.h	/^#define GTK_FORM_CLASS(/;"	d
GTK_IS_FORM	gui_gtk_f.h	/^#define GTK_IS_FORM(/;"	d
GTK_IS_FORM_CLASS	gui_gtk_f.h	/^#define GTK_IS_FORM_CLASS(/;"	d
GTK_TYPE_FORM	gui_gtk_f.h	/^#define GTK_TYPE_FORM	/;"	d
GTK_USE_ACCEL	gui_gtk.c	/^#  define GTK_USE_ACCEL$/;"	d	file:
GUARANTEE_STRING	if_mzsch.h	/^# define GUARANTEE_STRING(/;"	d
GUARDED	netbeans.c	/^#define GUARDED	/;"	d	file:
GUARDEDOFFSET	netbeans.c	/^#define GUARDEDOFFSET /;"	d	file:
GUI_ATTR_ENTRY	syntax.c	/^#define GUI_ATTR_ENTRY(/;"	d	file:
GUI_BEVAL_H	gui_beval.h	/^#define GUI_BEVAL_H$/;"	d
GUI_MON_INVERT	gui.h	/^#define GUI_MON_INVERT	/;"	d
GUI_MON_IS_CURSOR	gui.h	/^#define GUI_MON_IS_CURSOR	/;"	d
GUI_MON_NOCLEAR	gui.h	/^#define GUI_MON_NOCLEAR	/;"	d
GUI_MON_TRS_CURSOR	gui.h	/^#define GUI_MON_TRS_CURSOR	/;"	d
GUI_MON_WRAP_CURSOR	gui.h	/^#define GUI_MON_WRAP_CURSOR	/;"	d
GVIMRC_FILE	os_unix.h	/^#  define GVIMRC_FILE	/;"	d
GdkAtom	gui_gtk_x11.c	/^# define GdkAtom /;"	d	file:
GdkBitmap	gui_gtk.c	/^# define GdkBitmap /;"	d	file:
GdkDragContext	gui_gtk_x11.c	/^# define GdkDragContext /;"	d	file:
GdkEvent	mbyte.c	/^   typedef int GdkEvent;$/;"	t	file:
GdkEvent	proto.h	/^#  define GdkEvent /;"	d
GdkEventButton	gui_gtk_x11.c	/^# define GdkEventButton /;"	d	file:
GdkEventClient	gui_gtk_x11.c	/^# define GdkEventClient /;"	d	file:
GdkEventConfigure	gui_gtk_x11.c	/^# define GdkEventConfigure /;"	d	file:
GdkEventExpose	gui_gtk_x11.c	/^# define GdkEventExpose /;"	d	file:
GdkEventFocus	gui_gtk_x11.c	/^# define GdkEventFocus /;"	d	file:
GdkEventKey	gui_gtk.c	/^# define GdkEventKey /;"	d	file:
GdkEventKey	gui_gtk_x11.c	/^# define GdkEventKey /;"	d	file:
GdkEventKey	mbyte.c	/^   typedef int GdkEventKey;$/;"	t	file:
GdkEventKey	proto.h	/^#  define GdkEventKey /;"	d
GdkEventMotion	gui_gtk_x11.c	/^# define GdkEventMotion /;"	d	file:
GdkEventProperty	gui_gtk_x11.c	/^# define GdkEventProperty /;"	d	file:
GdkEventSelection	gui_gtk_x11.c	/^# define GdkEventSelection /;"	d	file:
GdkEventVisibility	gui_gtk_x11.c	/^# define GdkEventVisibility /;"	d	file:
GdkIC	mbyte.c	/^#  define GdkIC /;"	d	file:
GdkIC	mbyte.c	/^typedef int GdkIC;$/;"	t	file:
GdkPixmap	gui_gtk.c	/^# define GdkPixmap /;"	d	file:
Get	if_cscope.h	/^    Get,$/;"	e	enum:__anon70
GetBufferLine	if_python.c	/^GetBufferLine(buf_T *buf, PyInt n)$/;"	f	file:
GetBufferLineList	if_python.c	/^GetBufferLineList(buf_T *buf, PyInt lo, PyInt hi)$/;"	f	file:
GetRegProp	if_xcmdsrv.c	/^GetRegProp(dpy, regPropp, numItemsp, domsg)$/;"	f	file:
GetWin32Error	if_cscope.c	/^GetWin32Error()$/;"	f	file:
GtkAdjustment	gui_gtk.c	/^# define GtkAdjustment /;"	d	file:
GtkContainer	gui_gtk_x11.c	/^# define GtkContainer /;"	d	file:
GtkForm	gui_gtk_f.h	/^typedef struct _GtkForm GtkForm;$/;"	t	typeref:struct:_GtkForm
GtkFormChild	gui_gtk_f.c	/^typedef struct _GtkFormChild GtkFormChild;$/;"	t	typeref:struct:_GtkFormChild	file:
GtkFormClass	gui_gtk_f.h	/^typedef struct _GtkFormClass GtkFormClass;$/;"	t	typeref:struct:_GtkFormClass
GtkIconFactory	gui_gtk.c	/^# define GtkIconFactory /;"	d	file:
GtkSelectionData	gui_gtk_x11.c	/^# define GtkSelectionData /;"	d	file:
GtkTargetEntry	gui_gtk_x11.c	/^# define GtkTargetEntry /;"	d	file:
GtkToolbar	gui_gtk.c	/^# define GtkToolbar /;"	d	file:
GtkType	gui_gtk_x11.c	/^# define GtkType /;"	d	file:
GtkWidget	gui_gtk.c	/^typedef int GtkWidget;$/;"	t	file:
GtkWidget	gui_gtk_x11.c	/^# define GtkWidget /;"	d	file:
Gui	gui.h	/^typedef struct Gui$/;"	s
GuiFont	gui.h	/^  typedef GdkFont	*GuiFont;	\/* handle for a GUI font *\/$/;"	t
GuiFont	gui.h	/^  typedef PangoFontDescription	*GuiFont;       \/* handle for a GUI font *\/$/;"	t
GuiFont	gui.h	/^  typedef XFontStruct	*GuiFont;	\/* handle for a GUI font *\/$/;"	t
GuiFont	gui.h	/^  typedef char		*GuiFont;$/;"	t
GuiFont	gui.h	/^  typedef long_u	GuiFont;	\/* handle for a GUI font *\/$/;"	t
GuiFontset	gui.h	/^  typedef GdkFont	*GuiFontset;	\/* handle for a GUI fontset *\/$/;"	t
GuiFontset	gui.h	/^  typedef PangoFontDescription  *GuiFontset;    \/* handle for a GUI fontset *\/$/;"	t
GuiFontset	gui.h	/^  typedef XFontSet	GuiFontset;	\/* handle for a GUI fontset *\/$/;"	t
GuiFontset	gui.h	/^  typedef char		*GuiFontset;$/;"	t
GuiFontset	gui.h	/^  typedef long_u	GuiFontset;	\/* handle for a GUI fontset *\/$/;"	t
GuiScrollbar	gui.h	/^typedef struct GuiScrollbar$/;"	s
HAMZE	farsi.h	/^#define HAMZE	/;"	d
HANDLE	if_tcl.c	/^typedef int HANDLE;$/;"	t	file:
HANDLE_ERRORS	integration.c	/^#define HANDLE_ERRORS(/;"	d	file:
HANGUL_DEFAULT_KEYBOARD	feature.h	/^# define HANGUL_DEFAULT_KEYBOARD /;"	d
HANGUL_DEFAULT_KEYBOARD	hangulin.c	/^# define HANGUL_DEFAULT_KEYBOARD /;"	d	file:
HASHITEM_EMPTY	structs.h	/^#define HASHITEM_EMPTY(/;"	d
HASLOOKBH	regexp.c	/^#define HASLOOKBH	/;"	d	file:
HASNL	regexp.c	/^#define HASNL	/;"	d	file:
HASWIDTH	regexp.c	/^#define HASWIDTH	/;"	d	file:
HAS_BW_FLAGS	fileio.c	/^# define HAS_BW_FLAGS$/;"	d	file:
HAS_HOTKEY_LEN	message.c	/^#define HAS_HOTKEY_LEN /;"	d	file:
HAS_SWAP_EXISTS_ACTION	globals.h	/^# define HAS_SWAP_EXISTS_ACTION$/;"	d
HAVE_ACL	os_unix.h	/^#define HAVE_ACL /;"	d
HAVE_BIND_TEXTDOMAIN_CODESET	vim.h	/^#   define HAVE_BIND_TEXTDOMAIN_CODESET /;"	d
HAVE_BUFLIST_MATCH	buffer.c	/^# define HAVE_BUFLIST_MATCH$/;"	d	file:
HAVE_CHECK_STACK_GROWTH	os_unix.c	/^# define HAVE_CHECK_STACK_GROWTH$/;"	d	file:
HAVE_DROP_FILE	gui.h	/^# define HAVE_DROP_FILE$/;"	d
HAVE_DUP	os_unix.h	/^#define HAVE_DUP	/;"	d
HAVE_EX_SCRIPT_NI	ex_docmd.c	/^# define HAVE_EX_SCRIPT_NI$/;"	d	file:
HAVE_FCHDIR	vim.h	/^#  undef HAVE_FCHDIR$/;"	d
HAVE_FCNTL_H	if_python.c	/^# undef HAVE_FCNTL_H$/;"	d	file:
HAVE_FCNTL_H	if_python.c	/^#undef HAVE_FCNTL_H /;"	d	file:
HAVE_ISSYMLINK	vim.h	/^# define HAVE_ISSYMLINK$/;"	d
HAVE_PATHDEF	vim.h	/^# define HAVE_PATHDEF$/;"	d
HAVE_SANDBOX	globals.h	/^# define HAVE_SANDBOX$/;"	d
HAVE_SETENV	vim.h	/^#  define HAVE_SETENV$/;"	d
HAVE_STDARG_H	if_python.c	/^# undef HAVE_STDARG_H	/;"	d	file:
HAVE_ST_MODE	os_unix.h	/^#define HAVE_ST_MODE	/;"	d
HAVE_SVR4_PTYS	pty.c	/^# undef HAVE_SVR4_PTYS$/;"	d	file:
HAVE_SYS_UTSNAME_H	os_unix.h	/^#  undef HAVE_SYS_UTSNAME_H$/;"	d
HAVE_TOTAL_MEM	os_unix.h	/^# define HAVE_TOTAL_MEM$/;"	d
HAVE_UTIME	os_unix.h	/^#  undef HAVE_UTIME$/;"	d
HAVE_XPM	feature.h	/^# define HAVE_XPM /;"	d
HEAD	regexp.c	/^#define HEAD	/;"	d	file:
HEADER_SIZE	memline.c	/^#define HEADER_SIZE /;"	d	file:
HEX	regexp.c	/^#define HEX	/;"	d	file:
HE_J	farsi.h	/^#define HE_J	/;"	d
HI2AH	spell.c	/^#define HI2AH(/;"	d	file:
HI2CI	spell.c	/^#define HI2CI(/;"	d	file:
HI2DI	eval.c	/^#define HI2DI(/;"	d	file:
HI2KE	syntax.c	/^#define HI2KE(/;"	d	file:
HI2SFT	spell.c	/^#define HI2SFT(/;"	d	file:
HI2UF	eval.c	/^#define HI2UF(/;"	d	file:
HI2WC	spell.c	/^#define HI2WC(/;"	d	file:
HI2WN	spell.c	/^#define HI2WN(/;"	d	file:
HIGHLIGHT	gui_x11_pm.h	/^#define HIGHLIGHT	/;"	d
HIGHLIGHT_INIT	option.c	/^# define HIGHLIGHT_INIT /;"	d	file:
HIGHL_COST	screen.c	/^#define HIGHL_COST /;"	d	file:
HIKEY2DI	eval.c	/^#define HIKEY2DI(/;"	d	file:
HIKEY2KE	syntax.c	/^#define HIKEY2KE(/;"	d	file:
HIKEY2SFT	spell.c	/^#define HIKEY2SFT(/;"	d	file:
HIKEY2UF	eval.c	/^#define HIKEY2UF(/;"	d	file:
HINSTANCE	if_python.c	/^#  define HINSTANCE /;"	d	file:
HINSTANCE	if_ruby.c	/^# define HINSTANCE /;"	d	file:
HINSTANCE	mbyte.c	/^# define HINSTANCE /;"	d	file:
HIST_CMD	vim.h	/^#define HIST_CMD	/;"	d
HIST_COUNT	vim.h	/^#define HIST_COUNT	/;"	d
HIST_DEBUG	vim.h	/^#define HIST_DEBUG	/;"	d
HIST_EXPR	vim.h	/^#define HIST_EXPR	/;"	d
HIST_INPUT	vim.h	/^#define HIST_INPUT	/;"	d
HIST_SEARCH	vim.h	/^#define HIST_SEARCH	/;"	d
HITRETURN	vim.h	/^#define HITRETURN	/;"	d
HI_KEY_REMOVED	structs.h	/^#define HI_KEY_REMOVED /;"	d
HLF_8	vim.h	/^    HLF_8 = 0	    \/* Meta & special keys listed with ":map", text that is$/;"	e	enum:__anon103
HLF_ADD	vim.h	/^    , HLF_ADD	    \/* Added diff line *\/$/;"	e	enum:__anon103
HLF_AT	vim.h	/^    , HLF_AT	    \/* @ and ~ characters at end of screen, characters that$/;"	e	enum:__anon103
HLF_C	vim.h	/^    , HLF_C	    \/* column to separate vertically split windows *\/$/;"	e	enum:__anon103
HLF_CHD	vim.h	/^    , HLF_CHD	    \/* Changed diff line *\/$/;"	e	enum:__anon103
HLF_CM	vim.h	/^    , HLF_CM	    \/* Mode (e.g., "-- INSERT --") *\/$/;"	e	enum:__anon103
HLF_COUNT	vim.h	/^    , HLF_COUNT	    \/* MUST be the last one *\/$/;"	e	enum:__anon103
HLF_CUC	vim.h	/^    , HLF_CUC	    \/* 'cursurcolumn' *\/$/;"	e	enum:__anon103
HLF_CUL	vim.h	/^    , HLF_CUL	    \/* 'cursurline' *\/$/;"	e	enum:__anon103
HLF_D	vim.h	/^    , HLF_D	    \/* directories in CTRL-D listing *\/$/;"	e	enum:__anon103
HLF_DED	vim.h	/^    , HLF_DED	    \/* Deleted diff line *\/$/;"	e	enum:__anon103
HLF_E	vim.h	/^    , HLF_E	    \/* error messages *\/$/;"	e	enum:__anon103
HLF_FC	vim.h	/^    , HLF_FC	    \/* Fold column *\/$/;"	e	enum:__anon103
HLF_FL	vim.h	/^    , HLF_FL	    \/* Folded line *\/$/;"	e	enum:__anon103
HLF_H	vim.h	/^    , HLF_H	    \/* obsolete, ignored *\/$/;"	e	enum:__anon103
HLF_I	vim.h	/^    , HLF_I	    \/* incremental search *\/$/;"	e	enum:__anon103
HLF_L	vim.h	/^    , HLF_L	    \/* last search string *\/$/;"	e	enum:__anon103
HLF_M	vim.h	/^    , HLF_M	    \/* "--More--" message *\/$/;"	e	enum:__anon103
HLF_N	vim.h	/^    , HLF_N	    \/* line number for ":number" and ":#" commands *\/$/;"	e	enum:__anon103
HLF_PNI	vim.h	/^    , HLF_PNI	    \/* popup menu normal item *\/$/;"	e	enum:__anon103
HLF_PSB	vim.h	/^    , HLF_PSB	    \/* popup menu scrollbar *\/$/;"	e	enum:__anon103
HLF_PSI	vim.h	/^    , HLF_PSI	    \/* popup menu selected item *\/$/;"	e	enum:__anon103
HLF_PST	vim.h	/^    , HLF_PST	    \/* popup menu scrollbar thumb *\/$/;"	e	enum:__anon103
HLF_R	vim.h	/^    , HLF_R	    \/* return to continue message and yes\/no questions *\/$/;"	e	enum:__anon103
HLF_S	vim.h	/^    , HLF_S	    \/* status lines *\/$/;"	e	enum:__anon103
HLF_SC	vim.h	/^    , HLF_SC	    \/* Sign column *\/$/;"	e	enum:__anon103
HLF_SNC	vim.h	/^    , HLF_SNC	    \/* status lines of not-current windows *\/$/;"	e	enum:__anon103
HLF_SPB	vim.h	/^    , HLF_SPB	    \/* SpellBad *\/$/;"	e	enum:__anon103
HLF_SPC	vim.h	/^    , HLF_SPC	    \/* SpellCap *\/$/;"	e	enum:__anon103
HLF_SPL	vim.h	/^    , HLF_SPL	    \/* SpellLocal *\/$/;"	e	enum:__anon103
HLF_SPR	vim.h	/^    , HLF_SPR	    \/* SpellRare *\/$/;"	e	enum:__anon103
HLF_T	vim.h	/^    , HLF_T	    \/* Titles for output from ":set all", ":autocmd" etc. *\/$/;"	e	enum:__anon103
HLF_TP	vim.h	/^    , HLF_TP	    \/* tabpage line *\/$/;"	e	enum:__anon103
HLF_TPF	vim.h	/^    , HLF_TPF	    \/* tabpage line filler *\/$/;"	e	enum:__anon103
HLF_TPS	vim.h	/^    , HLF_TPS	    \/* tabpage line selected *\/$/;"	e	enum:__anon103
HLF_TXD	vim.h	/^    , HLF_TXD	    \/* Text Changed in diff line *\/$/;"	e	enum:__anon103
HLF_V	vim.h	/^    , HLF_V	    \/* Visual mode *\/$/;"	e	enum:__anon103
HLF_VNC	vim.h	/^    , HLF_VNC	    \/* Visual mode, autoselecting and not clipboard owner *\/$/;"	e	enum:__anon103
HLF_W	vim.h	/^    , HLF_W	    \/* warning messages *\/$/;"	e	enum:__anon103
HLF_WM	vim.h	/^    , HLF_WM	    \/* Wildmenu highlight *\/$/;"	e	enum:__anon103
HL_ALL	vim.h	/^#define HL_ALL	/;"	d
HL_BOLD	vim.h	/^#define HL_BOLD	/;"	d
HL_CONTAINED	syntax.c	/^#define HL_CONTAINED	/;"	d	file:
HL_DISPLAY	syntax.c	/^#define HL_DISPLAY	/;"	d	file:
HL_EXCLUDENL	syntax.c	/^#define HL_EXCLUDENL	/;"	d	file:
HL_EXTEND	syntax.c	/^#define HL_EXTEND	/;"	d	file:
HL_FLAGS	vim.h	/^#define HL_FLAGS /;"	d
HL_FOLD	syntax.c	/^#define HL_FOLD	/;"	d	file:
HL_HAS_EOL	syntax.c	/^#define HL_HAS_EOL	/;"	d	file:
HL_INVERSE	vim.h	/^#define HL_INVERSE	/;"	d
HL_ITALIC	vim.h	/^#define HL_ITALIC	/;"	d
HL_KEEPEND	syntax.c	/^#define HL_KEEPEND	/;"	d	file:
HL_MATCH	syntax.c	/^#define HL_MATCH	/;"	d	file:
HL_MATCHCONT	syntax.c	/^#define HL_MATCHCONT	/;"	d	file:
HL_NORMAL	vim.h	/^#define HL_NORMAL	/;"	d
HL_ONELINE	syntax.c	/^#define HL_ONELINE	/;"	d	file:
HL_SKIPEMPTY	syntax.c	/^#define HL_SKIPEMPTY	/;"	d	file:
HL_SKIPNL	syntax.c	/^#define HL_SKIPNL	/;"	d	file:
HL_SKIPWHITE	syntax.c	/^#define HL_SKIPWHITE	/;"	d	file:
HL_STANDOUT	vim.h	/^#define HL_STANDOUT	/;"	d
HL_SYNC_HERE	syntax.c	/^#define HL_SYNC_HERE	/;"	d	file:
HL_SYNC_THERE	syntax.c	/^#define HL_SYNC_THERE	/;"	d	file:
HL_TABLE	syntax.c	/^#define HL_TABLE(/;"	d	file:
HL_TRANSP	syntax.c	/^#define HL_TRANSP	/;"	d	file:
HL_TRANS_CONT	syntax.c	/^#define HL_TRANS_CONT	/;"	d	file:
HL_UNDERCURL	vim.h	/^#define HL_UNDERCURL	/;"	d
HL_UNDERLINE	vim.h	/^#define HL_UNDERLINE	/;"	d
HMT_DEC	term.c	/^#  define HMT_DEC	/;"	d	file:
HMT_JSBTERM	term.c	/^#  define HMT_JSBTERM	/;"	d	file:
HMT_NETTERM	term.c	/^#  define HMT_NETTERM	/;"	d	file:
HMT_NORMAL	term.c	/^#  define HMT_NORMAL	/;"	d	file:
HMT_PTERM	term.c	/^#  define HMT_PTERM	/;"	d	file:
HOTK_LEN	message.c	/^# define HOTK_LEN /;"	d	file:
HT_INIT_SIZE	structs.h	/^#define HT_INIT_SIZE /;"	d
HWND	globals.h	/^typedef int HWND;$/;"	t
HandleThumb	gui_at_sb.c	/^HandleThumb(w, event, params, num_params)$/;"	f	file:
Help	if_cscope.h	/^typedef enum { Add, Find, Help, Kill, Reset, Show } csid_e;$/;"	e	enum:__anon69
ICONV_E2BIG	vim.h	/^#   define ICONV_E2BIG /;"	d
ICONV_EILSEQ	vim.h	/^#   define ICONV_EILSEQ /;"	d
ICONV_EINVAL	vim.h	/^#   define ICONV_EINVAL /;"	d
ICONV_ERRNO	vim.h	/^#   define ICONV_ERRNO /;"	d
ICONV_MULT	fileio.c	/^#define ICONV_MULT /;"	d	file:
ICONV_TESTLEN	mbyte.c	/^#define ICONV_TESTLEN /;"	d	file:
IDENT	regexp.c	/^#define IDENT	/;"	d	file:
IDX_BIG5	mbyte.c	/^#define IDX_BIG5	/;"	d	file:
IDX_COUNT	mbyte.c	/^#define IDX_COUNT	/;"	d	file:
IDX_CP1250	mbyte.c	/^#define IDX_CP1250	/;"	d	file:
IDX_CP1251	mbyte.c	/^#define IDX_CP1251	/;"	d	file:
IDX_CP1253	mbyte.c	/^#define IDX_CP1253	/;"	d	file:
IDX_CP1254	mbyte.c	/^#define IDX_CP1254	/;"	d	file:
IDX_CP1255	mbyte.c	/^#define IDX_CP1255	/;"	d	file:
IDX_CP1256	mbyte.c	/^#define IDX_CP1256	/;"	d	file:
IDX_CP1257	mbyte.c	/^#define IDX_CP1257	/;"	d	file:
IDX_CP1258	mbyte.c	/^#define IDX_CP1258	/;"	d	file:
IDX_CP437	mbyte.c	/^#define IDX_CP437	/;"	d	file:
IDX_CP737	mbyte.c	/^#define IDX_CP737	/;"	d	file:
IDX_CP775	mbyte.c	/^#define IDX_CP775	/;"	d	file:
IDX_CP850	mbyte.c	/^#define IDX_CP850	/;"	d	file:
IDX_CP852	mbyte.c	/^#define IDX_CP852	/;"	d	file:
IDX_CP855	mbyte.c	/^#define IDX_CP855	/;"	d	file:
IDX_CP857	mbyte.c	/^#define IDX_CP857	/;"	d	file:
IDX_CP860	mbyte.c	/^#define IDX_CP860	/;"	d	file:
IDX_CP861	mbyte.c	/^#define IDX_CP861	/;"	d	file:
IDX_CP862	mbyte.c	/^#define IDX_CP862	/;"	d	file:
IDX_CP863	mbyte.c	/^#define IDX_CP863	/;"	d	file:
IDX_CP865	mbyte.c	/^#define IDX_CP865	/;"	d	file:
IDX_CP866	mbyte.c	/^#define IDX_CP866	/;"	d	file:
IDX_CP869	mbyte.c	/^#define IDX_CP869	/;"	d	file:
IDX_CP874	mbyte.c	/^#define IDX_CP874	/;"	d	file:
IDX_CP932	mbyte.c	/^#define IDX_CP932	/;"	d	file:
IDX_CP936	mbyte.c	/^#define IDX_CP936	/;"	d	file:
IDX_CP949	mbyte.c	/^#define IDX_CP949	/;"	d	file:
IDX_CP950	mbyte.c	/^#define IDX_CP950	/;"	d	file:
IDX_DEBUG	mbyte.c	/^#define IDX_DEBUG	/;"	d	file:
IDX_DECMCS	mbyte.c	/^#define IDX_DECMCS	/;"	d	file:
IDX_EUC_CN	mbyte.c	/^#define IDX_EUC_CN	/;"	d	file:
IDX_EUC_JP	mbyte.c	/^#define IDX_EUC_JP	/;"	d	file:
IDX_EUC_KR	mbyte.c	/^#define IDX_EUC_KR	/;"	d	file:
IDX_EUC_TW	mbyte.c	/^#define IDX_EUC_TW	/;"	d	file:
IDX_HPROMAN8	mbyte.c	/^#define IDX_HPROMAN8	/;"	d	file:
IDX_ISO_10	mbyte.c	/^#define IDX_ISO_10	/;"	d	file:
IDX_ISO_11	mbyte.c	/^#define IDX_ISO_11	/;"	d	file:
IDX_ISO_13	mbyte.c	/^#define IDX_ISO_13	/;"	d	file:
IDX_ISO_14	mbyte.c	/^#define IDX_ISO_14	/;"	d	file:
IDX_ISO_15	mbyte.c	/^#define IDX_ISO_15	/;"	d	file:
IDX_ISO_2	mbyte.c	/^#define IDX_ISO_2	/;"	d	file:
IDX_ISO_3	mbyte.c	/^#define IDX_ISO_3	/;"	d	file:
IDX_ISO_4	mbyte.c	/^#define IDX_ISO_4	/;"	d	file:
IDX_ISO_5	mbyte.c	/^#define IDX_ISO_5	/;"	d	file:
IDX_ISO_6	mbyte.c	/^#define IDX_ISO_6	/;"	d	file:
IDX_ISO_7	mbyte.c	/^#define IDX_ISO_7	/;"	d	file:
IDX_ISO_8	mbyte.c	/^#define IDX_ISO_8	/;"	d	file:
IDX_ISO_9	mbyte.c	/^#define IDX_ISO_9	/;"	d	file:
IDX_KOI8_R	mbyte.c	/^#define IDX_KOI8_R	/;"	d	file:
IDX_KOI8_U	mbyte.c	/^#define IDX_KOI8_U	/;"	d	file:
IDX_LATIN_1	mbyte.c	/^#define IDX_LATIN_1	/;"	d	file:
IDX_MACROMAN	mbyte.c	/^#define IDX_MACROMAN	/;"	d	file:
IDX_SJIS	mbyte.c	/^#define IDX_SJIS	/;"	d	file:
IDX_UCS2	mbyte.c	/^#define IDX_UCS2	/;"	d	file:
IDX_UCS2LE	mbyte.c	/^#define IDX_UCS2LE	/;"	d	file:
IDX_UCS4	mbyte.c	/^#define IDX_UCS4	/;"	d	file:
IDX_UCS4LE	mbyte.c	/^#define IDX_UCS4LE	/;"	d	file:
IDX_UTF16	mbyte.c	/^#define IDX_UTF16	/;"	d	file:
IDX_UTF16LE	mbyte.c	/^#define IDX_UTF16LE	/;"	d	file:
IDX_UTF8	mbyte.c	/^#define IDX_UTF8	/;"	d	file:
ID_LIST_ALL	syntax.c	/^#define ID_LIST_ALL	/;"	d	file:
IE	farsi.h	/^#define IE	/;"	d
IE_	farsi.h	/^#define IE_	/;"	d
IF_EB	ascii.h	/^#define IF_EB(/;"	d
IMLEN_MAX	mbyte.c	/^#define IMLEN_MAX /;"	d	file:
IMPORT	if_ruby.c	/^#  define IMPORT /;"	d	file:
INBUFLEN	ui.c	/^# define INBUFLEN /;"	d	file:
INC	option.c	/^#define INC /;"	d	file:
INC2	term.c	/^#define INC2 /;"	d	file:
INC3	term.c	/^#define INC3 /;"	d	file:
INCSTACK_SIZE	tag.c	/^# define INCSTACK_SIZE /;"	d	file:
INDENT_DEC	vim.h	/^#define INDENT_DEC	/;"	d
INDENT_FILE	os_unix.h	/^# define INDENT_FILE	/;"	d
INDENT_INC	vim.h	/^#define INDENT_INC	/;"	d
INDENT_SET	vim.h	/^#define INDENT_SET	/;"	d
INDEX_SIZE	memline.c	/^#define INDEX_SIZE /;"	d	file:
INDOFF_FILE	os_unix.h	/^# define INDOFF_FILE	/;"	d
INET_SOCKETS	netbeans.c	/^#define INET_SOCKETS$/;"	d	file:
INIT	vim.h	/^#  define INIT(/;"	d
INIT	vim.h	/^# define INIT(/;"	d
INIT_POS_T	structs.h	/^# define INIT_POS_T /;"	d
INPUT_BUFLEN	edit.c	/^#define INPUT_BUFLEN /;"	d	file:
INSCHAR_CTRLV	vim.h	/^#define INSCHAR_CTRLV	/;"	d
INSCHAR_DO_COM	vim.h	/^#define INSCHAR_DO_COM	/;"	d
INSCHAR_FORMAT	vim.h	/^#define INSCHAR_FORMAT	/;"	d
INSCHAR_NO_FEX	vim.h	/^#define INSCHAR_NO_FEX	/;"	d
INSERT	vim.h	/^#define INSERT	/;"	d
INSERT_PANGO_ATTR	gui_gtk_x11.c	/^#define INSERT_PANGO_ATTR(/;"	d	file:
INTPROCINT	os_unix.c	/^typedef int (*INTPROCINT)__ARGS((int));$/;"	t	file:
INTPROCSTR	os_unix.c	/^typedef char_u * (*INTPROCSTR)__ARGS((int));$/;"	t	file:
INVALCOLOR	gui.h	/^#define INVALCOLOR /;"	d
INVALID_BUFFER_VALUE	if_mzsch.c	/^#define INVALID_BUFFER_VALUE /;"	d	file:
INVALID_BUFFER_VALUE	if_python.c	/^#define INVALID_BUFFER_VALUE /;"	d	file:
INVALID_STATE	syntax.c	/^#define INVALID_STATE(/;"	d	file:
INVALID_WINDOW_VALUE	if_mzsch.c	/^#define INVALID_WINDOW_VALUE /;"	d	file:
INVALID_WINDOW_VALUE	if_python.c	/^#define INVALID_WINDOW_VALUE /;"	d	file:
INVERTED	vim.h	/^#define INVERTED	/;"	d
INVERTED_ALL	vim.h	/^#define INVERTED_ALL	/;"	d
IN_BUFFER	vim.h	/^# define IN_BUFFER	/;"	d
IN_OPTION_C	option.c	/^#define IN_OPTION_C$/;"	d	file:
IN_OTHER_WIN	vim.h	/^# define IN_OTHER_WIN	/;"	d
IN_PERL_FILE	if_perlsfio.c	/^#define IN_PERL_FILE	/;"	d	file:
IN_SEP_LINE	vim.h	/^# define IN_SEP_LINE	/;"	d
IN_STATUS_LINE	vim.h	/^# define IN_STATUS_LINE	/;"	d
IN_UNKNOWN	vim.h	/^# define IN_UNKNOWN	/;"	d
IOSIZE	vim.h	/^#define IOSIZE	/;"	d
IObuff	globals.h	/^EXTERN char_u	*IObuff;		\/* sprintf's are done in this buffer,$/;"	v
ISK_LATIN1	option.c	/^#define ISK_LATIN1 /;"	d	file:
ISP_LATIN1	option.c	/^# define ISP_LATIN1 /;"	d	file:
ISSPECIAL	edit.c	/^# define ISSPECIAL(/;"	d	file:
ISSYMLINK	vim.h	/^#  define ISSYMLINK(/;"	d
IS_LL_WINDOW	quickfix.c	/^#define IS_LL_WINDOW(/;"	d	file:
IS_NONPRINTABLE	gui_beval.c	/^#  define IS_NONPRINTABLE(/;"	d	file:
IS_NONPRINTABLE	gui_beval.c	/^#  undef IS_NONPRINTABLE$/;"	d	file:
IS_QF_WINDOW	quickfix.c	/^#define IS_QF_WINDOW(/;"	d	file:
IS_SPECIAL	keymap.h	/^#define IS_SPECIAL(/;"	d
ITEM_COMPARE_FAIL	eval.c	/^#define ITEM_COMPARE_FAIL /;"	d	file:
ITEM_END	syntax.c	/^#define ITEM_END	/;"	d	file:
ITEM_MATCHGROUP	syntax.c	/^#define ITEM_MATCHGROUP	/;"	d	file:
ITEM_SKIP	syntax.c	/^#define ITEM_SKIP	/;"	d	file:
ITEM_START	syntax.c	/^#define ITEM_START	/;"	d	file:
Initialize	gui_at_sb.c	/^Initialize(request, new, args, num_args)$/;"	f	file:
Initialize	gui_xmebw.c	/^Initialize(Widget rq, Widget ebw, ArgList args, Cardinal *n)$/;"	f	file:
InsertBufferLines	if_python.c	/^InsertBufferLines(buf_T *buf, PyInt n, PyObject *lines, PyInt *len_change)$/;"	f	file:
Insstart	globals.h	/^EXTERN pos_T	Insstart;		\/* This is where the latest$/;"	v
Insstart_blank_vcol	edit.c	/^static colnr_T	Insstart_blank_vcol;	\/* vcol for first inserted blank *\/$/;"	v	file:
Insstart_textlen	edit.c	/^static colnr_T	Insstart_textlen;	\/* length of line when insert started *\/$/;"	v	file:
IsNull	gui_xmebw.c	/^#define IsNull(/;"	d	file:
IsSerialName	if_xcmdsrv.c	/^IsSerialName(str)$/;"	f	file:
JAZR	farsi.h	/^#define JAZR	/;"	d
JAZR_N	farsi.h	/^#define JAZR_N	/;"	d
JE	farsi.h	/^#define JE	/;"	d
JIM	farsi.h	/^#define JIM	/;"	d
JMP_BUF	os_unix.h	/^#  define JMP_BUF /;"	d
JUMPLISTSIZE	structs.h	/^#define JUMPLISTSIZE	/;"	d
JUST_CALC_SIZE	regexp.c	/^#define JUST_CALC_SIZE	/;"	d	file:
KAF	farsi.h	/^#define KAF	/;"	d
KE2HIKEY	syntax.c	/^#define KE2HIKEY(/;"	d	file:
KEEP_ROOM	misc2.c	/^# define KEEP_ROOM /;"	d	file:
KEY2TERMCAP0	keymap.h	/^#define KEY2TERMCAP0(/;"	d
KEY2TERMCAP1	keymap.h	/^#define KEY2TERMCAP1(/;"	d
KEYMAP_INIT	structs.h	/^# define KEYMAP_INIT	/;"	d
KEYMAP_LOADED	structs.h	/^# define KEYMAP_LOADED	/;"	d
KEYWORD_IDX	syntax.c	/^#define KEYWORD_IDX	/;"	d	file:
KEY_COMPLETE	vim.h	/^#define KEY_COMPLETE	/;"	d
KEY_NAMES_TABLE_LEN	misc2.c	/^#define KEY_NAMES_TABLE_LEN /;"	d	file:
KEY_OPEN_BACK	vim.h	/^#define KEY_OPEN_BACK	/;"	d
KEY_OPEN_FORW	vim.h	/^#define KEY_OPEN_FORW	/;"	d
KE_CMDWIN	keymap.h	/^    , KE_CMDWIN		\/* open command-line window from Command-line Mode *\/$/;"	e	enum:key_extra
KE_CSI	keymap.h	/^    , KE_CSI		\/* CSI typed directly *\/$/;"	e	enum:key_extra
KE_CURSORHOLD	keymap.h	/^    , KE_CURSORHOLD	\/* CursorHold event *\/$/;"	e	enum:key_extra
KE_C_END	keymap.h	/^    , KE_C_END		\/* control-end *\/$/;"	e	enum:key_extra
KE_C_HOME	keymap.h	/^    , KE_C_HOME		\/* control-home *\/$/;"	e	enum:key_extra
KE_C_LEFT	keymap.h	/^    , KE_C_LEFT		\/* control-left *\/$/;"	e	enum:key_extra
KE_C_RIGHT	keymap.h	/^    , KE_C_RIGHT	\/* control-right *\/$/;"	e	enum:key_extra
KE_DROP	keymap.h	/^    , KE_DROP		\/* DnD data is available *\/$/;"	e	enum:key_extra
KE_FILLER	keymap.h	/^#define KE_FILLER	/;"	d
KE_FOCUSGAINED	keymap.h	/^    , KE_FOCUSGAINED	\/* focus gained *\/$/;"	e	enum:key_extra
KE_FOCUSLOST	keymap.h	/^    , KE_FOCUSLOST	\/* focus lost *\/$/;"	e	enum:key_extra
KE_IGNORE	keymap.h	/^    , KE_IGNORE		\/* Ignored mouse drag\/release *\/$/;"	e	enum:key_extra
KE_KDEL	keymap.h	/^    , KE_KDEL		\/* keypad Delete key *\/$/;"	e	enum:key_extra
KE_KINS	keymap.h	/^    , KE_KINS		\/* keypad Insert key *\/$/;"	e	enum:key_extra
KE_LEFTDRAG	keymap.h	/^    , KE_LEFTDRAG	\/* Drag with left mouse button down *\/$/;"	e	enum:key_extra
KE_LEFTMOUSE	keymap.h	/^    , KE_LEFTMOUSE	\/* Left mouse button click *\/$/;"	e	enum:key_extra
KE_LEFTMOUSE_NM	keymap.h	/^    , KE_LEFTMOUSE_NM	\/* non-mappable Left mouse button click *\/$/;"	e	enum:key_extra
KE_LEFTRELEASE	keymap.h	/^    , KE_LEFTRELEASE	\/* Left mouse button release *\/$/;"	e	enum:key_extra
KE_LEFTRELEASE_NM	keymap.h	/^    , KE_LEFTRELEASE_NM	\/* non-mappable left mouse button release *\/$/;"	e	enum:key_extra
KE_MIDDLEDRAG	keymap.h	/^    , KE_MIDDLEDRAG	\/* Drag with middle mouse button down *\/$/;"	e	enum:key_extra
KE_MIDDLEMOUSE	keymap.h	/^    , KE_MIDDLEMOUSE	\/* Middle mouse button click *\/$/;"	e	enum:key_extra
KE_MIDDLERELEASE	keymap.h	/^    , KE_MIDDLERELEASE	\/* Middle mouse button release *\/$/;"	e	enum:key_extra
KE_MOUSE	keymap.h	/^    , KE_MOUSE		\/* mouse event start *\/$/;"	e	enum:key_extra
KE_MOUSEDOWN	keymap.h	/^    , KE_MOUSEDOWN	\/* scroll wheel pseudo-button Down *\/$/;"	e	enum:key_extra
KE_MOUSEUP	keymap.h	/^    , KE_MOUSEUP	\/* scroll wheel pseudo-button Up *\/$/;"	e	enum:key_extra
KE_NAME	keymap.h	/^    KE_NAME = 3		\/* name of this terminal entry *\/$/;"	e	enum:key_extra
KE_NOP	keymap.h	/^    , KE_NOP		\/* doesn't do something *\/$/;"	e	enum:key_extra
KE_PLUG	keymap.h	/^    , KE_PLUG		\/* <Plug> *\/$/;"	e	enum:key_extra
KE_RIGHTDRAG	keymap.h	/^    , KE_RIGHTDRAG	\/* Drag with right mouse button down *\/$/;"	e	enum:key_extra
KE_RIGHTMOUSE	keymap.h	/^    , KE_RIGHTMOUSE	\/* Right mouse button click *\/$/;"	e	enum:key_extra
KE_RIGHTRELEASE	keymap.h	/^    , KE_RIGHTRELEASE	\/* Right mouse button release *\/$/;"	e	enum:key_extra
KE_SNIFF	keymap.h	/^    , KE_SNIFF		\/* SNiFF+ input waiting *\/$/;"	e	enum:key_extra
KE_SNR	keymap.h	/^    , KE_SNR		\/* <SNR> *\/$/;"	e	enum:key_extra
KE_S_DOWN	keymap.h	/^    , KE_S_DOWN		\/* shift-down *\/$/;"	e	enum:key_extra
KE_S_F1	keymap.h	/^    , KE_S_F1		\/* shifted function keys *\/$/;"	e	enum:key_extra
KE_S_F10	keymap.h	/^    , KE_S_F10$/;"	e	enum:key_extra
KE_S_F11	keymap.h	/^    , KE_S_F11$/;"	e	enum:key_extra
KE_S_F12	keymap.h	/^    , KE_S_F12$/;"	e	enum:key_extra
KE_S_F13	keymap.h	/^    , KE_S_F13$/;"	e	enum:key_extra
KE_S_F14	keymap.h	/^    , KE_S_F14$/;"	e	enum:key_extra
KE_S_F15	keymap.h	/^    , KE_S_F15$/;"	e	enum:key_extra
KE_S_F16	keymap.h	/^    , KE_S_F16$/;"	e	enum:key_extra
KE_S_F17	keymap.h	/^    , KE_S_F17$/;"	e	enum:key_extra
KE_S_F18	keymap.h	/^    , KE_S_F18$/;"	e	enum:key_extra
KE_S_F19	keymap.h	/^    , KE_S_F19$/;"	e	enum:key_extra
KE_S_F2	keymap.h	/^    , KE_S_F2$/;"	e	enum:key_extra
KE_S_F20	keymap.h	/^    , KE_S_F20$/;"	e	enum:key_extra
KE_S_F21	keymap.h	/^    , KE_S_F21$/;"	e	enum:key_extra
KE_S_F22	keymap.h	/^    , KE_S_F22$/;"	e	enum:key_extra
KE_S_F23	keymap.h	/^    , KE_S_F23$/;"	e	enum:key_extra
KE_S_F24	keymap.h	/^    , KE_S_F24$/;"	e	enum:key_extra
KE_S_F25	keymap.h	/^    , KE_S_F25$/;"	e	enum:key_extra
KE_S_F26	keymap.h	/^    , KE_S_F26$/;"	e	enum:key_extra
KE_S_F27	keymap.h	/^    , KE_S_F27$/;"	e	enum:key_extra
KE_S_F28	keymap.h	/^    , KE_S_F28$/;"	e	enum:key_extra
KE_S_F29	keymap.h	/^    , KE_S_F29$/;"	e	enum:key_extra
KE_S_F3	keymap.h	/^    , KE_S_F3$/;"	e	enum:key_extra
KE_S_F30	keymap.h	/^    , KE_S_F30$/;"	e	enum:key_extra
KE_S_F31	keymap.h	/^    , KE_S_F31$/;"	e	enum:key_extra
KE_S_F32	keymap.h	/^    , KE_S_F32$/;"	e	enum:key_extra
KE_S_F33	keymap.h	/^    , KE_S_F33$/;"	e	enum:key_extra
KE_S_F34	keymap.h	/^    , KE_S_F34$/;"	e	enum:key_extra
KE_S_F35	keymap.h	/^    , KE_S_F35$/;"	e	enum:key_extra
KE_S_F36	keymap.h	/^    , KE_S_F36$/;"	e	enum:key_extra
KE_S_F37	keymap.h	/^    , KE_S_F37$/;"	e	enum:key_extra
KE_S_F4	keymap.h	/^    , KE_S_F4$/;"	e	enum:key_extra
KE_S_F5	keymap.h	/^    , KE_S_F5$/;"	e	enum:key_extra
KE_S_F6	keymap.h	/^    , KE_S_F6$/;"	e	enum:key_extra
KE_S_F7	keymap.h	/^    , KE_S_F7$/;"	e	enum:key_extra
KE_S_F8	keymap.h	/^    , KE_S_F8$/;"	e	enum:key_extra
KE_S_F9	keymap.h	/^    , KE_S_F9$/;"	e	enum:key_extra
KE_S_TAB_OLD	keymap.h	/^    , KE_S_TAB_OLD	\/* shifted TAB key (no longer used) *\/$/;"	e	enum:key_extra
KE_S_UP	keymap.h	/^    , KE_S_UP		\/* shift-up *\/$/;"	e	enum:key_extra
KE_S_XF1	keymap.h	/^    , KE_S_XF1		\/* extra vt100 shifted function keys for xterm *\/$/;"	e	enum:key_extra
KE_S_XF2	keymap.h	/^    , KE_S_XF2$/;"	e	enum:key_extra
KE_S_XF3	keymap.h	/^    , KE_S_XF3$/;"	e	enum:key_extra
KE_S_XF4	keymap.h	/^    , KE_S_XF4$/;"	e	enum:key_extra
KE_TAB	keymap.h	/^    , KE_TAB		\/* unshifted TAB key *\/$/;"	e	enum:key_extra
KE_X1DRAG	keymap.h	/^    , KE_X1DRAG$/;"	e	enum:key_extra
KE_X1MOUSE	keymap.h	/^    , KE_X1MOUSE	\/* X1\/X2 mouse-buttons *\/$/;"	e	enum:key_extra
KE_X1RELEASE	keymap.h	/^    , KE_X1RELEASE$/;"	e	enum:key_extra
KE_X2DRAG	keymap.h	/^    , KE_X2DRAG$/;"	e	enum:key_extra
KE_X2MOUSE	keymap.h	/^    , KE_X2MOUSE$/;"	e	enum:key_extra
KE_X2RELEASE	keymap.h	/^    , KE_X2RELEASE$/;"	e	enum:key_extra
KE_XDOWN	keymap.h	/^    , KE_XDOWN$/;"	e	enum:key_extra
KE_XEND	keymap.h	/^    , KE_XEND		\/* extra (vt100) end key for xterm *\/$/;"	e	enum:key_extra
KE_XF1	keymap.h	/^    , KE_XF1		\/* extra vt100 function keys for xterm *\/$/;"	e	enum:key_extra
KE_XF2	keymap.h	/^    , KE_XF2$/;"	e	enum:key_extra
KE_XF3	keymap.h	/^    , KE_XF3$/;"	e	enum:key_extra
KE_XF4	keymap.h	/^    , KE_XF4$/;"	e	enum:key_extra
KE_XHOME	keymap.h	/^    , KE_XHOME		\/* extra (vt100) home key for xterm *\/$/;"	e	enum:key_extra
KE_XLEFT	keymap.h	/^    , KE_XLEFT$/;"	e	enum:key_extra
KE_XRIGHT	keymap.h	/^    , KE_XRIGHT$/;"	e	enum:key_extra
KE_XUP	keymap.h	/^    , KE_XUP		\/* extra vt100 cursor keys for xterm *\/$/;"	e	enum:key_extra
KE_ZEND	keymap.h	/^    , KE_ZEND		\/* extra (vt100) end key for xterm *\/$/;"	e	enum:key_extra
KE_ZHOME	keymap.h	/^    , KE_ZHOME		\/* extra (vt100) home key for xterm *\/$/;"	e	enum:key_extra
KG_ALT	os_unix.c	/^# define KG_ALT	/;"	d	file:
KG_ALTGR	os_unix.c	/^# define KG_ALTGR	/;"	d	file:
KG_CAPSSHIFT	os_unix.c	/^# define KG_CAPSSHIFT	/;"	d	file:
KG_CTRL	os_unix.c	/^# define KG_CTRL	/;"	d	file:
KG_CTRLL	os_unix.c	/^# define KG_CTRLL	/;"	d	file:
KG_CTRLR	os_unix.c	/^# define KG_CTRLR	/;"	d	file:
KG_SHIFT	os_unix.c	/^# define KG_SHIFT	/;"	d	file:
KG_SHIFTL	os_unix.c	/^# define KG_SHIFTL	/;"	d	file:
KG_SHIFTR	os_unix.c	/^# define KG_SHIFTR	/;"	d	file:
KL_PART_KEY	getchar.c	/^#define KL_PART_KEY /;"	d	file:
KL_PART_MAP	getchar.c	/^#define KL_PART_MAP /;"	d	file:
KMAP_LLEN	digraph.c	/^#define KMAP_LLEN /;"	d	file:
KMAP_MAXLEN	digraph.c	/^#define KMAP_MAXLEN /;"	d	file:
KS_AL	term.h	/^    KS_AL,	\/* add new blank line *\/$/;"	e	enum:SpecialKey
KS_BC	term.h	/^    KS_BC,	\/* backspace character (cursor left) *\/$/;"	e	enum:SpecialKey
KS_CAB	term.h	/^    KS_CAB,	\/* set background color (ANSI) *\/$/;"	e	enum:SpecialKey
KS_CAF	term.h	/^    KS_CAF,	\/* set foreground color (ANSI) *\/$/;"	e	enum:SpecialKey
KS_CAL	term.h	/^    KS_CAL,	\/* add number of blank lines *\/$/;"	e	enum:SpecialKey
KS_CCO	term.h	/^    KS_CCO,	\/* number of colors *\/$/;"	e	enum:SpecialKey
KS_CCS	term.h	/^    KS_CCS,	\/* cur is relative to scroll region *\/$/;"	e	enum:SpecialKey
KS_CD	term.h	/^    KS_CD,	\/* clear to end of display *\/$/;"	e	enum:SpecialKey
KS_CDL	term.h	/^    KS_CDL,	\/* delete number of lines *\/$/;"	e	enum:SpecialKey
KS_CE	term.h	/^    KS_CE,	\/* clear to end of line *\/$/;"	e	enum:SpecialKey
KS_CEI	term.h	/^    KS_CEI,	\/* end insert mode (block cursor) *\/$/;"	e	enum:SpecialKey
KS_CIE	term.h	/^    KS_CIE,	\/* set icon text end *\/$/;"	e	enum:SpecialKey
KS_CIS	term.h	/^    KS_CIS,	\/* set icon text start *\/$/;"	e	enum:SpecialKey
KS_CL	term.h	/^    KS_CL,	\/* clear screen *\/$/;"	e	enum:SpecialKey
KS_CM	term.h	/^    KS_CM,	\/* cursor motion *\/$/;"	e	enum:SpecialKey
KS_CRI	term.h	/^    KS_CRI,	\/* cursor number of chars right *\/$/;"	e	enum:SpecialKey
KS_CRV	term.h	/^    KS_CRV,	\/* request version string *\/$/;"	e	enum:SpecialKey
KS_CS	term.h	/^    KS_CS,	\/* scroll region *\/$/;"	e	enum:SpecialKey
KS_CSB	term.h	/^    KS_CSB,	\/* set background color *\/$/;"	e	enum:SpecialKey
KS_CSF	term.h	/^    KS_CSF,	\/* set foreground color *\/$/;"	e	enum:SpecialKey
KS_CSI	term.h	/^    KS_CSI,	\/* start insert mode (bar cursor) *\/$/;"	e	enum:SpecialKey
KS_CSV	term.h	/^    KS_CSV,	\/* scroll region vertical *\/$/;"	e	enum:SpecialKey
KS_CWP	term.h	/^    KS_CWP,	\/* set window position in pixels *\/$/;"	e	enum:SpecialKey
KS_CWS	term.h	/^    KS_CWS,	\/* set window size in characters *\/$/;"	e	enum:SpecialKey
KS_CZH	term.h	/^    KS_CZH,	\/* italic mode start *\/$/;"	e	enum:SpecialKey
KS_CZR	term.h	/^    KS_CZR,	\/* italic mode end *\/$/;"	e	enum:SpecialKey
KS_DA	term.h	/^    KS_DA,	\/* text may be scrolled down from up *\/$/;"	e	enum:SpecialKey
KS_DB	term.h	/^    KS_DB,	\/* text may be scrolled up from down *\/$/;"	e	enum:SpecialKey
KS_DEC_MOUSE	keymap.h	/^#define KS_DEC_MOUSE	/;"	d
KS_DL	term.h	/^    KS_DL,	\/* delete line *\/$/;"	e	enum:SpecialKey
KS_EXTRA	keymap.h	/^#define KS_EXTRA	/;"	d
KS_FS	term.h	/^    KS_FS,	\/* set window title end (from status line) *\/$/;"	e	enum:SpecialKey
KS_HOR_SCROLLBAR	keymap.h	/^#define KS_HOR_SCROLLBAR	/;"	d
KS_JSBTERM_MOUSE	keymap.h	/^#define KS_JSBTERM_MOUSE	/;"	d
KS_KE	term.h	/^    KS_KE,	\/* out of "keypad transmit" mode *\/$/;"	e	enum:SpecialKey
KS_KEY	keymap.h	/^#define KS_KEY	/;"	d
KS_KS	term.h	/^    KS_KS,	\/* put term in "keypad transmit" mode *\/$/;"	e	enum:SpecialKey
KS_LAST	term.h	/^#define KS_LAST	/;"	d
KS_LE	term.h	/^    KS_LE,	\/* cursor left (mostly backspace) *\/$/;"	e	enum:SpecialKey
KS_MB	term.h	/^    KS_MB,	\/* blink mode *\/$/;"	e	enum:SpecialKey
KS_MD	term.h	/^    KS_MD,	\/* bold mode *\/$/;"	e	enum:SpecialKey
KS_ME	term.h	/^    KS_ME,	\/* normal mode *\/$/;"	e	enum:SpecialKey
KS_MENU	keymap.h	/^#define KS_MENU	/;"	d
KS_MODIFIER	keymap.h	/^#define KS_MODIFIER	/;"	d
KS_MOUSE	keymap.h	/^#define KS_MOUSE	/;"	d
KS_MR	term.h	/^    KS_MR,	\/* reverse mode *\/$/;"	e	enum:SpecialKey
KS_MS	term.h	/^    KS_MS,	\/* save to move cur in reverse mode *\/$/;"	e	enum:SpecialKey
KS_NAME	term.h	/^    KS_NAME = 0,\/* name of this terminal entry *\/$/;"	e	enum:SpecialKey
KS_ND	term.h	/^    KS_ND,	\/* cursor right *\/$/;"	e	enum:SpecialKey
KS_NETTERM_MOUSE	keymap.h	/^#define KS_NETTERM_MOUSE	/;"	d
KS_OP	term.h	/^    KS_OP	\/* original color pair *\/$/;"	e	enum:SpecialKey
KS_PTERM_MOUSE	keymap.h	/^#define KS_PTERM_MOUSE	/;"	d
KS_SE	term.h	/^    KS_SE,	\/* normal mode *\/$/;"	e	enum:SpecialKey
KS_SELECT	keymap.h	/^#define KS_SELECT	/;"	d
KS_SO	term.h	/^    KS_SO,	\/* standout mode *\/$/;"	e	enum:SpecialKey
KS_SPECIAL	keymap.h	/^#define KS_SPECIAL	/;"	d
KS_SR	term.h	/^    KS_SR,	\/* scroll reverse (backward) *\/$/;"	e	enum:SpecialKey
KS_TABLINE	keymap.h	/^#define KS_TABLINE	/;"	d
KS_TABMENU	keymap.h	/^#define KS_TABMENU	/;"	d
KS_TE	term.h	/^    KS_TE,	\/* out of termcap mode *\/$/;"	e	enum:SpecialKey
KS_TEAROFF	keymap.h	/^#define KS_TEAROFF	/;"	d
KS_TI	term.h	/^    KS_TI,	\/* put terminal in termcap mode *\/$/;"	e	enum:SpecialKey
KS_TS	term.h	/^    KS_TS,	\/* set window title start (to status line)*\/$/;"	e	enum:SpecialKey
KS_UCE	term.h	/^    KS_UCE,	\/* exit undercurl mode *\/$/;"	e	enum:SpecialKey
KS_UCS	term.h	/^    KS_UCS,	\/* undercurl mode *\/$/;"	e	enum:SpecialKey
KS_UE	term.h	/^    KS_UE,	\/* exit underscore (underline) mode *\/$/;"	e	enum:SpecialKey
KS_US	term.h	/^    KS_US,	\/* underscore (underline) mode *\/$/;"	e	enum:SpecialKey
KS_UT	term.h	/^    KS_UT,	\/* clearing uses current background color *\/$/;"	e	enum:SpecialKey
KS_VB	term.h	/^    KS_VB,	\/* visual bell *\/$/;"	e	enum:SpecialKey
KS_VE	term.h	/^    KS_VE,	\/* cursor visible *\/$/;"	e	enum:SpecialKey
KS_VER_SCROLLBAR	keymap.h	/^#define KS_VER_SCROLLBAR	/;"	d
KS_VI	term.h	/^    KS_VI,	\/* cursor invisible *\/$/;"	e	enum:SpecialKey
KS_VS	term.h	/^    KS_VS,	\/* cursor very visible *\/$/;"	e	enum:SpecialKey
KS_XS	term.h	/^    KS_XS,	\/* standout not erased by overwriting (hpterm) *\/$/;"	e	enum:SpecialKey
KS_ZERO	keymap.h	/^#define KS_ZERO	/;"	d
KWORD	regexp.c	/^#define KWORD	/;"	d	file:
K_BS	keymap.h	/^#define K_BS	/;"	d
K_CMDWIN	keymap.h	/^#define K_CMDWIN	/;"	d
K_CSI	keymap.h	/^#define K_CSI	/;"	d
K_CURSORHOLD	keymap.h	/^#define K_CURSORHOLD	/;"	d
K_C_END	keymap.h	/^#define K_C_END	/;"	d
K_C_HOME	keymap.h	/^#define K_C_HOME	/;"	d
K_C_LEFT	keymap.h	/^#define K_C_LEFT	/;"	d
K_C_RIGHT	keymap.h	/^#define K_C_RIGHT	/;"	d
K_DEC_MOUSE	keymap.h	/^#define K_DEC_MOUSE	/;"	d
K_DEL	keymap.h	/^#define K_DEL	/;"	d
K_DOWN	keymap.h	/^#define K_DOWN	/;"	d
K_DROP	keymap.h	/^#define K_DROP	/;"	d
K_END	keymap.h	/^#define K_END	/;"	d
K_F1	keymap.h	/^#define K_F1	/;"	d
K_F10	keymap.h	/^#define K_F10	/;"	d
K_F11	keymap.h	/^#define K_F11	/;"	d
K_F12	keymap.h	/^#define K_F12	/;"	d
K_F13	keymap.h	/^#define K_F13	/;"	d
K_F14	keymap.h	/^#define K_F14	/;"	d
K_F15	keymap.h	/^#define K_F15	/;"	d
K_F16	keymap.h	/^#define K_F16	/;"	d
K_F17	keymap.h	/^#define K_F17	/;"	d
K_F18	keymap.h	/^#define K_F18	/;"	d
K_F19	keymap.h	/^#define K_F19	/;"	d
K_F2	keymap.h	/^#define K_F2	/;"	d
K_F20	keymap.h	/^#define K_F20	/;"	d
K_F21	keymap.h	/^#define K_F21	/;"	d
K_F22	keymap.h	/^#define K_F22	/;"	d
K_F23	keymap.h	/^#define K_F23	/;"	d
K_F24	keymap.h	/^#define K_F24	/;"	d
K_F25	keymap.h	/^#define K_F25	/;"	d
K_F26	keymap.h	/^#define K_F26	/;"	d
K_F27	keymap.h	/^#define K_F27	/;"	d
K_F28	keymap.h	/^#define K_F28	/;"	d
K_F29	keymap.h	/^#define K_F29	/;"	d
K_F3	keymap.h	/^#define K_F3	/;"	d
K_F30	keymap.h	/^#define K_F30	/;"	d
K_F31	keymap.h	/^#define K_F31	/;"	d
K_F32	keymap.h	/^#define K_F32	/;"	d
K_F33	keymap.h	/^#define K_F33	/;"	d
K_F34	keymap.h	/^#define K_F34	/;"	d
K_F35	keymap.h	/^#define K_F35	/;"	d
K_F36	keymap.h	/^#define K_F36	/;"	d
K_F37	keymap.h	/^#define K_F37	/;"	d
K_F4	keymap.h	/^#define K_F4	/;"	d
K_F5	keymap.h	/^#define K_F5	/;"	d
K_F6	keymap.h	/^#define K_F6	/;"	d
K_F7	keymap.h	/^#define K_F7	/;"	d
K_F8	keymap.h	/^#define K_F8	/;"	d
K_F9	keymap.h	/^#define K_F9	/;"	d
K_FOCUSGAINED	keymap.h	/^#define K_FOCUSGAINED	/;"	d
K_FOCUSLOST	keymap.h	/^#define K_FOCUSLOST	/;"	d
K_HELP	keymap.h	/^#define K_HELP	/;"	d
K_HOME	keymap.h	/^#define K_HOME	/;"	d
K_HOR_SCROLLBAR	keymap.h	/^#define K_HOR_SCROLLBAR /;"	d
K_IGNORE	keymap.h	/^#define K_IGNORE	/;"	d
K_INS	keymap.h	/^#define K_INS	/;"	d
K_JSBTERM_MOUSE	keymap.h	/^#define K_JSBTERM_MOUSE	/;"	d
K_K0	keymap.h	/^#define K_K0	/;"	d
K_K1	keymap.h	/^#define K_K1	/;"	d
K_K2	keymap.h	/^#define K_K2	/;"	d
K_K3	keymap.h	/^#define K_K3	/;"	d
K_K4	keymap.h	/^#define K_K4	/;"	d
K_K5	keymap.h	/^#define K_K5	/;"	d
K_K6	keymap.h	/^#define K_K6	/;"	d
K_K7	keymap.h	/^#define K_K7	/;"	d
K_K8	keymap.h	/^#define K_K8	/;"	d
K_K9	keymap.h	/^#define K_K9	/;"	d
K_KDEL	keymap.h	/^#define K_KDEL	/;"	d
K_KDIVIDE	keymap.h	/^#define K_KDIVIDE	/;"	d
K_KEND	keymap.h	/^#define K_KEND	/;"	d
K_KENTER	keymap.h	/^#define K_KENTER	/;"	d
K_KHOME	keymap.h	/^#define K_KHOME	/;"	d
K_KINS	keymap.h	/^#define K_KINS	/;"	d
K_KMINUS	keymap.h	/^#define K_KMINUS	/;"	d
K_KMULTIPLY	keymap.h	/^#define K_KMULTIPLY	/;"	d
K_KPAGEDOWN	keymap.h	/^#define K_KPAGEDOWN	/;"	d
K_KPAGEUP	keymap.h	/^#define K_KPAGEUP	/;"	d
K_KPLUS	keymap.h	/^#define K_KPLUS	/;"	d
K_KPOINT	keymap.h	/^#define K_KPOINT	/;"	d
K_LEFT	keymap.h	/^#define K_LEFT	/;"	d
K_LEFTDRAG	keymap.h	/^#define K_LEFTDRAG	/;"	d
K_LEFTMOUSE	keymap.h	/^#define K_LEFTMOUSE	/;"	d
K_LEFTMOUSE_NM	keymap.h	/^#define K_LEFTMOUSE_NM	/;"	d
K_LEFTRELEASE	keymap.h	/^#define K_LEFTRELEASE	/;"	d
K_LEFTRELEASE_NM	keymap.h	/^#define K_LEFTRELEASE_NM /;"	d
K_MENU	keymap.h	/^#define K_MENU	/;"	d
K_MIDDLEDRAG	keymap.h	/^#define K_MIDDLEDRAG	/;"	d
K_MIDDLEMOUSE	keymap.h	/^#define K_MIDDLEMOUSE	/;"	d
K_MIDDLERELEASE	keymap.h	/^#define K_MIDDLERELEASE	/;"	d
K_MOUSE	keymap.h	/^#define K_MOUSE	/;"	d
K_MOUSEDOWN	keymap.h	/^#define K_MOUSEDOWN	/;"	d
K_MOUSEUP	keymap.h	/^#define K_MOUSEUP	/;"	d
K_NETTERM_MOUSE	keymap.h	/^#define K_NETTERM_MOUSE	/;"	d
K_NOP	keymap.h	/^#define K_NOP	/;"	d
K_NUL	keymap.h	/^#define K_NUL	/;"	d
K_PAGEDOWN	keymap.h	/^#define K_PAGEDOWN	/;"	d
K_PAGEUP	keymap.h	/^#define K_PAGEUP	/;"	d
K_PLUG	keymap.h	/^#define K_PLUG	/;"	d
K_PTERM_MOUSE	keymap.h	/^#define K_PTERM_MOUSE	/;"	d
K_RIGHT	keymap.h	/^#define K_RIGHT	/;"	d
K_RIGHTDRAG	keymap.h	/^#define K_RIGHTDRAG	/;"	d
K_RIGHTMOUSE	keymap.h	/^#define K_RIGHTMOUSE	/;"	d
K_RIGHTRELEASE	keymap.h	/^#define K_RIGHTRELEASE	/;"	d
K_SECOND	keymap.h	/^#define K_SECOND(/;"	d
K_SELECT	keymap.h	/^#define K_SELECT	/;"	d
K_SELECT_STRING	keymap.h	/^#define K_SELECT_STRING	/;"	d
K_SNIFF	keymap.h	/^#define K_SNIFF	/;"	d
K_SNR	keymap.h	/^#define K_SNR	/;"	d
K_SPECIAL	keymap.h	/^#define K_SPECIAL	/;"	d
K_S_DOWN	keymap.h	/^#define K_S_DOWN	/;"	d
K_S_END	keymap.h	/^#define K_S_END	/;"	d
K_S_F1	keymap.h	/^#define K_S_F1	/;"	d
K_S_F10	keymap.h	/^#define K_S_F10	/;"	d
K_S_F11	keymap.h	/^#define K_S_F11	/;"	d
K_S_F12	keymap.h	/^#define K_S_F12	/;"	d
K_S_F2	keymap.h	/^#define K_S_F2	/;"	d
K_S_F3	keymap.h	/^#define K_S_F3	/;"	d
K_S_F4	keymap.h	/^#define K_S_F4	/;"	d
K_S_F5	keymap.h	/^#define K_S_F5	/;"	d
K_S_F6	keymap.h	/^#define K_S_F6	/;"	d
K_S_F7	keymap.h	/^#define K_S_F7	/;"	d
K_S_F8	keymap.h	/^#define K_S_F8	/;"	d
K_S_F9	keymap.h	/^#define K_S_F9	/;"	d
K_S_HOME	keymap.h	/^#define K_S_HOME	/;"	d
K_S_LEFT	keymap.h	/^#define K_S_LEFT	/;"	d
K_S_RIGHT	keymap.h	/^#define K_S_RIGHT	/;"	d
K_S_TAB	keymap.h	/^#define K_S_TAB	/;"	d
K_S_UP	keymap.h	/^#define K_S_UP	/;"	d
K_S_XF1	keymap.h	/^#define K_S_XF1	/;"	d
K_S_XF2	keymap.h	/^#define K_S_XF2	/;"	d
K_S_XF3	keymap.h	/^#define K_S_XF3	/;"	d
K_S_XF4	keymap.h	/^#define K_S_XF4	/;"	d
K_TAB	keymap.h	/^#define K_TAB	/;"	d
K_TABLINE	keymap.h	/^#define K_TABLINE	/;"	d
K_TABMENU	keymap.h	/^#define K_TABMENU	/;"	d
K_TEAROFF	keymap.h	/^#define K_TEAROFF	/;"	d
K_THIRD	keymap.h	/^#define K_THIRD(/;"	d
K_UNDO	keymap.h	/^#define K_UNDO	/;"	d
K_UP	keymap.h	/^#define K_UP	/;"	d
K_VER_SCROLLBAR	keymap.h	/^#define K_VER_SCROLLBAR	/;"	d
K_X1DRAG	keymap.h	/^#define K_X1DRAG	/;"	d
K_X1MOUSE	keymap.h	/^#define K_X1MOUSE /;"	d
K_X1RELEASE	keymap.h	/^#define K_X1RELEASE /;"	d
K_X2DRAG	keymap.h	/^#define K_X2DRAG	/;"	d
K_X2MOUSE	keymap.h	/^#define K_X2MOUSE /;"	d
K_X2RELEASE	keymap.h	/^#define K_X2RELEASE /;"	d
K_XDOWN	keymap.h	/^#define K_XDOWN	/;"	d
K_XEND	keymap.h	/^#define K_XEND	/;"	d
K_XF1	keymap.h	/^#define K_XF1	/;"	d
K_XF2	keymap.h	/^#define K_XF2	/;"	d
K_XF3	keymap.h	/^#define K_XF3	/;"	d
K_XF4	keymap.h	/^#define K_XF4	/;"	d
K_XHOME	keymap.h	/^#define K_XHOME	/;"	d
K_XLEFT	keymap.h	/^#define K_XLEFT	/;"	d
K_XRIGHT	keymap.h	/^#define K_XRIGHT	/;"	d
K_XUP	keymap.h	/^#define K_XUP	/;"	d
K_ZEND	keymap.h	/^#define K_ZEND	/;"	d
K_ZERO	keymap.h	/^#define K_ZERO	/;"	d
K_ZHOME	keymap.h	/^#define K_ZHOME	/;"	d
KeyNoremap	getchar.c	/^static int		KeyNoremap = 0;	    \/* remapping flags *\/$/;"	v	file:
KeyStuffed	globals.h	/^EXTERN int	KeyStuffed;		\/* TRUE if current char from stuffbuf *\/$/;"	v
KeyTyped	globals.h	/^EXTERN int	KeyTyped;		\/* TRUE if user typed current char *\/$/;"	v
Kill	if_cscope.h	/^typedef enum { Add, Find, Help, Kill, Reset, Show } csid_e;$/;"	e	enum:__anon69
LA	farsi.h	/^#define LA	/;"	d
LAM	farsi.h	/^#define LAM	/;"	d
LANGMAP	vim.h	/^#define LANGMAP	/;"	d
LANGMAP_ADJUST	macros.h	/^# define LANGMAP_ADJUST(/;"	d
LANGP_ENTRY	spell.c	/^#define LANGP_ENTRY(/;"	d	file:
LAST_NL	regexp.c	/^#define LAST_NL	/;"	d	file:
LATIN1LOWER	charset.c	/^#define LATIN1LOWER /;"	d	file:
LATIN1UPPER	charset.c	/^#define LATIN1UPPER /;"	d	file:
LBUFLEN	diff.c	/^#define LBUFLEN /;"	d	file:
LEN_FROM_CONV	mbyte.c	/^# define LEN_FROM_CONV$/;"	d	file:
LINE_ATTR	screen.c	/^# define LINE_ATTR$/;"	d	file:
LINE_DELAY	gui_at_sb.c	/^#define LINE_DELAY	/;"	d	file:
LINE_REPEAT	gui_at_sb.c	/^#define LINE_REPEAT	/;"	d	file:
LISPWORD_VALUE	option.h	/^#define LISPWORD_VALUE	/;"	d
LISTCOUNT	quickfix.c	/^#define LISTCOUNT /;"	d	file:
LIST_ATTR	syntax.c	/^#define LIST_ATTR /;"	d	file:
LIST_INT	syntax.c	/^#define LIST_INT /;"	d	file:
LIST_STRING	syntax.c	/^#define LIST_STRING /;"	d	file:
LONGJMP	os_unix.h	/^#  define LONGJMP /;"	d
LOOKFOR_ANY	misc1.c	/^#define LOOKFOR_ANY	/;"	d	file:
LOOKFOR_CASE	misc1.c	/^#define LOOKFOR_CASE	/;"	d	file:
LOOKFOR_CPP_BASECLASS	misc1.c	/^#define LOOKFOR_CPP_BASECLASS	/;"	d	file:
LOOKFOR_DO	misc1.c	/^#define LOOKFOR_DO	/;"	d	file:
LOOKFOR_ENUM_OR_INIT	misc1.c	/^#define LOOKFOR_ENUM_OR_INIT	/;"	d	file:
LOOKFOR_IF	misc1.c	/^#define LOOKFOR_IF	/;"	d	file:
LOOKFOR_INITIAL	misc1.c	/^#define LOOKFOR_INITIAL	/;"	d	file:
LOOKFOR_NOBREAK	misc1.c	/^#define LOOKFOR_NOBREAK	/;"	d	file:
LOOKFOR_SCOPEDECL	misc1.c	/^#define LOOKFOR_SCOPEDECL	/;"	d	file:
LOOKFOR_TERM	misc1.c	/^#define LOOKFOR_TERM	/;"	d	file:
LOOKFOR_UNTERM	misc1.c	/^#define LOOKFOR_UNTERM	/;"	d	file:
LOWER	regexp.c	/^#define LOWER	/;"	d	file:
LPBOOL	proto.h	/^   typedef int LPBOOL;$/;"	t
LPCWSTR	proto.h	/^   typedef LPCSTR LPCWSTR;$/;"	t
LPWSTR	proto.h	/^   typedef LPSTR LPWSTR;$/;"	t
LREPLACE	vim.h	/^#define LREPLACE	/;"	d
LSIZE	vim.h	/^#define LSIZE	/;"	d
L_MATCH	screen.c	/^#define L_MATCH(/;"	d	file:
L_NULL	hangulin.c	/^#define L_NULL /;"	d	file:
L_SHOWFILE	ex_getln.c	/^#define L_SHOWFILE(/;"	d	file:
Lab_IsMenupane	gui_xmebw.c	/^#  define Lab_IsMenupane(/;"	d	file:
Leave	gui_xmebw.c	/^Leave(Widget wid, XEvent *event, String *params, Cardinal *num_params)$/;"	f	file:
LineOffset	globals.h	/^EXTERN unsigned	*LineOffset INIT(= NULL);$/;"	v
LineToString	if_python.c	/^LineToString(const char *str)$/;"	f	file:
LineWraps	globals.h	/^EXTERN char_u	*LineWraps INIT(= NULL);	\/* line wraps to next line *\/$/;"	v
ListSpecifier	gui_xmdlg.c	/^enum ListSpecifier$/;"	g	file:
LookAhead	gui_at_sb.c	/^LookAhead(w, event)$/;"	f	file:
LookupName	if_xcmdsrv.c	/^LookupName(dpy, name, delete, loose)$/;"	f	file:
MACOS	vim.h	/^#  define MACOS$/;"	d
MACOS_CLASSIC	vim.h	/^# define MACOS_CLASSIC$/;"	d
MACOS_CONVERT	vim.h	/^# define MACOS_CONVERT$/;"	d
MACOS_X	vim.h	/^# define MACOS_X$/;"	d
MAD	farsi.h	/^#define MAD	/;"	d
MAD_N	farsi.h	/^#define MAD_N	/;"	d
MAGIC_ALL	regexp.c	/^#define MAGIC_ALL	/;"	d	file:
MAGIC_NONE	regexp.c	/^#define MAGIC_NONE	/;"	d	file:
MAGIC_OFF	regexp.c	/^#define MAGIC_OFF	/;"	d	file:
MAGIC_ON	regexp.c	/^#define MAGIC_ON	/;"	d	file:
MAP_ALL_MODES	vim.h	/^#define MAP_ALL_MODES	/;"	d
MAP_HASH	getchar.c	/^#define MAP_HASH(/;"	d	file:
MARGIN	gui_at_sb.c	/^#define MARGIN(/;"	d	file:
MATCH	regexp.c	/^#define MATCH	/;"	d	file:
MAUTO	vim.h	/^#define MAUTO	/;"	d
MAX	gui.h	/^#   undef MAX$/;"	d
MAX	gui_gtk.c	/^# undef MAX$/;"	d	file:
MAX	integration.c	/^# define MAX(/;"	d	file:
MAX	vim.h	/^#  undef MAX$/;"	d
MAXCOL	vim.h	/^#  define MAXCOL /;"	d
MAXCOL	vim.h	/^# define MAXCOL	/;"	d
MAXITEMCNT	spell.c	/^#define MAXITEMCNT /;"	d	file:
MAXKEYWLEN	syntax.c	/^#define MAXKEYWLEN	/;"	d	file:
MAXLINELEN	spell.c	/^#define MAXLINELEN /;"	d	file:
MAXLNUM	vim.h	/^#define MAXLNUM /;"	d
MAXMAPLEN	vim.h	/^#define MAXMAPLEN /;"	d
MAXMSGSIZE	netbeans.c	/^#define MAXMSGSIZE /;"	d	file:
MAXNAMLEN	os_unix.h	/^# define MAXNAMLEN /;"	d
MAXPATHL	os_unix.h	/^# define MAXPATHL	/;"	d
MAXPATHL	vim.h	/^#  define MAXPATHL /;"	d
MAXSCORE	spell.c	/^#define MAXSCORE(/;"	d	file:
MAXSUFLEN	misc1.c	/^#define MAXSUFLEN /;"	d	file:
MAXWLEN	spell.c	/^#define MAXWLEN /;"	d	file:
MAXWORDCOUNT	spell.c	/^#define MAXWORDCOUNT /;"	d	file:
MAX_ARG_CMDS	main.c	/^#define MAX_ARG_CMDS /;"	d	file:
MAX_DISPLAY_SIZE	gui_xmdlg.c	/^#define MAX_DISPLAY_SIZE	/;"	d	file:
MAX_ENTRIES_IN_LIST	gui_xmdlg.c	/^#define MAX_ENTRIES_IN_LIST	/;"	d	file:
MAX_FONTS	gui_xmdlg.c	/^#define MAX_FONTS	/;"	d	file:
MAX_FONT_NAME_LEN	gui_xmdlg.c	/^#define MAX_FONT_NAME_LEN	/;"	d	file:
MAX_FUNC_ARGS	eval.c	/^#define MAX_FUNC_ARGS	/;"	d	file:
MAX_KEY_CODE_LEN	keymap.h	/^#define MAX_KEY_CODE_LEN /;"	d
MAX_KEY_NAME_LEN	keymap.h	/^#define MAX_KEY_NAME_LEN /;"	d
MAX_LEVEL	fold.c	/^#define MAX_LEVEL	/;"	d	file:
MAX_LIMIT	regexp.c	/^#define MAX_LIMIT	/;"	d	file:
MAX_MCO	vim.h	/^# define MAX_MCO	/;"	d
MAX_MSG_HIST_LEN	feature.h	/^# define MAX_MSG_HIST_LEN /;"	d
MAX_NAME_LENGTH	if_xcmdsrv.c	/^#define MAX_NAME_LENGTH /;"	d	file:
MAX_PROP_WORDS	if_xcmdsrv.c	/^#define MAX_PROP_WORDS /;"	d	file:
MAX_SWAP_PAGE_SIZE	vim.h	/^#define MAX_SWAP_PAGE_SIZE /;"	d
MAX_TYPENR	vim.h	/^# define MAX_TYPENR /;"	d
MAYBE	vim.h	/^#define MAYBE	/;"	d
MAY_FORK	gui.c	/^# define MAY_FORK$/;"	d	file:
MAY_LOOP	os_unix.c	/^# define MAY_LOOP$/;"	d	file:
MBLOCK	vim.h	/^#define MBLOCK	/;"	d
MB_BYTE2LEN	vim.h	/^# define MB_BYTE2LEN(/;"	d
MB_BYTE2LEN_CHECK	vim.h	/^# define MB_BYTE2LEN_CHECK(/;"	d
MB_CHARLEN	macros.h	/^# define MB_CHARLEN(/;"	d
MB_COPY_CHAR	macros.h	/^# define MB_COPY_CHAR(/;"	d
MB_ISLOWER	macros.h	/^# define MB_ISLOWER(/;"	d
MB_ISUPPER	macros.h	/^# define MB_ISUPPER(/;"	d
MB_MAXBYTES	vim.h	/^# define MB_MAXBYTES	/;"	d
MB_STRICMP	vim.h	/^# define MB_STRICMP(/;"	d
MB_STRNICMP	vim.h	/^# define MB_STRNICMP(/;"	d
MB_TOLOWER	macros.h	/^# define MB_TOLOWER(/;"	d
MB_TOUPPER	macros.h	/^# define MB_TOUPPER(/;"	d
MCHAR	vim.h	/^#define MCHAR	/;"	d
MCH_CURSOR_SHAPE	feature.h	/^#  define MCH_CURSOR_SHAPE$/;"	d
MCLOSE	regexp.c	/^#define MCLOSE	/;"	d	file:
MEMBLOCKSIZE	undo.c	/^#define MEMBLOCKSIZE /;"	d	file:
MEMFILE_PAGE_SIZE	memfile.c	/^#define MEMFILE_PAGE_SIZE /;"	d	file:
MEMHASH	structs.h	/^#define MEMHASH(/;"	d
MEMHASHSIZE	structs.h	/^#define MEMHASHSIZE	/;"	d
MEM_SIZES	misc2.c	/^# define MEM_SIZES /;"	d	file:
MENUDEPTH	menu.c	/^#define MENUDEPTH /;"	d	file:
MENU_ALL_MODES	structs.h	/^#define MENU_ALL_MODES	/;"	d
MENU_CMDLINE_MODE	structs.h	/^#define MENU_CMDLINE_MODE	/;"	d
MENU_DEFAULT_HEIGHT	gui.h	/^#define MENU_DEFAULT_HEIGHT /;"	d
MENU_INC	workshop.c	/^#define MENU_INC	/;"	d	file:
MENU_INDEX_CMDLINE	structs.h	/^#define MENU_INDEX_CMDLINE	/;"	d
MENU_INDEX_INSERT	structs.h	/^#define MENU_INDEX_INSERT	/;"	d
MENU_INDEX_INVALID	structs.h	/^#define MENU_INDEX_INVALID	/;"	d
MENU_INDEX_NORMAL	structs.h	/^#define MENU_INDEX_NORMAL	/;"	d
MENU_INDEX_OP_PENDING	structs.h	/^#define MENU_INDEX_OP_PENDING	/;"	d
MENU_INDEX_SELECT	structs.h	/^#define MENU_INDEX_SELECT	/;"	d
MENU_INDEX_TIP	structs.h	/^#define MENU_INDEX_TIP	/;"	d
MENU_INDEX_VISUAL	structs.h	/^#define MENU_INDEX_VISUAL	/;"	d
MENU_INSERT_MODE	structs.h	/^#define MENU_INSERT_MODE	/;"	d
MENU_MODES	structs.h	/^#define MENU_MODES	/;"	d
MENU_NORMAL_MODE	structs.h	/^#define MENU_NORMAL_MODE	/;"	d
MENU_OP_PENDING_MODE	structs.h	/^#define MENU_OP_PENDING_MODE	/;"	d
MENU_SELECT_MODE	structs.h	/^#define MENU_SELECT_MODE	/;"	d
MENU_TIP_MODE	structs.h	/^#define MENU_TIP_MODE	/;"	d
MENU_VISUAL_MODE	structs.h	/^#define MENU_VISUAL_MODE	/;"	d
MESSAGE_FILE	message.c	/^#define MESSAGE_FILE	/;"	d	file:
META	regexp.c	/^static char_u META[] = "%&()*+.123456789<=>?@ACDFHIKLMOPSUVWX[_acdfhiklmnopsuvwxz{|~";$/;"	v	file:
META_flags	regexp.c	/^static char_u META_flags[] = {$/;"	v	file:
ME_ARG_MISSING	main.c	/^#define ME_ARG_MISSING	/;"	d	file:
ME_EXTRA_CMD	main.c	/^#define ME_EXTRA_CMD	/;"	d	file:
ME_GARBAGE	main.c	/^#define ME_GARBAGE	/;"	d	file:
ME_INVALID_ARG	main.c	/^#define ME_INVALID_ARG	/;"	d	file:
ME_TOO_MANY_ARGS	main.c	/^#define ME_TOO_MANY_ARGS	/;"	d	file:
ME_UNKNOWN_OPTION	main.c	/^#define ME_UNKNOWN_OPTION	/;"	d	file:
MFS_ALL	vim.h	/^#define MFS_ALL	/;"	d
MFS_FLUSH	vim.h	/^#define MFS_FLUSH	/;"	d
MFS_STOP	vim.h	/^#define MFS_STOP	/;"	d
MFS_ZERO	vim.h	/^#define MFS_ZERO	/;"	d
MIM	farsi.h	/^#define MIM	/;"	d
MIN	fileio.c	/^# define MIN(/;"	d	file:
MIN	gui.h	/^#   undef MIN$/;"	d
MIN	gui_gtk.c	/^# undef MIN$/;"	d	file:
MIN	vim.h	/^#  undef MIN$/;"	d
MINIMAL_SIZE	getchar.c	/^#define MINIMAL_SIZE /;"	d	file:
MIN_COLUMNS	vim.h	/^#define MIN_COLUMNS	/;"	d
MIN_LINES	vim.h	/^#define MIN_LINES	/;"	d
MIN_SPACE	edit.c	/^#define	MIN_SPACE /;"	d	file:
MIN_SWAP_PAGE_SIZE	vim.h	/^#define MIN_SWAP_PAGE_SIZE /;"	d
MKSESSION_NL	ex_docmd.c	/^# define MKSESSION_NL$/;"	d	file:
MLCS_MAXL	memline.c	/^#define MLCS_MAXL /;"	d	file:
MLCS_MINL	memline.c	/^#define MLCS_MINL /;"	d	file:
MLINE	vim.h	/^#define MLINE	/;"	d
ML_CHNK_ADDLINE	structs.h	/^#define ML_CHNK_ADDLINE /;"	d
ML_CHNK_DELLINE	structs.h	/^#define ML_CHNK_DELLINE /;"	d
ML_CHNK_UPDLINE	structs.h	/^#define ML_CHNK_UPDLINE /;"	d
ML_DELETE	memline.c	/^#define ML_DELETE	/;"	d	file:
ML_EMPTY	structs.h	/^#define ML_EMPTY	/;"	d
ML_EXTRA	tag.c	/^# define ML_EXTRA /;"	d	file:
ML_FIND	memline.c	/^#define ML_FIND	/;"	d	file:
ML_FLUSH	memline.c	/^#define ML_FLUSH	/;"	d	file:
ML_HELP_LEN	tag.c	/^#define ML_HELP_LEN /;"	d	file:
ML_INSERT	memline.c	/^#define ML_INSERT	/;"	d	file:
ML_LINE_DIRTY	structs.h	/^#define ML_LINE_DIRTY	/;"	d
ML_LOCKED_DIRTY	structs.h	/^#define ML_LOCKED_DIRTY	/;"	d
ML_LOCKED_POS	structs.h	/^#define ML_LOCKED_POS	/;"	d
ML_SIMPLE	memline.c	/^#define ML_SIMPLE(/;"	d	file:
MNU_HIDDEN_CHAR	structs.h	/^#define MNU_HIDDEN_CHAR	/;"	d
MODBY_LEN	version.c	/^# define MODBY_LEN /;"	d	file:
MODIFY	ex_cmds.h	/^#define MODIFY /;"	d
MOD_KEYS_ENTRY_SIZE	misc2.c	/^#define MOD_KEYS_ENTRY_SIZE /;"	d	file:
MOD_MASK_2CLICK	keymap.h	/^#define MOD_MASK_2CLICK	/;"	d
MOD_MASK_3CLICK	keymap.h	/^#define MOD_MASK_3CLICK	/;"	d
MOD_MASK_4CLICK	keymap.h	/^#define MOD_MASK_4CLICK	/;"	d
MOD_MASK_ALT	keymap.h	/^#define MOD_MASK_ALT	/;"	d
MOD_MASK_CMD	keymap.h	/^# define MOD_MASK_CMD	/;"	d
MOD_MASK_CTRL	keymap.h	/^#define MOD_MASK_CTRL	/;"	d
MOD_MASK_META	keymap.h	/^#define MOD_MASK_META	/;"	d
MOD_MASK_MULTI_CLICK	keymap.h	/^#define MOD_MASK_MULTI_CLICK	/;"	d
MOD_MASK_SHIFT	keymap.h	/^#define MOD_MASK_SHIFT	/;"	d
MOPEN	regexp.c	/^#define MOPEN	/;"	d	file:
MOTIF_POPUP	gui_motif.c	/^#define MOTIF_POPUP$/;"	d	file:
MOUSEWHEEL_LOW	vim.h	/^# define MOUSEWHEEL_LOW	/;"	d
MOUSE_4	vim.h	/^# define MOUSE_4	/;"	d
MOUSE_5	vim.h	/^# define MOUSE_5	/;"	d
MOUSE_A	option.h	/^#define MOUSE_A	/;"	d
MOUSE_ALL	option.h	/^#define MOUSE_ALL	/;"	d
MOUSE_ALT	vim.h	/^# define MOUSE_ALT	/;"	d
MOUSE_CLICK_MASK	vim.h	/^# define MOUSE_CLICK_MASK	/;"	d
MOUSE_COLOFF	vim.h	/^# define MOUSE_COLOFF /;"	d
MOUSE_COMMAND	option.h	/^#define MOUSE_COMMAND	/;"	d
MOUSE_CTRL	vim.h	/^# define MOUSE_CTRL	/;"	d
MOUSE_DID_MOVE	vim.h	/^# define MOUSE_DID_MOVE	/;"	d
MOUSE_DRAG	vim.h	/^# define MOUSE_DRAG	/;"	d
MOUSE_DRAG_XTERM	vim.h	/^# define MOUSE_DRAG_XTERM /;"	d
MOUSE_FOCUS	vim.h	/^# define MOUSE_FOCUS	/;"	d
MOUSE_FOLD_CLOSE	vim.h	/^# define MOUSE_FOLD_CLOSE	/;"	d
MOUSE_FOLD_OPEN	vim.h	/^# define MOUSE_FOLD_OPEN	/;"	d
MOUSE_HELP	option.h	/^#define MOUSE_HELP	/;"	d
MOUSE_INSERT	option.h	/^#define MOUSE_INSERT	/;"	d
MOUSE_LEFT	vim.h	/^# define MOUSE_LEFT	/;"	d
MOUSE_MAY_STOP_VIS	vim.h	/^# define MOUSE_MAY_STOP_VIS	/;"	d
MOUSE_MAY_VIS	vim.h	/^# define MOUSE_MAY_VIS	/;"	d
MOUSE_MIDDLE	vim.h	/^# define MOUSE_MIDDLE	/;"	d
MOUSE_NONE	option.h	/^#define MOUSE_NONE	/;"	d
MOUSE_NONEF	option.h	/^#define MOUSE_NONEF	/;"	d
MOUSE_NORMAL	option.h	/^#define MOUSE_NORMAL	/;"	d
MOUSE_RELEASE	vim.h	/^# define MOUSE_RELEASE	/;"	d
MOUSE_RELEASED	vim.h	/^# define MOUSE_RELEASED	/;"	d
MOUSE_RETURN	option.h	/^#define MOUSE_RETURN	/;"	d
MOUSE_RIGHT	vim.h	/^# define MOUSE_RIGHT	/;"	d
MOUSE_SETPOS	vim.h	/^# define MOUSE_SETPOS	/;"	d
MOUSE_SHIFT	vim.h	/^# define MOUSE_SHIFT	/;"	d
MOUSE_VISUAL	option.h	/^#define MOUSE_VISUAL	/;"	d
MOUSE_X1	vim.h	/^# define MOUSE_X1	/;"	d
MOUSE_X2	vim.h	/^# define MOUSE_X2	/;"	d
MSG	vim.h	/^#define MSG(/;"	d
MSG_ATTR	vim.h	/^#define MSG_ATTR(/;"	d
MSG_BUF_CLEN	vim.h	/^# define MSG_BUF_CLEN /;"	d
MSG_BUF_LEN	vim.h	/^# define MSG_BUF_LEN /;"	d
MSG_HIST	vim.h	/^#define MSG_HIST	/;"	d
MSG_PUTS	vim.h	/^#define MSG_PUTS(/;"	d
MSG_PUTS_ATTR	vim.h	/^#define MSG_PUTS_ATTR(/;"	d
MSG_PUTS_LONG	vim.h	/^#define MSG_PUTS_LONG(/;"	d
MSG_PUTS_LONG_ATTR	vim.h	/^#define MSG_PUTS_LONG_ATTR(/;"	d
MSG_PUTS_TITLE	vim.h	/^#define MSG_PUTS_TITLE(/;"	d
MSHAPE_HIDE	structs.h	/^#define MSHAPE_HIDE	/;"	d
MSHAPE_NUMBERED	structs.h	/^#define MSHAPE_NUMBERED	/;"	d
MSWIN	vim.h	/^# define MSWIN$/;"	d
MSWIN_FIND_REPLACE	feature.h	/^# define MSWIN_FIND_REPLACE	/;"	d
MSWIN_FR_BUFSIZE	feature.h	/^# define MSWIN_FR_BUFSIZE /;"	d
MT_COUNT	tag.c	/^#define MT_COUNT	/;"	d	file:
MT_GL_CUR	tag.c	/^#define MT_GL_CUR	/;"	d	file:
MT_GL_OTH	tag.c	/^#define MT_GL_OTH	/;"	d	file:
MT_IC_GL_CUR	tag.c	/^#define MT_IC_GL_CUR	/;"	d	file:
MT_IC_GL_OTH	tag.c	/^#define MT_IC_GL_OTH	/;"	d	file:
MT_IC_OFF	tag.c	/^#define MT_IC_OFF	/;"	d	file:
MT_IC_ST_CUR	tag.c	/^#define MT_IC_ST_CUR	/;"	d	file:
MT_IC_ST_OTH	tag.c	/^#define MT_IC_ST_OTH	/;"	d	file:
MT_MASK	tag.c	/^#define MT_MASK	/;"	d	file:
MT_RE_OFF	tag.c	/^#define MT_RE_OFF	/;"	d	file:
MT_ST_CUR	tag.c	/^#define MT_ST_CUR	/;"	d	file:
MT_ST_OTH	tag.c	/^#define MT_ST_OTH	/;"	d	file:
MULTIBYTECODE	regexp.c	/^#define MULTIBYTECODE	/;"	d	file:
MULTISIGN_BYTE	vim.h	/^# define MULTISIGN_BYTE /;"	d
MULTI_MULT	regexp.c	/^#define MULTI_MULT	/;"	d	file:
MULTI_ONE	regexp.c	/^#define MULTI_ONE	/;"	d	file:
MZSCHEME_GUI_THREADS	feature.h	/^# define MZSCHEME_GUI_THREADS$/;"	d
M_NULL	hangulin.c	/^#define M_NULL /;"	d	file:
M_OFFSET	undo.c	/^# define M_OFFSET /;"	d	file:
M_delete	if_mzsch.c	/^static Scheme_Object *M_delete = NULL;$/;"	v	file:
M_execute	if_mzsch.c	/^static Scheme_Object *M_execute = NULL;$/;"	v	file:
M_global	if_mzsch.c	/^static Scheme_Object *M_global = NULL;$/;"	v	file:
M_read	if_mzsch.c	/^static Scheme_Object *M_read = NULL;$/;"	v	file:
M_write	if_mzsch.c	/^static Scheme_Object *M_write = NULL;$/;"	v	file:
MacOSHelpItems	gui.h	/^    int		MacOSHelpItems;	    \/* Nr of help-items supplied by MacOS *\/$/;"	m	struct:Gui
MacOSHelpMenu	gui.h	/^    MenuHandle	MacOSHelpMenu;	    \/* Help menu provided by the MacOS *\/$/;"	m	struct:Gui
Magic	regexp.c	/^#define Magic(/;"	d	file:
MenuMap	workshop.c	/^} MenuMap;$/;"	t	typeref:struct:__anon62	file:
Meta	ascii.h	/^#define Meta(/;"	d
MetaChar	ascii.h	/^#define MetaChar(/;"	d
MetaCharTable	os_unix.c	/^char MetaCharTable[]=$/;"	v
MoveThumb	gui_at_sb.c	/^MoveThumb(w, event, params, num_params)$/;"	f	file:
NALPHA	regexp.c	/^#define NALPHA	/;"	d	file:
NAME	gui_xmdlg.c	/^    NAME,$/;"	e	enum:ListSpecifier	file:
NAMLEN	os_unix.h	/^#  define NAMLEN(/;"	d
NAMLEN	os_unix.h	/^# define NAMLEN(/;"	d
NBDEBUG_H	nbdebug.h	/^#define NBDEBUG_H$/;"	d
NBDEBUG_TRACE	nbdebug.h	/^#define NBDEBUG_TRACE	/;"	d
NBDLEVEL	nbdebug.h	/^#define NBDLEVEL(/;"	d
NBSOCK	netbeans.c	/^typedef __int64 NBSOCK;$/;"	t	file:
NBSOCK	netbeans.c	/^typedef int NBSOCK;$/;"	t	file:
NB_DEBUG_ALL	nbdebug.h	/^#define NB_DEBUG_ALL	/;"	d
NB_DEF_ADDR	netbeans.c	/^#define NB_DEF_ADDR /;"	d	file:
NB_DEF_HOST	netbeans.c	/^#define NB_DEF_HOST /;"	d	file:
NB_DEF_PASS	netbeans.c	/^#define NB_DEF_PASS /;"	d	file:
NB_PRINT	nbdebug.h	/^#define NB_PRINT	/;"	d
NB_TRACE	nbdebug.h	/^#define NB_TRACE	/;"	d
NB_TRACE_COLONCMD	nbdebug.h	/^#define NB_TRACE_COLONCMD	/;"	d
NB_TRACE_VERBOSE	nbdebug.h	/^#define NB_TRACE_VERBOSE	/;"	d
NCLOSE	regexp.c	/^#define NCLOSE	/;"	d	file:
NDIGIT	regexp.c	/^#define NDIGIT	/;"	d	file:
NEEDARG	ex_cmds.h	/^#define NEEDARG	/;"	d
NEED_GUI_UPDATE_SCREEN	gui.c	/^# define NEED_GUI_UPDATE_SCREEN /;"	d	file:
NEWL	regexp.c	/^#define NEWL	/;"	d	file:
NEXT	regexp.c	/^#define NEXT(/;"	d	file:
NHEAD	regexp.c	/^#define NHEAD	/;"	d	file:
NHEX	regexp.c	/^#define NHEX	/;"	d	file:
NIL	if_perlsfio.c	/^#define NIL(/;"	d	file:
NL	ascii.h	/^#define NL	/;"	d
NLOWER	regexp.c	/^#define NLOWER	/;"	d	file:
NL_STR	ascii.h	/^#define NL_STR	/;"	d
NMARKS	structs.h	/^#define NMARKS	/;"	d
NOBEHIND	regexp.c	/^#define NOBEHIND	/;"	d	file:
NOCATGETS	integration.c	/^# define NOCATGETS(/;"	d	file:
NOCTAL	regexp.c	/^#define NOCTAL	/;"	d	file:
NODE_NORMAL	vim.h	/^#define NODE_NORMAL	/;"	d
NODE_OTHER	vim.h	/^#define NODE_OTHER	/;"	d
NODE_WRITABLE	vim.h	/^#define NODE_WRITABLE	/;"	d
NOFONT	gui.h	/^#   define NOFONT	/;"	d
NOFONT	gui.h	/^#  define NOFONT	/;"	d
NOFONT	gui.h	/^# define NOFONT	/;"	d
NOFONTSET	gui.h	/^#   define NOFONTSET	/;"	d
NOFONTSET	gui.h	/^#  define NOFONTSET	/;"	d
NOFONTSET	gui.h	/^# define NOFONTSET	/;"	d
NOHANDS_SUPPORT_FUNCTIONS	integration.h	/^#define NOHANDS_SUPPORT_FUNCTIONS$/;"	d
NOMATCH	regexp.c	/^#define NOMATCH	/;"	d	file:
NONE	gui_xmdlg.c	/^    NONE$/;"	e	enum:ListSpecifier	file:
NONE_IDX	syntax.c	/^#define NONE_IDX	/;"	d	file:
NOON	farsi.h	/^#define NOON	/;"	d
NOPEN	regexp.c	/^#define NOPEN	/;"	d	file:
NOPROTO	vim.h	/^#  define NOPROTO /;"	d
NORMAL	vim.h	/^# undef NORMAL$/;"	d
NORMAL	vim.h	/^#define NORMAL	/;"	d
NORMAL_BUSY	vim.h	/^#define NORMAL_BUSY	/;"	d
NOSPC	ex_cmds.h	/^#define NOSPC	/;"	d
NOTADR	ex_cmds.h	/^#define NOTADR	/;"	d
NOTAGFILE	tag.c	/^#define NOTAGFILE	/;"	d	file:
NOTDONE	vim.h	/^#define NOTDONE	/;"	d
NOTHING	regexp.c	/^#define NOTHING	/;"	d	file:
NOTRLCOM	ex_cmds.h	/^#define NOTRLCOM	/;"	d
NOT_EQUAL	gui_xmebw.c	/^#define NOT_EQUAL(/;"	d	file:
NOT_MULTI	regexp.c	/^#define NOT_MULTI	/;"	d	file:
NOT_VALID	vim.h	/^#define NOT_VALID	/;"	d
NOWIN	window.c	/^#define NOWIN	/;"	d	file:
NO_BUFFERS	vim.h	/^#define NO_BUFFERS	/;"	d
NO_CONSOLE_INPUT	gui.h	/^# define NO_CONSOLE_INPUT	/;"	d
NO_EXPANDPATH	os_unix.h	/^# define NO_EXPANDPATH$/;"	d
NO_SCREEN	vim.h	/^#define NO_SCREEN	/;"	d
NR_TRANS	structs.h	/^typedef struct nr_trans NR_TRANS;$/;"	t	typeref:struct:nr_trans
NSCRIPT	globals.h	/^#define NSCRIPT /;"	d
NSUBEXP	regexp.h	/^#define NSUBEXP /;"	d
NT	if_ruby.c	/^#   define NT$/;"	d	file:
NUL	ascii.h	/^#define NUL	/;"	d
NUMBUFLEN	vim.h	/^#define NUMBUFLEN /;"	d
NUM_ELEMENTS	hardcopy.c	/^#define NUM_ELEMENTS(/;"	d	file:
NUM_EVENTS	vim.h	/^    NUM_EVENTS			\/* MUST be the last one *\/$/;"	e	enum:auto_event
NUM_MOUSE_CLICKS	vim.h	/^# define NUM_MOUSE_CLICKS(/;"	d
NUM_REGISTERS	ops.c	/^#  define NUM_REGISTERS	/;"	d	file:
NUM_REGISTERS	ops.c	/^# define NUM_REGISTERS	/;"	d	file:
NUPPER	regexp.c	/^#define NUPPER	/;"	d	file:
NV_CMDS_SIZE	normal.c	/^#define NV_CMDS_SIZE /;"	d	file:
NV_KEEPREG	normal.c	/^#define NV_KEEPREG /;"	d	file:
NV_LANG	normal.c	/^#define NV_LANG	/;"	d	file:
NV_NCH	normal.c	/^#define NV_NCH	/;"	d	file:
NV_NCH_ALW	normal.c	/^#define NV_NCH_ALW /;"	d	file:
NV_NCH_NOP	normal.c	/^#define NV_NCH_NOP /;"	d	file:
NV_NCW	normal.c	/^#define NV_NCW	/;"	d	file:
NV_RL	normal.c	/^#define NV_RL	/;"	d	file:
NV_SS	normal.c	/^#define NV_SS	/;"	d	file:
NV_SSS	normal.c	/^#define NV_SSS	/;"	d	file:
NV_STS	normal.c	/^#define NV_STS	/;"	d	file:
NWHITE	regexp.c	/^#define NWHITE	/;"	d	file:
NWORD	regexp.c	/^#define NWORD	/;"	d	file:
N_	gui_gtk.c	/^#  undef N_$/;"	d	file:
N_	gui_gtk_x11.c	/^#  undef N_$/;"	d	file:
N_	vim.h	/^#   define N_(/;"	d
N_	vim.h	/^#  define N_(/;"	d
N_	vim.h	/^# define N_(/;"	d
N_DND_TARGETS	gui_gtk_x11.c	/^# define N_DND_TARGETS /;"	d	file:
N_SELECTION_TARGETS	gui_gtk_x11.c	/^#define N_SELECTION_TARGETS /;"	d	file:
NameBuff	globals.h	/^EXTERN char_u	*NameBuff;		\/* file names are expanded in this$/;"	v
NoButton	gui_at_sb.c	/^#define NoButton /;"	d	file:
NotifyScroll	gui_at_sb.c	/^NotifyScroll(w, event, params, num_params)$/;"	f	file:
NotifyThumb	gui_at_sb.c	/^NotifyThumb(w, event, params, num_params)$/;"	f	file:
OCTAL	regexp.c	/^#define OCTAL	/;"	d	file:
OK	vim.h	/^# define OK	/;"	d
ONE_LINE_DATA	gui_at_sb.h	/^#define ONE_LINE_DATA	/;"	d
ONE_PAGE_DATA	gui_at_sb.h	/^#define ONE_PAGE_DATA	/;"	d
OO	farsi.h	/^#define OO	/;"	d
OP	regexp.c	/^#define OP(/;"	d	file:
OPENLINE_DELSPACES	vim.h	/^#define OPENLINE_DELSPACES /;"	d
OPENLINE_DO_COM	vim.h	/^#define OPENLINE_DO_COM	/;"	d
OPENLINE_KEEPTRAIL	vim.h	/^#define OPENLINE_KEEPTRAIL /;"	d
OPENLINE_MARKFIX	vim.h	/^#define OPENLINE_MARKFIX /;"	d
OPEN_CHR_FILES	fileio.c	/^# define OPEN_CHR_FILES$/;"	d	file:
OPEN_OH_ARGTYPE	if_cscope.c	/^#  define OPEN_OH_ARGTYPE /;"	d	file:
OPERAND	regexp.c	/^#define OPERAND(/;"	d	file:
OPERAND_CMP	regexp.c	/^#define OPERAND_CMP(/;"	d	file:
OPERAND_MAX	regexp.c	/^#define OPERAND_MAX(/;"	d	file:
OPERAND_MIN	regexp.c	/^#define OPERAND_MIN(/;"	d	file:
OPT_BOTH	option.c	/^#define OPT_BOTH(/;"	d	file:
OPT_BUF	option.c	/^#define OPT_BUF(/;"	d	file:
OPT_FREE	vim.h	/^#define OPT_FREE	/;"	d
OPT_GLOBAL	vim.h	/^#define OPT_GLOBAL	/;"	d
OPT_LOCAL	vim.h	/^#define OPT_LOCAL	/;"	d
OPT_MBFONT_ASCII	hardcopy.c	/^# define OPT_MBFONT_ASCII /;"	d	file:
OPT_MBFONT_BOLD	hardcopy.c	/^# define OPT_MBFONT_BOLD	/;"	d	file:
OPT_MBFONT_BOLDOBLIQUE	hardcopy.c	/^# define OPT_MBFONT_BOLDOBLIQUE /;"	d	file:
OPT_MBFONT_NUM_OPTIONS	hardcopy.c	/^# define OPT_MBFONT_NUM_OPTIONS /;"	d	file:
OPT_MBFONT_OBLIQUE	hardcopy.c	/^# define OPT_MBFONT_OBLIQUE /;"	d	file:
OPT_MBFONT_REGULAR	hardcopy.c	/^# define OPT_MBFONT_REGULAR /;"	d	file:
OPT_MBFONT_USECOURIER	hardcopy.c	/^# define OPT_MBFONT_USECOURIER /;"	d	file:
OPT_MODELINE	vim.h	/^#define OPT_MODELINE	/;"	d
OPT_NOWIN	vim.h	/^#define OPT_NOWIN	/;"	d
OPT_PRINT_BOT	globals.h	/^# define OPT_PRINT_BOT	/;"	d
OPT_PRINT_COLLATE	globals.h	/^# define OPT_PRINT_COLLATE	/;"	d
OPT_PRINT_DUPLEX	globals.h	/^# define OPT_PRINT_DUPLEX	/;"	d
OPT_PRINT_FORMFEED	globals.h	/^# define OPT_PRINT_FORMFEED	/;"	d
OPT_PRINT_HEADERHEIGHT	globals.h	/^# define OPT_PRINT_HEADERHEIGHT	/;"	d
OPT_PRINT_JOBSPLIT	globals.h	/^# define OPT_PRINT_JOBSPLIT	/;"	d
OPT_PRINT_LEFT	globals.h	/^# define OPT_PRINT_LEFT	/;"	d
OPT_PRINT_NUMBER	globals.h	/^# define OPT_PRINT_NUMBER	/;"	d
OPT_PRINT_NUM_OPTIONS	globals.h	/^# define OPT_PRINT_NUM_OPTIONS	/;"	d
OPT_PRINT_PAPER	globals.h	/^# define OPT_PRINT_PAPER	/;"	d
OPT_PRINT_PORTRAIT	globals.h	/^# define OPT_PRINT_PORTRAIT	/;"	d
OPT_PRINT_RIGHT	globals.h	/^# define OPT_PRINT_RIGHT	/;"	d
OPT_PRINT_SYNTAX	globals.h	/^# define OPT_PRINT_SYNTAX	/;"	d
OPT_PRINT_TOP	globals.h	/^# define OPT_PRINT_TOP	/;"	d
OPT_PRINT_WRAP	globals.h	/^# define OPT_PRINT_WRAP	/;"	d
OPT_WIN	option.c	/^#define OPT_WIN(/;"	d	file:
OPT_WINONLY	vim.h	/^#define OPT_WINONLY	/;"	d
OP_APPEND	vim.h	/^#define OP_APPEND	/;"	d
OP_CHANGE	vim.h	/^#define OP_CHANGE	/;"	d
OP_COLON	vim.h	/^#define OP_COLON	/;"	d
OP_DELETE	vim.h	/^# undef OP_DELETE$/;"	d
OP_DELETE	vim.h	/^#define OP_DELETE	/;"	d
OP_FILTER	vim.h	/^#define OP_FILTER	/;"	d
OP_FOLD	vim.h	/^#define OP_FOLD	/;"	d
OP_FOLDCLOSE	vim.h	/^#define OP_FOLDCLOSE	/;"	d
OP_FOLDCLOSEREC	vim.h	/^#define OP_FOLDCLOSEREC	/;"	d
OP_FOLDDEL	vim.h	/^#define OP_FOLDDEL	/;"	d
OP_FOLDDELREC	vim.h	/^#define OP_FOLDDELREC	/;"	d
OP_FOLDOPEN	vim.h	/^#define OP_FOLDOPEN	/;"	d
OP_FOLDOPENREC	vim.h	/^#define OP_FOLDOPENREC	/;"	d
OP_FORMAT	vim.h	/^#define OP_FORMAT	/;"	d
OP_FORMAT2	vim.h	/^#define OP_FORMAT2	/;"	d
OP_FUNCTION	vim.h	/^#define OP_FUNCTION	/;"	d
OP_INDENT	vim.h	/^#define OP_INDENT	/;"	d
OP_INSERT	vim.h	/^#define OP_INSERT	/;"	d
OP_JOIN	vim.h	/^# undef OP_JOIN$/;"	d
OP_JOIN	vim.h	/^#define OP_JOIN	/;"	d
OP_JOIN_NS	vim.h	/^#define OP_JOIN_NS	/;"	d
OP_LOWER	vim.h	/^#define OP_LOWER	/;"	d
OP_LSHIFT	vim.h	/^#define OP_LSHIFT	/;"	d
OP_NOP	vim.h	/^#define OP_NOP	/;"	d
OP_PENDING	vim.h	/^#define OP_PENDING	/;"	d
OP_REPLACE	vim.h	/^#define OP_REPLACE	/;"	d
OP_ROT13	vim.h	/^#define OP_ROT13	/;"	d
OP_RSHIFT	vim.h	/^#define OP_RSHIFT	/;"	d
OP_TILDE	vim.h	/^#define OP_TILDE	/;"	d
OP_UPPER	vim.h	/^#define OP_UPPER	/;"	d
OP_YANK	vim.h	/^#define OP_YANK	/;"	d
ORIGINAL_TEXT	edit.c	/^#define ORIGINAL_TEXT	/;"	d	file:
OUT_SIZE	term.c	/^#  define OUT_SIZE	/;"	d	file:
OUT_SIZE	term.c	/^# define OUT_SIZE	/;"	d	file:
OUT_STR	vim.h	/^#define OUT_STR(/;"	d
OUT_STR_NF	vim.h	/^#define OUT_STR_NF(/;"	d
OW	farsi.h	/^#define OW	/;"	d
OW_OW	farsi.h	/^#define OW_OW	/;"	d
O_EXTRA	vim.h	/^# define O_EXTRA /;"	d
O_NOCTTY	pty.c	/^# define O_NOCTTY /;"	d	file:
O_NOFOLLOW	vim.h	/^# define O_NOFOLLOW /;"	d
O_NONBLOCK	eval.c	/^# define O_NONBLOCK /;"	d	file:
Offset	gui_at_sb.c	/^#define Offset(/;"	d	file:
Offset	gui_at_sb.c	/^#undef Offset$/;"	d	file:
OpenPTY	pty.c	/^OpenPTY(ttyn)$/;"	f
Output	if_python.c	/^static OutputObject Output =$/;"	v	file:
OutputGetattr	if_python.c	/^OutputGetattr(PyObject *self, char *name)$/;"	f	file:
OutputMethods	if_python.c	/^static struct PyMethodDef OutputMethods[] = {$/;"	v	typeref:struct:PyMethodDef	file:
OutputObject	if_python.c	/^} OutputObject;$/;"	t	typeref:struct:__anon29	file:
OutputSetattr	if_python.c	/^OutputSetattr(PyObject *self, char *name, PyObject *val)$/;"	f	file:
OutputType	if_python.c	/^static PyTypeObject OutputType = {$/;"	v	file:
OutputWrite	if_python.c	/^OutputWrite(PyObject *self, PyObject *args)$/;"	f	file:
OutputWritelines	if_python.c	/^OutputWritelines(PyObject *self, PyObject *args)$/;"	f	file:
PAGE_DELAY	gui_at_sb.c	/^#define PAGE_DELAY	/;"	d	file:
PAGE_REPEAT	gui_at_sb.c	/^#define PAGE_REPEAT	/;"	d	file:
PARAM_COUNT	option.c	/^#define PARAM_COUNT /;"	d	file:
PATHSEP	ascii.h	/^#  define PATHSEP	/;"	d
PATHSEP	ascii.h	/^# define PATHSEP	/;"	d
PATHSEPSTR	ascii.h	/^#  define PATHSEPSTR	/;"	d
PATHSEPSTR	ascii.h	/^# define PATHSEPSTR	/;"	d
PATH_ESC_CHARS	vim.h	/^# define PATH_ESC_CHARS /;"	d
PC	term.c	/^char *UP, *BC, PC;$/;"	v
PC	termlib.c	/^char	PC = 0;		      \/* Pad character, default NULL *\/$/;"	v
PC_STATUS_LEFT	edit.c	/^#define PC_STATUS_LEFT	/;"	d	file:
PC_STATUS_RIGHT	edit.c	/^#define PC_STATUS_RIGHT	/;"	d	file:
PC_STATUS_SET	edit.c	/^#define PC_STATUS_SET	/;"	d	file:
PC_STATUS_UNSET	edit.c	/^#define PC_STATUS_UNSET	/;"	d	file:
PE	farsi.h	/^#define PE	/;"	d
PERROR	vim.h	/^# define PERROR(/;"	d
PERTURB_SHIFT	hashtab.c	/^#define PERTURB_SHIFT /;"	d	file:
PFD_NOPREFIX	spell.c	/^#define PFD_NOPREFIX	/;"	d	file:
PFD_NOTSPECIAL	spell.c	/^#define PFD_NOTSPECIAL	/;"	d	file:
PFD_PREFIXTREE	spell.c	/^#define PFD_PREFIXTREE	/;"	d	file:
PFX_FLAGS	spell.c	/^#define PFX_FLAGS	/;"	d	file:
PICKLENGTH	gui_at_sb.c	/^#define PICKLENGTH(/;"	d	file:
PLAN_CR	screen.c	/^#define PLAN_CR	/;"	d	file:
PLAN_LE	screen.c	/^#define PLAN_LE	/;"	d	file:
PLAN_NL	screen.c	/^#define PLAN_NL	/;"	d	file:
PLAN_WRITE	screen.c	/^#define PLAN_WRITE /;"	d	file:
PLUS	regexp.c	/^#define PLUS	/;"	d	file:
PLUS_REGISTER	ops.c	/^#   define PLUS_REGISTER	/;"	d	file:
POUND	ascii.h	/^#define POUND	/;"	d
PRCOLOR_BLACK	hardcopy.c	/^#define PRCOLOR_BLACK	/;"	d	file:
PRCOLOR_WHITE	hardcopy.c	/^#define PRCOLOR_WHITE	/;"	d	file:
PRINT	regexp.c	/^#define PRINT	/;"	d	file:
PRINTF_DECIMAL_LONG_U	vim.h	/^#define PRINTF_DECIMAL_LONG_U /;"	d
PRINTF_HEX_LONG_U	vim.h	/^# define PRINTF_HEX_LONG_U /;"	d
PRINTLINESIZE	spell.c	/^#define PRINTLINESIZE	/;"	d	file:
PRINTSOME	spell.c	/^#define PRINTSOME(/;"	d	file:
PRINTWIDTH	spell.c	/^#define PRINTWIDTH	/;"	d	file:
PRINT_NUMBER_WIDTH	structs.h	/^#define PRINT_NUMBER_WIDTH /;"	d
PRL_ITEM	ex_cmds2.c	/^#  define PRL_ITEM(/;"	d	file:
PROF_NONE	vim.h	/^#define PROF_NONE	/;"	d
PROF_PAUSED	vim.h	/^#define PROF_PAUSED	/;"	d
PROF_YES	vim.h	/^#define PROF_YES	/;"	d
PROTOCOL_VERSION	integration.c	/^#define	PROTOCOL_VERSION	/;"	d	file:
PRT_CID_PROLOG_VERSION	hardcopy.c	/^#define PRT_CID_PROLOG_VERSION /;"	d	file:
PRT_DSC_ENDCOMMENTS	hardcopy.c	/^#define PRT_DSC_ENDCOMMENTS	/;"	d	file:
PRT_DSC_ENDCOMMENTS_TYPE	hardcopy.c	/^#define PRT_DSC_ENDCOMMENTS_TYPE /;"	d	file:
PRT_DSC_MISC_TYPE	hardcopy.c	/^#define PRT_DSC_MISC_TYPE	/;"	d	file:
PRT_DSC_TITLE	hardcopy.c	/^#define PRT_DSC_TITLE	/;"	d	file:
PRT_DSC_TITLE_TYPE	hardcopy.c	/^#define PRT_DSC_TITLE_TYPE	/;"	d	file:
PRT_DSC_VERSION	hardcopy.c	/^#define PRT_DSC_VERSION	/;"	d	file:
PRT_DSC_VERSION_TYPE	hardcopy.c	/^#define PRT_DSC_VERSION_TYPE	/;"	d	file:
PRT_FILE_BUFFER_LEN	hardcopy.c	/^#define PRT_FILE_BUFFER_LEN /;"	d	file:
PRT_MEDIASIZE_LEN	hardcopy.c	/^#define PRT_MEDIASIZE_LEN /;"	d	file:
PRT_PROLOG_VERSION	hardcopy.c	/^#define PRT_PROLOG_VERSION /;"	d	file:
PRT_PS_DEFAULT_BUFFER_SIZE	hardcopy.c	/^#define PRT_PS_DEFAULT_BUFFER_SIZE /;"	d	file:
PRT_PS_DEFAULT_DPI	hardcopy.c	/^#define PRT_PS_DEFAULT_DPI	/;"	d	file:
PRT_PS_DEFAULT_FONTSIZE	hardcopy.c	/^#define PRT_PS_DEFAULT_FONTSIZE /;"	d	file:
PRT_PS_FONT_BOLD	hardcopy.c	/^#define PRT_PS_FONT_BOLD	/;"	d	file:
PRT_PS_FONT_BOLDOBLIQUE	hardcopy.c	/^#define PRT_PS_FONT_BOLDOBLIQUE /;"	d	file:
PRT_PS_FONT_OBLIQUE	hardcopy.c	/^#define PRT_PS_FONT_OBLIQUE	/;"	d	file:
PRT_PS_FONT_ROMAN	hardcopy.c	/^#define PRT_PS_FONT_ROMAN	/;"	d	file:
PRT_PS_FONT_TO_USER	hardcopy.c	/^#define PRT_PS_FONT_TO_USER(/;"	d	file:
PRT_RESOURCE_CMAP	hardcopy.c	/^#define PRT_RESOURCE_CMAP	/;"	d	file:
PRT_RESOURCE_ENCODING	hardcopy.c	/^#define PRT_RESOURCE_ENCODING	/;"	d	file:
PRT_RESOURCE_HEADER	hardcopy.c	/^#define PRT_RESOURCE_HEADER	/;"	d	file:
PRT_RESOURCE_PROCSET	hardcopy.c	/^#define PRT_RESOURCE_PROCSET	/;"	d	file:
PRT_RESOURCE_RESOURCE	hardcopy.c	/^#define PRT_RESOURCE_RESOURCE	/;"	d	file:
PRT_RESOURCE_TYPE_CMAP	hardcopy.c	/^#define PRT_RESOURCE_TYPE_CMAP /;"	d	file:
PRT_RESOURCE_TYPE_ENCODING	hardcopy.c	/^#define PRT_RESOURCE_TYPE_ENCODING /;"	d	file:
PRT_RESOURCE_TYPE_PROCSET	hardcopy.c	/^#define PRT_RESOURCE_TYPE_PROCSET /;"	d	file:
PRT_UNIT_INCH	globals.h	/^# define PRT_UNIT_INCH	/;"	d
PRT_UNIT_MM	globals.h	/^# define PRT_UNIT_MM	/;"	d
PRT_UNIT_NAMES	globals.h	/^# define PRT_UNIT_NAMES /;"	d
PRT_UNIT_NONE	globals.h	/^# define PRT_UNIT_NONE	/;"	d
PRT_UNIT_PERC	globals.h	/^# define PRT_UNIT_PERC	/;"	d
PRT_UNIT_POINT	globals.h	/^# define PRT_UNIT_POINT	/;"	d
PSCR	hardcopy.c	/^#define PSCR /;"	d	file:
PSLF	hardcopy.c	/^#define PSLF /;"	d	file:
PTR2CHAR	macros.h	/^# define PTR2CHAR(/;"	d
PTR_BL	memline.c	/^typedef struct pointer_block	PTR_BL;	    \/* contents of a pointer block *\/$/;"	t	typeref:struct:pointer_block	file:
PTR_EN	memline.c	/^typedef struct pointer_entry	PTR_EN;	    \/* block\/line-count pair *\/$/;"	t	typeref:struct:pointer_entry	file:
PTR_ID	memline.c	/^#define PTR_ID	/;"	d	file:
PTYRANGE0	pty.c	/^# define PTYRANGE0 /;"	d	file:
PTYRANGE1	pty.c	/^# define PTYRANGE1 /;"	d	file:
PTY_DONE	pty.c	/^#define PTY_DONE$/;"	d	file:
PUM_DEF_HEIGHT	popupmnu.c	/^#define PUM_DEF_HEIGHT /;"	d	file:
PUM_DEF_WIDTH	popupmnu.c	/^#define PUM_DEF_WIDTH /;"	d	file:
PUT_CURSEND	vim.h	/^#define PUT_CURSEND	/;"	d
PUT_CURSLINE	vim.h	/^#define PUT_CURSLINE	/;"	d
PUT_FIXINDENT	vim.h	/^#define PUT_FIXINDENT	/;"	d
PUT_LINE	vim.h	/^#define PUT_LINE	/;"	d
PUT_LINE_FORWARD	vim.h	/^#define PUT_LINE_FORWARD /;"	d
PUT_LINE_SPLIT	vim.h	/^#define PUT_LINE_SPLIT	/;"	d
PV_AI	option.c	/^#define PV_AI	/;"	d	file:
PV_AR	option.c	/^#define PV_AR	/;"	d	file:
PV_ARAB	option.c	/^# define PV_ARAB	/;"	d	file:
PV_BEXPR	option.c	/^# define PV_BEXPR	/;"	d	file:
PV_BH	option.c	/^# define PV_BH	/;"	d	file:
PV_BIN	option.c	/^#define PV_BIN	/;"	d	file:
PV_BL	option.c	/^#define PV_BL	/;"	d	file:
PV_BOMB	option.c	/^# define PV_BOMB	/;"	d	file:
PV_BOTH	option.c	/^#define PV_BOTH /;"	d	file:
PV_BT	option.c	/^# define PV_BT	/;"	d	file:
PV_BUF	option.c	/^#define PV_BUF /;"	d	file:
PV_CFU	option.c	/^# define PV_CFU	/;"	d	file:
PV_CI	option.c	/^#define PV_CI	/;"	d	file:
PV_CIN	option.c	/^# define PV_CIN	/;"	d	file:
PV_CINK	option.c	/^# define PV_CINK	/;"	d	file:
PV_CINO	option.c	/^# define PV_CINO	/;"	d	file:
PV_CINW	option.c	/^# define PV_CINW	/;"	d	file:
PV_CMS	option.c	/^# define PV_CMS	/;"	d	file:
PV_COM	option.c	/^# define PV_COM	/;"	d	file:
PV_CPT	option.c	/^# define PV_CPT	/;"	d	file:
PV_CUC	option.c	/^# define PV_CUC	/;"	d	file:
PV_CUL	option.c	/^# define PV_CUL	/;"	d	file:
PV_DEF	option.c	/^# define PV_DEF	/;"	d	file:
PV_DICT	option.c	/^# define PV_DICT	/;"	d	file:
PV_DIFF	option.c	/^# define PV_DIFF	/;"	d	file:
PV_EFM	option.c	/^# define PV_EFM	/;"	d	file:
PV_EOL	option.c	/^#define PV_EOL	/;"	d	file:
PV_EP	option.c	/^#define PV_EP	/;"	d	file:
PV_ET	option.c	/^#define PV_ET	/;"	d	file:
PV_FDC	option.c	/^# define PV_FDC	/;"	d	file:
PV_FDE	option.c	/^#  define PV_FDE	/;"	d	file:
PV_FDI	option.c	/^# define PV_FDI	/;"	d	file:
PV_FDL	option.c	/^# define PV_FDL	/;"	d	file:
PV_FDM	option.c	/^# define PV_FDM	/;"	d	file:
PV_FDN	option.c	/^# define PV_FDN	/;"	d	file:
PV_FDT	option.c	/^#  define PV_FDT	/;"	d	file:
PV_FEN	option.c	/^# define PV_FEN	/;"	d	file:
PV_FENC	option.c	/^# define PV_FENC	/;"	d	file:
PV_FEX	option.c	/^# define PV_FEX	/;"	d	file:
PV_FF	option.c	/^#define PV_FF	/;"	d	file:
PV_FLP	option.c	/^#define PV_FLP	/;"	d	file:
PV_FML	option.c	/^# define PV_FML	/;"	d	file:
PV_FMR	option.c	/^# define PV_FMR	/;"	d	file:
PV_FO	option.c	/^#define PV_FO	/;"	d	file:
PV_FT	option.c	/^# define PV_FT	/;"	d	file:
PV_GP	option.c	/^# define PV_GP	/;"	d	file:
PV_IMI	option.c	/^#define PV_IMI	/;"	d	file:
PV_IMS	option.c	/^#define PV_IMS	/;"	d	file:
PV_INC	option.c	/^# define PV_INC	/;"	d	file:
PV_INDE	option.c	/^# define PV_INDE	/;"	d	file:
PV_INDK	option.c	/^# define PV_INDK	/;"	d	file:
PV_INEX	option.c	/^# define PV_INEX	/;"	d	file:
PV_INF	option.c	/^#define PV_INF	/;"	d	file:
PV_ISK	option.c	/^#define PV_ISK	/;"	d	file:
PV_KEY	option.c	/^# define PV_KEY	/;"	d	file:
PV_KMAP	option.c	/^# define PV_KMAP	/;"	d	file:
PV_KP	option.c	/^#define PV_KP	/;"	d	file:
PV_LBR	option.c	/^# define PV_LBR	/;"	d	file:
PV_LISP	option.c	/^# define PV_LISP	/;"	d	file:
PV_LIST	option.c	/^#define PV_LIST	/;"	d	file:
PV_MA	option.c	/^#define PV_MA	/;"	d	file:
PV_MASK	option.c	/^#define PV_MASK /;"	d	file:
PV_MAXVAL	option.c	/^    PV_MAXVAL = 0xffff    \/* to avoid warnings for value out of range *\/$/;"	e	enum:__anon45	file:
PV_ML	option.c	/^#define PV_ML	/;"	d	file:
PV_MOD	option.c	/^#define PV_MOD	/;"	d	file:
PV_MP	option.c	/^# define PV_MP	/;"	d	file:
PV_MPS	option.c	/^#define PV_MPS	/;"	d	file:
PV_NF	option.c	/^#define PV_NF	/;"	d	file:
PV_NONE	option.c	/^    PV_NONE = 0,$/;"	e	enum:__anon45	file:
PV_NU	option.c	/^#define PV_NU	/;"	d	file:
PV_NUW	option.c	/^# define PV_NUW	/;"	d	file:
PV_OFT	option.c	/^# define PV_OFT	/;"	d	file:
PV_OFU	option.c	/^# define PV_OFU	/;"	d	file:
PV_PATH	option.c	/^#define PV_PATH	/;"	d	file:
PV_PI	option.c	/^#define PV_PI	/;"	d	file:
PV_PVW	option.c	/^# define PV_PVW	/;"	d	file:
PV_QE	option.c	/^# define PV_QE	/;"	d	file:
PV_RL	option.c	/^# define PV_RL	/;"	d	file:
PV_RLC	option.c	/^# define PV_RLC	/;"	d	file:
PV_RO	option.c	/^#define PV_RO	/;"	d	file:
PV_SCBIND	option.c	/^# define PV_SCBIND	/;"	d	file:
PV_SCROLL	option.c	/^#define PV_SCROLL	/;"	d	file:
PV_SI	option.c	/^# define PV_SI	/;"	d	file:
PV_SMC	option.c	/^# define PV_SMC	/;"	d	file:
PV_SN	option.c	/^# define PV_SN	/;"	d	file:
PV_SPC	option.c	/^# define PV_SPC	/;"	d	file:
PV_SPELL	option.c	/^# define PV_SPELL	/;"	d	file:
PV_SPF	option.c	/^# define PV_SPF	/;"	d	file:
PV_SPL	option.c	/^# define PV_SPL	/;"	d	file:
PV_STL	option.c	/^# define PV_STL	/;"	d	file:
PV_STS	option.c	/^#define PV_STS	/;"	d	file:
PV_SUA	option.c	/^# define PV_SUA	/;"	d	file:
PV_SW	option.c	/^#define PV_SW	/;"	d	file:
PV_SWF	option.c	/^#define PV_SWF	/;"	d	file:
PV_SYN	option.c	/^# define PV_SYN	/;"	d	file:
PV_TAGS	option.c	/^#define PV_TAGS	/;"	d	file:
PV_TS	option.c	/^#define PV_TS	/;"	d	file:
PV_TSR	option.c	/^# define PV_TSR	/;"	d	file:
PV_TW	option.c	/^#define PV_TW	/;"	d	file:
PV_TX	option.c	/^#define PV_TX	/;"	d	file:
PV_WFH	option.c	/^# define PV_WFH	/;"	d	file:
PV_WFW	option.c	/^# define PV_WFW	/;"	d	file:
PV_WIN	option.c	/^#define PV_WIN /;"	d	file:
PV_WM	option.c	/^#define PV_WM	/;"	d	file:
PV_WRAP	option.c	/^#define PV_WRAP	/;"	d	file:
PYTHON_PROC	if_python.c	/^# define PYTHON_PROC /;"	d	file:
PY_CAN_RECURSE	if_python.c	/^# define PY_CAN_RECURSE$/;"	d	file:
PY_SSIZE_T_CLEAN	if_python.c	/^#define PY_SSIZE_T_CLEAN$/;"	d	file:
P_ALLOCED	option.c	/^#define P_ALLOCED	/;"	d	file:
P_BOOL	option.c	/^#define P_BOOL	/;"	d	file:
P_COMMA	option.c	/^#define P_COMMA	/;"	d	file:
P_DEF_ALLOCED	option.c	/^#define P_DEF_ALLOCED	/;"	d	file:
P_EXPAND	option.c	/^#define P_EXPAND	/;"	d	file:
P_FLAGLIST	option.c	/^#define P_FLAGLIST	/;"	d	file:
P_GETTEXT	option.c	/^#define P_GETTEXT	/;"	d	file:
P_HID	option.h	/^# define P_HID(/;"	d
P_INSECURE	option.c	/^#define P_INSECURE /;"	d	file:
P_NFNAME	option.c	/^#define P_NFNAME /;"	d	file:
P_NODEFAULT	option.c	/^#define P_NODEFAULT	/;"	d	file:
P_NODUP	option.c	/^#define P_NODUP	/;"	d	file:
P_NOGLOB	option.c	/^#define P_NOGLOB /;"	d	file:
P_NO_MKRC	option.c	/^#define P_NO_MKRC	/;"	d	file:
P_NUM	option.c	/^#define P_NUM	/;"	d	file:
P_PRI_MKRC	option.c	/^#define P_PRI_MKRC /;"	d	file:
P_RALL	option.c	/^#define P_RALL	/;"	d	file:
P_RBUF	option.c	/^#define P_RBUF	/;"	d	file:
P_RCLR	option.c	/^#define P_RCLR	/;"	d	file:
P_RSTAT	option.c	/^#define P_RSTAT	/;"	d	file:
P_RWIN	option.c	/^#define P_RWIN	/;"	d	file:
P_SECURE	option.c	/^#define P_SECURE	/;"	d	file:
P_STRING	option.c	/^#define P_STRING	/;"	d	file:
P_VIM	option.c	/^#define P_VIM	/;"	d	file:
P_VI_DEF	option.c	/^#define P_VI_DEF	/;"	d	file:
P_WAS_SET	option.c	/^#define P_WAS_SET	/;"	d	file:
PaintArrows	gui_at_sb.c	/^PaintArrows(sbw)$/;"	f	file:
PaintThumb	gui_at_sb.c	/^PaintThumb(sbw)$/;"	f	file:
PeekNotifyEvent	gui_at_sb.c	/^PeekNotifyEvent(dpy, event, args)$/;"	f	file:
PendingCommand	if_xcmdsrv.c	/^typedef struct PendingCommand$/;"	s	file:
PendingCommand	if_xcmdsrv.c	/^} PendingCommand;$/;"	t	typeref:struct:PendingCommand	file:
Port_Info	if_mzsch.c	/^} Port_Info;$/;"	t	typeref:struct:__anon24	file:
Print	if_cscope.h	/^    Print$/;"	e	enum:__anon70
PtyProto	pty.c	/^static char PtyProto[] = "\/dev\/pt\/XY";$/;"	v	file:
PtyProto	pty.c	/^static char PtyProto[] = "\/dev\/ptyXY";$/;"	v	file:
PtyProto	pty.c	/^static char PtyProto[] = "\/dev\/ptym\/ptyXY";$/;"	v	file:
PyArg_Parse	if_python.c	/^# define PyArg_Parse /;"	d	file:
PyArg_Parse	if_python.c	/^#undef PyArg_Parse$/;"	d	file:
PyArg_ParseTuple	if_python.c	/^# define PyArg_ParseTuple /;"	d	file:
PyArg_ParseTuple	if_python.c	/^#undef PyArg_ParseTuple$/;"	d	file:
PyDict_GetItemString	if_python.c	/^# define PyDict_GetItemString /;"	d	file:
PyDict_New	if_python.c	/^# define PyDict_New /;"	d	file:
PyDict_SetItemString	if_python.c	/^# define PyDict_SetItemString /;"	d	file:
PyErr_BadArgument	if_python.c	/^# define PyErr_BadArgument /;"	d	file:
PyErr_Clear	if_python.c	/^# define PyErr_Clear /;"	d	file:
PyErr_NoMemory	if_python.c	/^# define PyErr_NoMemory /;"	d	file:
PyErr_Occurred	if_python.c	/^# define PyErr_Occurred /;"	d	file:
PyErr_SetNone	if_python.c	/^# define PyErr_SetNone /;"	d	file:
PyErr_SetString	if_python.c	/^# define PyErr_SetString /;"	d	file:
PyErr_SetVim	if_python.c	/^#define PyErr_SetVim(/;"	d	file:
PyEval_InitThreads	if_python.c	/^# define PyEval_InitThreads /;"	d	file:
PyEval_RestoreThread	if_python.c	/^# define PyEval_RestoreThread /;"	d	file:
PyEval_SaveThread	if_python.c	/^# define PyEval_SaveThread /;"	d	file:
PyExc_AttributeError	if_python.c	/^# define PyExc_AttributeError /;"	d	file:
PyExc_IndexError	if_python.c	/^# define PyExc_IndexError /;"	d	file:
PyExc_KeyboardInterrupt	if_python.c	/^# define PyExc_KeyboardInterrupt /;"	d	file:
PyExc_TypeError	if_python.c	/^# define PyExc_TypeError /;"	d	file:
PyExc_ValueError	if_python.c	/^# define PyExc_ValueError /;"	d	file:
PyGILState_Ensure	if_python.c	/^#  define PyGILState_Ensure /;"	d	file:
PyGILState_Release	if_python.c	/^#  define PyGILState_Release /;"	d	file:
PyImport_ImportModule	if_python.c	/^# define PyImport_ImportModule /;"	d	file:
PyInquiry	if_python.c	/^# define PyInquiry /;"	d	file:
PyInt	if_python.c	/^# define PyInt /;"	d	file:
PyIntArgFunc	if_python.c	/^# define PyIntArgFunc /;"	d	file:
PyIntIntArgFunc	if_python.c	/^# define PyIntIntArgFunc /;"	d	file:
PyIntIntObjArgProc	if_python.c	/^# define PyIntIntObjArgProc /;"	d	file:
PyIntObjArgProc	if_python.c	/^# define PyIntObjArgProc /;"	d	file:
PyInt_AsLong	if_python.c	/^# define PyInt_AsLong /;"	d	file:
PyInt_FromLong	if_python.c	/^# define PyInt_FromLong /;"	d	file:
PyInt_Type	if_python.c	/^# define PyInt_Type /;"	d	file:
PyList_Append	if_python.c	/^# define PyList_Append /;"	d	file:
PyList_GetItem	if_python.c	/^# define PyList_GetItem /;"	d	file:
PyList_New	if_python.c	/^# define PyList_New /;"	d	file:
PyList_SetItem	if_python.c	/^# define PyList_SetItem /;"	d	file:
PyList_Size	if_python.c	/^# define PyList_Size /;"	d	file:
PyList_Type	if_python.c	/^# define PyList_Type /;"	d	file:
PyMethodDef	if_python.c	/^struct PyMethodDef { Py_ssize_t a; };$/;"	s	file:
PyModule_GetDict	if_python.c	/^# define PyModule_GetDict /;"	d	file:
PyObject	if_python.c	/^# define PyObject /;"	d	file:
PyObject_Free	if_python.c	/^#  define PyObject_Free /;"	d	file:
PyObject_Init	if_python.c	/^# define PyObject_Init /;"	d	file:
PyObject_Malloc	if_python.c	/^#  define PyObject_Malloc /;"	d	file:
PyRun_SimpleString	if_python.c	/^# define PyRun_SimpleString /;"	d	file:
PyRun_SimpleString	if_python.c	/^#undef PyRun_SimpleString$/;"	d	file:
PySequenceMethods	if_python.c	/^# define PySequenceMethods /;"	d	file:
PyString_AsString	if_python.c	/^# define PyString_AsString /;"	d	file:
PyString_FromString	if_python.c	/^# define PyString_FromString /;"	d	file:
PyString_FromStringAndSize	if_python.c	/^# define PyString_FromStringAndSize /;"	d	file:
PyString_Size	if_python.c	/^# define PyString_Size /;"	d	file:
PyString_Type	if_python.c	/^# define PyString_Type /;"	d	file:
PySys_SetArgv	if_python.c	/^# define PySys_SetArgv /;"	d	file:
PySys_SetObject	if_python.c	/^# define PySys_SetObject /;"	d	file:
PyThreadState	if_python.c	/^# define PyThreadState /;"	d	file:
PyThreadState	if_python.c	/^typedef PyObject PyThreadState;$/;"	t	file:
PyTypeObject	if_python.c	/^# define PyTypeObject /;"	d	file:
PyType_IsSubtype	if_python.c	/^#  define PyType_IsSubtype /;"	d	file:
PyType_Type	if_python.c	/^# define PyType_Type /;"	d	file:
Py_BuildValue	if_python.c	/^# define Py_BuildValue /;"	d	file:
Py_BuildValue	if_python.c	/^#undef Py_BuildValue$/;"	d	file:
Py_Finalize	if_python.c	/^# define Py_Finalize /;"	d	file:
Py_FindMethod	if_python.c	/^# define Py_FindMethod /;"	d	file:
Py_GetProgramName	if_python.c	/^Py_GetProgramName(void)$/;"	f
Py_InitModule4	if_python.c	/^# define Py_InitModule4 /;"	d	file:
Py_InitModule4	if_python.c	/^#undef Py_InitModule4$/;"	d	file:
Py_InitModule4_64	if_python.c	/^#undef Py_InitModule4_64$/;"	d	file:
Py_Initialize	if_python.c	/^# define Py_Initialize /;"	d	file:
Py_IsInitialized	if_python.c	/^# define Py_IsInitialized /;"	d	file:
Py_ssize_t_fmt	if_python.c	/^# define Py_ssize_t_fmt /;"	d	file:
PythonIO_Flush	if_python.c	/^PythonIO_Flush(void)$/;"	f	file:
PythonIO_Init	if_python.c	/^PythonIO_Init(void)$/;"	f	file:
PythonMod_Init	if_python.c	/^PythonMod_Init(void)$/;"	f	file:
Python_Init	if_python.c	/^Python_Init(void)$/;"	f	file:
Python_Lock_Vim	if_python.c	/^static void Python_Lock_Vim(void)$/;"	f	file:
Python_Release_Vim	if_python.c	/^static void Python_Release_Vim(void)$/;"	f	file:
Python_RestoreThread	if_python.c	/^Python_RestoreThread(void)$/;"	f	file:
Python_SaveThread	if_python.c	/^Python_SaveThread(void)$/;"	f	file:
QF_WINHEIGHT	vim.h	/^#define QF_WINHEIGHT	/;"	d
R13_	ascii.h	/^#define R13_(/;"	d
RANGE	ex_cmds.h	/^# undef RANGE	/;"	d
RANGE	ex_cmds.h	/^#define RANGE	/;"	d
RA_BREAK	regexp.c	/^#define RA_BREAK	/;"	d	file:
RA_CONT	regexp.c	/^#define RA_CONT	/;"	d	file:
RA_FAIL	regexp.c	/^#define RA_FAIL	/;"	d	file:
RA_MATCH	regexp.c	/^#define RA_MATCH	/;"	d	file:
RA_NOMATCH	regexp.c	/^#define RA_NOMATCH	/;"	d	file:
RBAppend	if_python.c	/^RBAppend(BufferObject *self, PyObject *args, PyInt start, PyInt end, PyInt *new_end)$/;"	f	file:
RBAssItem	if_python.c	/^RBAssItem(BufferObject *self, PyInt n, PyObject *val, PyInt start, PyInt end, PyInt *new_end)$/;"	f	file:
RBAssSlice	if_python.c	/^RBAssSlice(BufferObject *self, PyInt lo, PyInt hi, PyObject *val, PyInt start, PyInt end, PyInt *new_end)$/;"	f	file:
RBItem	if_python.c	/^RBItem(BufferObject *self, PyInt n, PyInt start, PyInt end)$/;"	f	file:
RBSlice	if_python.c	/^RBSlice(BufferObject *self, PyInt lo, PyInt hi, PyInt start, PyInt end)$/;"	f	file:
RE	farsi.h	/^#define RE	/;"	d
READBIN	vim.h	/^# define READBIN /;"	d
READ_BUFFER	vim.h	/^#define READ_BUFFER	/;"	d
READ_DUMMY	vim.h	/^#define READ_DUMMY	/;"	d
READ_FILTER	vim.h	/^#define READ_FILTER	/;"	d
READ_NEW	vim.h	/^#define READ_NEW	/;"	d
READ_STDIN	vim.h	/^#define READ_STDIN	/;"	d
REDRAW_TOP	vim.h	/^#define REDRAW_TOP	/;"	d
REGEXP_ABBR	regexp.c	/^static char_u REGEXP_ABBR[] = "nrtebdoxuU";$/;"	v	file:
REGEXP_INRANGE	regexp.c	/^static char_u REGEXP_INRANGE[] = "]^-n\\\\";$/;"	v	file:
REGION_ALL	spell.c	/^#define REGION_ALL /;"	d	file:
REGMAGIC	regexp.c	/^#define REGMAGIC	/;"	d	file:
REGSTACK_INITIAL	regexp.c	/^#define REGSTACK_INITIAL	/;"	d	file:
REGSTR	ex_cmds.h	/^#define REGSTR	/;"	d
REG_MULTI	regexp.c	/^#define REG_MULTI	/;"	d	file:
REG_NOPAREN	regexp.c	/^#define REG_NOPAREN	/;"	d	file:
REG_NPAREN	regexp.c	/^#define REG_NPAREN	/;"	d	file:
REG_PAREN	regexp.c	/^#define REG_PAREN	/;"	d	file:
REG_ZPAREN	regexp.c	/^#define REG_ZPAREN	/;"	d	file:
REMAP_NONE	vim.h	/^#define REMAP_NONE	/;"	d
REMAP_SCRIPT	vim.h	/^#define REMAP_SCRIPT	/;"	d
REMAP_SKIP	vim.h	/^#define REMAP_SKIP	/;"	d
REMAP_YES	vim.h	/^#define REMAP_YES	/;"	d
REPLACE	vim.h	/^#define REPLACE	/;"	d
REPLACE_FLAG	vim.h	/^#define REPLACE_FLAG	/;"	d
REPLACE_NORMAL	macros.h	/^# define REPLACE_NORMAL(/;"	d
RESCORE	spell.c	/^#define RESCORE(/;"	d	file:
RESET_CHARTAB	charset.c	/^#define RESET_CHARTAB(/;"	d	file:
RESIZE_BOTH	vim.h	/^#define RESIZE_BOTH	/;"	d
RESIZE_HOR	vim.h	/^#define RESIZE_HOR	/;"	d
RESIZE_VERT	vim.h	/^#define RESIZE_VERT	/;"	d
RET_WIN_BUF_CHARTABSIZE	charset.c	/^#define RET_WIN_BUF_CHARTABSIZE(/;"	d	file:
REX_SET	vim.h	/^# define REX_SET	/;"	d
REX_USE	vim.h	/^# define REX_USE	/;"	d
RE_BOF	regexp.c	/^#define RE_BOF	/;"	d	file:
RE_BOTH	vim.h	/^#define RE_BOTH	/;"	d
RE_COL	regexp.c	/^#define RE_COL	/;"	d	file:
RE_EOF	regexp.c	/^#define RE_EOF	/;"	d	file:
RE_LAST	vim.h	/^#define RE_LAST	/;"	d
RE_LNUM	regexp.c	/^#define RE_LNUM	/;"	d	file:
RE_MAGIC	vim.h	/^#define RE_MAGIC	/;"	d
RE_MARK	regexp.c	/^#define RE_MARK	/;"	d	file:
RE_SEARCH	vim.h	/^#define RE_SEARCH	/;"	d
RE_STRICT	vim.h	/^#define RE_STRICT	/;"	d
RE_STRING	vim.h	/^#define RE_STRING	/;"	d
RE_SUBST	vim.h	/^#define RE_SUBST	/;"	d
RE_VCOL	regexp.c	/^#define RE_VCOL	/;"	d	file:
RE_VISUAL	regexp.c	/^#define RE_VISUAL	/;"	d	file:
RF_HASNL	regexp.c	/^#define RF_HASNL /;"	d	file:
RF_ICASE	regexp.c	/^#define RF_ICASE /;"	d	file:
RF_ICOMBINE	regexp.c	/^#define RF_ICOMBINE /;"	d	file:
RF_LOOKBH	regexp.c	/^#define RF_LOOKBH /;"	d	file:
RF_NOICASE	regexp.c	/^#define RF_NOICASE /;"	d	file:
RI_ALPHA	regexp.c	/^#define	    RI_ALPHA	/;"	d	file:
RI_DIGIT	regexp.c	/^#define	    RI_DIGIT	/;"	d	file:
RI_HEAD	regexp.c	/^#define	    RI_HEAD	/;"	d	file:
RI_HEX	regexp.c	/^#define	    RI_HEX	/;"	d	file:
RI_LOWER	regexp.c	/^#define	    RI_LOWER	/;"	d	file:
RI_OCTAL	regexp.c	/^#define	    RI_OCTAL	/;"	d	file:
RI_UPPER	regexp.c	/^#define	    RI_UPPER	/;"	d	file:
RI_WHITE	regexp.c	/^#define	    RI_WHITE	/;"	d	file:
RI_WORD	regexp.c	/^#define	    RI_WORD	/;"	d	file:
RLADDSUBFIX	ops.c	/^# define RLADDSUBFIX(/;"	d	file:
RL_MEMSET	screen.c	/^# define RL_MEMSET(/;"	d	file:
RM_ABBR	getchar.c	/^#define RM_ABBR	/;"	d	file:
RM_NONE	getchar.c	/^#define RM_NONE	/;"	d	file:
RM_SCRIPT	getchar.c	/^#define RM_SCRIPT	/;"	d	file:
RM_YES	getchar.c	/^#define RM_YES	/;"	d	file:
ROOT_UID	vim.h	/^# define ROOT_UID /;"	d
ROT13	ascii.h	/^#define ROT13(/;"	d
ROWS_AVAIL	window.c	/^# define ROWS_AVAIL /;"	d	file:
RP_DISCARD	ex_eval.c	/^#define RP_DISCARD	/;"	d	file:
RP_MAKE	ex_eval.c	/^#define RP_MAKE	/;"	d	file:
RP_RESUME	ex_eval.c	/^#define RP_RESUME	/;"	d	file:
RS_BEHIND1	regexp.c	/^    , RS_BEHIND1	\/* BEHIND \/ NOBEHIND matching rest *\/$/;"	e	enum:regstate_E	file:
RS_BEHIND2	regexp.c	/^    , RS_BEHIND2	\/* BEHIND \/ NOBEHIND matching behind part *\/$/;"	e	enum:regstate_E	file:
RS_BRANCH	regexp.c	/^    , RS_BRANCH		\/* BRANCH *\/$/;"	e	enum:regstate_E	file:
RS_BRCPLX_LONG	regexp.c	/^    , RS_BRCPLX_LONG	\/* BRACE_COMPLEX and trying longest match *\/$/;"	e	enum:regstate_E	file:
RS_BRCPLX_MORE	regexp.c	/^    , RS_BRCPLX_MORE	\/* BRACE_COMPLEX and trying one more match *\/$/;"	e	enum:regstate_E	file:
RS_BRCPLX_SHORT	regexp.c	/^    , RS_BRCPLX_SHORT	\/* BRACE_COMPLEX and trying shortest match *\/$/;"	e	enum:regstate_E	file:
RS_FAIL	gui_gtk_x11.c	/^#define RS_FAIL	/;"	d	file:
RS_MCLOSE	regexp.c	/^    , RS_MCLOSE		\/* MCLOSE + [0-9] *\/$/;"	e	enum:regstate_E	file:
RS_MOPEN	regexp.c	/^    , RS_MOPEN		\/* MOPEN + [0-9] *\/$/;"	e	enum:regstate_E	file:
RS_NOMATCH	regexp.c	/^    , RS_NOMATCH	\/* NOMATCH *\/$/;"	e	enum:regstate_E	file:
RS_NONE	gui_gtk_x11.c	/^#define RS_NONE	/;"	d	file:
RS_NOPEN	regexp.c	/^    RS_NOPEN = 0	\/* NOPEN and NCLOSE *\/$/;"	e	enum:regstate_E	file:
RS_OK	gui_gtk_x11.c	/^#define RS_OK	/;"	d	file:
RS_STAR_LONG	regexp.c	/^    , RS_STAR_LONG	\/* STAR\/PLUS\/BRACE_SIMPLE longest match *\/$/;"	e	enum:regstate_E	file:
RS_STAR_SHORT	regexp.c	/^    , RS_STAR_SHORT	\/* STAR\/PLUS\/BRACE_SIMPLE shortest match *\/$/;"	e	enum:regstate_E	file:
RS_ZCLOSE	regexp.c	/^    , RS_ZCLOSE		\/* ZCLOSE + [0-9] *\/$/;"	e	enum:regstate_E	file:
RS_ZOPEN	regexp.c	/^    , RS_ZOPEN		\/* ZOPEN + [0-9] *\/$/;"	e	enum:regstate_E	file:
RUBYEXTERN	if_ruby.c	/^#  define RUBYEXTERN /;"	d	file:
RUBYEXTERN	if_ruby.c	/^# define RUBYEXTERN /;"	d	file:
RUBY_DATA_FUNC	if_ruby.c	/^# define RUBY_DATA_FUNC /;"	d	file:
RUBY_EXPORT	if_ruby.c	/^#  define RUBY_EXPORT$/;"	d	file:
RUBY_PROC	if_ruby.c	/^#define RUBY_PROC /;"	d	file:
RUNTIME_DIRNAME	feature.h	/^# define RUNTIME_DIRNAME /;"	d
R_OK	vim.h	/^# define R_OK /;"	d
RangeAppend	if_python.c	/^RangeAppend(PyObject *self, PyObject *args)$/;"	f	file:
RangeAsSeq	if_python.c	/^static PySequenceMethods RangeAsSeq = {$/;"	v	file:
RangeAssItem	if_python.c	/^RangeAssItem(PyObject *self, PyInt n, PyObject *val)$/;"	f	file:
RangeAssSlice	if_python.c	/^RangeAssSlice(PyObject *self, PyInt lo, PyInt hi, PyObject *val)$/;"	f	file:
RangeDestructor	if_python.c	/^RangeDestructor(PyObject *self)$/;"	f	file:
RangeEnd	if_python.c	/^static PyInt RangeEnd;$/;"	v	file:
RangeGetattr	if_python.c	/^RangeGetattr(PyObject *self, char *name)$/;"	f	file:
RangeItem	if_python.c	/^RangeItem(PyObject *self, PyInt n)$/;"	f	file:
RangeLength	if_python.c	/^RangeLength(PyObject *self)$/;"	f	file:
RangeMethods	if_python.c	/^static struct PyMethodDef RangeMethods[] = {$/;"	v	typeref:struct:PyMethodDef	file:
RangeNew	if_python.c	/^RangeNew(buf_T *buf, PyInt start, PyInt end)$/;"	f	file:
RangeObject	if_python.c	/^RangeObject;$/;"	t	typeref:struct:__anon32	file:
RangeRepr	if_python.c	/^RangeRepr(PyObject *self)$/;"	f	file:
RangeSlice	if_python.c	/^RangeSlice(PyObject *self, PyInt lo, PyInt hi)$/;"	f	file:
RangeStart	if_python.c	/^static PyInt RangeStart;$/;"	v	file:
RangeType	if_python.c	/^static PyTypeObject RangeType = {$/;"	v	file:
RangeType_Check	if_python.c	/^#define RangeType_Check(/;"	d	file:
RealWaitForChar	os_unix.c	/^RealWaitForChar(fd, msec, check_for_gpm)$/;"	f
Realize	gui_at_sb.c	/^Realize(w, valueMask, attributes)$/;"	f	file:
Recording	globals.h	/^EXTERN int Recording INIT(= FALSE);	\/* TRUE when recording into a reg. *\/$/;"	v
Redisplay	gui_at_sb.c	/^Redisplay(w, event, region)$/;"	f	file:
Redisplay	gui_xmebw.c	/^Redisplay(Widget w, XEvent *event, Region region)$/;"	f	file:
RedrawingDisabled	globals.h	/^EXTERN int	RedrawingDisabled INIT(= 0);$/;"	v
RepeatNotify	gui_at_sb.c	/^RepeatNotify(client_data, idp)$/;"	f	file:
Reset	if_cscope.h	/^typedef enum { Add, Find, Help, Kill, Reset, Show } csid_e;$/;"	e	enum:__anon69
ResetRedobuff	getchar.c	/^ResetRedobuff()$/;"	f
Resize	gui_at_sb.c	/^Resize(w)$/;"	f	file:
Rows	globals.h	/^EXTERN long	Rows			\/* nr of rows in the screen *\/$/;"	v
SAD	farsi.h	/^#define SAD	/;"	d
SAL_COLLAPSE	spell.c	/^#define SAL_COLLAPSE	/;"	d	file:
SAL_F0LLOWUP	spell.c	/^#define SAL_F0LLOWUP	/;"	d	file:
SAL_REM_ACCENTS	spell.c	/^#define SAL_REM_ACCENTS	/;"	d	file:
SAVE_YOURSELF_IDX	gui_x11.c	/^#define SAVE_YOURSELF_IDX /;"	d	file:
SBAR_BOTTOM	gui.h	/^#define SBAR_BOTTOM	/;"	d
SBAR_HORIZ	gui.h	/^#define SBAR_HORIZ	/;"	d
SBAR_LEFT	gui.h	/^#define SBAR_LEFT	/;"	d
SBAR_NONE	gui.h	/^#define SBAR_NONE	/;"	d
SBAR_RIGHT	gui.h	/^#define SBAR_RIGHT	/;"	d
SBAR_VERT	gui.h	/^#define SBAR_VERT	/;"	d
SBLOCKSIZE	spell.c	/^#define  SBLOCKSIZE /;"	d	file:
SBOXOK	ex_cmds.h	/^#define SBOXOK	/;"	d
SB_DEFAULT_WIDTH	gui.h	/^#define SB_DEFAULT_WIDTH /;"	d
SCANF_DECIMAL_LONG_U	vim.h	/^# define SCANF_DECIMAL_LONG_U /;"	d
SCANF_HEX_LONG_U	vim.h	/^# define SCANF_HEX_LONG_U /;"	d
SCHEME_BYTE_STRLEN_VAL	if_mzsch.h	/^# define SCHEME_BYTE_STRLEN_VAL /;"	d
SCHEME_BYTE_STR_VAL	if_mzsch.h	/^# define SCHEME_BYTE_STR_VAL /;"	d
SCHEME_GET_BYTE_STRING	if_mzsch.h	/^# define SCHEME_GET_BYTE_STRING(/;"	d
SCHEME_STRINGP	if_mzsch.h	/^# define SCHEME_STRINGP(/;"	d
SCHEME_STR_VAL	if_mzsch.h	/^# define SCHEME_STR_VAL(/;"	d
SCHEME_VIMBUFFERP	if_mzsch.c	/^#define SCHEME_VIMBUFFERP(/;"	d	file:
SCHEME_VIMWINDOWP	if_mzsch.c	/^#define SCHEME_VIMWINDOWP(/;"	d	file:
SCORE_BIG	spell.c	/^#define SCORE_BIG	/;"	d	file:
SCORE_COMMON1	spell.c	/^#define SCORE_COMMON1	/;"	d	file:
SCORE_COMMON2	spell.c	/^#define SCORE_COMMON2	/;"	d	file:
SCORE_COMMON3	spell.c	/^#define SCORE_COMMON3	/;"	d	file:
SCORE_DEL	spell.c	/^#define SCORE_DEL	/;"	d	file:
SCORE_DELCOMP	spell.c	/^#define SCORE_DELCOMP	/;"	d	file:
SCORE_DELDUP	spell.c	/^#define SCORE_DELDUP	/;"	d	file:
SCORE_EDIT_MIN	spell.c	/^#define SCORE_EDIT_MIN	/;"	d	file:
SCORE_FILE	spell.c	/^#define SCORE_FILE	/;"	d	file:
SCORE_ICASE	spell.c	/^#define SCORE_ICASE	/;"	d	file:
SCORE_INS	spell.c	/^#define SCORE_INS	/;"	d	file:
SCORE_INSCOMP	spell.c	/^#define SCORE_INSCOMP	/;"	d	file:
SCORE_INSDUP	spell.c	/^#define SCORE_INSDUP	/;"	d	file:
SCORE_LIMITMAX	spell.c	/^#define SCORE_LIMITMAX	/;"	d	file:
SCORE_MAXINIT	spell.c	/^#define SCORE_MAXINIT	/;"	d	file:
SCORE_MAXMAX	spell.c	/^#define SCORE_MAXMAX	/;"	d	file:
SCORE_NONWORD	spell.c	/^#define SCORE_NONWORD	/;"	d	file:
SCORE_RARE	spell.c	/^#define SCORE_RARE	/;"	d	file:
SCORE_REGION	spell.c	/^#define SCORE_REGION	/;"	d	file:
SCORE_REP	spell.c	/^#define SCORE_REP	/;"	d	file:
SCORE_SFMAX1	spell.c	/^#define SCORE_SFMAX1	/;"	d	file:
SCORE_SFMAX2	spell.c	/^#define SCORE_SFMAX2	/;"	d	file:
SCORE_SFMAX3	spell.c	/^#define SCORE_SFMAX3	/;"	d	file:
SCORE_SIMILAR	spell.c	/^#define SCORE_SIMILAR	/;"	d	file:
SCORE_SPLIT	spell.c	/^#define SCORE_SPLIT	/;"	d	file:
SCORE_SPLIT_NO	spell.c	/^#define SCORE_SPLIT_NO	/;"	d	file:
SCORE_SUBCOMP	spell.c	/^#define SCORE_SUBCOMP	/;"	d	file:
SCORE_SUBST	spell.c	/^#define SCORE_SUBST	/;"	d	file:
SCORE_SWAP	spell.c	/^#define SCORE_SWAP	/;"	d	file:
SCORE_SWAP3	spell.c	/^#define SCORE_SWAP3	/;"	d	file:
SCORE_THRES2	spell.c	/^#define SCORE_THRES2	/;"	d	file:
SCORE_THRES3	spell.c	/^#define SCORE_THRES3	/;"	d	file:
SCREEN_LINE	screen.c	/^# define SCREEN_LINE(/;"	d	file:
SCRIPT_ITEM	ex_cmds2.c	/^#define SCRIPT_ITEM(/;"	d	file:
SCRIPT_SV	eval.c	/^#define SCRIPT_SV(/;"	d	file:
SCRIPT_VARS	eval.c	/^#define SCRIPT_VARS(/;"	d	file:
SCROLL_PAST_END	gui.c	/^# define SCROLL_PAST_END$/;"	d	file:
SE	farsi.h	/^#define SE	/;"	d
SEARCH_ECHO	vim.h	/^#define SEARCH_ECHO /;"	d
SEARCH_END	vim.h	/^#define SEARCH_END /;"	d
SEARCH_HIS	vim.h	/^#define SEARCH_HIS /;"	d
SEARCH_HL_PRIORITY	screen.c	/^#define SEARCH_HL_PRIORITY /;"	d	file:
SEARCH_KEEP	vim.h	/^#define SEARCH_KEEP /;"	d
SEARCH_MARK	vim.h	/^#define SEARCH_MARK /;"	d
SEARCH_MSG	vim.h	/^#define SEARCH_MSG /;"	d
SEARCH_NFMSG	vim.h	/^#define SEARCH_NFMSG /;"	d
SEARCH_NOOF	vim.h	/^#define SEARCH_NOOF /;"	d
SEARCH_OPT	vim.h	/^#define SEARCH_OPT /;"	d
SEARCH_PEEK	vim.h	/^#define SEARCH_PEEK /;"	d
SEARCH_REV	vim.h	/^#define SEARCH_REV /;"	d
SEARCH_START	vim.h	/^#define SEARCH_START /;"	d
SEA_DIALOG	vim.h	/^#define SEA_DIALOG	/;"	d
SEA_NONE	vim.h	/^#define SEA_NONE	/;"	d
SEA_QUIT	vim.h	/^#define SEA_QUIT	/;"	d
SEA_RECOVER	vim.h	/^#define SEA_RECOVER	/;"	d
SEEK_END	misc1.c	/^# define SEEK_END /;"	d	file:
SEEK_END	os_unix.c	/^# define SEEK_END /;"	d	file:
SEEK_SET	misc1.c	/^# define SEEK_SET /;"	d	file:
SEEK_SET	os_unix.c	/^# define SEEK_SET /;"	d	file:
SELECTMODE	vim.h	/^#define SELECTMODE	/;"	d
SELECT_CLEARED	vim.h	/^# define SELECT_CLEARED	/;"	d
SELECT_DONE	vim.h	/^# define SELECT_DONE	/;"	d
SELECT_IN_PROGRESS	vim.h	/^# define SELECT_IN_PROGRESS	/;"	d
SELECT_MODE_CHAR	vim.h	/^# define SELECT_MODE_CHAR	/;"	d
SELECT_MODE_LINE	vim.h	/^# define SELECT_MODE_LINE	/;"	d
SELECT_MODE_WORD	vim.h	/^# define SELECT_MODE_WORD	/;"	d
SEL_FILE_CANCEL	gui_at_fs.c	/^#define SEL_FILE_CANCEL	/;"	d	file:
SEL_FILE_NULL	gui_at_fs.c	/^#define SEL_FILE_NULL	/;"	d	file:
SEL_FILE_OK	gui_at_fs.c	/^#define SEL_FILE_OK	/;"	d	file:
SEL_FILE_TEXT	gui_at_fs.c	/^#define SEL_FILE_TEXT	/;"	d	file:
SEND_MSEC_POLL	if_xcmdsrv.c	/^#   define SEND_MSEC_POLL /;"	d	file:
SESSION_FILE	feature.h	/^#define SESSION_FILE	/;"	d
SETJMP	os_unix.h	/^#  define SETJMP(/;"	d
SETWSIZE	vim.h	/^#define SETWSIZE	/;"	d
SET_CHARTAB	charset.c	/^#define SET_CHARTAB(/;"	d	file:
SET_NUM_MOUSE_CLICKS	vim.h	/^# define SET_NUM_MOUSE_CLICKS(/;"	d
SET_SIG_ALARM	os_unix.c	/^# define SET_SIG_ALARM$/;"	d	file:
SFDir	gui_at_fs.c	/^} SFDir;$/;"	t	typeref:struct:__anon14	file:
SFEntry	gui_at_fs.c	/^} SFEntry;$/;"	t	typeref:struct:__anon13	file:
SFLogin	gui_at_fs.c	/^} SFLogin;$/;"	t	typeref:struct:__anon15	file:
SFNAME	regexp.c	/^#define SFNAME	/;"	d	file:
SF_CCOMMENT	syntax.c	/^#define SF_CCOMMENT	/;"	d	file:
SF_DEFAULT_FONT	gui_at_fs.c	/^# define SF_DEFAULT_FONT /;"	d	file:
SF_DO_NOT_SCROLL	gui_at_fs.c	/^#define SF_DO_NOT_SCROLL	/;"	d	file:
SF_DO_SCROLL	gui_at_fs.c	/^#define SF_DO_SCROLL	/;"	d	file:
SF_MATCH	syntax.c	/^#define SF_MATCH	/;"	d	file:
SFaboveAndBelowText	gui_at_fs.c	/^static int	SFaboveAndBelowText = 2;$/;"	v	file:
SFapp	gui_at_fs.c	/^static XtAppContext SFapp;$/;"	v	file:
SFback	gui_at_fs.c	/^static Pixel	SFfore, SFback;$/;"	v	file:
SFbesideText	gui_at_fs.c	/^static int	SFbesideText = 3;$/;"	v	file:
SFbuttonPressList	gui_at_fs.c	/^SFbuttonPressList(w, n, event)$/;"	f	file:
SFbuttonPressed	gui_at_fs.c	/^static int	SFbuttonPressed = 0;$/;"	v	file:
SFbuttonReleaseList	gui_at_fs.c	/^SFbuttonReleaseList(w, n, event)$/;"	f	file:
SFcancelCallback	gui_at_fs.c	/^SFcancelCallback(w, cl, cd)$/;"	f	file:
SFcancelSelect	gui_at_fs.c	/^static XtCallbackRec SFcancelSelect[] =$/;"	v	file:
SFcharAscent	gui_at_fs.c	/^static int	SFcharWidth, SFcharAscent, SFcharHeight;$/;"	v	file:
SFcharHeight	gui_at_fs.c	/^static int	SFcharWidth, SFcharAscent, SFcharHeight;$/;"	v	file:
SFcharWidth	gui_at_fs.c	/^static int	SFcharWidth, SFcharAscent, SFcharHeight;$/;"	v	file:
SFcharsPerEntry	gui_at_fs.c	/^static int	SFcharsPerEntry = 15;$/;"	v	file:
SFchdir	gui_at_fs.c	/^SFchdir(path)$/;"	f	file:
SFcheckDir	gui_at_fs.c	/^SFcheckDir(n, dir)$/;"	f	file:
SFcheckFiles	gui_at_fs.c	/^SFcheckFiles(dir)$/;"	f	file:
SFclearList	gui_at_fs.c	/^SFclearList(n, doScroll)$/;"	f	file:
SFcompareEntries	gui_at_fs.c	/^SFcompareEntries(p, q)$/;"	f	file:
SFcompareLogins	gui_at_fs.c	/^SFcompareLogins(p, q)$/;"	f	file:
SFcompletionSegs	gui_at_fs.c	/^static XSegment SFsegs[2], SFcompletionSegs[2];$/;"	v	file:
SFcreateGC	gui_at_fs.c	/^SFcreateGC()$/;"	f	file:
SFcreateWidgets	gui_at_fs.c	/^SFcreateWidgets(toplevel, prompt, ok, cancel)$/;"	f	file:
SFcurrentDir	gui_at_fs.c	/^		SFcurrentDir[MAXPATHL];$/;"	v	file:
SFcurrentInvert	gui_at_fs.c	/^static int	SFcurrentInvert[3] = { -1, -1, -1 };$/;"	v	file:
SFcurrentListY	gui_at_fs.c	/^static int SFcurrentListY;$/;"	v	file:
SFcurrentPath	gui_at_fs.c	/^		SFcurrentPath[MAXPATHL],$/;"	v	file:
SFdeleteEntry	gui_at_fs.c	/^SFdeleteEntry(dir, entry)$/;"	f	file:
SFdirEnd	gui_at_fs.c	/^static int	SFdirEnd;$/;"	v	file:
SFdirModTimer	gui_at_fs.c	/^SFdirModTimer(cl, id)$/;"	f	file:
SFdirModTimerId	gui_at_fs.c	/^static XtIntervalId SFdirModTimerId;$/;"	v	file:
SFdirPtr	gui_at_fs.c	/^static int	SFdirPtr;$/;"	v	file:
SFdirs	gui_at_fs.c	/^static SFDir	*SFdirs = NULL;$/;"	v	file:
SFdismissAction	gui_at_fs.c	/^SFdismissAction(w, event, params, num_params)$/;"	f	file:
SFdisplay	gui_at_fs.c	/^static Display	*SFdisplay;$/;"	v	file:
SFdoNotTouchDirPtr	gui_at_fs.c	/^static int	SFdoNotTouchDirPtr = 0;$/;"	v	file:
SFdoNotTouchVorigin	gui_at_fs.c	/^static int	SFdoNotTouchVorigin = 0;$/;"	v	file:
SFdrawList	gui_at_fs.c	/^SFdrawList(n, doScroll)$/;"	f	file:
SFdrawLists	gui_at_fs.c	/^SFdrawLists(doScroll)$/;"	f	file:
SFdrawStrings	gui_at_fs.c	/^SFdrawStrings(w, dir, from, to)$/;"	f	file:
SFenterList	gui_at_fs.c	/^SFenterList(w, n, event)$/;"	f	file:
SFentryHeight	gui_at_fs.c	/^static int	SFentryWidth, SFentryHeight;$/;"	v	file:
SFentryWidth	gui_at_fs.c	/^static int	SFentryWidth, SFentryHeight;$/;"	v	file:
SFexpand	gui_at_fs.c	/^SFexpand(str)$/;"	f	file:
SFexposeList	gui_at_fs.c	/^SFexposeList(w, n, event, cont)$/;"	f	file:
SFfindFile	gui_at_fs.c	/^SFfindFile(dir, str)$/;"	f	file:
SFfindHomeDir	gui_at_fs.c	/^SFfindHomeDir(begin, end)$/;"	f	file:
SFfont	gui_at_fs.c	/^static XFontSet SFfont;$/;"	v	file:
SFfont	gui_at_fs.c	/^static XFontStruct *SFfont;$/;"	v	file:
SFfore	gui_at_fs.c	/^static Pixel	SFfore, SFback;$/;"	v	file:
SFfree	gui_at_fs.c	/^SFfree(i)$/;"	f	file:
SFfunc	gui_at_fs.c	/^static int	(*SFfunc)();$/;"	v	file:
SFgetDir	gui_at_fs.c	/^SFgetDir(dir)$/;"	f	file:
SFgetHomeDirs	gui_at_fs.c	/^SFgetHomeDirs()$/;"	f	file:
SFgetText	gui_at_fs.c	/^SFgetText()$/;"	f	file:
SFhAreaSelectedCallback	gui_at_fs.c	/^SFhAreaSelectedCallback(w, n, pnew)$/;"	f	file:
SFhScrollWidth	gui_at_fs.c	/^static int	SFpathScrollWidth, SFvScrollHeight, SFhScrollWidth;$/;"	v	file:
SFhSliderMovedCallback	gui_at_fs.c	/^SFhSliderMovedCallback(w, n, nw)$/;"	f	file:
SFhomeDir	gui_at_fs.c	/^static SFDir	SFrootDir, SFhomeDir;$/;"	v	file:
SFinitFont	gui_at_fs.c	/^SFinitFont()$/;"	f	file:
SFinvertEntry	gui_at_fs.c	/^SFinvertEntry(n)$/;"	f	file:
SFinvertGC	gui_at_fs.c	/^static GC SFlineGC, SFscrollGC, SFinvertGC, SFtextGC;$/;"	v	file:
SFleaveList	gui_at_fs.c	/^SFleaveList(w, n, event)$/;"	f	file:
SFlineGC	gui_at_fs.c	/^static GC SFlineGC, SFscrollGC, SFinvertGC, SFtextGC;$/;"	v	file:
SFlineToTextH	gui_at_fs.c	/^static int	SFlineToTextH = 3;$/;"	v	file:
SFlineToTextV	gui_at_fs.c	/^static int	SFlineToTextV = 3;$/;"	v	file:
SFlistSize	gui_at_fs.c	/^static int	SFlistSize = 10;$/;"	v	file:
SFlogins	gui_at_fs.c	/^static SFLogin	*SFlogins;$/;"	v	file:
SFlowerY	gui_at_fs.c	/^static int	SFupperX, SFlowerY, SFupperY;$/;"	v	file:
SFmodVerifyCallback	gui_at_fs.c	/^SFmodVerifyCallback(w, client_data, event, cont)$/;"	f	file:
SFmotionList	gui_at_fs.c	/^SFmotionList(w, n, event)$/;"	f	file:
SFnewInvertEntry	gui_at_fs.c	/^SFnewInvertEntry(n, event)$/;"	f	file:
SFokCallback	gui_at_fs.c	/^SFokCallback(w, cl, cd)$/;"	f	file:
SFokSelect	gui_at_fs.c	/^static XtCallbackRec SFokSelect[] =$/;"	v	file:
SFpathAreaSelectedCallback	gui_at_fs.c	/^SFpathAreaSelectedCallback(w, client_data, pnew)$/;"	f	file:
SFpathScrollWidth	gui_at_fs.c	/^static int	SFpathScrollWidth, SFvScrollHeight, SFhScrollWidth;$/;"	v	file:
SFpathSliderMovedCallback	gui_at_fs.c	/^SFpathSliderMovedCallback(w, client_data, nw)$/;"	f	file:
SFprepareToReturn	gui_at_fs.c	/^SFprepareToReturn()$/;"	f	file:
SFreplaceText	gui_at_fs.c	/^SFreplaceText(dir, str)$/;"	f	file:
SFrootDir	gui_at_fs.c	/^static SFDir	SFrootDir, SFhomeDir;$/;"	v	file:
SFscrollGC	gui_at_fs.c	/^static GC SFlineGC, SFscrollGC, SFinvertGC, SFtextGC;$/;"	v	file:
SFscrollTimer	gui_at_fs.c	/^SFscrollTimer(p, id)$/;"	f	file:
SFscrollTimerId	gui_at_fs.c	/^static XtIntervalId SFscrollTimerId;$/;"	v	file:
SFscrollTimerInterval	gui_at_fs.c	/^SFscrollTimerInterval()$/;"	f	file:
SFsegs	gui_at_fs.c	/^static XSegment SFsegs[2], SFcompletionSegs[2];$/;"	v	file:
SFsetColors	gui_at_fs.c	/^SFsetColors(bg, fg, scroll_bg, scroll_fg)$/;"	f	file:
SFsetText	gui_at_fs.c	/^SFsetText(path)$/;"	f	file:
SFstartDir	gui_at_fs.c	/^static char	SFstartDir[MAXPATHL],$/;"	v	file:
SFstatAndCheck	gui_at_fs.c	/^SFstatAndCheck(dir, entry)$/;"	f	file:
SFstatChar	gui_at_fs.c	/^SFstatChar(statBuf)$/;"	f	file:
SFstatus	gui_at_fs.c	/^static int	SFstatus = SEL_FILE_NULL;$/;"	v	file:
SFstrdup	gui_at_fs.c	/^SFstrdup(s1, s2)$/;"	f	file:
SFtextBuffer	gui_at_fs.c	/^static char	SFtextBuffer[MAXPATHL*sizeof(wchar_t)];$/;"	v	file:
SFtextBuffer	gui_at_fs.c	/^static char	SFtextBuffer[MAXPATHL];$/;"	v	file:
SFtextChanged	gui_at_fs.c	/^SFtextChanged()$/;"	f	file:
SFtextGC	gui_at_fs.c	/^static GC SFlineGC, SFscrollGC, SFinvertGC, SFtextGC;$/;"	v	file:
SFtextPos	gui_at_fs.c	/^static XawTextPosition SFtextPos;$/;"	v	file:
SFtextX	gui_at_fs.c	/^static int	SFtextX, SFtextYoffset;$/;"	v	file:
SFtextYoffset	gui_at_fs.c	/^static int	SFtextX, SFtextYoffset;$/;"	v	file:
SFtwiddle	gui_at_fs.c	/^static int	SFtwiddle = 0;$/;"	v	file:
SFunreadableDir	gui_at_fs.c	/^SFunreadableDir(dir)$/;"	f	file:
SFunselect	gui_at_fs.c	/^SFunselect()$/;"	f	file:
SFupdatePath	gui_at_fs.c	/^SFupdatePath()$/;"	f	file:
SFupperX	gui_at_fs.c	/^static int	SFupperX, SFlowerY, SFupperY;$/;"	v	file:
SFupperY	gui_at_fs.c	/^static int	SFupperX, SFlowerY, SFupperY;$/;"	v	file:
SFvAreaSelectedCallback	gui_at_fs.c	/^SFvAreaSelectedCallback(w, n, pnew)$/;"	f	file:
SFvFloatSliderMovedCallback	gui_at_fs.c	/^SFvFloatSliderMovedCallback(w, n, fnew)$/;"	f	file:
SFvScrollHeight	gui_at_fs.c	/^static int	SFpathScrollWidth, SFvScrollHeight, SFhScrollWidth;$/;"	v	file:
SFvSliderMovedCallback	gui_at_fs.c	/^SFvSliderMovedCallback(w, n, nw)$/;"	f	file:
SFwmDeleteWindow	gui_at_fs.c	/^static Atom	SFwmDeleteWindow;$/;"	v	file:
SFworkProc	gui_at_fs.c	/^SFworkProc()$/;"	f	file:
SFworkProcAdded	gui_at_fs.c	/^static int	SFworkProcAdded = 0;$/;"	v	file:
SFwriteStatChar	gui_at_fs.c	/^SFwriteStatChar(name, last, statBuf)$/;"	f	file:
SG_CTERM	syntax.c	/^#define SG_CTERM	/;"	d	file:
SG_GUI	syntax.c	/^#define SG_GUI	/;"	d	file:
SG_LINK	syntax.c	/^#define SG_LINK	/;"	d	file:
SG_TERM	syntax.c	/^#define SG_TERM	/;"	d	file:
SHAPE_BLOCK	structs.h	/^#define SHAPE_BLOCK	/;"	d
SHAPE_CURSOR	structs.h	/^#define SHAPE_CURSOR	/;"	d
SHAPE_HOR	structs.h	/^#define SHAPE_HOR	/;"	d
SHAPE_IDX_C	structs.h	/^#define SHAPE_IDX_C	/;"	d
SHAPE_IDX_CI	structs.h	/^#define SHAPE_IDX_CI	/;"	d
SHAPE_IDX_CLINE	structs.h	/^#define SHAPE_IDX_CLINE	/;"	d
SHAPE_IDX_COUNT	structs.h	/^#define SHAPE_IDX_COUNT	/;"	d
SHAPE_IDX_CR	structs.h	/^#define SHAPE_IDX_CR	/;"	d
SHAPE_IDX_I	structs.h	/^#define SHAPE_IDX_I	/;"	d
SHAPE_IDX_MORE	structs.h	/^#define SHAPE_IDX_MORE	/;"	d
SHAPE_IDX_MOREL	structs.h	/^#define SHAPE_IDX_MOREL	/;"	d
SHAPE_IDX_N	structs.h	/^#define SHAPE_IDX_N	/;"	d
SHAPE_IDX_O	structs.h	/^#define SHAPE_IDX_O	/;"	d
SHAPE_IDX_R	structs.h	/^#define SHAPE_IDX_R	/;"	d
SHAPE_IDX_SDRAG	structs.h	/^#define SHAPE_IDX_SDRAG /;"	d
SHAPE_IDX_SM	structs.h	/^#define SHAPE_IDX_SM	/;"	d
SHAPE_IDX_STATUS	structs.h	/^#define SHAPE_IDX_STATUS /;"	d
SHAPE_IDX_V	structs.h	/^#define SHAPE_IDX_V	/;"	d
SHAPE_IDX_VDRAG	structs.h	/^#define SHAPE_IDX_VDRAG /;"	d
SHAPE_IDX_VE	structs.h	/^#define SHAPE_IDX_VE	/;"	d
SHAPE_IDX_VSEP	structs.h	/^#define SHAPE_IDX_VSEP	/;"	d
SHAPE_MOUSE	structs.h	/^#define SHAPE_MOUSE	/;"	d
SHAPE_VER	structs.h	/^#define SHAPE_VER	/;"	d
SHARED_MASK	spell.c	/^#define SHARED_MASK	/;"	d	file:
SHELL_COOKED	vim.h	/^#define SHELL_COOKED	/;"	d
SHELL_DOOUT	vim.h	/^#define SHELL_DOOUT	/;"	d
SHELL_EXPAND	vim.h	/^#define SHELL_EXPAND	/;"	d
SHELL_FILTER	vim.h	/^#define SHELL_FILTER	/;"	d
SHELL_READ	vim.h	/^#define SHELL_READ	/;"	d
SHELL_SILENT	vim.h	/^#define SHELL_SILENT	/;"	d
SHELL_SPECIAL	os_unix.c	/^#define SHELL_SPECIAL /;"	d	file:
SHELL_WRITE	vim.h	/^#define SHELL_WRITE	/;"	d
SHIN	farsi.h	/^#define SHIN	/;"	d
SHM_A	option.h	/^#define SHM_A	/;"	d
SHM_ALL	option.h	/^#define SHM_ALL	/;"	d
SHM_ATTENTION	option.h	/^#define SHM_ATTENTION	/;"	d
SHM_FILE	option.h	/^#define SHM_FILE	/;"	d
SHM_INTRO	option.h	/^#define SHM_INTRO	/;"	d
SHM_LAST	option.h	/^#define SHM_LAST	/;"	d
SHM_LINES	option.h	/^#define SHM_LINES	/;"	d
SHM_MOD	option.h	/^#define SHM_MOD	/;"	d
SHM_NEW	option.h	/^#define SHM_NEW	/;"	d
SHM_OVER	option.h	/^#define SHM_OVER	/;"	d
SHM_OVERALL	option.h	/^#define SHM_OVERALL	/;"	d
SHM_RO	option.h	/^#define SHM_RO	/;"	d
SHM_SEARCH	option.h	/^#define SHM_SEARCH	/;"	d
SHM_TEXT	option.h	/^#define SHM_TEXT	/;"	d
SHM_TRUNC	option.h	/^#define SHM_TRUNC	/;"	d
SHM_TRUNCALL	option.h	/^#define SHM_TRUNCALL	/;"	d
SHM_WRI	option.h	/^#define SHM_WRI	/;"	d
SHM_WRITE	option.h	/^#define SHM_WRITE	/;"	d
SHOWCMD_BUFLEN	normal.c	/^# define SHOWCMD_BUFLEN /;"	d	file:
SHOWCMD_COLS	vim.h	/^#define SHOWCMD_COLS /;"	d
SHOWMATCH	vim.h	/^#define SHOWMATCH	/;"	d
SIDENT	regexp.c	/^#define SIDENT	/;"	d	file:
SID_CARG	vim.h	/^#define SID_CARG	/;"	d
SID_CMDARG	vim.h	/^#define SID_CMDARG	/;"	d
SID_ENV	vim.h	/^#define SID_ENV	/;"	d
SID_ERROR	vim.h	/^#define SID_ERROR	/;"	d
SID_MODELINE	vim.h	/^#define SID_MODELINE	/;"	d
SID_NONE	vim.h	/^#define SID_NONE	/;"	d
SIGDEFARG	if_cscope.c	/^sig_handler SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.c	/^catch_sigint SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.c	/^catch_sigpwr SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.c	/^deathtrap SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.c	/^sig_alarm SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.c	/^sig_sysmouse SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.c	/^sig_winch SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.c	/^sigcont_handler SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.h	/^#  define SIGDEFARG(/;"	d
SIGDEFARG	os_unix.h	/^# define SIGDEFARG(/;"	d
SIGDUMMYARG	os_unix.h	/^#  define SIGDUMMYARG	/;"	d
SIGDUMMYARG	os_unix.h	/^# define SIGDUMMYARG$/;"	d
SIGHAS3ARGS	os_unix.h	/^# define SIGHAS3ARGS$/;"	d
SIGHASARG	os_unix.h	/^#define SIGHASARG$/;"	d
SIGNAL_BLOCK	vim.h	/^#define SIGNAL_BLOCK	/;"	d
SIGNAL_UNBLOCK	vim.h	/^#define SIGNAL_UNBLOCK /;"	d
SIGNCMD_DEFINE	ex_cmds.c	/^#define SIGNCMD_DEFINE	/;"	d	file:
SIGNCMD_JUMP	ex_cmds.c	/^#define SIGNCMD_JUMP	/;"	d	file:
SIGNCMD_LAST	ex_cmds.c	/^#define SIGNCMD_LAST	/;"	d	file:
SIGNCMD_LIST	ex_cmds.c	/^#define SIGNCMD_LIST	/;"	d	file:
SIGNCMD_PLACE	ex_cmds.c	/^#define SIGNCMD_PLACE	/;"	d	file:
SIGNCMD_UNDEFINE	ex_cmds.c	/^#define SIGNCMD_UNDEFINE /;"	d	file:
SIGNCMD_UNPLACE	ex_cmds.c	/^#define SIGNCMD_UNPLACE	/;"	d	file:
SIGN_ANY	structs.h	/^#define SIGN_ANY	/;"	d
SIGN_ASPECT	gui_gtk_x11.c	/^# define SIGN_ASPECT /;"	d	file:
SIGN_BYTE	vim.h	/^#define SIGN_BYTE /;"	d
SIGN_HEIGHT	gui_gtk_x11.c	/^# define SIGN_HEIGHT /;"	d	file:
SIGN_ICON	structs.h	/^#define SIGN_ICON	/;"	d
SIGN_LINEHL	structs.h	/^#define SIGN_LINEHL	/;"	d
SIGN_TEXT	structs.h	/^#define SIGN_TEXT	/;"	d
SIGN_WIDTH	gui_gtk_x11.c	/^# define SIGN_WIDTH /;"	d	file:
SIGN_WIDTH	gui_x11.c	/^# define SIGN_WIDTH /;"	d	file:
SIGPROTOARG	os_unix.h	/^#  define SIGPROTOARG	/;"	d
SIGPROTOARG	os_unix.h	/^# define SIGPROTOARG /;"	d
SIGSTKSZ	os_unix.c	/^# define SIGSTKSZ /;"	d	file:
SIGWINCH	os_unix.c	/^#  undef SIGWINCH$/;"	d	file:
SIGWINCH	os_unix.c	/^# define SIGWINCH /;"	d	file:
SIG_ERR	os_unix.c	/^# define SIG_ERR	/;"	d	file:
SIMPLE	regexp.c	/^#define SIMPLE	/;"	d	file:
SIN	farsi.h	/^#define SIN	/;"	d
SIN_CHANGED	vim.h	/^#define SIN_CHANGED	/;"	d
SIN_INSERT	vim.h	/^#define SIN_INSERT	/;"	d
SIN_UNDO	vim.h	/^#define SIN_UNDO	/;"	d
SIZE	gui_xmdlg.c	/^    SIZE,$/;"	e	enum:ListSpecifier	file:
SIZEOF_CSTR	hardcopy.c	/^#define SIZEOF_CSTR(/;"	d	file:
SIZEOF_INT	vim.h	/^#   define SIZEOF_INT	/;"	d
SIZEOF_INT	vim.h	/^#   define SIZEOF_INT /;"	d
SIZEOF_INT	vim.h	/^#  define SIZEOF_INT /;"	d
SIZEOF_INT	vim.h	/^# define SIZEOF_INT /;"	d
SKIP_STOP	netbeans.c	/^#define SKIP_STOP /;"	d	file:
SKWORD	regexp.c	/^#define SKWORD	/;"	d	file:
SMALL_MEM	misc2.c	/^# define SMALL_MEM$/;"	d	file:
SMBUFSIZE	fileio.c	/^#define SMBUFSIZE	/;"	d	file:
SMODE_CONT	gui_at_sb.h	/^#define SMODE_CONT	/;"	d
SMODE_LINE_DOWN	gui_at_sb.h	/^#define SMODE_LINE_DOWN	/;"	d
SMODE_LINE_UP	gui_at_sb.h	/^#define SMODE_LINE_UP	/;"	d
SMODE_NONE	gui_at_sb.h	/^#define SMODE_NONE	/;"	d
SMODE_PAGE_DOWN	gui_at_sb.h	/^#define SMODE_PAGE_DOWN	/;"	d
SMODE_PAGE_UP	gui_at_sb.h	/^#define SMODE_PAGE_UP	/;"	d
SNF_REQUIRED	spell.c	/^#define SNF_REQUIRED	/;"	d	file:
SNIFF_IDX	os_unix.c	/^#  define SNIFF_IDX /;"	d	file:
SN_CHARFLAGS	spell.c	/^#define SN_CHARFLAGS	/;"	d	file:
SN_COMPOUND	spell.c	/^#define SN_COMPOUND	/;"	d	file:
SN_END	spell.c	/^#define SN_END	/;"	d	file:
SN_INFO	spell.c	/^#define SN_INFO	/;"	d	file:
SN_MAP	spell.c	/^#define SN_MAP	/;"	d	file:
SN_MIDWORD	spell.c	/^#define SN_MIDWORD	/;"	d	file:
SN_NOBREAK	spell.c	/^#define SN_NOBREAK	/;"	d	file:
SN_NOSPLITSUGS	spell.c	/^#define SN_NOSPLITSUGS	/;"	d	file:
SN_PREFCOND	spell.c	/^#define SN_PREFCOND	/;"	d	file:
SN_REGION	spell.c	/^#define SN_REGION	/;"	d	file:
SN_REP	spell.c	/^#define SN_REP	/;"	d	file:
SN_REPSAL	spell.c	/^#define SN_REPSAL	/;"	d	file:
SN_SAL	spell.c	/^#define SN_SAL	/;"	d	file:
SN_SOFO	spell.c	/^#define SN_SOFO	/;"	d	file:
SN_SUGFILE	spell.c	/^#define SN_SUGFILE	/;"	d	file:
SN_SYLLABLE	spell.c	/^#define SN_SYLLABLE	/;"	d	file:
SN_WORDS	spell.c	/^#define SN_WORDS	/;"	d	file:
SOLARIS	os_unix.h	/^# define SOLARIS$/;"	d
SOME_BUILTIN_TCAPS	feature.h	/^#  define SOME_BUILTIN_TCAPS	/;"	d
SOME_VALID	vim.h	/^#define SOME_VALID	/;"	d
SPECIAL_WILDCHAR	os_unix.h	/^#define SPECIAL_WILDCHAR /;"	d
SPEC_ABUF	ex_docmd.c	/^# define SPEC_ABUF /;"	d	file:
SPEC_AFILE	ex_docmd.c	/^# define SPEC_AFILE /;"	d	file:
SPEC_AMATCH	ex_docmd.c	/^# define SPEC_AMATCH /;"	d	file:
SPEC_CCWORD	ex_docmd.c	/^#define SPEC_CCWORD /;"	d	file:
SPEC_CFILE	ex_docmd.c	/^#define SPEC_CFILE /;"	d	file:
SPEC_CLIENT	ex_docmd.c	/^# define SPEC_CLIENT /;"	d	file:
SPEC_COUNT	ex_docmd.c	/^#define SPEC_COUNT /;"	d	file:
SPEC_CWORD	ex_docmd.c	/^#define SPEC_CWORD /;"	d	file:
SPEC_HASH	ex_docmd.c	/^#define SPEC_HASH /;"	d	file:
SPEC_PERC	ex_docmd.c	/^#define SPEC_PERC /;"	d	file:
SPEC_SFILE	ex_docmd.c	/^#define SPEC_SFILE /;"	d	file:
SPELL_ISUPPER	spell.c	/^#  define SPELL_ISUPPER(/;"	d	file:
SPELL_ISUPPER	spell.c	/^# define SPELL_ISUPPER(/;"	d	file:
SPELL_TOFOLD	spell.c	/^#  define SPELL_TOFOLD(/;"	d	file:
SPELL_TOFOLD	spell.c	/^# define SPELL_TOFOLD(/;"	d	file:
SPELL_TOUPPER	spell.c	/^#  define SPELL_TOUPPER(/;"	d	file:
SPELL_TOUPPER	spell.c	/^# define SPELL_TOUPPER(/;"	d	file:
SPO_COUNT	syntax.c	/^#define SPO_COUNT	/;"	d	file:
SPO_HE_OFF	syntax.c	/^#define SPO_HE_OFF	/;"	d	file:
SPO_HS_OFF	syntax.c	/^#define SPO_HS_OFF	/;"	d	file:
SPO_LC_OFF	syntax.c	/^#define SPO_LC_OFF	/;"	d	file:
SPO_ME_OFF	syntax.c	/^#define SPO_ME_OFF	/;"	d	file:
SPO_MS_OFF	syntax.c	/^#define SPO_MS_OFF	/;"	d	file:
SPO_RE_OFF	syntax.c	/^#define SPO_RE_OFF	/;"	d	file:
SPO_RS_OFF	syntax.c	/^#define SPO_RS_OFF	/;"	d	file:
SPRINT	regexp.c	/^#define SPRINT	/;"	d	file:
SPSTART	regexp.c	/^#define SPSTART	/;"	d	file:
SPS_BEST	spell.c	/^#define SPS_BEST /;"	d	file:
SPS_DOUBLE	spell.c	/^#define SPS_DOUBLE /;"	d	file:
SPS_FAST	spell.c	/^#define SPS_FAST /;"	d	file:
SPTYPE_END	syntax.c	/^#define SPTYPE_END	/;"	d	file:
SPTYPE_MATCH	syntax.c	/^#define SPTYPE_MATCH	/;"	d	file:
SPTYPE_SKIP	syntax.c	/^#define SPTYPE_SKIP	/;"	d	file:
SPTYPE_START	syntax.c	/^#define SPTYPE_START	/;"	d	file:
SPWORDLEN	screen.c	/^# define SPWORDLEN /;"	d	file:
SP_BAD	spell.c	/^#define SP_BAD	/;"	d	file:
SP_BANNED	spell.c	/^#define SP_BANNED	/;"	d	file:
SP_END	eval.c	/^#define SP_END	/;"	d	file:
SP_FORMERROR	spell.c	/^#define	SP_FORMERROR	/;"	d	file:
SP_LOCAL	spell.c	/^#define SP_LOCAL	/;"	d	file:
SP_NOMOVE	eval.c	/^#define SP_NOMOVE	/;"	d	file:
SP_OK	spell.c	/^#define SP_OK	/;"	d	file:
SP_OTHERERROR	spell.c	/^#define SP_OTHERERROR	/;"	d	file:
SP_RARE	spell.c	/^#define SP_RARE	/;"	d	file:
SP_REPEAT	eval.c	/^#define SP_REPEAT	/;"	d	file:
SP_RETCOUNT	eval.c	/^#define SP_RETCOUNT	/;"	d	file:
SP_SETPCMARK	eval.c	/^#define SP_SETPCMARK	/;"	d	file:
SP_START	eval.c	/^#define SP_START	/;"	d	file:
SP_SUBPAT	eval.c	/^#define SP_SUBPAT	/;"	d	file:
SP_TRUNCERROR	spell.c	/^#define	SP_TRUNCERROR	/;"	d	file:
SRC_CMD	farsi.h	/^#define SRC_CMD /;"	d
SRC_EDT	farsi.h	/^#define SRC_EDT	/;"	d
SROP_Add	if_xcmdsrv.c	/^enum ServerReplyOp { SROP_Find, SROP_Add, SROP_Delete };$/;"	e	enum:ServerReplyOp	file:
SROP_Delete	if_xcmdsrv.c	/^enum ServerReplyOp { SROP_Find, SROP_Add, SROP_Delete };$/;"	e	enum:ServerReplyOp	file:
SROP_Find	if_xcmdsrv.c	/^enum ServerReplyOp { SROP_Find, SROP_Add, SROP_Delete };$/;"	e	enum:ServerReplyOp	file:
SSOP_BLANK	option.h	/^# define SSOP_BLANK	/;"	d
SSOP_BUFFERS	option.h	/^# define SSOP_BUFFERS	/;"	d
SSOP_CURDIR	option.h	/^# define SSOP_CURDIR	/;"	d
SSOP_CURSOR	option.h	/^# define SSOP_CURSOR	/;"	d
SSOP_FOLDS	option.h	/^# define SSOP_FOLDS	/;"	d
SSOP_GLOBALS	option.h	/^# define SSOP_GLOBALS	/;"	d
SSOP_HELP	option.h	/^# define SSOP_HELP	/;"	d
SSOP_LOCALOPTIONS	option.h	/^# define SSOP_LOCALOPTIONS	/;"	d
SSOP_OPTIONS	option.h	/^# define SSOP_OPTIONS	/;"	d
SSOP_RESIZE	option.h	/^# define SSOP_RESIZE	/;"	d
SSOP_SESDIR	option.h	/^# define SSOP_SESDIR	/;"	d
SSOP_SLASH	option.h	/^# define SSOP_SLASH	/;"	d
SSOP_TABPAGES	option.h	/^# define SSOP_TABPAGES	/;"	d
SSOP_UNIX	option.h	/^# define SSOP_UNIX	/;"	d
SSOP_WINPOS	option.h	/^# define SSOP_WINPOS	/;"	d
SSOP_WINSIZE	option.h	/^# define SSOP_WINSIZE	/;"	d
SST_DIST	vim.h	/^# define SST_DIST	/;"	d
SST_FIX_STATES	vim.h	/^# define SST_FIX_STATES	/;"	d
SST_MAX_ENTRIES	vim.h	/^#  define SST_MAX_ENTRIES /;"	d
SST_MIN_ENTRIES	vim.h	/^# define SST_MIN_ENTRIES /;"	d
STACK_INCR	memline.c	/^#define STACK_INCR	/;"	d	file:
STAR	regexp.c	/^#define STAR	/;"	d	file:
STAR_REGISTER	ops.c	/^# define STAR_REGISTER	/;"	d	file:
STATE_DEL	spell.c	/^    STATE_DEL,		\/* Delete a byte from the bad word. *\/$/;"	e	enum:__anon53	file:
STATE_ENDNUL	spell.c	/^    STATE_ENDNUL,	\/* Past NUL bytes at start of the node. *\/$/;"	e	enum:__anon53	file:
STATE_FINAL	spell.c	/^    STATE_FINAL		\/* End of this node. *\/$/;"	e	enum:__anon53	file:
STATE_INS	spell.c	/^    STATE_INS,		\/* Insert a byte in the bad word. *\/$/;"	e	enum:__anon53	file:
STATE_INS_PREP	spell.c	/^    STATE_INS_PREP,	\/* Prepare for inserting bytes. *\/$/;"	e	enum:__anon53	file:
STATE_NOPREFIX	spell.c	/^    STATE_NOPREFIX,	\/* try without prefix *\/$/;"	e	enum:__anon53	file:
STATE_PLAIN	spell.c	/^    STATE_PLAIN,	\/* Use each byte of the node. *\/$/;"	e	enum:__anon53	file:
STATE_REP	spell.c	/^    STATE_REP,		\/* Use matching REP items from the .aff file. *\/$/;"	e	enum:__anon53	file:
STATE_REP_INI	spell.c	/^    STATE_REP_INI,	\/* Prepare for using REP items. *\/$/;"	e	enum:__anon53	file:
STATE_REP_UNDO	spell.c	/^    STATE_REP_UNDO,	\/* Undo a REP item replacement. *\/$/;"	e	enum:__anon53	file:
STATE_SPLITUNDO	spell.c	/^    STATE_SPLITUNDO,	\/* Undo splitting. *\/$/;"	e	enum:__anon53	file:
STATE_START	spell.c	/^    STATE_START = 0,	\/* At start of node check for NUL bytes (goodword$/;"	e	enum:__anon53	file:
STATE_SWAP	spell.c	/^    STATE_SWAP,		\/* Swap two bytes. *\/$/;"	e	enum:__anon53	file:
STATE_SWAP3	spell.c	/^    STATE_SWAP3,	\/* Swap two characters over three. *\/$/;"	e	enum:__anon53	file:
STATE_UNROT3L	spell.c	/^    STATE_UNROT3L,	\/* Undo rotate three characters left *\/$/;"	e	enum:__anon53	file:
STATE_UNROT3R	spell.c	/^    STATE_UNROT3R,	\/* Undo rotate three characters right *\/$/;"	e	enum:__anon53	file:
STATE_UNSWAP	spell.c	/^    STATE_UNSWAP,	\/* Undo swap two characters. *\/$/;"	e	enum:__anon53	file:
STATE_UNSWAP3	spell.c	/^    STATE_UNSWAP3,	\/* Undo Swap two characters over three. *\/$/;"	e	enum:__anon53	file:
STATFS	memfile.c	/^#  define STATFS /;"	d	file:
STATFS	memfile.c	/^# define STATFS /;"	d	file:
STATUS_HEIGHT	vim.h	/^#define STATUS_HEIGHT	/;"	d
STERM	ascii.h	/^#define STERM	/;"	d
STIPPLE_BITMAP	gui_xmebw.c	/^#define STIPPLE_BITMAP	/;"	d	file:
STL_ALL	option.h	/^#define STL_ALL	/;"	d
STL_ALTPERCENT	option.h	/^#define STL_ALTPERCENT	/;"	d
STL_ARGLISTSTAT	option.h	/^#define STL_ARGLISTSTAT	/;"	d
STL_BUFNO	option.h	/^#define STL_BUFNO	/;"	d
STL_BYTEVAL	option.h	/^#define STL_BYTEVAL	/;"	d
STL_BYTEVAL_X	option.h	/^#define STL_BYTEVAL_X	/;"	d
STL_COLUMN	option.h	/^#define STL_COLUMN	/;"	d
STL_FILENAME	option.h	/^#define STL_FILENAME	/;"	d
STL_FILEPATH	option.h	/^#define STL_FILEPATH	/;"	d
STL_FILETYPE	option.h	/^#define STL_FILETYPE	/;"	d
STL_FILETYPE_ALT	option.h	/^#define STL_FILETYPE_ALT /;"	d
STL_FULLPATH	option.h	/^#define STL_FULLPATH	/;"	d
STL_HELPFLAG	option.h	/^#define STL_HELPFLAG	/;"	d
STL_HELPFLAG_ALT	option.h	/^#define STL_HELPFLAG_ALT /;"	d
STL_HIGHLIGHT	option.h	/^#define STL_HIGHLIGHT	/;"	d
STL_IN_ICON	globals.h	/^# define STL_IN_ICON	/;"	d
STL_IN_TITLE	globals.h	/^# define STL_IN_TITLE	/;"	d
STL_KEYMAP	option.h	/^#define STL_KEYMAP	/;"	d
STL_LINE	option.h	/^#define STL_LINE	/;"	d
STL_MAX_ITEM	vim.h	/^#define STL_MAX_ITEM /;"	d
STL_MIDDLEMARK	option.h	/^#define STL_MIDDLEMARK	/;"	d
STL_MODIFIED	option.h	/^#define STL_MODIFIED	/;"	d
STL_MODIFIED_ALT	option.h	/^#define STL_MODIFIED_ALT /;"	d
STL_NUMLINES	option.h	/^#define STL_NUMLINES	/;"	d
STL_OFFSET	option.h	/^#define STL_OFFSET	/;"	d
STL_OFFSET_X	option.h	/^#define STL_OFFSET_X	/;"	d
STL_PAGENUM	option.h	/^#define STL_PAGENUM	/;"	d
STL_PERCENTAGE	option.h	/^#define STL_PERCENTAGE	/;"	d
STL_PREVIEWFLAG	option.h	/^#define STL_PREVIEWFLAG	/;"	d
STL_PREVIEWFLAG_ALT	option.h	/^#define STL_PREVIEWFLAG_ALT /;"	d
STL_ROFLAG	option.h	/^#define STL_ROFLAG	/;"	d
STL_ROFLAG_ALT	option.h	/^#define STL_ROFLAG_ALT	/;"	d
STL_TABCLOSENR	option.h	/^#define STL_TABCLOSENR	/;"	d
STL_TABPAGENR	option.h	/^#define STL_TABPAGENR	/;"	d
STL_TRUNCMARK	option.h	/^#define STL_TRUNCMARK	/;"	d
STL_USER_HL	option.h	/^#define STL_USER_HL	/;"	d
STL_VIM_EXPR	option.h	/^#define STL_VIM_EXPR	/;"	d
STL_VIRTCOL	option.h	/^#define STL_VIRTCOL	/;"	d
STL_VIRTCOL_ALT	option.h	/^#define STL_VIRTCOL_ALT	/;"	d
STRCAT	vim.h	/^#define STRCAT(/;"	d
STRCMP	vim.h	/^#define STRCMP(/;"	d
STRCPY	vim.h	/^#define STRCPY(/;"	d
STRICMP	vim.h	/^#  define STRICMP(/;"	d
STRICMP	vim.h	/^# define STRICMP(/;"	d
STRING_TAG	gui_motif.c	/^# define STRING_TAG /;"	d	file:
STRLEN	vim.h	/^# undef STRLEN$/;"	d
STRLEN	vim.h	/^#define STRLEN(/;"	d
STRMOVE	vim.h	/^#define STRMOVE(/;"	d
STRNCAT	vim.h	/^#define STRNCAT(/;"	d
STRNCMP	vim.h	/^#define STRNCMP(/;"	d
STRNCPY	vim.h	/^#define STRNCPY(/;"	d
STRNICMP	vim.h	/^#  define STRNICMP(/;"	d
STRNICMP	vim.h	/^# define STRNICMP(/;"	d
STRPROCINT	os_unix.c	/^typedef int (*STRPROCINT)__ARGS((char_u *));$/;"	t	file:
STRPROCSTR	os_unix.c	/^typedef char_u * (*STRPROCSTR)__ARGS((char_u *));$/;"	t	file:
STR_CHAR	charset.c	/^#define STR_CHAR(/;"	d	file:
STR_PTR	charset.c	/^#define STR_PTR(/;"	d	file:
STYLE	gui_xmdlg.c	/^    STYLE,$/;"	e	enum:ListSpecifier	file:
SUBPAT	regexp.c	/^#define SUBPAT	/;"	d	file:
SUG	spell.c	/^#define SUG(/;"	d	file:
SUG_CLEAN_COUNT	spell.c	/^#define SUG_CLEAN_COUNT(/;"	d	file:
SUG_MAX_COUNT	spell.c	/^#define SUG_MAX_COUNT(/;"	d	file:
SWB_NEWTAB	option.h	/^#define SWB_NEWTAB	/;"	d
SWB_SPLIT	option.h	/^#define SWB_SPLIT	/;"	d
SWB_USEOPEN	option.h	/^#define SWB_USEOPEN	/;"	d
SWB_USETAB	option.h	/^#define SWB_USETAB	/;"	d
SYNID_ALLBUT	syntax.c	/^#define SYNID_ALLBUT	/;"	d	file:
SYNID_CLUSTER	syntax.c	/^#define SYNID_CLUSTER	/;"	d	file:
SYNID_CONTAINED	syntax.c	/^#define SYNID_CONTAINED	/;"	d	file:
SYNID_TOP	syntax.c	/^#define SYNID_TOP	/;"	d	file:
SYNSPL_DEFAULT	structs.h	/^#define SYNSPL_DEFAULT	/;"	d
SYNSPL_NOTOP	structs.h	/^#define SYNSPL_NOTOP	/;"	d
SYNSPL_TOP	structs.h	/^#define SYNSPL_TOP	/;"	d
SYNTAX_FNAME	os_unix.h	/^# define SYNTAX_FNAME	/;"	d
SYN_CLSTR	syntax.c	/^#define SYN_CLSTR(/;"	d	file:
SYN_ITEMS	syntax.c	/^#define SYN_ITEMS(/;"	d	file:
SYN_NAMELEN	syntax.c	/^#define SYN_NAMELEN	/;"	d	file:
SYN_STATE_P	syntax.c	/^#define SYN_STATE_P(/;"	d	file:
SYS_GVIMRC_FILE	os_unix.h	/^# define SYS_GVIMRC_FILE /;"	d
SYS_MENU_FILE	os_unix.h	/^# define SYS_MENU_FILE	/;"	d
SYS_NMLN	os_unixx.h	/^#  define SYS_NMLN /;"	d
SYS_OPTWIN_FILE	feature.h	/^# define SYS_OPTWIN_FILE	/;"	d
SYS_VIMRC_FILE	os_unix.h	/^# define SYS_VIMRC_FILE /;"	d
SY_MAXLEN	spell.c	/^#define SY_MAXLEN /;"	d	file:
S_ISBLK	os_unix.h	/^# define	S_ISBLK(/;"	d
S_ISCHR	os_unix.h	/^# define	S_ISCHR(/;"	d
S_ISDIR	os_unix.h	/^# define	S_ISDIR(/;"	d
S_ISFIFO	os_unix.h	/^# define	S_ISFIFO(/;"	d
S_ISREG	os_unix.h	/^# define	S_ISREG(/;"	d
S_ISSOCK	os_unix.h	/^# define	S_ISSOCK(/;"	d
S_ISXXX	gui_at_fs.c	/^#define S_ISXXX(/;"	d	file:
S_IXGRP	gui_at_fs.c	/^# define S_IXGRP /;"	d	file:
S_IXOTH	gui_at_fs.c	/^# define S_IXOTH /;"	d	file:
S_IXUSR	gui_at_fs.c	/^# define S_IXUSR /;"	d	file:
ScreenAttrs	globals.h	/^EXTERN sattr_T	*ScreenAttrs INIT(= NULL);$/;"	v
ScreenLines	globals.h	/^EXTERN schar_T	*ScreenLines INIT(= NULL);$/;"	v
ScreenLines2	globals.h	/^EXTERN schar_T	*ScreenLines2 INIT(= NULL);$/;"	v
ScreenLinesC	globals.h	/^EXTERN u8char_T	*ScreenLinesC[MAX_MCO];		\/* composing characters *\/$/;"	v
ScreenLinesUC	globals.h	/^EXTERN u8char_T	*ScreenLinesUC INIT(= NULL);	\/* decoded UTF-8 characters *\/$/;"	v
Screen_mco	globals.h	/^EXTERN int	Screen_mco INIT(= 0);		\/* value of p_mco used when$/;"	v
ScrollOneLineDown	gui_at_sb.c	/^ScrollOneLineDown(w, event, params, num_params)$/;"	f	file:
ScrollOneLineUp	gui_at_sb.c	/^ScrollOneLineUp(w, event, params, num_params)$/;"	f	file:
ScrollPageDown	gui_at_sb.c	/^ScrollPageDown(w, event, params, num_params)$/;"	f	file:
ScrollPageUp	gui_at_sb.c	/^ScrollPageUp(w, event, params, num_params)$/;"	f	file:
ScrollSome	gui_at_sb.c	/^ScrollSome(w, event, call_data)$/;"	f	file:
ScrollbarClassPart	gui_at_sb.h	/^typedef struct {int empty;} ScrollbarClassPart;$/;"	t	typeref:struct:__anon65
ScrollbarClassRec	gui_at_sb.h	/^} ScrollbarClassRec;$/;"	t	typeref:struct:_ScrollbarClassRec
ScrollbarPart	gui_at_sb.h	/^} ScrollbarPart;$/;"	t	typeref:struct:__anon64
ScrollbarRec	gui_at_sb.h	/^} ScrollbarRec;$/;"	t	typeref:struct:_ScrollbarRec
ScrollbarWidget	gui_at_sb.h	/^typedef struct _ScrollbarRec	  *ScrollbarWidget;$/;"	t	typeref:struct:_ScrollbarRec
ScrollbarWidgetClass	gui_at_sb.h	/^typedef struct _ScrollbarClassRec *ScrollbarWidgetClass;$/;"	t	typeref:struct:_ScrollbarClassRec
SearchedFile	search.c	/^typedef struct SearchedFile$/;"	s	file:
SearchedFile	search.c	/^} SearchedFile;$/;"	t	typeref:struct:SearchedFile	file:
SendInit	if_xcmdsrv.c	/^SendInit(dpy)$/;"	f	file:
ServerReply	if_xcmdsrv.c	/^struct ServerReply$/;"	s	file:
ServerReplyFind	if_xcmdsrv.c	/^ServerReplyFind(w, op)$/;"	f	file:
ServerReplyOp	if_xcmdsrv.c	/^enum ServerReplyOp { SROP_Find, SROP_Add, SROP_Delete };$/;"	g	file:
ServerWait	if_xcmdsrv.c	/^ServerWait(dpy, w, endCond, endData, localLoop, seconds)$/;"	f	file:
SetBufferLine	if_python.c	/^SetBufferLine(buf_T *buf, PyInt n, PyObject *line, PyInt *len_change)$/;"	f	file:
SetBufferLineList	if_python.c	/^SetBufferLineList(buf_T *buf, PyInt lo, PyInt hi, PyObject *list, PyInt *len_change)$/;"	f	file:
SetDimensions	gui_at_sb.c	/^SetDimensions(sbw)$/;"	f	file:
SetValues	gui_at_sb.c	/^SetValues(current, request, desired, args, num_args)$/;"	f	file:
SetValues	gui_xmebw.c	/^SetValues(Widget current, Widget request, Widget new, ArgList args, Cardinal *n)$/;"	f	file:
SetupSlavePTY	pty.c	/^SetupSlavePTY(fd)$/;"	f
Sfdisc_t	if_perlsfio.c	/^# define Sfdisc_t /;"	d	file:
Sfio_t	if_perlsfio.c	/^# define Sfio_t /;"	d	file:
ShS_NEUTRAL	gui_beval.h	/^    ShS_NEUTRAL,			\/* nothing showing or pending *\/$/;"	e	enum:__anon66
ShS_PENDING	gui_beval.h	/^    ShS_PENDING,			\/* data requested from debugger *\/$/;"	e	enum:__anon66
ShS_SHOWING	gui_beval.h	/^    ShS_SHOWING				\/* the balloon is being displayed *\/$/;"	e	enum:__anon66
ShS_UPDATE_PENDING	gui_beval.h	/^    ShS_UPDATE_PENDING,			\/* switching information displayed *\/$/;"	e	enum:__anon66
SharedFindReplace	gui_gtk.c	/^} SharedFindReplace;$/;"	t	typeref:struct:_SharedFindReplace	file:
SharedFindReplace	gui_motif.c	/^} SharedFindReplace;$/;"	t	typeref:struct:_SharedFindReplace	file:
SharedFontSelData	gui_xmdlg.c	/^} SharedFontSelData;$/;"	t	typeref:struct:_SharedFontSelData	file:
Show	if_cscope.h	/^typedef enum { Add, Find, Help, Kill, Reset, Show } csid_e;$/;"	e	enum:__anon69
SpecialKey	term.h	/^enum SpecialKey$/;"	g
State	globals.h	/^EXTERN int	State INIT(= NORMAL);	\/* This is the current state of the$/;"	v
Store	if_cscope.h	/^    Store,$/;"	e	enum:__anon70
StringToLine	if_python.c	/^StringToLine(PyObject *obj)$/;"	f	file:
TAB	ascii.h	/^#define TAB	/;"	d
TABLINE_HEIGHT	gui.h	/^# define TABLINE_HEIGHT /;"	d
TABLINE_MENU_CLOSE	globals.h	/^#  define TABLINE_MENU_CLOSE	/;"	d
TABLINE_MENU_NEW	globals.h	/^#  define TABLINE_MENU_NEW	/;"	d
TABLINE_MENU_OPEN	globals.h	/^#  define TABLINE_MENU_OPEN	/;"	d
TAGSTACKSIZE	structs.h	/^#define TAGSTACKSIZE	/;"	d
TAG_BREAK	if_ruby.c	/^#define TAG_BREAK	/;"	d	file:
TAG_CSCOPE	vim.h	/^# define TAG_CSCOPE	/;"	d
TAG_FATAL	if_ruby.c	/^#define TAG_FATAL	/;"	d	file:
TAG_HELP	vim.h	/^#define TAG_HELP	/;"	d
TAG_INS_COMP	vim.h	/^#define TAG_INS_COMP	/;"	d
TAG_KEEP_LANG	vim.h	/^#define TAG_KEEP_LANG	/;"	d
TAG_MANY	vim.h	/^#define TAG_MANY	/;"	d
TAG_MASK	if_ruby.c	/^#define TAG_MASK	/;"	d	file:
TAG_NAMES	vim.h	/^#define TAG_NAMES	/;"	d
TAG_NEXT	if_ruby.c	/^#define TAG_NEXT	/;"	d	file:
TAG_NOIC	vim.h	/^#define	TAG_NOIC	/;"	d
TAG_RAISE	if_ruby.c	/^#define TAG_RAISE	/;"	d	file:
TAG_REDO	if_ruby.c	/^#define TAG_REDO	/;"	d	file:
TAG_REGEXP	vim.h	/^#define	TAG_REGEXP	/;"	d
TAG_RETRY	if_ruby.c	/^#define TAG_RETRY	/;"	d	file:
TAG_RETURN	if_ruby.c	/^#define TAG_RETURN	/;"	d	file:
TAG_THROW	if_ruby.c	/^#define TAG_THROW	/;"	d	file:
TAG_VERBOSE	vim.h	/^#define TAG_VERBOSE	/;"	d
TARGET_COMPOUND_TEXT	gui_gtk_x11.c	/^    TARGET_COMPOUND_TEXT,$/;"	e	enum:__anon17	file:
TARGET_STRING	gui_gtk_x11.c	/^    TARGET_STRING,$/;"	e	enum:__anon17	file:
TARGET_TEXT	gui_gtk_x11.c	/^    TARGET_TEXT,$/;"	e	enum:__anon17	file:
TARGET_TEXT_PLAIN	gui_gtk_x11.c	/^    TARGET_TEXT_PLAIN,$/;"	e	enum:__anon17	file:
TARGET_TEXT_URI_LIST	gui_gtk_x11.c	/^    TARGET_TEXT_URI_LIST,$/;"	e	enum:__anon17	file:
TARGET_TYPE_NONE	gui_gtk_x11.c	/^    TARGET_TYPE_NONE,$/;"	e	enum:__anon17	file:
TARGET_UTF8_STRING	gui_gtk_x11.c	/^    TARGET_UTF8_STRING,$/;"	e	enum:__anon17	file:
TARGET_VIM	gui_gtk_x11.c	/^    TARGET_VIM,$/;"	e	enum:__anon17	file:
TARGET_VIMENC	gui_gtk_x11.c	/^    TARGET_VIMENC$/;"	e	enum:__anon17	file:
TASH	farsi.h	/^#define TASH	/;"	d
TBIS_LARGE	option.h	/^# define TBIS_LARGE	/;"	d
TBIS_MEDIUM	option.h	/^# define TBIS_MEDIUM	/;"	d
TBIS_SMALL	option.h	/^# define TBIS_SMALL	/;"	d
TBIS_TINY	option.h	/^# define TBIS_TINY	/;"	d
TBUFSZ	vim.h	/^# define TBUFSZ /;"	d
TCL_EXIT	if_tcl.c	/^#define TCL_EXIT	/;"	d	file:
TCL_PROC	if_tcl.c	/^#define TCL_PROC /;"	d	file:
TE	farsi.h	/^#define TE	/;"	d
TEAR_LEN	gui.h	/^#define TEAR_LEN	/;"	d
TEAR_STRING	gui.h	/^#define TEAR_STRING	/;"	d
TEE	farsi.h	/^#define TEE	/;"	d
TEE_	farsi.h	/^#define TEE_	/;"	d
TEMPDIRNAMES	os_unix.h	/^#  define TEMPDIRNAMES /;"	d
TEMPDIRNAMES	os_unix.h	/^# define TEMPDIRNAMES	/;"	d
TEMPNAME	os_unix.h	/^#  define TEMPNAME /;"	d
TEMPNAMELEN	os_unix.h	/^#  define TEMPNAMELEN /;"	d
TEMPNAMELEN	os_unix.h	/^# define TEMPNAMELEN	/;"	d
TEMP_BUF_SIZE	gui_xmdlg.c	/^#define TEMP_BUF_SIZE	/;"	d	file:
TERMCAP2KEY	keymap.h	/^#define TERMCAP2KEY(/;"	d
TERMCAPFILE	termlib.c	/^#   define TERMCAPFILE /;"	d	file:
TERMCAPFILE	termlib.c	/^#  define TERMCAPFILE /;"	d	file:
TERM_ATTR_ENTRY	syntax.c	/^#define TERM_ATTR_ENTRY(/;"	d	file:
TEXT_X	gui.h	/^# define TEXT_X(/;"	d
TEXT_Y	gui.h	/^# define TEXT_Y(/;"	d
TFN_INT	eval.c	/^#define TFN_INT	/;"	d	file:
TFN_QUIET	eval.c	/^#define TFN_QUIET	/;"	d	file:
TGETENT	term.c	/^# define TGETENT(/;"	d	file:
TGETSTR	term.c	/^# define TGETSTR(/;"	d	file:
THROW_ON_ERROR	ex_eval.c	/^# define THROW_ON_ERROR	/;"	d	file:
THROW_ON_INTERRUPT	ex_eval.c	/^# define THROW_ON_INTERRUPT	/;"	d	file:
TILDE_REGISTER	ops.c	/^# define TILDE_REGISTER	/;"	d	file:
TIME_MSG	macros.h	/^# define TIME_MSG(/;"	d
TIOCGWINSZ	os_unix.c	/^#  undef TIOCGWINSZ$/;"	d	file:
TMODE_COOK	term.h	/^#define TMODE_COOK /;"	d
TMODE_RAW	term.h	/^#define TMODE_RAW /;"	d
TMODE_SLEEP	term.h	/^#define TMODE_SLEEP /;"	d
TMPLEN	buffer.c	/^#define TMPLEN /;"	d	file:
TMP_LEN	message.c	/^# define TMP_LEN /;"	d	file:
TOLOWER_ASC	macros.h	/^# define TOLOWER_ASC(/;"	d
TOLOWER_LOC	macros.h	/^#  define TOLOWER_LOC	/;"	d
TOLOWER_LOC	macros.h	/^#  define TOLOWER_LOC(/;"	d
TOOLBAR_BORDER_HEIGHT	gui.h	/^#define TOOLBAR_BORDER_HEIGHT	/;"	d
TOOLBAR_BUTTON_HEIGHT	gui.h	/^# define TOOLBAR_BUTTON_HEIGHT	/;"	d
TOOLBAR_BUTTON_WIDTH	gui.h	/^# define TOOLBAR_BUTTON_WIDTH	/;"	d
TOOLBAR_HORIZ	option.h	/^# define TOOLBAR_HORIZ	/;"	d
TOOLBAR_ICONS	option.h	/^# define TOOLBAR_ICONS	/;"	d
TOOLBAR_NAME_COUNT	menu.c	/^# define TOOLBAR_NAME_COUNT /;"	d	file:
TOOLBAR_TEXT	option.h	/^# define TOOLBAR_TEXT	/;"	d
TOOLBAR_TOOLTIPS	option.h	/^# define TOOLBAR_TOOLTIPS	/;"	d
TOP_SHADOW	gui_x11_pm.h	/^#define TOP_SHADOW	/;"	d
TOUPPER_ASC	macros.h	/^# define TOUPPER_ASC(/;"	d
TOUPPER_LOC	macros.h	/^#  define TOUPPER_LOC	/;"	d
TOUPPER_LOC	macros.h	/^#  define TOUPPER_LOC(/;"	d
TO_SPECIAL	keymap.h	/^#define TO_SPECIAL(/;"	d
TPUTSFUNCAST	term.c	/^#   define TPUTSFUNCAST /;"	d	file:
TPUTSFUNCAST	term.c	/^#  define TPUTSFUNCAST$/;"	d	file:
TRLBAR	ex_cmds.h	/^#define TRLBAR	/;"	d
TRUE	vim.h	/^# define TRUE	/;"	d
TRY_DEEPER	spell.c	/^#define TRY_DEEPER(/;"	d	file:
TSF_DIDDEL	spell.c	/^#define TSF_DIDDEL	/;"	d	file:
TSF_DIDSPLIT	spell.c	/^#define TSF_DIDSPLIT	/;"	d	file:
TSF_PREFIXOK	spell.c	/^#define TSF_PREFIXOK	/;"	d	file:
TTYM_DEC	option.h	/^# define TTYM_DEC	/;"	d
TTYM_JSBTERM	option.h	/^# define TTYM_JSBTERM	/;"	d
TTYM_NETTERM	option.h	/^# define TTYM_NETTERM	/;"	d
TTYM_PTERM	option.h	/^# define TTYM_PTERM	/;"	d
TTYM_XTERM	option.h	/^# define TTYM_XTERM	/;"	d
TTYM_XTERM2	option.h	/^# define TTYM_XTERM2	/;"	d
TYPELEN_INIT	getchar.c	/^#define TYPELEN_INIT	/;"	d	file:
TYPE_EQUAL	eval.c	/^    , TYPE_EQUAL	\/* == *\/$/;"	e	enum:__anon6	file:
TYPE_GEQUAL	eval.c	/^    , TYPE_GEQUAL	\/* >= *\/$/;"	e	enum:__anon6	file:
TYPE_GREATER	eval.c	/^    , TYPE_GREATER	\/* >  *\/$/;"	e	enum:__anon6	file:
TYPE_MATCH	eval.c	/^    , TYPE_MATCH	\/* =~ *\/$/;"	e	enum:__anon6	file:
TYPE_NEQUAL	eval.c	/^    , TYPE_NEQUAL	\/* != *\/$/;"	e	enum:__anon6	file:
TYPE_NOMATCH	eval.c	/^    , TYPE_NOMATCH	\/* !~ *\/$/;"	e	enum:__anon6	file:
TYPE_SEQUAL	eval.c	/^    , TYPE_SEQUAL	\/* <= *\/$/;"	e	enum:__anon6	file:
TYPE_SMALLER	eval.c	/^    , TYPE_SMALLER	\/* <  *\/$/;"	e	enum:__anon6	file:
TYPE_UNKNOWN	eval.c	/^    TYPE_UNKNOWN = 0$/;"	e	enum:__anon6	file:
T_AL	term.h	/^#define T_AL	/;"	d
T_BC	term.h	/^#define T_BC	/;"	d
T_CAB	term.h	/^#define T_CAB	/;"	d
T_CAF	term.h	/^#define T_CAF	/;"	d
T_CAL	term.h	/^#define T_CAL	/;"	d
T_CCO	term.h	/^#define T_CCO	/;"	d
T_CCS	term.h	/^#define T_CCS	/;"	d
T_CD	term.h	/^#define T_CD	/;"	d
T_CDL	term.h	/^#define T_CDL	/;"	d
T_CE	term.h	/^#define T_CE	/;"	d
T_CEI	term.h	/^#define T_CEI	/;"	d
T_CIE	term.h	/^#define T_CIE	/;"	d
T_CIS	term.h	/^#define T_CIS	/;"	d
T_CL	term.h	/^#define T_CL	/;"	d
T_CM	term.h	/^#define T_CM	/;"	d
T_CRI	term.h	/^#define T_CRI	/;"	d
T_CRV	term.h	/^#define T_CRV	/;"	d
T_CS	term.h	/^#define T_CS	/;"	d
T_CSB	term.h	/^#define T_CSB	/;"	d
T_CSF	term.h	/^#define T_CSF	/;"	d
T_CSI	term.h	/^#define T_CSI	/;"	d
T_CSV	term.h	/^#define T_CSV	/;"	d
T_CWP	term.h	/^#define T_CWP	/;"	d
T_CWS	term.h	/^#define T_CWS	/;"	d
T_CZH	term.h	/^#define T_CZH	/;"	d
T_CZR	term.h	/^#define T_CZR	/;"	d
T_DA	term.h	/^#define T_DA	/;"	d
T_DB	term.h	/^#define T_DB	/;"	d
T_DL	term.h	/^#define T_DL	/;"	d
T_FS	term.h	/^#define T_FS	/;"	d
T_KE	term.h	/^#define T_KE	/;"	d
T_KS	term.h	/^#define T_KS	/;"	d
T_LE	term.h	/^#define T_LE	/;"	d
T_MB	term.h	/^#define T_MB	/;"	d
T_MD	term.h	/^#define T_MD	/;"	d
T_ME	term.h	/^#define T_ME	/;"	d
T_MR	term.h	/^#define T_MR	/;"	d
T_MS	term.h	/^#define T_MS	/;"	d
T_NAME	term.h	/^#define T_NAME	/;"	d
T_ND	term.h	/^#define T_ND	/;"	d
T_OP	term.h	/^#define T_OP	/;"	d
T_SE	term.h	/^#define T_SE	/;"	d
T_SO	term.h	/^#define T_SO	/;"	d
T_SR	term.h	/^#define T_SR	/;"	d
T_TE	term.h	/^#define T_TE	/;"	d
T_TI	term.h	/^#define T_TI	/;"	d
T_TS	term.h	/^#define T_TS	/;"	d
T_UCE	term.h	/^#define T_UCE	/;"	d
T_UCS	term.h	/^#define T_UCS	/;"	d
T_UE	term.h	/^#define T_UE	/;"	d
T_US	term.h	/^#define T_US	/;"	d
T_UT	term.h	/^#define T_UT	/;"	d
T_VB	term.h	/^#define T_VB	/;"	d
T_VE	term.h	/^#define T_VE	/;"	d
T_VI	term.h	/^#define T_VI	/;"	d
T_VS	term.h	/^#define T_VS	/;"	d
T_XS	term.h	/^#define T_XS	/;"	d
TabPageIdxs	globals.h	/^EXTERN short	*TabPageIdxs INIT(= NULL);$/;"	v
TextData	gui_at_fs.c	/^} TextData;$/;"	t	typeref:struct:__anon16	file:
TheBufferList	if_python.c	/^static BufListObject TheBufferList =$/;"	v	file:
TheCurrent	if_python.c	/^static CurrentObject TheCurrent =$/;"	v	file:
TheWindowList	if_python.c	/^static WinListObject TheWindowList =$/;"	v	file:
Thunk_Info	if_mzsch.c	/^} Thunk_Info;$/;"	t	typeref:struct:__anon27	file:
TtyProto	pty.c	/^static char TtyProto[] = "\/dev\/pty\/ttyXY";$/;"	v	file:
TtyProto	pty.c	/^static char TtyProto[] = "\/dev\/tt\/XY";$/;"	v	file:
TtyProto	pty.c	/^static char TtyProto[] = "\/dev\/ttyXY";$/;"	v	file:
UCHARAT	regexp.c	/^#define UCHARAT(/;"	d	file:
UC_BUFFER	ex_docmd.c	/^#define UC_BUFFER	/;"	d	file:
UE_MAGIC	undo.c	/^#define UE_MAGIC /;"	d	file:
UF2HIKEY	eval.c	/^#define UF2HIKEY(/;"	d	file:
UH_CHANGED	structs.h	/^#define UH_CHANGED /;"	d
UH_EMPTYBUF	structs.h	/^#define UH_EMPTYBUF /;"	d
UH_MAGIC	undo.c	/^#define UH_MAGIC /;"	d	file:
UNHIGHLIGHTT	gui_xmebw.c	/^# define UNHIGHLIGHTT$/;"	d	file:
UNIX	vim.h	/^#  define UNIX$/;"	d
UNKNOWN	fileio.c	/^#define UNKNOWN	/;"	d	file:
UP	term.c	/^char *UP, *BC, PC;$/;"	v
UP	termlib.c	/^char	*UP = 0, *BC = 0;     \/* Pointers to UP and BC strings from database *\/$/;"	v
UPPER	regexp.c	/^#define UPPER	/;"	d	file:
URL_BACKSLASH	window.c	/^#define URL_BACKSLASH	/;"	d	file:
URL_SLASH	window.c	/^#define URL_SLASH	/;"	d	file:
USECTRLV	ex_cmds.h	/^#define USECTRLV /;"	d
USER_CMD	ex_docmd.c	/^#define USER_CMD(/;"	d	file:
USER_CMDIDX	ex_cmds.h	/^#define USER_CMDIDX(/;"	d
USER_CMD_GA	ex_docmd.c	/^#define USER_CMD_GA(/;"	d	file:
USER_HIGHLIGHT	globals.h	/^# define USER_HIGHLIGHT$/;"	d
USE_DLOPEN	feature.h	/^# define USE_DLOPEN$/;"	d
USE_FNAME_CASE	os_unix.h	/^# define USE_FNAME_CASE	/;"	d
USE_FSTATFS	memfile.c	/^# define USE_FSTATFS$/;"	d	file:
USE_GETCWD	os_unix.h	/^# define USE_GETCWD$/;"	d
USE_ICONV	feature.h	/^# define USE_ICONV$/;"	d
USE_IM_CONTROL	vim.h	/^# define USE_IM_CONTROL$/;"	d
USE_INPUT_BUF	vim.h	/^# define USE_INPUT_BUF$/;"	d
USE_MCH_ACCESS	fileio.c	/^#define USE_MCH_ACCESS$/;"	d	file:
USE_MCH_ERRMSG	vim.h	/^# define USE_MCH_ERRMSG$/;"	d
USE_NL	screen.c	/^#define USE_NL	/;"	d	file:
USE_ON_FLY_SCROLL	gui.h	/^# define USE_ON_FLY_SCROLL$/;"	d
USE_REDRAW	screen.c	/^#define USE_REDRAW /;"	d	file:
USE_START_TV	os_unix.c	/^#  define USE_START_TV$/;"	d	file:
USE_TCL_STUBS	if_tcl.c	/^# define USE_TCL_STUBS /;"	d	file:
USE_T_AL	screen.c	/^#define USE_T_AL /;"	d	file:
USE_T_CAL	screen.c	/^#define USE_T_CAL /;"	d	file:
USE_T_CD	screen.c	/^#define USE_T_CD /;"	d	file:
USE_T_CDL	screen.c	/^#define USE_T_CDL /;"	d	file:
USE_T_CE	screen.c	/^#define USE_T_CE /;"	d	file:
USE_T_DL	screen.c	/^#define USE_T_DL /;"	d	file:
USE_T_SR	screen.c	/^#define USE_T_SR /;"	d	file:
USE_UTF8LOOKUP	gui_x11.c	/^#  define USE_UTF8LOOKUP$/;"	d	file:
USE_UTF8_STRING	os_unix.c	/^#  define USE_UTF8_STRING$/;"	d	file:
USE_X11R6_XIM	mbyte.c	/^#  define USE_X11R6_XIM$/;"	d	file:
USE_XIM	feature.h	/^# define USE_XIM /;"	d
USE_XSMP	feature.h	/^# define USE_XSMP$/;"	d
USE_XSMP_INTERACT	feature.h	/^# undef USE_XSMP_INTERACT$/;"	d
USR_EXRC_FILE	os_unix.h	/^#  define USR_EXRC_FILE /;"	d
USR_EXRC_FILE2	os_unix.h	/^# define USR_EXRC_FILE2 /;"	d
USR_GVIMRC_FILE	os_unix.h	/^#  define USR_GVIMRC_FILE /;"	d
USR_GVIMRC_FILE2	os_unix.h	/^#  define USR_GVIMRC_FILE2 /;"	d
USR_VIMRC_FILE	os_unix.h	/^#  define USR_VIMRC_FILE /;"	d
USR_VIMRC_FILE	os_unix.h	/^# define USR_VIMRC_FILE /;"	d
USR_VIMRC_FILE2	os_unix.h	/^# define USR_VIMRC_FILE2 /;"	d
UTF_COMPOSINGLIKE	macros.h	/^# define UTF_COMPOSINGLIKE(/;"	d
U_ALLOC_LINE	undo.c	/^# define U_ALLOC_LINE(/;"	d	file:
U_FREE_LINE	undo.c	/^# define U_FREE_LINE(/;"	d	file:
U_USE_MALLOC	undo.c	/^#define U_USE_MALLOC /;"	d	file:
VALID	vim.h	/^#define VALID	/;"	d
VALID_BOTLINE	vim.h	/^#define VALID_BOTLINE	/;"	d
VALID_BOTLINE_AP	vim.h	/^#define VALID_BOTLINE_AP /;"	d
VALID_CHEIGHT	vim.h	/^#define VALID_CHEIGHT	/;"	d
VALID_CROW	vim.h	/^#define VALID_CROW	/;"	d
VALID_HEAD	vim.h	/^#define VALID_HEAD	/;"	d
VALID_PATH	vim.h	/^#define VALID_PATH	/;"	d
VALID_STATE	syntax.c	/^#define VALID_STATE(/;"	d	file:
VALID_TOPLINE	vim.h	/^#define VALID_TOPLINE	/;"	d
VALID_VIRTCOL	vim.h	/^#define VALID_VIRTCOL	/;"	d
VALID_WCOL	vim.h	/^#define VALID_WCOL	/;"	d
VALID_WROW	vim.h	/^#define VALID_WROW	/;"	d
VALUE	if_ruby.c	/^# define VALUE /;"	d	file:
VARNAME_SIZE	if_tcl.c	/^#define VARNAME_SIZE	/;"	d	file:
VAR_CURBUF	if_tcl.c	/^#define VAR_CURBUF	/;"	d	file:
VAR_CURLINE	if_tcl.c	/^#define VAR_CURLINE	/;"	d	file:
VAR_CURLNUM	if_tcl.c	/^#define VAR_CURLNUM	/;"	d	file:
VAR_CURWIN	if_tcl.c	/^#define VAR_CURWIN	/;"	d	file:
VAR_DICT	structs.h	/^#define VAR_DICT /;"	d
VAR_FIXED	structs.h	/^#define VAR_FIXED /;"	d
VAR_FLAVOUR_DEFAULT	eval.c	/^    VAR_FLAVOUR_DEFAULT,	\/* doesn't start with uppercase *\/$/;"	e	enum:__anon7	file:
VAR_FLAVOUR_SESSION	eval.c	/^    VAR_FLAVOUR_SESSION,	\/* starts with uppercase, some lower *\/$/;"	e	enum:__anon7	file:
VAR_FLAVOUR_VIMINFO	eval.c	/^    VAR_FLAVOUR_VIMINFO		\/* all uppercase *\/$/;"	e	enum:__anon7	file:
VAR_FLOAT	structs.h	/^#define VAR_FLOAT /;"	d
VAR_FUNC	structs.h	/^#define VAR_FUNC /;"	d
VAR_LBASE	if_tcl.c	/^#define VAR_LBASE	/;"	d	file:
VAR_LIST	structs.h	/^#define VAR_LIST /;"	d
VAR_LOCKED	structs.h	/^#define VAR_LOCKED /;"	d
VAR_NUMBER	structs.h	/^#define VAR_NUMBER /;"	d
VAR_RANGE1	if_tcl.c	/^#define VAR_RANGE1	/;"	d	file:
VAR_RANGE2	if_tcl.c	/^#define VAR_RANGE2	/;"	d	file:
VAR_RANGE3	if_tcl.c	/^#define VAR_RANGE3	/;"	d	file:
VAR_SHORT_LEN	eval.c	/^#define VAR_SHORT_LEN	/;"	d	file:
VAR_STRING	structs.h	/^#define VAR_STRING /;"	d
VAR_UNKNOWN	structs.h	/^#define VAR_UNKNOWN /;"	d
VAR_WIN	option.c	/^#define VAR_WIN /;"	d	file:
VE_ALL	option.h	/^# define VE_ALL	/;"	d
VE_BLOCK	option.h	/^# define VE_BLOCK	/;"	d
VE_INSERT	option.h	/^# define VE_INSERT	/;"	d
VE_ONEMORE	option.h	/^# define VE_ONEMORE	/;"	d
VGR_GLOBAL	vim.h	/^#define VGR_GLOBAL	/;"	d
VGR_NOJUMP	vim.h	/^#define VGR_NOJUMP	/;"	d
VIMENC_ATOM_NAME	vim.h	/^#define VIMENC_ATOM_NAME /;"	d
VIMERR	if_tcl.c	/^#define VIMERR	/;"	d	file:
VIMINFO_FILE	os_unix.h	/^#   define VIMINFO_FILE /;"	d
VIMINFO_FILE2	os_unix.h	/^#  define VIMINFO_FILE2 /;"	d
VIMOUT	if_tcl.c	/^#define VIMOUT	/;"	d	file:
VIMPACKAGE	vim.h	/^# define VIMPACKAGE	/;"	d
VIMRC_FILE	os_unix.h	/^# define VIMRC_FILE	/;"	d
VIMSPELLMAGIC	spell.c	/^#define VIMSPELLMAGIC /;"	d	file:
VIMSPELLMAGICL	spell.c	/^#define VIMSPELLMAGICL /;"	d	file:
VIMSPELLVERSION	spell.c	/^#define VIMSPELLVERSION /;"	d	file:
VIMSUGMAGIC	spell.c	/^#define VIMSUGMAGIC /;"	d	file:
VIMSUGMAGICL	spell.c	/^#define VIMSUGMAGICL /;"	d	file:
VIMSUGVERSION	spell.c	/^#define VIMSUGVERSION /;"	d	file:
VIM_ALL	vim.h	/^#define VIM_ALL	/;"	d
VIM_ATOM_NAME	vim.h	/^#define VIM_ATOM_NAME /;"	d
VIM_BACKTICK	feature.h	/^# define VIM_BACKTICK	/;"	d
VIM_CANCEL	vim.h	/^#define VIM_CANCEL	/;"	d
VIM_CLASS	gui_x11.c	/^#define VIM_CLASS	/;"	d	file:
VIM_DEFAULT	option.c	/^#define VIM_DEFAULT /;"	d	file:
VIM_DISCARDALL	vim.h	/^#define VIM_DISCARDALL /;"	d
VIM_ERROR	vim.h	/^#define VIM_ERROR	/;"	d
VIM_GENERIC	vim.h	/^#define VIM_GENERIC	/;"	d
VIM_INFO	vim.h	/^#define VIM_INFO	/;"	d
VIM_ISDIGIT	macros.h	/^#define VIM_ISDIGIT(/;"	d
VIM_LAST_TYPE	vim.h	/^#define VIM_LAST_TYPE	/;"	d
VIM_LC_MESSAGES	ex_cmds2.c	/^# define VIM_LC_MESSAGES /;"	d	file:
VIM_MEMCMP	vim.h	/^#  define VIM_MEMCMP$/;"	d
VIM_MEMMOVE	os_unix.h	/^#   define VIM_MEMMOVE	/;"	d
VIM_NAME	gui_x11.c	/^#define VIM_NAME	/;"	d	file:
VIM_NO	vim.h	/^#define VIM_NO	/;"	d
VIM_QUESTION	vim.h	/^#define VIM_QUESTION	/;"	d
VIM_VERSION_100	version.h	/^#define VIM_VERSION_100	/;"	d
VIM_VERSION_BUILD	version.h	/^#define VIM_VERSION_BUILD	/;"	d
VIM_VERSION_BUILD_BCD	version.h	/^#define VIM_VERSION_BUILD_BCD	/;"	d
VIM_VERSION_BUILD_STR	version.h	/^#define VIM_VERSION_BUILD_STR	/;"	d
VIM_VERSION_LONG	version.h	/^#define VIM_VERSION_LONG	/;"	d
VIM_VERSION_LONG_DATE	version.h	/^#define VIM_VERSION_LONG_DATE	/;"	d
VIM_VERSION_MAJOR	version.h	/^#define VIM_VERSION_MAJOR	/;"	d
VIM_VERSION_MAJOR_STR	version.h	/^#define VIM_VERSION_MAJOR_STR	/;"	d
VIM_VERSION_MEDIUM	version.h	/^#define VIM_VERSION_MEDIUM	/;"	d
VIM_VERSION_MINOR	version.h	/^#define VIM_VERSION_MINOR	/;"	d
VIM_VERSION_MINOR_STR	version.h	/^#define VIM_VERSION_MINOR_STR	/;"	d
VIM_VERSION_NODOT	version.h	/^#define VIM_VERSION_NODOT	/;"	d
VIM_VERSION_PATCHLEVEL	version.h	/^#define VIM_VERSION_PATCHLEVEL	/;"	d
VIM_VERSION_PATCHLEVEL_STR	version.h	/^#define VIM_VERSION_PATCHLEVEL_STR	/;"	d
VIM_VERSION_RELEASE	version.h	/^#define VIM_VERSION_RELEASE	/;"	d
VIM_VERSION_SHORT	version.h	/^#define VIM_VERSION_SHORT	/;"	d
VIM_WARNING	vim.h	/^#define VIM_WARNING	/;"	d
VIM_YES	vim.h	/^#define VIM_YES	/;"	d
VIM__H	vim.h	/^# define VIM__H$/;"	d
VISUAL	vim.h	/^#define VISUAL	/;"	d
VIS_SEL	getchar.c	/^# undef VIS_SEL$/;"	d	file:
VIS_SEL	getchar.c	/^#define VIS_SEL	/;"	d	file:
VI_DEFAULT	option.c	/^#define VI_DEFAULT /;"	d	file:
VIsual	globals.h	/^EXTERN pos_T	VIsual;		\/* start position of active Visual selection *\/$/;"	v
VIsual_active	globals.h	/^EXTERN int	VIsual_active INIT(= FALSE);$/;"	v
VIsual_mode	globals.h	/^EXTERN int	VIsual_mode INIT(= 'v');$/;"	v
VIsual_reselect	globals.h	/^EXTERN int	VIsual_reselect;$/;"	v
VIsual_select	globals.h	/^EXTERN int	VIsual_select INIT(= FALSE);$/;"	v
VMS_TEMPNAM	os_unix.h	/^#   define VMS_TEMPNAM /;"	d
VREPLACE	vim.h	/^# define VREPLACE	/;"	d
VREPLACE_FLAG	vim.h	/^# define VREPLACE_FLAG	/;"	d
VV_BEVAL_BUFNR	vim.h	/^#define VV_BEVAL_BUFNR	/;"	d
VV_BEVAL_COL	vim.h	/^#define VV_BEVAL_COL	/;"	d
VV_BEVAL_LNUM	vim.h	/^#define VV_BEVAL_LNUM	/;"	d
VV_BEVAL_TEXT	vim.h	/^#define VV_BEVAL_TEXT	/;"	d
VV_BEVAL_WINNR	vim.h	/^#define VV_BEVAL_WINNR	/;"	d
VV_CC_FROM	vim.h	/^#define VV_CC_FROM	/;"	d
VV_CC_TO	vim.h	/^#define VV_CC_TO	/;"	d
VV_CHAR	vim.h	/^#define VV_CHAR	/;"	d
VV_CMDARG	vim.h	/^#define VV_CMDARG	/;"	d
VV_CMDBANG	vim.h	/^#define VV_CMDBANG	/;"	d
VV_COMPAT	eval.c	/^#define VV_COMPAT	/;"	d	file:
VV_COUNT	vim.h	/^#define VV_COUNT	/;"	d
VV_COUNT1	vim.h	/^#define VV_COUNT1	/;"	d
VV_CTYPE	vim.h	/^#define VV_CTYPE	/;"	d
VV_DYING	vim.h	/^#define VV_DYING	/;"	d
VV_ERRMSG	vim.h	/^#define VV_ERRMSG	/;"	d
VV_EXCEPTION	vim.h	/^#define VV_EXCEPTION	/;"	d
VV_FCS_CHOICE	vim.h	/^#define VV_FCS_CHOICE	/;"	d
VV_FCS_REASON	vim.h	/^#define VV_FCS_REASON	/;"	d
VV_FNAME	vim.h	/^#define VV_FNAME	/;"	d
VV_FNAME_DIFF	vim.h	/^#define VV_FNAME_DIFF	/;"	d
VV_FNAME_IN	vim.h	/^#define VV_FNAME_IN	/;"	d
VV_FNAME_NEW	vim.h	/^#define VV_FNAME_NEW	/;"	d
VV_FNAME_OUT	vim.h	/^#define VV_FNAME_OUT	/;"	d
VV_FOLDDASHES	vim.h	/^#define VV_FOLDDASHES	/;"	d
VV_FOLDEND	vim.h	/^#define VV_FOLDEND	/;"	d
VV_FOLDLEVEL	vim.h	/^#define VV_FOLDLEVEL	/;"	d
VV_FOLDSTART	vim.h	/^#define VV_FOLDSTART	/;"	d
VV_INSERTMODE	vim.h	/^#define VV_INSERTMODE	/;"	d
VV_KEY	vim.h	/^#define VV_KEY	/;"	d
VV_LANG	vim.h	/^#define VV_LANG	/;"	d
VV_LC_TIME	vim.h	/^#define VV_LC_TIME	/;"	d
VV_LEN	vim.h	/^#define VV_LEN	/;"	d
VV_LNUM	vim.h	/^#define VV_LNUM	/;"	d
VV_MOUSE_COL	vim.h	/^#define VV_MOUSE_COL	/;"	d
VV_MOUSE_LNUM	vim.h	/^#define VV_MOUSE_LNUM /;"	d
VV_MOUSE_WIN	vim.h	/^#define VV_MOUSE_WIN	/;"	d
VV_NAME	eval.c	/^#define VV_NAME(/;"	d	file:
VV_OP	vim.h	/^#define VV_OP	/;"	d
VV_PREVCOUNT	vim.h	/^#define VV_PREVCOUNT	/;"	d
VV_PROFILING	vim.h	/^#define VV_PROFILING	/;"	d
VV_PROGNAME	vim.h	/^#define VV_PROGNAME	/;"	d
VV_REG	vim.h	/^#define VV_REG	/;"	d
VV_RO	eval.c	/^#define VV_RO	/;"	d	file:
VV_RO_SBX	eval.c	/^#define VV_RO_SBX	/;"	d	file:
VV_SCROLLSTART	vim.h	/^#define VV_SCROLLSTART	/;"	d
VV_SEARCHFORWARD	vim.h	/^#define VV_SEARCHFORWARD /;"	d
VV_SEND_SERVER	vim.h	/^#define VV_SEND_SERVER	/;"	d
VV_SHELL_ERROR	vim.h	/^#define VV_SHELL_ERROR	/;"	d
VV_STATUSMSG	vim.h	/^#define VV_STATUSMSG	/;"	d
VV_SWAPCHOICE	vim.h	/^#define VV_SWAPCHOICE	/;"	d
VV_SWAPCOMMAND	vim.h	/^#define VV_SWAPCOMMAND	/;"	d
VV_SWAPNAME	vim.h	/^#define VV_SWAPNAME	/;"	d
VV_TERMRESPONSE	vim.h	/^#define VV_TERMRESPONSE	/;"	d
VV_THIS_SESSION	vim.h	/^#define VV_THIS_SESSION	/;"	d
VV_THROWPOINT	vim.h	/^#define VV_THROWPOINT	/;"	d
VV_VAL	vim.h	/^#define VV_VAL	/;"	d
VV_VERSION	vim.h	/^#define VV_VERSION	/;"	d
VV_WARNINGMSG	vim.h	/^#define VV_WARNINGMSG	/;"	d
VW_POS_CENTER	gui.h	/^    VW_POS_CENTER,$/;"	e	enum:__anon63
VW_POS_MOUSE	gui.h	/^    VW_POS_MOUSE,$/;"	e	enum:__anon63
VW_POS_TOP_CENTER	gui.h	/^    VW_POS_TOP_CENTER$/;"	e	enum:__anon63
VerbSense	integration.h	/^} VerbSense;$/;"	t	typeref:struct:__anon71
Version	version.c	/^char		*Version = VIM_VERSION_SHORT;$/;"	v
VimClipboard	vim.h	/^typedef int VimClipboard;	\/* This is required for the prototypes. *\/$/;"	t
VimClipboard	vim.h	/^typedef struct VimClipboard$/;"	s
VimClipboard	vim.h	/^} VimClipboard;$/;"	t	typeref:struct:VimClipboard
VimCommand	if_python.c	/^VimCommand(PyObject *self, PyObject *args)$/;"	f	file:
VimError	if_python.c	/^static PyObject *VimError;$/;"	v	file:
VimErrorCheck	if_python.c	/^VimErrorCheck(void)$/;"	f	file:
VimEval	if_python.c	/^VimEval(PyObject *self, PyObject *args)$/;"	f	file:
VimMain	main.c	/^VimMain$/;"	f
VimMenu	structs.h	/^struct VimMenu$/;"	s
VimMethods	if_python.c	/^static struct PyMethodDef VimMethods[] = {$/;"	v	typeref:struct:PyMethodDef	file:
VimToPython	if_python.c	/^VimToPython(typval_T *our_tv, int depth, PyObject *lookupDict)$/;"	f	file:
VimWindow	gui.h	/^    WindowPtr	VimWindow;$/;"	m	struct:Gui
Vim_Prim	if_mzsch.c	/^} Vim_Prim;$/;"	t	typeref:struct:__anon23	file:
WANT_X11	feature.h	/^# define WANT_X11$/;"	d
WARGCOUNT	structs.h	/^#define WARGCOUNT(/;"	d
WARGLIST	structs.h	/^#define WARGLIST(/;"	d
WAS_BANNED	spell.c	/^#define WAS_BANNED(/;"	d	file:
WAW	farsi.h	/^#define WAW	/;"	d
WAW_H	farsi.h	/^#define WAW_H	/;"	d
WC_KEY_OFF	spell.c	/^#define WC_KEY_OFF /;"	d	file:
WEXITSTATUS	os_unixx.h	/^#   define WEXITSTATUS(/;"	d
WFP_COMPFORBID	spell.c	/^#define WFP_COMPFORBID	/;"	d	file:
WFP_COMPPERMIT	spell.c	/^#define WFP_COMPPERMIT	/;"	d	file:
WFP_NC	spell.c	/^#define WFP_NC	/;"	d	file:
WFP_RARE	spell.c	/^#define WFP_RARE	/;"	d	file:
WFP_UP	spell.c	/^#define WFP_UP	/;"	d	file:
WF_AFX	spell.c	/^#define WF_AFX	/;"	d	file:
WF_ALLCAP	spell.c	/^#define WF_ALLCAP /;"	d	file:
WF_BANNED	spell.c	/^#define WF_BANNED /;"	d	file:
WF_CAPMASK	spell.c	/^#define WF_CAPMASK /;"	d	file:
WF_COMPROOT	spell.c	/^#define WF_COMPROOT /;"	d	file:
WF_FIXCAP	spell.c	/^#define WF_FIXCAP /;"	d	file:
WF_HAS_AFF	spell.c	/^#define WF_HAS_AFF /;"	d	file:
WF_KEEPCAP	spell.c	/^#define WF_KEEPCAP /;"	d	file:
WF_MIXCAP	spell.c	/^#define WF_MIXCAP /;"	d	file:
WF_NEEDCOMP	spell.c	/^#define WF_NEEDCOMP /;"	d	file:
WF_NOCOMPAFT	spell.c	/^#define WF_NOCOMPAFT /;"	d	file:
WF_NOCOMPBEF	spell.c	/^#define WF_NOCOMPBEF /;"	d	file:
WF_NOSUGGEST	spell.c	/^#define WF_NOSUGGEST /;"	d	file:
WF_ONECAP	spell.c	/^#define WF_ONECAP /;"	d	file:
WF_PFX_COMPFORBID	spell.c	/^#define WF_PFX_COMPFORBID /;"	d	file:
WF_PFX_COMPPERMIT	spell.c	/^#define WF_PFX_COMPPERMIT /;"	d	file:
WF_PFX_NC	spell.c	/^#define WF_PFX_NC /;"	d	file:
WF_PFX_UP	spell.c	/^#define WF_PFX_UP /;"	d	file:
WF_RARE	spell.c	/^#define WF_RARE	/;"	d	file:
WF_RAREPFX	spell.c	/^#define WF_RAREPFX /;"	d	file:
WF_REGION	spell.c	/^#define WF_REGION /;"	d	file:
WHITE	regexp.c	/^#define WHITE	/;"	d	file:
WHITECHAR	edit.c	/^# define WHITECHAR(/;"	d	file:
WHOLEFOLD	ex_cmds.h	/^#define WHOLEFOLD	/;"	d
WIFEXITED	os_unixx.h	/^#   define WIFEXITED(/;"	d
WILD_ADD_SLASH	vim.h	/^#define WILD_ADD_SLASH	/;"	d
WILD_ALL	vim.h	/^#define WILD_ALL	/;"	d
WILD_ESCAPE	vim.h	/^#define WILD_ESCAPE	/;"	d
WILD_EXPAND_FREE	vim.h	/^#define WILD_EXPAND_FREE	/;"	d
WILD_EXPAND_KEEP	vim.h	/^#define WILD_EXPAND_KEEP	/;"	d
WILD_FREE	vim.h	/^#define WILD_FREE	/;"	d
WILD_HOME_REPLACE	vim.h	/^#define WILD_HOME_REPLACE	/;"	d
WILD_KEEP_ALL	vim.h	/^#define WILD_KEEP_ALL	/;"	d
WILD_LIST_NOTFOUND	vim.h	/^#define WILD_LIST_NOTFOUND	/;"	d
WILD_LONGEST	vim.h	/^#define WILD_LONGEST	/;"	d
WILD_NEXT	vim.h	/^#define WILD_NEXT	/;"	d
WILD_NO_BEEP	vim.h	/^#define WILD_NO_BEEP	/;"	d
WILD_PREV	vim.h	/^#define WILD_PREV	/;"	d
WILD_SILENT	vim.h	/^#define WILD_SILENT	/;"	d
WILD_USE_NL	vim.h	/^#define WILD_USE_NL	/;"	d
WIM_FULL	option.h	/^#define WIM_FULL	/;"	d
WIM_LIST	option.h	/^#define WIM_LIST	/;"	d
WIM_LONGEST	option.h	/^#define WIM_LONGEST	/;"	d
WIN32	mbyte.c	/^#  undef WIN32	/;"	d	file:
WIN3264	vim.h	/^# define WIN3264$/;"	d
WIN32UNIX	os_unix.h	/^# define WIN32UNIX	/;"	d
WIN32_LEAN_AND_MEAN	if_cscope.h	/^#   define WIN32_LEAN_AND_MEAN$/;"	d
WIN32_LEAN_AND_MEAN	mbyte.c	/^#  define WIN32_LEAN_AND_MEAN$/;"	d	file:
WIN_HOR	main.c	/^#define WIN_HOR	/;"	d	file:
WIN_TABS	main.c	/^#define	WIN_TABS /;"	d	file:
WIN_VER	main.c	/^#define	WIN_VER	/;"	d	file:
WITH_NL	regexp.c	/^#define WITH_NL(/;"	d	file:
WITH_OFF	screen.c	/^# define WITH_OFF(/;"	d	file:
WITH_WIDTH	screen.c	/^# define WITH_WIDTH(/;"	d	file:
WL_CMDLINE	screen.c	/^# define WL_CMDLINE	/;"	d	file:
WL_FOLD	screen.c	/^# define WL_FOLD	/;"	d	file:
WL_LINE	screen.c	/^#define WL_LINE	/;"	d	file:
WL_NR	screen.c	/^#define WL_NR	/;"	d	file:
WL_SBR	screen.c	/^# define WL_SBR	/;"	d	file:
WL_SIGN	screen.c	/^# define WL_SIGN	/;"	d	file:
WL_START	screen.c	/^#define WL_START	/;"	d	file:
WM_NETBEANS	vim.h	/^#   define WM_NETBEANS /;"	d
WM_OLE	vim.h	/^#   define WM_OLE /;"	d
WM_SCROLLED	globals.h	/^#define WM_SCROLLED	/;"	d
WM_SHOWN	globals.h	/^#define WM_SHOWN	/;"	d
WN_MASK	spell.c	/^#define WN_MASK	/;"	d	file:
WORD	regexp.c	/^#define WORD	/;"	d	file:
WORD1	ex_cmds.h	/^#define WORD1	/;"	d
WORKSHOP_H	workshop.h	/^#define WORKSHOP_H$/;"	d
WORST	regexp.c	/^#define WORST	/;"	d	file:
WRITEBIN	vim.h	/^# define WRITEBIN /;"	d
WSDEBUG_H	wsdebug.h	/^#define WSDEBUG_H$/;"	d
WSDEBUG_TRACE	wsdebug.h	/^#define WSDEBUG_TRACE	/;"	d
WSDLEVEL	wsdebug.h	/^#define WSDLEVEL(/;"	d
WSP_ABOVE	vim.h	/^#define WSP_ABOVE	/;"	d
WSP_BELOW	vim.h	/^#define WSP_BELOW	/;"	d
WSP_BOT	vim.h	/^#define WSP_BOT	/;"	d
WSP_HELP	vim.h	/^#define WSP_HELP	/;"	d
WSP_ROOM	vim.h	/^#define WSP_ROOM	/;"	d
WSP_TOP	vim.h	/^#define WSP_TOP	/;"	d
WSP_VERT	vim.h	/^#define WSP_VERT	/;"	d
WS_DEBUG_ALL	wsdebug.h	/^#define WS_DEBUG_ALL	/;"	d
WS_TRACE	wsdebug.h	/^#define WS_TRACE	/;"	d
WS_TRACE_COLONCMD	wsdebug.h	/^#define WS_TRACE_COLONCMD	/;"	d
WS_TRACE_VERBOSE	wsdebug.h	/^#define WS_TRACE_VERBOSE	/;"	d
WT_ENV	nbdebug.h	/^		WT_ENV = 1,		\/* look for env var if set *\/$/;"	e	enum:__anon72
WT_ENV	wsdebug.h	/^		WT_ENV = 1,		\/* look for env var if set *\/$/;"	e	enum:__anon104
WT_STOP	nbdebug.h	/^		WT_STOP			\/* look for ~\/.gvimstop if set *\/$/;"	e	enum:__anon72
WT_STOP	wsdebug.h	/^		WT_STOP			\/* look for ~\/.gvimstop if set *\/$/;"	e	enum:__anon104
WT_WAIT	nbdebug.h	/^		WT_WAIT,		\/* look for ~\/.gvimwait if set *\/$/;"	e	enum:__anon72
WT_WAIT	wsdebug.h	/^		WT_WAIT,		\/* look for ~\/.gvimwait if set *\/$/;"	e	enum:__anon104
WV_ARAB	option.h	/^    , WV_ARAB$/;"	e	enum:__anon74
WV_COUNT	option.h	/^    , WV_COUNT	    \/* must be the last one *\/$/;"	e	enum:__anon74
WV_CUC	option.h	/^    , WV_CUC$/;"	e	enum:__anon74
WV_CUL	option.h	/^    , WV_CUL$/;"	e	enum:__anon74
WV_DIFF	option.h	/^    , WV_DIFF$/;"	e	enum:__anon74
WV_FDC	option.h	/^    , WV_FDC$/;"	e	enum:__anon74
WV_FDE	option.h	/^    , WV_FDE$/;"	e	enum:__anon74
WV_FDI	option.h	/^    , WV_FDI$/;"	e	enum:__anon74
WV_FDL	option.h	/^    , WV_FDL$/;"	e	enum:__anon74
WV_FDM	option.h	/^    , WV_FDM$/;"	e	enum:__anon74
WV_FDN	option.h	/^    , WV_FDN$/;"	e	enum:__anon74
WV_FDT	option.h	/^    , WV_FDT$/;"	e	enum:__anon74
WV_FEN	option.h	/^    , WV_FEN$/;"	e	enum:__anon74
WV_FML	option.h	/^    , WV_FML$/;"	e	enum:__anon74
WV_FMR	option.h	/^    , WV_FMR$/;"	e	enum:__anon74
WV_LBR	option.h	/^    , WV_LBR$/;"	e	enum:__anon74
WV_LIST	option.h	/^    WV_LIST = 0$/;"	e	enum:__anon74
WV_NU	option.h	/^    , WV_NU$/;"	e	enum:__anon74
WV_NUW	option.h	/^    , WV_NUW$/;"	e	enum:__anon74
WV_PVW	option.h	/^    , WV_PVW$/;"	e	enum:__anon74
WV_RL	option.h	/^    , WV_RL$/;"	e	enum:__anon74
WV_RLC	option.h	/^    , WV_RLC$/;"	e	enum:__anon74
WV_SCBIND	option.h	/^    , WV_SCBIND$/;"	e	enum:__anon74
WV_SCROLL	option.h	/^    , WV_SCROLL$/;"	e	enum:__anon74
WV_SPELL	option.h	/^    , WV_SPELL$/;"	e	enum:__anon74
WV_STL	option.h	/^    , WV_STL$/;"	e	enum:__anon74
WV_WFH	option.h	/^    , WV_WFH$/;"	e	enum:__anon74
WV_WFW	option.h	/^    , WV_WFW$/;"	e	enum:__anon74
WV_WRAP	option.h	/^    , WV_WRAP$/;"	e	enum:__anon74
WW_ALL	option.h	/^#define WW_ALL	/;"	d
W_CONV	farsi.h	/^#define W_CONV /;"	d
W_ENDCOL	vim.h	/^# define W_ENDCOL(/;"	d
W_NEXT	globals.h	/^# define W_NEXT(/;"	d
W_OK	vim.h	/^# define W_OK /;"	d
W_R_L	farsi.h	/^#define W_R_L /;"	d
W_STATUS_HEIGHT	vim.h	/^# define W_STATUS_HEIGHT(/;"	d
W_VSEP_WIDTH	vim.h	/^# define W_VSEP_WIDTH(/;"	d
W_WIDTH	vim.h	/^# define W_WIDTH(/;"	d
W_WINCOL	vim.h	/^# define W_WINCOL(/;"	d
W_WINROW	vim.h	/^# define W_WINROW(/;"	d
WaitForChar	os_unix.c	/^WaitForChar(msec)$/;"	f	file:
WaitForPend	if_xcmdsrv.c	/^WaitForPend(p)$/;"	f	file:
WaitForReply	if_xcmdsrv.c	/^WaitForReply(p)$/;"	f	file:
WantQueryMouse	globals.h	/^EXTERN int	WantQueryMouse INIT(= FALSE);$/;"	v
WcsLen	gui_at_fs.c	/^WcsLen(p)$/;"	f	file:
Widget	proto.h	/^#  define Widget /;"	d
WinListAsSeq	if_python.c	/^static PySequenceMethods WinListAsSeq = {$/;"	v	file:
WinListItem	if_python.c	/^WinListItem(PyObject *self, PyInt n)$/;"	f	file:
WinListLength	if_python.c	/^WinListLength(PyObject *self)$/;"	f	file:
WinListObject	if_python.c	/^WinListObject;$/;"	t	typeref:struct:__anon34	file:
WinListType	if_python.c	/^static PyTypeObject WinListType = {$/;"	v	file:
WindowDestructor	if_python.c	/^WindowDestructor(PyObject *self)$/;"	f	file:
WindowGetattr	if_python.c	/^WindowGetattr(PyObject *self, char *name)$/;"	f	file:
WindowMethods	if_python.c	/^static struct PyMethodDef WindowMethods[] = {$/;"	v	typeref:struct:PyMethodDef	file:
WindowNew	if_python.c	/^WindowNew(win_T *win)$/;"	f	file:
WindowObject	if_python.c	/^WindowObject;$/;"	t	typeref:struct:__anon30	file:
WindowRepr	if_python.c	/^WindowRepr(PyObject *self)$/;"	f	file:
WindowSetattr	if_python.c	/^WindowSetattr(PyObject *self, char *name, PyObject *val)$/;"	f	file:
WindowType	if_python.c	/^static PyTypeObject WindowType = {$/;"	v	file:
WindowType_Check	if_python.c	/^#define WindowType_Check(/;"	d	file:
WindowValid	if_xcmdsrv.c	/^WindowValid(dpy, w)$/;"	f	file:
WtWait	nbdebug.h	/^} WtWait;$/;"	t	typeref:enum:__anon72
WtWait	wsdebug.h	/^} WtWait;$/;"	t	typeref:enum:__anon104
XD_GUI	os_unix.c	/^#define XD_GUI	/;"	d	file:
XD_HERE	os_unix.c	/^#define XD_HERE	/;"	d	file:
XD_NONE	os_unix.c	/^#define XD_NONE	/;"	d	file:
XD_XTERM	os_unix.c	/^#define XD_XTERM /;"	d	file:
XDrawImageString16	gui_x11.c	/^#define XDrawImageString16(/;"	d	file:
XDrawString	gui_x11.c	/^#define XDrawString(/;"	d	file:
XDrawString16	gui_x11.c	/^#define XDrawString16(/;"	d	file:
XE	farsi.h	/^#define XE	/;"	d
XFILE	ex_cmds.h	/^#define XFILE	/;"	d
XIMPreeditDisable	mbyte.c	/^#  define XIMPreeditDisable	/;"	d	file:
XIMPreeditEnable	mbyte.c	/^#  define XIMPreeditEnable	/;"	d	file:
XIMPreeditUnKnown	mbyte.c	/^#  define XIMPreeditUnKnown	/;"	d	file:
XImage	proto.h	/^#  define XImage /;"	d
XNPreeditState	mbyte.c	/^#  define XNPreeditState	/;"	d	file:
XP_BS_NONE	structs.h	/^#define XP_BS_NONE	/;"	d
XP_BS_ONE	structs.h	/^#define XP_BS_ONE	/;"	d
XP_BS_THREE	structs.h	/^#define XP_BS_THREE	/;"	d
XT_LEN	term.c	/^#define XT_LEN /;"	d	file:
XT_TRACE_DELAY	os_unix.c	/^# define XT_TRACE_DELAY	/;"	d	file:
X_2_COL	gui.h	/^# define X_2_COL(/;"	d
X_DISPLAY	vim.h	/^#   define X_DISPLAY	/;"	d
X_DISPLAY	vim.h	/^#  define X_DISPLAY	/;"	d
XmBOTTOM	gui_xmebw.h	/^# define XmBOTTOM /;"	d
XmCLocation	gui_xmebw.h	/^# define XmCLocation	/;"	d
XmCShift	gui_xmebw.h	/^# define XmCShift	/;"	d
XmEnhancedButtonClassPart	gui_xmebwp.h	/^} XmEnhancedButtonClassPart;$/;"	t	typeref:struct:_XmEnhancedButtonClassPart
XmEnhancedButtonClassRec	gui_xmebwp.h	/^} XmEnhancedButtonClassRec;$/;"	t	typeref:struct:__anon67
XmEnhancedButtonPart	gui_xmebwp.h	/^} XmEnhancedButtonPart;$/;"	t	typeref:struct:_XmEnhancedButtonPart
XmEnhancedButtonRec	gui_xmebwp.h	/^} XmEnhancedButtonRec;$/;"	t	typeref:struct:_XmEnhancedButtonRec
XmEnhancedButtonWidget	gui_xmebw.h	/^typedef struct _XmEnhancedButtonRec *XmEnhancedButtonWidget;$/;"	t	typeref:struct:_XmEnhancedButtonRec
XmEnhancedButtonWidgetClass	gui_xmebw.h	/^typedef struct _XmEnhancedButtonClassRec *XmEnhancedButtonWidgetClass;$/;"	t	typeref:struct:_XmEnhancedButtonClassRec
XmFOCUS_IGNORE	gui_xmebw.c	/^# define XmFOCUS_IGNORE /;"	d	file:
XmIsEnhancedButton	gui_xmebw.h	/^#define XmIsEnhancedButton(/;"	d
XmLEFT	gui_xmebw.h	/^# define XmLEFT	/;"	d
XmNlabelLocation	gui_xmebw.h	/^# define XmNlabelLocation	/;"	d
XmNpixmapData	gui_xmebw.h	/^# define XmNpixmapData	/;"	d
XmNpixmapFile	gui_xmebw.h	/^# define XmNpixmapFile	/;"	d
XmNshift	gui_xmebw.h	/^# define XmNshift	/;"	d
XmRIGHT	gui_xmebw.h	/^# define XmRIGHT /;"	d
XmTOP	gui_xmebw.h	/^# define XmTOP	/;"	d
XmeClearBorder	gui_xmebw.c	/^# define XmeClearBorder	/;"	d	file:
XmeDrawHighlight	gui_xmebw.c	/^# define XmeDrawHighlight(/;"	d	file:
XmeDrawShadows	gui_xmebw.c	/^# define XmeDrawShadows	/;"	d	file:
XtCBoldFont	gui_x11.c	/^#define XtCBoldFont	/;"	d	file:
XtCBoldItalicFont	gui_x11.c	/^#define XtCBoldItalicFont	/;"	d	file:
XtCBottomShadowPixel	gui_at_sb.h	/^#define XtCBottomShadowPixel	/;"	d
XtCItalicFont	gui_x11.c	/^#define XtCItalicFont	/;"	d	file:
XtCLimitThumb	gui_at_sb.h	/^#define XtCLimitThumb	/;"	d
XtCMaxOfThumb	gui_at_sb.h	/^#define XtCMaxOfThumb	/;"	d
XtCMenuBackground	gui_x11.c	/^#define XtCMenuBackground	/;"	d	file:
XtCMenuFont	gui_x11.c	/^#define XtCMenuFont	/;"	d	file:
XtCMenuFontSet	gui_x11.c	/^#define XtCMenuFontSet	/;"	d	file:
XtCMenuForeground	gui_x11.c	/^#define XtCMenuForeground	/;"	d	file:
XtCMenuHeight	gui_x11.c	/^#define XtCMenuHeight	/;"	d	file:
XtCMinimumThumb	gui_at_sb.h	/^#define XtCMinimumThumb	/;"	d
XtCScrollBackground	gui_x11.c	/^#define XtCScrollBackground	/;"	d	file:
XtCScrollForeground	gui_x11.c	/^#define XtCScrollForeground	/;"	d	file:
XtCScrollbarWidth	gui_x11.c	/^#define XtCScrollbarWidth	/;"	d	file:
XtCShadowWidth	gui_at_sb.h	/^#define XtCShadowWidth	/;"	d
XtCShown	gui_at_sb.h	/^#define XtCShown	/;"	d
XtCTooltipBackground	gui_x11.c	/^#define XtCTooltipBackground	/;"	d	file:
XtCTooltipFont	gui_x11.c	/^#define XtCTooltipFont	/;"	d	file:
XtCTooltipForeground	gui_x11.c	/^#define XtCTooltipForeground	/;"	d	file:
XtCTopOfThumb	gui_at_sb.h	/^#define XtCTopOfThumb	/;"	d
XtCTopShadowPixel	gui_at_sb.h	/^#define XtCTopShadowPixel	/;"	d
XtNboldFont	gui_x11.c	/^#define XtNboldFont	/;"	d	file:
XtNboldItalicFont	gui_x11.c	/^#define XtNboldItalicFont	/;"	d	file:
XtNbottomShadowPixel	gui_at_sb.h	/^#define XtNbottomShadowPixel	/;"	d
XtNitalicFont	gui_x11.c	/^#define XtNitalicFont	/;"	d	file:
XtNlimitThumb	gui_at_sb.h	/^#define XtNlimitThumb	/;"	d
XtNmaxOfThumb	gui_at_sb.h	/^#define XtNmaxOfThumb	/;"	d
XtNmenuBackground	gui_x11.c	/^#define XtNmenuBackground	/;"	d	file:
XtNmenuFont	gui_x11.c	/^#define XtNmenuFont	/;"	d	file:
XtNmenuFontSet	gui_x11.c	/^#define XtNmenuFontSet	/;"	d	file:
XtNmenuForeground	gui_x11.c	/^#define XtNmenuForeground	/;"	d	file:
XtNmenuHeight	gui_x11.c	/^#define XtNmenuHeight	/;"	d	file:
XtNminimumThumb	gui_at_sb.h	/^#define XtNminimumThumb	/;"	d
XtNscrollBackground	gui_x11.c	/^#define XtNscrollBackground	/;"	d	file:
XtNscrollForeground	gui_x11.c	/^#define XtNscrollForeground	/;"	d	file:
XtNscrollbarWidth	gui_x11.c	/^#define XtNscrollbarWidth	/;"	d	file:
XtNshadowWidth	gui_at_sb.h	/^#define XtNshadowWidth	/;"	d
XtNtooltipBackground	gui_x11.c	/^#define XtNtooltipBackground	/;"	d	file:
XtNtooltipFont	gui_x11.c	/^#define XtNtooltipFont	/;"	d	file:
XtNtooltipForeground	gui_x11.c	/^#define XtNtooltipForeground	/;"	d	file:
XtNtopOfThumb	gui_at_sb.h	/^#define XtNtopOfThumb	/;"	d
XtNtopShadowPixel	gui_at_sb.h	/^#define XtNtopShadowPixel	/;"	d
YE	farsi.h	/^#define YE	/;"	d
YEE	farsi.h	/^#define YEE	/;"	d
YEE_	farsi.h	/^#define YEE_	/;"	d
YE_	farsi.h	/^#define YE_	/;"	d
Y_2_ROW	gui.h	/^# define Y_2_ROW(/;"	d
ZAD	farsi.h	/^#define ZAD	/;"	d
ZAL	farsi.h	/^#define ZAL	/;"	d
ZCLOSE	regexp.c	/^# define ZCLOSE	/;"	d	file:
ZDECODE	macros.h	/^# define ZDECODE(/;"	d
ZE	farsi.h	/^#define ZE	/;"	d
ZENCODE	macros.h	/^# define ZENCODE(/;"	d
ZEROR	ex_cmds.h	/^#define ZEROR	/;"	d
ZERO_BL	memline.c	/^typedef struct block0		ZERO_BL;    \/* contents of the first block *\/$/;"	t	typeref:struct:block0	file:
ZOPEN	regexp.c	/^# define ZOPEN	/;"	d	file:
ZREF	regexp.c	/^# define ZREF	/;"	d	file:
_	gui_gtk.c	/^#  undef _$/;"	d	file:
_	gui_gtk_x11.c	/^#  undef _$/;"	d	file:
_	if_ruby.c	/^#undef _$/;"	d	file:
_	vim.h	/^#  define _(/;"	d
_	vim.h	/^#  undef _$/;"	d
_	vim.h	/^# define _(/;"	d
_AYN	farsi.h	/^#define _AYN	/;"	d
_AYN_	farsi.h	/^#define _AYN_	/;"	d
_BE	farsi.h	/^#define _BE	/;"	d
_ButtonData	gui_gtk.c	/^typedef struct _ButtonData$/;"	s	file:
_CHE	farsi.h	/^#define _CHE	/;"	d
_CRT_NONSTDC_NO_DEPRECATE	vim.h	/^# define _CRT_NONSTDC_NO_DEPRECATE$/;"	d
_CRT_SECURE_NO_DEPRECATE	vim.h	/^# define _CRT_SECURE_NO_DEPRECATE$/;"	d
_CancelData	gui_gtk.c	/^typedef struct _CancelData$/;"	s	file:
_DEBUG	if_python.c	/^# undef _DEBUG$/;"	d	file:
_DEBUG	vim.h	/^#  undef _DEBUG$/;"	d
_DialogInfo	gui_gtk.c	/^typedef struct _DialogInfo$/;"	s	file:
_FE	farsi.h	/^#define _FE	/;"	d
_GAF	farsi.h	/^#define _GAF	/;"	d
_GHAF	farsi.h	/^#define _GHAF	/;"	d
_GHAYN	farsi.h	/^#define _GHAYN	/;"	d
_GHAYN_	farsi.h	/^#define _GHAYN_	/;"	d
_GtkForm	gui_gtk_f.h	/^struct _GtkForm$/;"	s
_GtkFormChild	gui_gtk_f.c	/^struct _GtkFormChild$/;"	s	file:
_GtkFormClass	gui_gtk_f.h	/^struct _GtkFormClass$/;"	s
_HE	farsi.h	/^#define _HE	/;"	d
_HE_	farsi.h	/^#define _HE_	/;"	d
_HE_J	farsi.h	/^#define _HE_J	/;"	d
_IE	farsi.h	/^#define _IE	/;"	d
_IF_MZSCH_H_	if_mzsch.h	/^#define _IF_MZSCH_H_$/;"	d
_INTEGRATION_H	integration.h	/^#define _INTEGRATION_H$/;"	d
_IO_PTEM_H	os_unixx.h	/^#  define _IO_PTEM_H$/;"	d
_JIM	farsi.h	/^#define _JIM	/;"	d
_KAF	farsi.h	/^#define _KAF	/;"	d
_KAF_H	farsi.h	/^#define _KAF_H	/;"	d
_LAM	farsi.h	/^#define _LAM	/;"	d
_MIM	farsi.h	/^#define _MIM	/;"	d
_NOON	farsi.h	/^#define _NOON	/;"	d
_NO_PROTO	os_unix.h	/^# define _NO_PROTO$/;"	d
_PE	farsi.h	/^#define _PE	/;"	d
_POSIX_THREADS	if_python.c	/^# undef _POSIX_THREADS$/;"	d	file:
_PROTO_H	proto.h	/^# define _PROTO_H$/;"	d
_PyObject_New	if_python.c	/^# define _PyObject_New /;"	d	file:
_Py_NoneStruct	if_python.c	/^# define _Py_NoneStruct /;"	d	file:
_REGEXP_H	regexp.h	/^#define _REGEXP_H$/;"	d
_SAD	farsi.h	/^#define _SAD	/;"	d
_SE	farsi.h	/^#define _SE	/;"	d
_SHIN	farsi.h	/^#define _SHIN	/;"	d
_SIN	farsi.h	/^#define _SIN	/;"	d
_ScrollbarClassRec	gui_at_sb.h	/^typedef struct _ScrollbarClassRec {$/;"	s
_ScrollbarRec	gui_at_sb.h	/^typedef struct _ScrollbarRec {$/;"	s
_Scrollbar_h	gui_at_sb.h	/^#define _Scrollbar_h$/;"	d
_SharedFindReplace	gui_gtk.c	/^typedef struct _SharedFindReplace$/;"	s	file:
_SharedFindReplace	gui_motif.c	/^typedef struct _SharedFindReplace$/;"	s	file:
_SharedFontSelData	gui_xmdlg.c	/^typedef struct _SharedFontSelData$/;"	s	file:
_TA	farsi.h	/^#define _TA	/;"	d
_TANDEM_SOURCE	vim.h	/^# define _TANDEM_SOURCE$/;"	d
_TE	farsi.h	/^#define _TE	/;"	d
_XE	farsi.h	/^#define _XE	/;"	d
_Xaw3dDrawShadows	gui_at_sb.c	/^_Xaw3dDrawShadows(gw, event, region, out)$/;"	f	file:
_XmEnhancedButtonClassPart	gui_xmebwp.h	/^typedef struct _XmEnhancedButtonClassPart$/;"	s
_XmEnhancedButtonPart	gui_xmebwp.h	/^typedef struct _XmEnhancedButtonPart$/;"	s
_XmEnhancedButtonRec	gui_xmebwp.h	/^typedef struct _XmEnhancedButtonRec$/;"	s
_YE	farsi.h	/^#define _YE	/;"	d
_YEE	farsi.h	/^#define _YEE	/;"	d
_ZA	farsi.h	/^#define _ZA	/;"	d
_ZAD	farsi.h	/^#define _ZAD	/;"	d
__ARGS	os_unix.h	/^#  define __ARGS(/;"	d
__ARGS	os_unix.h	/^# undef __ARGS$/;"	d
__ARGS	regexp.c	/^# define __ARGS(/;"	d	file:
__ARGS	regexp.c	/^# undef __ARGS$/;"	d	file:
__ARGS	regexp.c	/^typedef void (*(*fptr_T) __ARGS((int *, int)))();$/;"	t	file:
__ARGS	vim.h	/^#  define __ARGS(/;"	d
__ARGS	vim.h	/^# define __ARGS(/;"	d
__CYGWIN32__	if_mzsch.h	/^# define __CYGWIN32__$/;"	d
__CYGWIN32__	if_mzsch.h	/^# undef __CYGWIN32__$/;"	d
__GTK_FORM_H__	gui_gtk_f.h	/^#define __GTK_FORM_H__$/;"	d
__OPENTRANSPORTPROTOCOL__	if_ruby.c	/^# define __OPENTRANSPORTPROTOCOL__$/;"	d	file:
__OPENTRANSPORTPROVIDERS__	if_ruby.c	/^# define __OPENTRANSPORTPROVIDERS__$/;"	d	file:
__OPENTRANSPORT__	if_ruby.c	/^# define __OPENTRANSPORT__$/;"	d	file:
__PARMS	vim.h	/^# define __PARMS(/;"	d
__SUSV3	os_unixx.h	/^#  define __SUSV3$/;"	d
__if_sniff_h__	if_sniff.h	/^#define __if_sniff_h__$/;"	d
__w64	vim.h	/^#  define __w64 /;"	d
_addfmt	termlib.c	/^_addfmt(buf, fmt, val)$/;"	f	file:
_apply_thunk_catch_exceptions	if_mzsch.c	/^_apply_thunk_catch_exceptions(Scheme_Object *f, Scheme_Object **exn)$/;"	f	file:
_bauds	termlib.c	/^long _bauds[16]={$/;"	v
_cdecl	misc1.c	/^#   define _cdecl /;"	d	file:
_cdecl	misc1.c	/^#  define _cdecl	/;"	d	file:
_find	termlib.c	/^_find(s, set)$/;"	f	file:
_match	termlib.c	/^_match(s1, s2)		\/* returns length of text common to s1 and s2 *\/$/;"	f	file:
_memory_h	if_perlsfio.c	/^#define _memory_h	/;"	d	file:
_stati64	vim.h	/^#  define _stati64 /;"	d
_xsmp_xtinputid	gui_x11.c	/^static XtInputId _xsmp_xtinputid;$/;"	v	file:
a	if_python.c	/^struct PyMethodDef { Py_ssize_t a; };$/;"	m	struct:PyMethodDef	file:
a	regexp.c	/^    int a, b, c;$/;"	m	struct:__anon52	file:
a_AIN	arabic.h	/^#define a_AIN	/;"	d
a_ALEF	arabic.h	/^#define a_ALEF	/;"	d
a_ALEF_HAMZA_ABOVE	arabic.h	/^#define a_ALEF_HAMZA_ABOVE	/;"	d
a_ALEF_HAMZA_BELOW	arabic.h	/^#define a_ALEF_HAMZA_BELOW	/;"	d
a_ALEF_MADDA	arabic.h	/^#define a_ALEF_MADDA	/;"	d
a_ALEF_MAKSURA	arabic.h	/^#define a_ALEF_MAKSURA	/;"	d
a_BEH	arabic.h	/^#define a_BEH	/;"	d
a_BYTE_ORDER_MARK	arabic.h	/^#define a_BYTE_ORDER_MARK	/;"	d
a_COMMA	arabic.h	/^#define a_COMMA	/;"	d
a_DAD	arabic.h	/^#define a_DAD	/;"	d
a_DAL	arabic.h	/^#define a_DAL	/;"	d
a_DAMMA	arabic.h	/^#define a_DAMMA	/;"	d
a_DAMMATAN	arabic.h	/^#define a_DAMMATAN	/;"	d
a_DECIMAL	arabic.h	/^#define a_DECIMAL	/;"	d
a_EIGHT	arabic.h	/^#define a_EIGHT	/;"	d
a_FATHA	arabic.h	/^#define a_FATHA	/;"	d
a_FATHATAN	arabic.h	/^#define a_FATHATAN	/;"	d
a_FEH	arabic.h	/^#define a_FEH	/;"	d
a_FIVE	arabic.h	/^#define a_FIVE	/;"	d
a_FOUR	arabic.h	/^#define a_FOUR	/;"	d
a_GHAIN	arabic.h	/^#define a_GHAIN	/;"	d
a_HAH	arabic.h	/^#define a_HAH	/;"	d
a_HAMZA	arabic.h	/^#define a_HAMZA	/;"	d
a_HAMZA_ABOVE	arabic.h	/^#define a_HAMZA_ABOVE	/;"	d
a_HAMZA_BELOW	arabic.h	/^#define a_HAMZA_BELOW	/;"	d
a_HEH	arabic.h	/^#define a_HEH	/;"	d
a_JEEM	arabic.h	/^#define a_JEEM	/;"	d
a_KAF	arabic.h	/^#define a_KAF	/;"	d
a_KASRA	arabic.h	/^#define a_KASRA	/;"	d
a_KASRATAN	arabic.h	/^#define a_KASRATAN	/;"	d
a_KHAH	arabic.h	/^#define a_KHAH	/;"	d
a_LAM	arabic.h	/^#define a_LAM	/;"	d
a_MADDA_ABOVE	arabic.h	/^#define a_MADDA_ABOVE	/;"	d
a_MEEM	arabic.h	/^#define a_MEEM	/;"	d
a_MINI_ALEF	arabic.h	/^#define a_MINI_ALEF	/;"	d
a_NINE	arabic.h	/^#define a_NINE	/;"	d
a_NOON	arabic.h	/^#define a_NOON	/;"	d
a_ONE	arabic.h	/^#define a_ONE	/;"	d
a_PERCENT	arabic.h	/^#define a_PERCENT	/;"	d
a_QAF	arabic.h	/^#define a_QAF	/;"	d
a_QUESTION	arabic.h	/^#define a_QUESTION	/;"	d
a_REH	arabic.h	/^#define a_REH	/;"	d
a_SAD	arabic.h	/^#define a_SAD	/;"	d
a_SEEN	arabic.h	/^#define a_SEEN	/;"	d
a_SEMICOLON	arabic.h	/^#define a_SEMICOLON	/;"	d
a_SEVEN	arabic.h	/^#define a_SEVEN	/;"	d
a_SHADDA	arabic.h	/^#define a_SHADDA	/;"	d
a_SHEEN	arabic.h	/^#define a_SHEEN	/;"	d
a_SIX	arabic.h	/^#define a_SIX	/;"	d
a_STAR	arabic.h	/^#define a_STAR	/;"	d
a_SUKUN	arabic.h	/^#define a_SUKUN	/;"	d
a_TAH	arabic.h	/^#define a_TAH	/;"	d
a_TATWEEL	arabic.h	/^#define a_TATWEEL	/;"	d
a_TEH	arabic.h	/^#define a_TEH	/;"	d
a_TEH_MARBUTA	arabic.h	/^#define a_TEH_MARBUTA	/;"	d
a_THAL	arabic.h	/^#define a_THAL	/;"	d
a_THEH	arabic.h	/^#define a_THEH	/;"	d
a_THOUSANDS	arabic.h	/^#define a_THOUSANDS	/;"	d
a_THREE	arabic.h	/^#define a_THREE	/;"	d
a_TWO	arabic.h	/^#define a_TWO	/;"	d
a_WAW	arabic.h	/^#define a_WAW	/;"	d
a_WAW_HAMZA	arabic.h	/^#define a_WAW_HAMZA	/;"	d
a_YEH	arabic.h	/^#define a_YEH	/;"	d
a_YEH_HAMZA	arabic.h	/^#define a_YEH_HAMZA	/;"	d
a_ZAH	arabic.h	/^#define a_ZAH	/;"	d
a_ZAIN	arabic.h	/^#define a_ZAIN	/;"	d
a_ZERO	arabic.h	/^#define a_ZERO	/;"	d
a_cur_menu	gui_athena.c	/^static vimmenu_T *a_cur_menu = NULL;$/;"	v	file:
a_f_AIN	arabic.h	/^#define a_f_AIN	/;"	d
a_f_ALEF	arabic.h	/^#define a_f_ALEF	/;"	d
a_f_ALEF_HAMZA_ABOVE	arabic.h	/^#define a_f_ALEF_HAMZA_ABOVE	/;"	d
a_f_ALEF_HAMZA_BELOW	arabic.h	/^#define a_f_ALEF_HAMZA_BELOW	/;"	d
a_f_ALEF_MADDA	arabic.h	/^#define a_f_ALEF_MADDA	/;"	d
a_f_ALEF_MAKSURA	arabic.h	/^#define a_f_ALEF_MAKSURA	/;"	d
a_f_BEH	arabic.h	/^#define a_f_BEH	/;"	d
a_f_DAD	arabic.h	/^#define a_f_DAD	/;"	d
a_f_DAL	arabic.h	/^#define a_f_DAL	/;"	d
a_f_FEH	arabic.h	/^#define a_f_FEH	/;"	d
a_f_GHAIN	arabic.h	/^#define a_f_GHAIN	/;"	d
a_f_HAH	arabic.h	/^#define a_f_HAH	/;"	d
a_f_HEH	arabic.h	/^#define a_f_HEH	/;"	d
a_f_JEEM	arabic.h	/^#define a_f_JEEM	/;"	d
a_f_KAF	arabic.h	/^#define a_f_KAF	/;"	d
a_f_KHAH	arabic.h	/^#define a_f_KHAH	/;"	d
a_f_LAM	arabic.h	/^#define a_f_LAM	/;"	d
a_f_LAM_ALEF	arabic.h	/^#define a_f_LAM_ALEF	/;"	d
a_f_LAM_ALEF_HAMZA_ABOVE	arabic.h	/^#define a_f_LAM_ALEF_HAMZA_ABOVE	/;"	d
a_f_LAM_ALEF_HAMZA_BELOW	arabic.h	/^#define a_f_LAM_ALEF_HAMZA_BELOW	/;"	d
a_f_LAM_ALEF_MADDA_ABOVE	arabic.h	/^#define a_f_LAM_ALEF_MADDA_ABOVE	/;"	d
a_f_MEEM	arabic.h	/^#define a_f_MEEM	/;"	d
a_f_NOON	arabic.h	/^#define a_f_NOON	/;"	d
a_f_QAF	arabic.h	/^#define a_f_QAF	/;"	d
a_f_REH	arabic.h	/^#define a_f_REH	/;"	d
a_f_SAD	arabic.h	/^#define a_f_SAD	/;"	d
a_f_SEEN	arabic.h	/^#define a_f_SEEN	/;"	d
a_f_SHEEN	arabic.h	/^#define a_f_SHEEN	/;"	d
a_f_TAH	arabic.h	/^#define a_f_TAH	/;"	d
a_f_TEH	arabic.h	/^#define a_f_TEH	/;"	d
a_f_TEH_MARBUTA	arabic.h	/^#define a_f_TEH_MARBUTA	/;"	d
a_f_THAL	arabic.h	/^#define a_f_THAL	/;"	d
a_f_THEH	arabic.h	/^#define a_f_THEH	/;"	d
a_f_WAW	arabic.h	/^#define a_f_WAW	/;"	d
a_f_WAW_HAMZA	arabic.h	/^#define a_f_WAW_HAMZA	/;"	d
a_f_YEH	arabic.h	/^#define a_f_YEH	/;"	d
a_f_YEH_HAMZA	arabic.h	/^#define a_f_YEH_HAMZA	/;"	d
a_f_ZAH	arabic.h	/^#define a_f_ZAH	/;"	d
a_f_ZAIN	arabic.h	/^#define a_f_ZAIN	/;"	d
a_i_AIN	arabic.h	/^#define a_i_AIN	/;"	d
a_i_BEH	arabic.h	/^#define a_i_BEH	/;"	d
a_i_DAD	arabic.h	/^#define a_i_DAD	/;"	d
a_i_FEH	arabic.h	/^#define a_i_FEH	/;"	d
a_i_GHAIN	arabic.h	/^#define a_i_GHAIN	/;"	d
a_i_HAH	arabic.h	/^#define a_i_HAH	/;"	d
a_i_HEH	arabic.h	/^#define a_i_HEH	/;"	d
a_i_JEEM	arabic.h	/^#define a_i_JEEM	/;"	d
a_i_KAF	arabic.h	/^#define a_i_KAF	/;"	d
a_i_KHAH	arabic.h	/^#define a_i_KHAH	/;"	d
a_i_LAM	arabic.h	/^#define a_i_LAM	/;"	d
a_i_MEEM	arabic.h	/^#define a_i_MEEM	/;"	d
a_i_NOON	arabic.h	/^#define a_i_NOON	/;"	d
a_i_QAF	arabic.h	/^#define a_i_QAF	/;"	d
a_i_SAD	arabic.h	/^#define a_i_SAD	/;"	d
a_i_SEEN	arabic.h	/^#define a_i_SEEN	/;"	d
a_i_SHEEN	arabic.h	/^#define a_i_SHEEN	/;"	d
a_i_TAH	arabic.h	/^#define a_i_TAH	/;"	d
a_i_TEH	arabic.h	/^#define a_i_TEH	/;"	d
a_i_THEH	arabic.h	/^#define a_i_THEH	/;"	d
a_i_YEH	arabic.h	/^#define a_i_YEH	/;"	d
a_i_YEH_HAMZA	arabic.h	/^#define a_i_YEH_HAMZA	/;"	d
a_i_ZAH	arabic.h	/^#define a_i_ZAH	/;"	d
a_m_AIN	arabic.h	/^#define a_m_AIN	/;"	d
a_m_BEH	arabic.h	/^#define a_m_BEH	/;"	d
a_m_DAD	arabic.h	/^#define a_m_DAD	/;"	d
a_m_DAMMA	arabic.h	/^#define a_m_DAMMA	/;"	d
a_m_FATHA	arabic.h	/^#define a_m_FATHA	/;"	d
a_m_FEH	arabic.h	/^#define a_m_FEH	/;"	d
a_m_GHAIN	arabic.h	/^#define a_m_GHAIN	/;"	d
a_m_HAH	arabic.h	/^#define a_m_HAH	/;"	d
a_m_HEH	arabic.h	/^#define a_m_HEH	/;"	d
a_m_JEEM	arabic.h	/^#define a_m_JEEM	/;"	d
a_m_KAF	arabic.h	/^#define a_m_KAF	/;"	d
a_m_KASRA	arabic.h	/^#define a_m_KASRA	/;"	d
a_m_KHAH	arabic.h	/^#define a_m_KHAH	/;"	d
a_m_LAM	arabic.h	/^#define a_m_LAM	/;"	d
a_m_MEEM	arabic.h	/^#define a_m_MEEM	/;"	d
a_m_NOON	arabic.h	/^#define a_m_NOON	/;"	d
a_m_QAF	arabic.h	/^#define a_m_QAF	/;"	d
a_m_SAD	arabic.h	/^#define a_m_SAD	/;"	d
a_m_SEEN	arabic.h	/^#define a_m_SEEN	/;"	d
a_m_SHADDA	arabic.h	/^#define a_m_SHADDA	/;"	d
a_m_SHEEN	arabic.h	/^#define a_m_SHEEN	/;"	d
a_m_SUKUN	arabic.h	/^#define a_m_SUKUN	/;"	d
a_m_TAH	arabic.h	/^#define a_m_TAH	/;"	d
a_m_TATWEEL_FATHATAN	arabic.h	/^#define a_m_TATWEEL_FATHATAN	/;"	d
a_m_TEH	arabic.h	/^#define a_m_TEH	/;"	d
a_m_THEH	arabic.h	/^#define a_m_THEH	/;"	d
a_m_YEH	arabic.h	/^#define a_m_YEH	/;"	d
a_m_YEH_HAMZA	arabic.h	/^#define a_m_YEH_HAMZA	/;"	d
a_m_ZAH	arabic.h	/^#define a_m_ZAH	/;"	d
a_s_AIN	arabic.h	/^#define a_s_AIN	/;"	d
a_s_ALEF	arabic.h	/^#define a_s_ALEF	/;"	d
a_s_ALEF_HAMZA_ABOVE	arabic.h	/^#define a_s_ALEF_HAMZA_ABOVE	/;"	d
a_s_ALEF_HAMZA_BELOW	arabic.h	/^#define a_s_ALEF_HAMZA_BELOW	/;"	d
a_s_ALEF_MADDA	arabic.h	/^#define a_s_ALEF_MADDA	/;"	d
a_s_ALEF_MAKSURA	arabic.h	/^#define a_s_ALEF_MAKSURA	/;"	d
a_s_BEH	arabic.h	/^#define a_s_BEH	/;"	d
a_s_DAD	arabic.h	/^#define a_s_DAD	/;"	d
a_s_DAL	arabic.h	/^#define a_s_DAL	/;"	d
a_s_DAMMA	arabic.h	/^#define a_s_DAMMA	/;"	d
a_s_DAMMATAN	arabic.h	/^#define a_s_DAMMATAN	/;"	d
a_s_FATHA	arabic.h	/^#define a_s_FATHA	/;"	d
a_s_FATHATAN	arabic.h	/^#define a_s_FATHATAN	/;"	d
a_s_FEH	arabic.h	/^#define a_s_FEH	/;"	d
a_s_GHAIN	arabic.h	/^#define a_s_GHAIN	/;"	d
a_s_HAH	arabic.h	/^#define a_s_HAH	/;"	d
a_s_HAMZA	arabic.h	/^#define a_s_HAMZA	/;"	d
a_s_HEH	arabic.h	/^#define a_s_HEH	/;"	d
a_s_JEEM	arabic.h	/^#define a_s_JEEM	/;"	d
a_s_KAF	arabic.h	/^#define a_s_KAF	/;"	d
a_s_KASRA	arabic.h	/^#define a_s_KASRA	/;"	d
a_s_KASRATAN	arabic.h	/^#define a_s_KASRATAN	/;"	d
a_s_KHAH	arabic.h	/^#define a_s_KHAH	/;"	d
a_s_LAM	arabic.h	/^#define a_s_LAM	/;"	d
a_s_LAM_ALEF	arabic.h	/^#define a_s_LAM_ALEF	/;"	d
a_s_LAM_ALEF_HAMZA_ABOVE	arabic.h	/^#define a_s_LAM_ALEF_HAMZA_ABOVE	/;"	d
a_s_LAM_ALEF_HAMZA_BELOW	arabic.h	/^#define a_s_LAM_ALEF_HAMZA_BELOW	/;"	d
a_s_LAM_ALEF_MADDA_ABOVE	arabic.h	/^#define a_s_LAM_ALEF_MADDA_ABOVE	/;"	d
a_s_MEEM	arabic.h	/^#define a_s_MEEM	/;"	d
a_s_NOON	arabic.h	/^#define a_s_NOON	/;"	d
a_s_QAF	arabic.h	/^#define a_s_QAF	/;"	d
a_s_REH	arabic.h	/^#define a_s_REH	/;"	d
a_s_SAD	arabic.h	/^#define a_s_SAD	/;"	d
a_s_SEEN	arabic.h	/^#define a_s_SEEN	/;"	d
a_s_SHADDA	arabic.h	/^#define a_s_SHADDA	/;"	d
a_s_SHEEN	arabic.h	/^#define a_s_SHEEN	/;"	d
a_s_SUKUN	arabic.h	/^#define a_s_SUKUN	/;"	d
a_s_TAH	arabic.h	/^#define a_s_TAH	/;"	d
a_s_TEH	arabic.h	/^#define a_s_TEH	/;"	d
a_s_TEH_MARBUTA	arabic.h	/^#define a_s_TEH_MARBUTA	/;"	d
a_s_THAL	arabic.h	/^#define a_s_THAL	/;"	d
a_s_THEH	arabic.h	/^#define a_s_THEH	/;"	d
a_s_WAW	arabic.h	/^#define a_s_WAW	/;"	d
a_s_WAW_HAMZA	arabic.h	/^#define a_s_WAW_HAMZA	/;"	d
a_s_YEH	arabic.h	/^#define a_s_YEH	/;"	d
a_s_YEH_HAMZA	arabic.h	/^#define a_s_YEH_HAMZA	/;"	d
a_s_ZAH	arabic.h	/^#define a_s_ZAH	/;"	d
a_s_ZAIN	arabic.h	/^#define a_s_ZAIN	/;"	d
aborted_in_try	ex_eval.c	/^aborted_in_try()$/;"	f
aborting	ex_eval.c	/^aborting()$/;"	f
accel	workshop.c	/^    char	*accel;			\/* optional accelerator key *\/$/;"	m	struct:__anon62	file:
accel_group	gui.h	/^    GtkAccelGroup *accel_group;$/;"	m	struct:Gui
acl_cnt	os_unix.c	/^    int acl_cnt;$/;"	m	struct:vim_acl_solaris_T	file:
acl_entry	os_unix.c	/^    aclent_t *acl_entry;$/;"	m	struct:vim_acl_solaris_T	file:
aco_save_T	structs.h	/^} aco_save_T;$/;"	t	typeref:struct:__anon97
actext	structs.h	/^    char_u	*actext;	    \/* accelerator text (after TAB) *\/$/;"	m	struct:VimMenu
actions	gui_at_fs.c	/^static XtActionsRec actions[] =$/;"	v	file:
actions	gui_at_sb.c	/^static XtActionsRec actions[] =$/;"	v	file:
actionsList	gui_xmebw.c	/^static XtActionsRec actionsList[] =$/;"	v	file:
activate_dialog_mnemonics	gui_motif.c	/^activate_dialog_mnemonics(Widget dialog)$/;"	f	file:
active_apc_list	fileio.c	/^static AutoPatCmd *active_apc_list = NULL; \/* stack of active autocommands *\/$/;"	v	file:
addEventHandler	gui_beval.c	/^addEventHandler(GtkWidget *target, BalloonEval *beval)$/;"	f	file:
addEventHandler	gui_beval.c	/^addEventHandler(target, beval)$/;"	f	file:
addMenu	workshop.c	/^addMenu($/;"	f	file:
addUniqueMnemonic	workshop.c	/^addUniqueMnemonic($/;"	f	file:
add_b0_fenc	memline.c	/^add_b0_fenc(b0p, buf)$/;"	f	file:
add_banned	spell.c	/^add_banned(su, word)$/;"	f	file:
add_buff	getchar.c	/^add_buff(buf, s, slen)$/;"	f	file:
add_cancel_action	gui_xmdlg.c	/^add_cancel_action(Widget shell, XtCallbackProc close_callback, void *arg)$/;"	f	file:
add_char2buf	edit.c	/^add_char2buf(c, s)$/;"	f
add_char_buff	getchar.c	/^add_char_buff(buf, c)$/;"	f	file:
add_fromto	spell.c	/^add_fromto(spin, gap, from, to)$/;"	f	file:
add_keyword	syntax.c	/^add_keyword(name, id, flags, cont_in_list, next_list)$/;"	f	file:
add_long_to_buf	term.c	/^add_long_to_buf(val, dst)$/;"	f
add_map	getchar.c	/^add_map(map, mode)$/;"	f
add_menu_path	menu.c	/^add_menu_path(menu_path, menuarg, pri_tab, call_data$/;"	f	file:
add_mnemonic_grabs	gui_motif.c	/^add_mnemonic_grabs(Widget dialog, Widget w)$/;"	f	file:
add_msg_hist	message.c	/^add_msg_hist(s, len, attr)$/;"	f	file:
add_nr_var	eval.c	/^add_nr_var(dp, v, name, nr)$/;"	f	file:
add_num_buff	getchar.c	/^add_num_buff(buf, n)$/;"	f	file:
add_pathsep	misc1.c	/^add_pathsep(p)$/;"	f
add_pixmap_args	gui_motif.c	/^add_pixmap_args(menu, args, n)$/;"	f	file:
add_sound_suggest	spell.c	/^add_sound_suggest(su, goodword, score, lp)$/;"	f	file:
add_stock_icon	gui_gtk.c	/^add_stock_icon(GtkIconFactory	*factory,$/;"	f	file:
add_suggestion	spell.c	/^add_suggestion(su, gap, goodword, badlenarg, score, altscore, had_bonus,$/;"	f	file:
add_tabline_menu_item	gui_gtk_x11.c	/^add_tabline_menu_item(GtkWidget *menu, char_u *text, int resp)$/;"	f	file:
add_tag_field	tag.c	/^add_tag_field(dict, field_name, start, end)$/;"	f	file:
add_termcap_entry	term.c	/^add_termcap_entry(name, force)$/;"	f
add_termcode	term.c	/^add_termcode(name, string, flags)$/;"	f
add_to_history	ex_getln.c	/^add_to_history(histype, new_entry, in_map, sep)$/;"	f
add_to_input_buf	ui.c	/^add_to_input_buf(s, len)$/;"	f
add_to_input_buf_csi	ui.c	/^add_to_input_buf_csi(char_u *str, int len)$/;"	f
add_to_list	gui_xmdlg.c	/^add_to_list(char **buf, char *item, int *count)$/;"	f	file:
add_to_showcmd	normal.c	/^add_to_showcmd(c)$/;"	f
add_to_showcmd_c	normal.c	/^add_to_showcmd_c(c)$/;"	f
add_vim_exn	if_mzsch.c	/^add_vim_exn(Scheme_Env *env)$/;"	f	file:
addfile	misc1.c	/^addfile(gap, f, flags)$/;"	f
addr	quickfix.c	/^    char_u	    addr[FMT_PATTERNS]; \/* indices of used % patterns *\/$/;"	m	struct:efm_S	file:
addr_count	ex_cmds.h	/^    int		addr_count;	\/* the number of addresses given *\/$/;"	m	struct:exarg
addsigntype	netbeans.c	/^addsigntype($/;"	f	file:
addstar	ex_getln.c	/^addstar(fname, len, context)$/;"	f
adjust_clip_reg	ops.c	/^adjust_clip_reg(rp)$/;"	f
adjust_cursor	normal.c	/^adjust_cursor(oap)$/;"	f	file:
adjust_cursor_col	misc2.c	/^adjust_cursor_col()$/;"	f
adjust_cursor_eol	ops.c	/^adjust_cursor_eol()$/;"	f
adjust_for_sel	normal.c	/^adjust_for_sel(cap)$/;"	f	file:
adjust_sign_name	integration.c	/^adjust_sign_name(char *filename)$/;"	f
adjustment_value_changed	gui_gtk.c	/^adjustment_value_changed(GtkAdjustment *adjustment, gpointer data)$/;"	f	file:
ae_add	spell.c	/^    char_u	*ae_add;	\/* text to add to basic word (can be NULL) *\/$/;"	m	struct:affentry_S	file:
ae_attr	structs.h	/^    short	    ae_attr;		\/* HL_BOLD, etc. *\/$/;"	m	struct:attr_entry
ae_chop	spell.c	/^    char_u	*ae_chop;	\/* text to chop off basic word (can be NULL) *\/$/;"	m	struct:affentry_S	file:
ae_compforbid	spell.c	/^    char	ae_compforbid;	\/* COMPOUNDFORBIDFLAG found *\/$/;"	m	struct:affentry_S	file:
ae_comppermit	spell.c	/^    char	ae_comppermit;	\/* COMPOUNDPERMITFLAG found *\/$/;"	m	struct:affentry_S	file:
ae_cond	spell.c	/^    char_u	*ae_cond;	\/* condition (NULL for ".") *\/$/;"	m	struct:affentry_S	file:
ae_flags	spell.c	/^    char_u	*ae_flags;	\/* flags on the affix (can be NULL) *\/$/;"	m	struct:affentry_S	file:
ae_fname	structs.h	/^    char_u	*ae_fname;	\/* file name as specified *\/$/;"	m	struct:argentry
ae_fnum	structs.h	/^    int		ae_fnum;	\/* buffer number with expanded file name *\/$/;"	m	struct:argentry
ae_next	spell.c	/^    affentry_T	*ae_next;	\/* next affix with same name\/number *\/$/;"	m	struct:affentry_S	file:
ae_prog	spell.c	/^    regprog_T	*ae_prog;	\/* regexp program for ae_cond or NULL *\/$/;"	m	struct:affentry_S	file:
ae_u	structs.h	/^    } ae_u;$/;"	m	struct:attr_entry	typeref:union:attr_entry::__anon86
aentry_T	structs.h	/^} aentry_T;$/;"	t	typeref:struct:argentry
af_bad	spell.c	/^    unsigned	af_bad;		\/* BAD ID for banned word *\/$/;"	m	struct:afffile_S	file:
af_circumfix	spell.c	/^    unsigned	af_circumfix;	\/* CIRCUMFIX ID *\/$/;"	m	struct:afffile_S	file:
af_comp	spell.c	/^    hashtab_T	af_comp;	\/* hashtable for compound flags, compitem_T *\/$/;"	m	struct:afffile_S	file:
af_compforbid	spell.c	/^    unsigned	af_compforbid;	\/* COMPOUNDFORBIDFLAG ID *\/$/;"	m	struct:afffile_S	file:
af_comppermit	spell.c	/^    unsigned	af_comppermit;	\/* COMPOUNDPERMITFLAG ID *\/$/;"	m	struct:afffile_S	file:
af_comproot	spell.c	/^    unsigned	af_comproot;	\/* COMPOUNDROOT ID *\/$/;"	m	struct:afffile_S	file:
af_enc	spell.c	/^    char_u	*af_enc;	\/* "SET", normalized, alloc'ed string or NULL *\/$/;"	m	struct:afffile_S	file:
af_flagtype	spell.c	/^    int		af_flagtype;	\/* AFT_CHAR, AFT_LONG, AFT_NUM or AFT_CAPLONG *\/$/;"	m	struct:afffile_S	file:
af_keepcase	spell.c	/^    unsigned	af_keepcase;	\/* KEEPCASE ID for keep-case word *\/$/;"	m	struct:afffile_S	file:
af_needaffix	spell.c	/^    unsigned	af_needaffix;	\/* NEEDAFFIX ID *\/$/;"	m	struct:afffile_S	file:
af_needcomp	spell.c	/^    unsigned	af_needcomp;	\/* NEEDCOMPOUND ID *\/$/;"	m	struct:afffile_S	file:
af_nosuggest	spell.c	/^    unsigned	af_nosuggest;	\/* NOSUGGEST ID *\/$/;"	m	struct:afffile_S	file:
af_pfxpostpone	spell.c	/^    int		af_pfxpostpone;	\/* postpone prefixes without chop string and$/;"	m	struct:afffile_S	file:
af_pref	spell.c	/^    hashtab_T	af_pref;	\/* hashtable for prefixes, affheader_T *\/$/;"	m	struct:afffile_S	file:
af_rare	spell.c	/^    unsigned	af_rare;	\/* RARE ID for rare word *\/$/;"	m	struct:afffile_S	file:
af_suff	spell.c	/^    hashtab_T	af_suff;	\/* hashtable for suffixes, affheader_T *\/$/;"	m	struct:afffile_S	file:
aff_check_number	spell.c	/^aff_check_number(spinval, affval, name)$/;"	f	file:
aff_check_string	spell.c	/^aff_check_string(spinval, affval, name)$/;"	f	file:
aff_process_flags	spell.c	/^aff_process_flags(affile, entry)$/;"	f	file:
affentry_S	spell.c	/^struct affentry_S$/;"	s	file:
affentry_T	spell.c	/^typedef struct affentry_S affentry_T;$/;"	t	typeref:struct:affentry_S	file:
afffile_S	spell.c	/^typedef struct afffile_S$/;"	s	file:
afffile_T	spell.c	/^} afffile_T;$/;"	t	typeref:struct:afffile_S	file:
affheader_S	spell.c	/^typedef struct affheader_S$/;"	s	file:
affheader_T	spell.c	/^} affheader_T;$/;"	t	typeref:struct:affheader_S	file:
affitem2flag	spell.c	/^affitem2flag(flagtype, item, fname, lnum)$/;"	f	file:
after_label	misc1.c	/^after_label(l)$/;"	f	file:
after_pathsep	misc2.c	/^after_pathsep(b, p)$/;"	f
after_pathsep	vim.h	/^# define after_pathsep(/;"	d
ah_combine	spell.c	/^    int		ah_combine;	\/* suffix may combine with prefix *\/$/;"	m	struct:affheader_S	file:
ah_first	spell.c	/^    affentry_T	*ah_first;	\/* first affix entry *\/$/;"	m	struct:affheader_S	file:
ah_flag	spell.c	/^    unsigned	ah_flag;	\/* affix name as number, uses "af_flagtype" *\/$/;"	m	struct:affheader_S	file:
ah_follows	spell.c	/^    int		ah_follows;	\/* another affix block should be following *\/$/;"	m	struct:affheader_S	file:
ah_key	spell.c	/^    char_u	ah_key[AH_KEY_LEN]; \/* key for hashtab == name of affix *\/$/;"	m	struct:affheader_S	file:
ah_newID	spell.c	/^    int		ah_newID;	\/* prefix ID after renumbering; 0 if not used *\/$/;"	m	struct:affheader_S	file:
ai_col	globals.h	/^EXTERN colnr_T	ai_col INIT(= 0);$/;"	v
aixhack	pty.c	/^int aixhack = -1;$/;"	v
al_ga	structs.h	/^    garray_T	al_ga;		\/* growarray with the array of file names *\/$/;"	m	struct:arglist
al_refcount	structs.h	/^    int		al_refcount;	\/* number of windows using this arglist *\/$/;"	m	struct:arglist
alist_T	structs.h	/^} alist_T;$/;"	t	typeref:struct:arglist
alist_add	ex_docmd.c	/^alist_add(al, fname, set_fnum)$/;"	f
alist_add_list	ex_cmds2.c	/^alist_add_list(count, files, after)$/;"	f	file:
alist_check_arg_idx	ex_cmds2.c	/^alist_check_arg_idx()$/;"	f	file:
alist_clear	ex_docmd.c	/^alist_clear(al)$/;"	f
alist_expand	ex_docmd.c	/^alist_expand(fnum_list, fnum_len)$/;"	f
alist_init	ex_docmd.c	/^alist_init(al)$/;"	f
alist_name	buffer.c	/^alist_name(aep)$/;"	f
alist_new	ex_docmd.c	/^alist_new()$/;"	f
alist_set	ex_docmd.c	/^alist_set(al, count, files, use_curbuf, fnum_list, fnum_len)$/;"	f
alist_slash_adjust	ex_docmd.c	/^alist_slash_adjust()$/;"	f
alist_unlink	ex_docmd.c	/^alist_unlink(al)$/;"	f
all	gui_gtk.c	/^    GtkWidget *all;	\/* 'Replace All' action button *\/$/;"	m	struct:_SharedFindReplace	file:
all	gui_motif.c	/^    Widget all;		\/* 'Replace All' action button *\/$/;"	m	struct:_SharedFindReplace	file:
allcap_copy	spell.c	/^allcap_copy(word, wcopy)$/;"	f	file:
alloc	misc2.c	/^alloc(size)$/;"	f
alloc_check	misc2.c	/^alloc_check(size)$/;"	f
alloc_clear	misc2.c	/^alloc_clear(size)$/;"	f
alloc_cmdbuff	ex_getln.c	/^alloc_cmdbuff(len)$/;"	f	file:
alloc_color	gui_xmebw.c	/^alloc_color(Display	*display,$/;"	f	file:
alloc_string_tv	eval.c	/^alloc_string_tv(s)$/;"	f	file:
alloc_tabpage	window.c	/^alloc_tabpage()$/;"	f	file:
alloc_tv	eval.c	/^alloc_tv()$/;"	f	file:
alloc_typebuf	getchar.c	/^alloc_typebuf()$/;"	f
allow_dirs	fileio.c	/^    char	    allow_dirs;		\/* Pattern may match whole path *\/$/;"	m	struct:AutoPat	file:
allow_keys	globals.h	/^EXTERN int allow_keys INIT(= FALSE);	\/* allow key codes when no_mapping$/;"	v
already_warned	fileio.c	/^static int already_warned = FALSE;$/;"	v	file:
alt_tabpage	window.c	/^alt_tabpage()$/;"	f	file:
amount	ex_cmds.h	/^    int		amount;		\/* number of '>' or '<' for shift command *\/$/;"	m	struct:exarg
ap	eval.c	/^static va_list	ap;$/;"	v	file:
app_context	globals.h	/^EXTERN XtAppContext app_context INIT(= (XtAppContext)NULL);$/;"	v
append	ex_cmds.h	/^    int		append;		\/* TRUE with ":w >>file" command *\/$/;"	m	struct:exarg
append_arg_number	buffer.c	/^append_arg_number(wp, buf, add_file, maxlen)$/;"	f
append_ga_line	os_unix.c	/^append_ga_line(gap)$/;"	f	file:
append_indent	ex_cmds.c	/^static int append_indent = 0;	    \/* autoindent for first line *\/$/;"	v	file:
append_redir	ex_cmds.c	/^append_redir(buf, opt, fname)$/;"	f
append_selection	workshop.c	/^append_selection($/;"	f	file:
appended_lines	misc1.c	/^appended_lines(lnum, count)$/;"	f
appended_lines_mark	misc1.c	/^appended_lines_mark(lnum, count)$/;"	f
apply_autocmds	fileio.c	/^apply_autocmds(event, fname, fname_io, force, buf)$/;"	f
apply_autocmds_exarg	fileio.c	/^apply_autocmds_exarg(event, fname, fname_io, force, buf, eap)$/;"	f	file:
apply_autocmds_group	fileio.c	/^apply_autocmds_group(event, fname, fname_io, force, group, buf, eap)$/;"	f	file:
apply_autocmds_retval	fileio.c	/^apply_autocmds_retval(event, fname, fname_io, force, buf, retval)$/;"	f
apply_fontlist	gui_xmdlg.c	/^# define apply_fontlist(/;"	d	file:
apply_wide_font_attr	gui_gtk_x11.c	/^apply_wide_font_attr(char_u *s, int len, PangoAttrList *attr_list)$/;"	f	file:
approximate_botline_win	move.c	/^approximate_botline_win(wp)$/;"	f
arabic_combine	mbyte.c	/^arabic_combine(one, two)$/;"	f
arabic_maycombine	mbyte.c	/^arabic_maycombine(two)$/;"	f
arabic_shape	arabic.c	/^arabic_shape(c, ccp, c1p, prev_c, prev_c1, next_c)$/;"	f
arg	ex_cmds.h	/^    char_u	*arg;		\/* argument of the command *\/$/;"	m	struct:exarg
arg	getchar.c	/^    char_u	*arg;$/;"	m	struct:initmap	file:
arg	structs.h	/^    int		arg;		\/* extra argument from nv_cmds[] *\/$/;"	m	struct:cmdarg_S
arg_all	ex_docmd.c	/^arg_all()$/;"	f	file:
arg_bufnr	fileio.c	/^    int		arg_bufnr;	\/* initially equal to <abuf>, set to zero when$/;"	m	struct:AutoPatCmd	file:
arg_had_last	globals.h	/^EXTERN int	arg_had_last INIT(= FALSE); \/* accessed last file in$/;"	v
argc	if_mzsch.c	/^    int		    argc;$/;"	m	struct:__anon26	file:
argc	main.c	/^    int		argc;$/;"	m	struct:__anon39	file:
argentry	structs.h	/^typedef struct argentry$/;"	s
arglist	structs.h	/^typedef struct arglist$/;"	s
args	gui_motif.c	/^    char *  args;   \/* not used right now *\/$/;"	m	struct:dialog_callback_arg	file:
argt	ex_cmds.h	/^    long	argt;		\/* flags for the command *\/$/;"	m	struct:exarg
arguments	structs.h	/^    char_u	*arguments;$/;"	m	struct:__anon100
argv	if_mzsch.c	/^    Scheme_Object   **argv;$/;"	m	struct:__anon26	file:
argv	main.c	/^    char	**argv;$/;"	m	struct:__anon39	file:
armed_pixmap	gui_xmebwp.h	/^    Pixmap armed_pixmap;$/;"	m	struct:_XmEnhancedButtonPart
arrow_used	globals.h	/^EXTERN int arrow_used;			\/* Normally FALSE, set to TRUE after$/;"	v
arshape_buf	ex_getln.c	/^static char_u	*arshape_buf = NULL;$/;"	v	file:
ascii_enc	hardcopy.c	/^    char			*ascii_enc;$/;"	m	struct:prt_ps_mbfont_S	file:
ascii_font	gui.h	/^    PangoFont	     *ascii_font;   \/* cached font for ASCII strings *\/$/;"	m	struct:Gui
ascii_glyph_table_init	gui_gtk_x11.c	/^ascii_glyph_table_init(void)$/;"	f	file:
ascii_glyphs	gui.h	/^    PangoGlyphString *ascii_glyphs; \/* cached code point -> glyph map *\/$/;"	m	struct:Gui
ask_for_key	main.c	/^    int		ask_for_key;		\/* -x argument *\/$/;"	m	struct:__anon39	file:
ask_yesno	misc1.c	/^ask_yesno(str, direct)$/;"	f
at_start	regexp.c	/^static int	at_start;	\/* True when on the first character *\/$/;"	v	file:
athena_calculate_ins_pos	gui_athena.c	/^athena_calculate_ins_pos(widget)$/;"	f	file:
attention_message	memline.c	/^attention_message(buf, fname)$/;"	f	file:
attr	message.c	/^    int			attr;$/;"	m	struct:msg_hist	file:
attr	structs.h	/^    int		attr;	\/* attributes to be used for a match *\/$/;"	m	struct:__anon96
attr_cur	structs.h	/^    int		attr_cur; \/* attributes currently active in win_line() *\/$/;"	m	struct:__anon96
attr_entry	structs.h	/^typedef struct attr_entry$/;"	s
attrentry_T	structs.h	/^} attrentry_T;$/;"	t	typeref:struct:attr_entry
au_cleanup	fileio.c	/^au_cleanup()$/;"	f	file:
au_del_group	fileio.c	/^au_del_group(name)$/;"	f	file:
au_event_disable	fileio.c	/^au_event_disable(what)$/;"	f
au_event_restore	fileio.c	/^au_event_restore(old_ei)$/;"	f
au_exists	fileio.c	/^au_exists(arg)$/;"	f
au_find_group	fileio.c	/^au_find_group(name)$/;"	f	file:
au_get_grouparg	fileio.c	/^au_get_grouparg(argp)$/;"	f	file:
au_has_group	fileio.c	/^au_has_group(name)$/;"	f
au_need_clean	fileio.c	/^static int au_need_clean = FALSE;   \/* need to delete marked patterns *\/$/;"	v	file:
au_new_curbuf	globals.h	/^EXTERN buf_T	*au_new_curbuf INIT(= NULL);$/;"	v
au_new_group	fileio.c	/^au_new_group(name)$/;"	f	file:
au_remove_cmds	fileio.c	/^au_remove_cmds(ap)$/;"	f	file:
au_remove_pat	fileio.c	/^au_remove_pat(ap)$/;"	f	file:
aubuflocal_remove	fileio.c	/^aubuflocal_remove(buf)$/;"	f
aucmd_prepbuf	fileio.c	/^aucmd_prepbuf(aco, buf)$/;"	f
aucmd_restbuf	fileio.c	/^aucmd_restbuf(aco)$/;"	f
augroups	fileio.c	/^static garray_T augroups = {0, 0, sizeof(char_u *), 10, NULL};$/;"	v	file:
auto_event	vim.h	/^enum auto_event$/;"	g
auto_format	edit.c	/^auto_format(trailblank, prev_line)$/;"	f
auto_next_pat	fileio.c	/^auto_next_pat(apc, stop_at_last)$/;"	f	file:
autocmd_blocked	fileio.c	/^static int	autocmd_blocked = 0;	\/* block all autocmds *\/$/;"	v	file:
autocmd_bufnr	globals.h	/^EXTERN int	autocmd_bufnr INIT(= 0);     \/* fnum for <abuf> on cmdline *\/$/;"	v
autocmd_busy	globals.h	/^EXTERN int	autocmd_busy INIT(= FALSE);	\/* Is apply_autocmds() busy? *\/$/;"	v
autocmd_fname	globals.h	/^EXTERN char_u	*autocmd_fname INIT(= NULL); \/* fname for <afile> on cmdline *\/$/;"	v
autocmd_match	globals.h	/^EXTERN char_u	*autocmd_match INIT(= NULL); \/* name for <amatch> on cmdline *\/$/;"	v
autocmd_nested	fileio.c	/^static int	autocmd_nested = FALSE;$/;"	v	file:
autocmd_no_enter	globals.h	/^EXTERN int	autocmd_no_enter INIT(= FALSE); \/* *Enter autocmds disabled *\/$/;"	v
autocmd_no_leave	globals.h	/^EXTERN int	autocmd_no_leave INIT(= FALSE); \/* *Leave autocmds disabled *\/$/;"	v
autocmd_supported	fileio.c	/^autocmd_supported(name)$/;"	f
autoload_name	eval.c	/^autoload_name(name)$/;"	f	file:
autowrite	ex_cmds2.c	/^autowrite(buf, forceit)$/;"	f
autowrite_all	ex_cmds2.c	/^autowrite_all()$/;"	f
available	vim.h	/^    int		available;	\/* Is clipboard available? *\/$/;"	m	struct:VimClipboard
b	regexp.c	/^    int a, b, c;$/;"	m	struct:__anon52	file:
b0_dirty	memline.c	/^#define b0_dirty	/;"	d	file:
b0_flags	memline.c	/^#define b0_flags	/;"	d	file:
b0_fname	memline.c	/^    char_u	b0_fname[B0_FNAME_SIZE_ORG]; \/* name of file being edited *\/$/;"	m	struct:block0	file:
b0_hname	memline.c	/^    char_u	b0_hname[B0_HNAME_SIZE]; \/* host name (if it has a name) *\/$/;"	m	struct:block0	file:
b0_id	memline.c	/^    char_u	b0_id[2];	\/* id for block 0: BLOCK0_ID0 and BLOCK0_ID1 *\/$/;"	m	struct:block0	file:
b0_ino	memline.c	/^    char_u	b0_ino[4];	\/* inode of b0_fname *\/$/;"	m	struct:block0	file:
b0_magic_char	memline.c	/^    char_u	b0_magic_char;	\/* check for last char *\/$/;"	m	struct:block0	file:
b0_magic_int	memline.c	/^    int		b0_magic_int;	\/* check for byte order of int *\/$/;"	m	struct:block0	file:
b0_magic_long	memline.c	/^    long	b0_magic_long;	\/* check for byte order of long *\/$/;"	m	struct:block0	file:
b0_magic_short	memline.c	/^    short	b0_magic_short;	\/* check for byte order of short *\/$/;"	m	struct:block0	file:
b0_magic_wrong	memline.c	/^b0_magic_wrong(b0p)$/;"	f	file:
b0_mtime	memline.c	/^    char_u	b0_mtime[4];	\/* last modification time of file *\/$/;"	m	struct:block0	file:
b0_page_size	memline.c	/^    char_u	b0_page_size[4];\/* number of bytes per page *\/$/;"	m	struct:block0	file:
b0_pid	memline.c	/^    char_u	b0_pid[4];	\/* process id of creator (or 0) *\/$/;"	m	struct:block0	file:
b0_uname	memline.c	/^    char_u	b0_uname[B0_UNAME_SIZE]; \/* name of user (uid if no name) *\/$/;"	m	struct:block0	file:
b0_version	memline.c	/^    char_u	b0_version[10];	\/* Vim version string *\/$/;"	m	struct:block0	file:
b_FSSpec	structs.h	/^    FSSpec	b_FSSpec;	\/* MacOS File Identification *\/$/;"	m	struct:file_buffer
b_bad_char	structs.h	/^    int		b_bad_char;	\/* "++bad=" argument when edit started or 0 *\/$/;"	m	struct:file_buffer
b_block_head	structs.h	/^    mblock_T	b_block_head;	\/* head of allocated memory block list *\/$/;"	m	struct:file_buffer
b_bufvar	structs.h	/^    dictitem_T	b_bufvar;	\/* variable for "b:" Dictionary *\/$/;"	m	struct:file_buffer
b_cap_prog	structs.h	/^    regprog_T	*b_cap_prog;	\/* program for 'spellcapcheck' *\/$/;"	m	struct:file_buffer
b_changed	structs.h	/^    int		b_changed;	\/* 'modified': Set to TRUE if something in the$/;"	m	struct:file_buffer
b_changedtick	structs.h	/^    int		b_changedtick;	\/* incremented for each change, also for undo *\/$/;"	m	struct:file_buffer
b_changelist	structs.h	/^    pos_T	b_changelist[JUMPLISTSIZE];$/;"	m	struct:file_buffer
b_changelistlen	structs.h	/^    int		b_changelistlen;	\/* number of active entries *\/$/;"	m	struct:file_buffer
b_chartab	structs.h	/^    char_u	b_chartab[32];$/;"	m	struct:file_buffer
b_dev	structs.h	/^    int		b_dev;		\/* device number (-1 if not set) *\/$/;"	m	struct:file_buffer
b_did_warn	structs.h	/^    int		b_did_warn;	\/* Set to 1 if user has been warned on first$/;"	m	struct:file_buffer
b_fab_mrs	structs.h	/^    unsigned int b_fab_mrs;	\/* Max record size  *\/$/;"	m	struct:file_buffer
b_fab_rat	structs.h	/^    char	 b_fab_rat;	\/* Record attribute *\/$/;"	m	struct:file_buffer
b_fab_rfm	structs.h	/^    char	 b_fab_rfm;	\/* Record format    *\/$/;"	m	struct:file_buffer
b_ffname	structs.h	/^    char_u	*b_ffname;	\/* full path file name *\/$/;"	m	struct:file_buffer
b_first_abbr	structs.h	/^    mapblock_T	*b_first_abbr;$/;"	m	struct:file_buffer
b_flags	structs.h	/^    int		b_flags;	\/* various BF_ flags *\/$/;"	m	struct:file_buffer
b_fname	structs.h	/^    char_u	*b_fname;	\/* current file name *\/$/;"	m	struct:file_buffer
b_fnum	structs.h	/^    int		b_fnum;		\/* buffer number for this file. *\/$/;"	m	struct:file_buffer
b_help	structs.h	/^    int		b_help;		\/* TRUE for help file buffer (when set b_p_bt$/;"	m	struct:file_buffer
b_ino	structs.h	/^    ino_t	b_ino;		\/* inode number *\/$/;"	m	struct:file_buffer
b_keywtab	structs.h	/^    hashtab_T	b_keywtab;		\/* syntax keywords hash table *\/$/;"	m	struct:file_buffer
b_keywtab_ic	structs.h	/^    hashtab_T	b_keywtab_ic;		\/* idem, ignore case *\/$/;"	m	struct:file_buffer
b_kmap_ga	structs.h	/^    garray_T	b_kmap_ga;	\/* the keymap table *\/$/;"	m	struct:file_buffer
b_kmap_state	structs.h	/^    short	b_kmap_state;	\/* using "lmap" mappings *\/$/;"	m	struct:file_buffer
b_langp	structs.h	/^    garray_T	b_langp;	\/* list of pointers to slang_T, see spell.c *\/$/;"	m	struct:file_buffer
b_last_change	structs.h	/^    pos_T	b_last_change;	\/* position of last change: '. mark *\/$/;"	m	struct:file_buffer
b_last_cursor	structs.h	/^    pos_T	b_last_cursor;	\/* cursor position when last unloading this$/;"	m	struct:file_buffer
b_last_insert	structs.h	/^    pos_T	b_last_insert;	\/* where Insert mode was left *\/$/;"	m	struct:file_buffer
b_m_search	structs.h	/^    minfo_T	*b_m_search;	\/* pointer to chunk before previously$/;"	m	struct:file_buffer
b_maphash	structs.h	/^    mapblock_T	*(b_maphash[256]);$/;"	m	struct:file_buffer
b_marks_read	structs.h	/^    int		b_marks_read;	\/* Have we read viminfo marks yet? *\/$/;"	m	struct:file_buffer
b_may_swap	structs.h	/^    int		b_may_swap;$/;"	m	struct:file_buffer
b_mb_current	structs.h	/^    mblock_T	*b_mb_current;	\/* block where m_search points in *\/$/;"	m	struct:file_buffer
b_ml	structs.h	/^    memline_T	b_ml;		\/* associated memline (also contains line$/;"	m	struct:file_buffer
b_mod_bot	structs.h	/^    linenr_T	b_mod_bot;	\/* lnum below last changed line, AFTER the$/;"	m	struct:file_buffer
b_mod_set	structs.h	/^    int		b_mod_set;	\/* TRUE when there are changes since the last$/;"	m	struct:file_buffer
b_mod_top	structs.h	/^    linenr_T	b_mod_top;	\/* topmost lnum that was changed *\/$/;"	m	struct:file_buffer
b_mod_xlines	structs.h	/^    long	b_mod_xlines;	\/* number of extra buffer lines inserted;$/;"	m	struct:file_buffer
b_mtime	structs.h	/^    long	b_mtime;	\/* last change time of original file *\/$/;"	m	struct:file_buffer
b_mtime_read	structs.h	/^    long	b_mtime_read;	\/* last change time when reading *\/$/;"	m	struct:file_buffer
b_mzscheme_ref	structs.h	/^    void	*b_mzscheme_ref; \/* The MzScheme reference to this buffer *\/$/;"	m	struct:file_buffer
b_namedm	structs.h	/^    pos_T	b_namedm[NMARKS]; \/* current named marks (mark.c) *\/$/;"	m	struct:file_buffer
b_netbeans_file	structs.h	/^    int		b_netbeans_file;    \/* TRUE when buffer is owned by NetBeans *\/$/;"	m	struct:file_buffer
b_new_change	structs.h	/^    int		b_new_change;		\/* set by u_savecommon() *\/$/;"	m	struct:file_buffer
b_next	structs.h	/^    buf_T	*b_next;	\/* links in list of buffers *\/$/;"	m	struct:file_buffer
b_next	structs.h	/^    struct buffblock	*b_next;	\/* pointer to next buffblock *\/$/;"	m	struct:buffblock	typeref:struct:buffblock::buffblock
b_nospell_cluster_id	structs.h	/^    int		b_nospell_cluster_id;	\/* @NoSpell cluster ID or 0 *\/$/;"	m	struct:file_buffer
b_nwindows	structs.h	/^    int		b_nwindows;	\/* nr of windows open on this buffer *\/$/;"	m	struct:file_buffer
b_op_end	structs.h	/^    pos_T	b_op_end;$/;"	m	struct:file_buffer
b_op_start	structs.h	/^    pos_T	b_op_start;$/;"	m	struct:file_buffer
b_orig_mode	structs.h	/^    int		b_orig_mode;	\/* mode of original file *\/$/;"	m	struct:file_buffer
b_orig_size	structs.h	/^    size_t	b_orig_size;	\/* size of original file in bytes *\/$/;"	m	struct:file_buffer
b_p_ai	structs.h	/^    int		b_p_ai;		\/* 'autoindent' *\/$/;"	m	struct:file_buffer
b_p_ai_nopaste	structs.h	/^    int		b_p_ai_nopaste;	\/* b_p_ai saved for paste mode *\/$/;"	m	struct:file_buffer
b_p_ar	structs.h	/^    int		b_p_ar;		\/* 'autoread' local value *\/$/;"	m	struct:file_buffer
b_p_bexpr	structs.h	/^    char_u	*b_p_bexpr;	\/* 'balloonexpr' local value *\/$/;"	m	struct:file_buffer
b_p_bexpr_flags	structs.h	/^    long_u	b_p_bexpr_flags;\/* flags for 'balloonexpr' *\/$/;"	m	struct:file_buffer
b_p_bh	structs.h	/^    char_u	*b_p_bh;	\/* 'bufhidden' *\/$/;"	m	struct:file_buffer
b_p_bin	structs.h	/^    int		b_p_bin;	\/* 'binary' *\/$/;"	m	struct:file_buffer
b_p_bl	structs.h	/^    int		b_p_bl;		\/* 'buflisted' *\/$/;"	m	struct:file_buffer
b_p_bomb	structs.h	/^    int		b_p_bomb;	\/* 'bomb' *\/$/;"	m	struct:file_buffer
b_p_bt	structs.h	/^    char_u	*b_p_bt;	\/* 'buftype' *\/$/;"	m	struct:file_buffer
b_p_cfu	structs.h	/^    char_u	*b_p_cfu;	\/* 'completefunc' *\/$/;"	m	struct:file_buffer
b_p_ci	structs.h	/^    int		b_p_ci;		\/* 'copyindent' *\/$/;"	m	struct:file_buffer
b_p_cin	structs.h	/^    int		b_p_cin;	\/* 'cindent' *\/$/;"	m	struct:file_buffer
b_p_cink	structs.h	/^    char_u	*b_p_cink;	\/* 'cinkeys' *\/$/;"	m	struct:file_buffer
b_p_cino	structs.h	/^    char_u	*b_p_cino;	\/* 'cinoptions' *\/$/;"	m	struct:file_buffer
b_p_cinw	structs.h	/^    char_u	*b_p_cinw;	\/* 'cinwords' *\/$/;"	m	struct:file_buffer
b_p_cms	structs.h	/^    char_u	*b_p_cms;	\/* 'commentstring' *\/$/;"	m	struct:file_buffer
b_p_com	structs.h	/^    char_u	*b_p_com;	\/* 'comments' *\/$/;"	m	struct:file_buffer
b_p_cpt	structs.h	/^    char_u	*b_p_cpt;	\/* 'complete' *\/$/;"	m	struct:file_buffer
b_p_def	structs.h	/^    char_u	*b_p_def;	\/* 'define' local value *\/$/;"	m	struct:file_buffer
b_p_dict	structs.h	/^    char_u	*b_p_dict;	\/* 'dictionary' local value *\/$/;"	m	struct:file_buffer
b_p_efm	structs.h	/^    char_u	*b_p_efm;	\/* 'errorformat' local value *\/$/;"	m	struct:file_buffer
b_p_eol	structs.h	/^    int		b_p_eol;	\/* 'endofline' *\/$/;"	m	struct:file_buffer
b_p_ep	structs.h	/^    char_u	*b_p_ep;	\/* 'equalprg' local value *\/$/;"	m	struct:file_buffer
b_p_et	structs.h	/^    int		b_p_et;		\/* 'expandtab' *\/$/;"	m	struct:file_buffer
b_p_et_nobin	structs.h	/^    int		b_p_et_nobin;	\/* b_p_et saved for binary mode *\/$/;"	m	struct:file_buffer
b_p_fenc	structs.h	/^    char_u	*b_p_fenc;	\/* 'fileencoding' *\/$/;"	m	struct:file_buffer
b_p_fex	structs.h	/^    char_u	*b_p_fex;	\/* 'formatexpr' *\/$/;"	m	struct:file_buffer
b_p_fex_flags	structs.h	/^    long_u	b_p_fex_flags;	\/* flags for 'formatexpr' *\/$/;"	m	struct:file_buffer
b_p_ff	structs.h	/^    char_u	*b_p_ff;	\/* 'fileformat' *\/$/;"	m	struct:file_buffer
b_p_flp	structs.h	/^    char_u	*b_p_flp;	\/* 'formatlistpat' *\/$/;"	m	struct:file_buffer
b_p_fo	structs.h	/^    char_u	*b_p_fo;	\/* 'formatoptions' *\/$/;"	m	struct:file_buffer
b_p_ft	structs.h	/^    char_u	*b_p_ft;	\/* 'filetype' *\/$/;"	m	struct:file_buffer
b_p_gp	structs.h	/^    char_u	*b_p_gp;	\/* 'grepprg' local value *\/$/;"	m	struct:file_buffer
b_p_iminsert	structs.h	/^    long	b_p_iminsert;	\/* input mode for insert *\/$/;"	m	struct:file_buffer
b_p_imsearch	structs.h	/^    long	b_p_imsearch;	\/* input mode for search *\/$/;"	m	struct:file_buffer
b_p_inc	structs.h	/^    char_u	*b_p_inc;	\/* 'include' *\/$/;"	m	struct:file_buffer
b_p_inde	structs.h	/^    char_u	*b_p_inde;	\/* 'indentexpr' *\/$/;"	m	struct:file_buffer
b_p_inde_flags	structs.h	/^    long_u	b_p_inde_flags;	\/* flags for 'indentexpr' *\/$/;"	m	struct:file_buffer
b_p_indk	structs.h	/^    char_u	*b_p_indk;	\/* 'indentkeys' *\/$/;"	m	struct:file_buffer
b_p_inex	structs.h	/^    char_u	*b_p_inex;	\/* 'includeexpr' *\/$/;"	m	struct:file_buffer
b_p_inex_flags	structs.h	/^    long_u	b_p_inex_flags;	\/* flags for 'includeexpr' *\/$/;"	m	struct:file_buffer
b_p_inf	structs.h	/^    int		b_p_inf;	\/* 'infercase' *\/$/;"	m	struct:file_buffer
b_p_initialized	structs.h	/^    int		b_p_initialized;	\/* set when options initialized *\/$/;"	m	struct:file_buffer
b_p_isk	structs.h	/^    char_u	*b_p_isk;	\/* 'iskeyword' *\/$/;"	m	struct:file_buffer
b_p_key	structs.h	/^    char_u	*b_p_key;	\/* 'key' *\/$/;"	m	struct:file_buffer
b_p_keymap	structs.h	/^    char_u	*b_p_keymap;	\/* 'keymap' *\/$/;"	m	struct:file_buffer
b_p_kp	structs.h	/^    char_u	*b_p_kp;	\/* 'keywordprg' *\/$/;"	m	struct:file_buffer
b_p_lisp	structs.h	/^    int		b_p_lisp;	\/* 'lisp' *\/$/;"	m	struct:file_buffer
b_p_ma	structs.h	/^    int		b_p_ma;		\/* 'modifiable' *\/$/;"	m	struct:file_buffer
b_p_ml	structs.h	/^    int		b_p_ml;		\/* 'modeline' *\/$/;"	m	struct:file_buffer
b_p_ml_nobin	structs.h	/^    int		b_p_ml_nobin;	\/* b_p_ml saved for binary mode *\/$/;"	m	struct:file_buffer
b_p_mp	structs.h	/^    char_u	*b_p_mp;	\/* 'makeprg' local value *\/$/;"	m	struct:file_buffer
b_p_mps	structs.h	/^    char_u	*b_p_mps;	\/* 'matchpairs' *\/$/;"	m	struct:file_buffer
b_p_nf	structs.h	/^    char_u	*b_p_nf;	\/* 'nrformats' *\/$/;"	m	struct:file_buffer
b_p_oft	structs.h	/^    char_u	*b_p_oft;	\/* 'osfiletype' *\/$/;"	m	struct:file_buffer
b_p_ofu	structs.h	/^    char_u	*b_p_ofu;	\/* 'omnifunc' *\/$/;"	m	struct:file_buffer
b_p_path	structs.h	/^    char_u	*b_p_path;	\/* 'path' local value *\/$/;"	m	struct:file_buffer
b_p_pi	structs.h	/^    int		b_p_pi;		\/* 'preserveindent' *\/$/;"	m	struct:file_buffer
b_p_qe	structs.h	/^    char_u	*b_p_qe;	\/* 'quoteescape' *\/$/;"	m	struct:file_buffer
b_p_ro	structs.h	/^    int		b_p_ro;		\/* 'readonly' *\/$/;"	m	struct:file_buffer
b_p_scriptID	structs.h	/^    int		b_p_scriptID[BV_COUNT];	\/* SIDs for buffer-local options *\/$/;"	m	struct:file_buffer
b_p_si	structs.h	/^    int		b_p_si;		\/* 'smartindent' *\/$/;"	m	struct:file_buffer
b_p_smc	structs.h	/^    long	b_p_smc;	\/* 'synmaxcol' *\/$/;"	m	struct:file_buffer
b_p_sn	structs.h	/^    int		b_p_sn;		\/* 'shortname' *\/$/;"	m	struct:file_buffer
b_p_spc	structs.h	/^    char_u	*b_p_spc;	\/* 'spellcapcheck' *\/$/;"	m	struct:file_buffer
b_p_spf	structs.h	/^    char_u	*b_p_spf;	\/* 'spellfile' *\/$/;"	m	struct:file_buffer
b_p_spl	structs.h	/^    char_u	*b_p_spl;	\/* 'spelllang' *\/$/;"	m	struct:file_buffer
b_p_sts	structs.h	/^    long	b_p_sts;	\/* 'softtabstop' *\/$/;"	m	struct:file_buffer
b_p_sts_nopaste	structs.h	/^    long	b_p_sts_nopaste; \/* b_p_sts saved for paste mode *\/$/;"	m	struct:file_buffer
b_p_sua	structs.h	/^    char_u	*b_p_sua;	\/* 'suffixesadd' *\/$/;"	m	struct:file_buffer
b_p_sw	structs.h	/^    long	b_p_sw;		\/* 'shiftwidth' *\/$/;"	m	struct:file_buffer
b_p_swf	structs.h	/^    int		b_p_swf;	\/* 'swapfile' *\/$/;"	m	struct:file_buffer
b_p_syn	structs.h	/^    char_u	*b_p_syn;	\/* 'syntax' *\/$/;"	m	struct:file_buffer
b_p_tags	structs.h	/^    char_u	*b_p_tags;	\/* 'tags' local value *\/$/;"	m	struct:file_buffer
b_p_ts	structs.h	/^    long	b_p_ts;		\/* 'tabstop' *\/$/;"	m	struct:file_buffer
b_p_tsr	structs.h	/^    char_u	*b_p_tsr;	\/* 'thesaurus' local value *\/$/;"	m	struct:file_buffer
b_p_tw	structs.h	/^    long	b_p_tw;		\/* 'textwidth' *\/$/;"	m	struct:file_buffer
b_p_tw_nobin	structs.h	/^    long	b_p_tw_nobin;	\/* b_p_tw saved for binary mode *\/$/;"	m	struct:file_buffer
b_p_tw_nopaste	structs.h	/^    long	b_p_tw_nopaste;	\/* b_p_tw saved for paste mode *\/$/;"	m	struct:file_buffer
b_p_tx	structs.h	/^    int		b_p_tx;		\/* 'textmode' *\/$/;"	m	struct:file_buffer
b_p_wm	structs.h	/^    long	b_p_wm;		\/* 'wrapmargin' *\/$/;"	m	struct:file_buffer
b_p_wm_nobin	structs.h	/^    long	b_p_wm_nobin;	\/* b_p_wm saved for binary mode *\/$/;"	m	struct:file_buffer
b_p_wm_nopaste	structs.h	/^    long	b_p_wm_nopaste;	\/* b_p_wm saved for paste mode *\/$/;"	m	struct:file_buffer
b_perl_private	structs.h	/^    void	*b_perl_private;$/;"	m	struct:file_buffer
b_prev	structs.h	/^    buf_T	*b_prev;$/;"	m	struct:file_buffer
b_python_ref	structs.h	/^    void	*b_python_ref;	\/* The Python reference to this buffer *\/$/;"	m	struct:file_buffer
b_ruby_ref	structs.h	/^    void	*b_ruby_ref;$/;"	m	struct:file_buffer
b_saving	structs.h	/^    int		b_saving;	\/* Set to TRUE if we are in the middle of$/;"	m	struct:file_buffer
b_scanned	structs.h	/^    int		b_scanned;	\/* ^N\/^P have scanned this buffer *\/$/;"	m	struct:file_buffer
b_sfname	structs.h	/^    char_u	*b_sfname;	\/* short file name *\/$/;"	m	struct:file_buffer
b_shortname	structs.h	/^    int		b_shortname;	\/* this file has an 8.3 file name *\/$/;"	m	struct:file_buffer
b_signlist	structs.h	/^    signlist_T	*b_signlist;	\/* list of signs to draw *\/$/;"	m	struct:file_buffer
b_sniff	structs.h	/^    int		b_sniff;	\/* file was loaded through Sniff *\/$/;"	m	struct:file_buffer
b_spell	structs.h	/^    int		b_spell;	\/* TRUE for a spell file buffer, most fields$/;"	m	struct:file_buffer
b_spell_cluster_id	structs.h	/^    int		b_spell_cluster_id;	\/* @Spell cluster ID or 0 *\/$/;"	m	struct:file_buffer
b_spell_ismw	structs.h	/^    char_u	b_spell_ismw[256];\/* flags: is midword char *\/$/;"	m	struct:file_buffer
b_spell_ismw_mb	structs.h	/^    char_u	*b_spell_ismw_mb; \/* multi-byte midword chars *\/$/;"	m	struct:file_buffer
b_sst_array	structs.h	/^    synstate_T	*b_sst_array;$/;"	m	struct:file_buffer
b_sst_check_lnum	structs.h	/^    linenr_T	b_sst_check_lnum;$/;"	m	struct:file_buffer
b_sst_first	structs.h	/^    synstate_T	*b_sst_first;$/;"	m	struct:file_buffer
b_sst_firstfree	structs.h	/^    synstate_T	*b_sst_firstfree;$/;"	m	struct:file_buffer
b_sst_freecount	structs.h	/^    int		b_sst_freecount;$/;"	m	struct:file_buffer
b_sst_lasttick	structs.h	/^    short_u	b_sst_lasttick;	\/* last display tick *\/$/;"	m	struct:file_buffer
b_sst_len	structs.h	/^    int		b_sst_len;$/;"	m	struct:file_buffer
b_start_bomb	structs.h	/^    int		b_start_bomb;	\/* 'bomb' when it was read *\/$/;"	m	struct:file_buffer
b_start_eol	structs.h	/^    int		b_start_eol;	\/* last line had eol when it was read *\/$/;"	m	struct:file_buffer
b_start_fenc	structs.h	/^    char_u	*b_start_fenc;	\/* 'fileencoding' when edit started or NULL *\/$/;"	m	struct:file_buffer
b_start_ffc	structs.h	/^    int		b_start_ffc;	\/* first char of 'ff' when edit started *\/$/;"	m	struct:file_buffer
b_str	structs.h	/^    char_u		b_str[1];	\/* contents (actually longer) *\/$/;"	m	struct:buffblock
b_syn_clusters	structs.h	/^    garray_T	b_syn_clusters;		\/* table for syntax clusters *\/$/;"	m	struct:file_buffer
b_syn_containedin	structs.h	/^    int		b_syn_containedin;	\/* TRUE when there is an item with a$/;"	m	struct:file_buffer
b_syn_error	structs.h	/^    int		b_syn_error;		\/* TRUE when error occured in HL *\/$/;"	m	struct:file_buffer
b_syn_folditems	structs.h	/^    int		b_syn_folditems;	\/* number of patterns with the HL_FOLD$/;"	m	struct:file_buffer
b_syn_ic	structs.h	/^    int		b_syn_ic;		\/* ignore case for :syn cmds *\/$/;"	m	struct:file_buffer
b_syn_linecont_ic	structs.h	/^    int		b_syn_linecont_ic;	\/* ignore-case flag for above *\/$/;"	m	struct:file_buffer
b_syn_linecont_pat	structs.h	/^    char_u	*b_syn_linecont_pat;	\/* line continuation pattern *\/$/;"	m	struct:file_buffer
b_syn_linecont_prog	structs.h	/^    regprog_T	*b_syn_linecont_prog;	\/* line continuation program *\/$/;"	m	struct:file_buffer
b_syn_patterns	structs.h	/^    garray_T	b_syn_patterns;		\/* table for syntax patterns *\/$/;"	m	struct:file_buffer
b_syn_spell	structs.h	/^    int		b_syn_spell;		\/* SYNSPL_ values *\/$/;"	m	struct:file_buffer
b_syn_sync_flags	structs.h	/^    int		b_syn_sync_flags;	\/* flags about how to sync *\/$/;"	m	struct:file_buffer
b_syn_sync_id	structs.h	/^    short	b_syn_sync_id;		\/* group to sync on *\/$/;"	m	struct:file_buffer
b_syn_sync_linebreaks	structs.h	/^    long	b_syn_sync_linebreaks;	\/* offset for multi-line pattern *\/$/;"	m	struct:file_buffer
b_syn_sync_maxlines	structs.h	/^    long	b_syn_sync_maxlines;	\/* maximal sync lines offset *\/$/;"	m	struct:file_buffer
b_syn_sync_minlines	structs.h	/^    long	b_syn_sync_minlines;	\/* minimal sync lines offset *\/$/;"	m	struct:file_buffer
b_syn_topgrp	structs.h	/^    int		b_syn_topgrp;		\/* for ":syntax include" *\/$/;"	m	struct:file_buffer
b_tcl_ref	structs.h	/^    void	*b_tcl_ref;$/;"	m	struct:file_buffer
b_u_curhead	structs.h	/^    u_header_T	*b_u_curhead;	\/* pointer to current header *\/$/;"	m	struct:file_buffer
b_u_line_colnr	structs.h	/^    colnr_T	b_u_line_colnr;	\/* optional column number *\/$/;"	m	struct:file_buffer
b_u_line_lnum	structs.h	/^    linenr_T	b_u_line_lnum;	\/* line number of line in u_line *\/$/;"	m	struct:file_buffer
b_u_line_ptr	structs.h	/^    char_u	*b_u_line_ptr;	\/* saved line for "U" command *\/$/;"	m	struct:file_buffer
b_u_newhead	structs.h	/^    u_header_T	*b_u_newhead;	\/* pointer to newest header; may not be valid$/;"	m	struct:file_buffer
b_u_numhead	structs.h	/^    int		b_u_numhead;	\/* current number of headers *\/$/;"	m	struct:file_buffer
b_u_oldhead	structs.h	/^    u_header_T	*b_u_oldhead;	\/* pointer to oldest header *\/$/;"	m	struct:file_buffer
b_u_seq_cur	structs.h	/^    long	b_u_seq_cur;	\/* hu_seq of header below which we are now *\/$/;"	m	struct:file_buffer
b_u_seq_last	structs.h	/^    long	b_u_seq_last;	\/* last used undo sequence number *\/$/;"	m	struct:file_buffer
b_u_seq_time	structs.h	/^    time_t	b_u_seq_time;	\/* uh_time of header below which we are now *\/$/;"	m	struct:file_buffer
b_u_synced	structs.h	/^    int		b_u_synced;	\/* entry lists are synced *\/$/;"	m	struct:file_buffer
b_ucmds	structs.h	/^    garray_T	b_ucmds;$/;"	m	struct:file_buffer
b_vars	structs.h	/^    dict_T	b_vars;		\/* internal variables, local to buffer *\/$/;"	m	struct:file_buffer
b_visual	structs.h	/^    visualinfo_T b_visual;$/;"	m	struct:file_buffer
b_visual_mode_eval	structs.h	/^    int		b_visual_mode_eval;  \/* b_visual.vi_mode for visualmode() *\/$/;"	m	struct:file_buffer
b_was_netbeans_file	structs.h	/^    int		b_was_netbeans_file;\/* TRUE if b_netbeans_file was once set *\/$/;"	m	struct:file_buffer
b_wininfo	structs.h	/^    wininfo_T	*b_wininfo;	\/* list of last used info for each window *\/$/;"	m	struct:file_buffer
back_gc	gui.h	/^    GC		back_gc;$/;"	m	struct:Gui
back_in_line	search.c	/^back_in_line()$/;"	f	file:
back_pixel	gui.h	/^    guicolor_T	back_pixel;	    \/* Color of background *\/$/;"	m	struct:Gui
background_argument	globals.h	/^EXTERN char	*background_argument INIT(= NULL);$/;"	v
backpos	regexp.c	/^static garray_T	backpos = {0, 0, 0, 0, NULL};$/;"	v	file:
backpos_S	regexp.c	/^typedef struct backpos_S$/;"	s	file:
backpos_T	regexp.c	/^} backpos_T;$/;"	t	typeref:struct:backpos_S	file:
backslash_halve	charset.c	/^backslash_halve(p)$/;"	f
backslash_halve_save	charset.c	/^backslash_halve_save(p)$/;"	f
backslash_trans	regexp.c	/^backslash_trans(c)$/;"	f	file:
backspace_until_column	edit.c	/^backspace_until_column(col)$/;"	f
bad_char	ex_cmds.h	/^    int		bad_char;	\/* ++bad= argument (index in cmd[]) *\/$/;"	m	struct:exarg
badi	spell.c	/^    int		badi;$/;"	m	struct:__anon57	file:
badword_captype	spell.c	/^badword_captype(word, end)$/;"	f	file:
balloonEval	globals.h	/^EXTERN BalloonEval	*balloonEval INIT(= NULL);$/;"	v
balloonLabel	gui_beval.h	/^    GtkWidget		*balloonLabel;$/;"	m	struct:BalloonEvalStruct
balloonShell	gui_beval.h	/^    GtkWidget		*balloonShell;$/;"	m	struct:BalloonEvalStruct
balloon_draw_cb	gui_beval.c	/^balloon_draw_cb(GtkWidget *widget, GdkRectangle *area, gpointer data)$/;"	f	file:
balloon_expose_event_cb	gui_beval.c	/^balloon_expose_event_cb(GtkWidget *widget, GdkEventExpose *event, gpointer data)$/;"	f	file:
bangredo	globals.h	/^EXTERN int	bangredo INIT(= FALSE);	    \/* set to TRUE with ! command *\/$/;"	v
bbox_max_y	hardcopy.c	/^    int		bbox_max_y;$/;"	m	struct:prt_ps_font_S	file:
bbox_min_y	hardcopy.c	/^    int		bbox_min_y;$/;"	m	struct:prt_ps_font_S	file:
bck_word	search.c	/^bck_word(count, bigword, stop)$/;"	f
bckend_word	search.c	/^bckend_word(count, bigword, eol)$/;"	f
beep_count	globals.h	/^EXTERN int	beep_count INIT(= 0);	\/* nr of beeps since last char typed *\/$/;"	v
beep_flush	misc1.c	/^beep_flush()$/;"	f
beepcmd	if_tcl.c	/^beepcmd(dummy, interp, objc, objv)$/;"	f	file:
before_blocking	getchar.c	/^before_blocking()$/;"	f
beginSelection	gui_at_fs.c	/^    int		beginSelection;$/;"	m	struct:__anon14	file:
beginline	edit.c	/^beginline(flags)$/;"	f
behind_pos	regexp.c	/^static regsave_T behind_pos;$/;"	v	file:
bevalServers	globals.h	/^EXTERN int bevalServers INIT(= 0);$/;"	v
bg_color	structs.h	/^	    guicolor_T	    bg_color;	\/* background color handle *\/$/;"	m	struct:attr_entry::__anon86::__anon89
bg_color	structs.h	/^	    short_u	    bg_color;	\/* background color number *\/$/;"	m	struct:attr_entry::__anon86::__anon88
bg_color	structs.h	/^    long_u	bg_color;$/;"	m	struct:__anon99
bg_colour	gui.h	/^    int		bg_colour;$/;"	m	struct:Gui
bgcolor	gui.h	/^    GdkColor	*bgcolor;	    \/* GDK-styled background color *\/$/;"	m	struct:Gui
bh_bnum	structs.h	/^    blocknr_T	bh_bnum;		\/* block number *\/$/;"	m	struct:block_hdr
bh_curr	structs.h	/^    struct buffblock	*bh_curr;	\/* buffblock for appending *\/$/;"	m	struct:buffheader	typeref:struct:buffheader::buffblock
bh_data	structs.h	/^    char_u	*bh_data;	    \/* pointer to memory (for used block) *\/$/;"	m	struct:block_hdr
bh_first	structs.h	/^    struct buffblock	bh_first;	\/* first (dummy) block of list *\/$/;"	m	struct:buffheader	typeref:struct:buffheader::buffblock
bh_flags	structs.h	/^    char	bh_flags;	    \/* BH_DIRTY or BH_LOCKED *\/$/;"	m	struct:block_hdr
bh_hash_next	structs.h	/^    bhdr_T	*bh_hash_next;	    \/* next block_hdr in hash list *\/$/;"	m	struct:block_hdr
bh_hash_prev	structs.h	/^    bhdr_T	*bh_hash_prev;	    \/* previous block_hdr in hash list *\/$/;"	m	struct:block_hdr
bh_index	structs.h	/^    int			bh_index;	\/* index for reading *\/$/;"	m	struct:buffheader
bh_next	structs.h	/^    bhdr_T	*bh_next;	    \/* next block_hdr in free or used list *\/$/;"	m	struct:block_hdr
bh_page_count	structs.h	/^    int		bh_page_count;	    \/* number of pages in this block *\/$/;"	m	struct:block_hdr
bh_prev	structs.h	/^    bhdr_T	*bh_prev;	    \/* previous block_hdr in used list *\/$/;"	m	struct:block_hdr
bh_space	structs.h	/^    int			bh_space;	\/* space in bh_curr for appending *\/$/;"	m	struct:buffheader
bhdr_T	structs.h	/^typedef struct block_hdr    bhdr_T;$/;"	t	typeref:struct:block_hdr
bin_window	gui_gtk_f.h	/^    GdkWindow *bin_window;$/;"	m	struct:_GtkForm
bind_textdomain_codeset	gui_gtk.c	/^#  undef bind_textdomain_codeset$/;"	d	file:
bind_textdomain_codeset	gui_gtk_x11.c	/^#  undef bind_textdomain_codeset$/;"	d	file:
bind_textdomain_codeset	vim.h	/^#  define bind_textdomain_codeset(/;"	d
bind_textdomain_codeset	vim.h	/^#  undef bind_textdomain_codeset$/;"	d
bind_textdomain_codeset	vim.h	/^# define bind_textdomain_codeset(/;"	d
bindtextdomain	gui_gtk.c	/^#  undef bindtextdomain$/;"	d	file:
bindtextdomain	gui_gtk_x11.c	/^#  undef bindtextdomain$/;"	d	file:
bindtextdomain	vim.h	/^#  define bindtextdomain(/;"	d
bindtextdomain	vim.h	/^#  undef bindtextdomain$/;"	d
bindtextdomain	vim.h	/^# define bindtextdomain(/;"	d
bkc_flags	option.h	/^EXTERN unsigned	bkc_flags;$/;"	v
bl_maxval	regexp.c	/^static long	bl_maxval;$/;"	v	file:
bl_minval	regexp.c	/^static long	bl_minval;$/;"	v	file:
blank_pointer	gui.h	/^    Cursor	blank_pointer;	    \/* Blank pointer *\/$/;"	m	struct:Gui
blank_pointer	gui.h	/^    GdkCursor	*blank_pointer;	    \/* Blank pointer *\/$/;"	m	struct:Gui
blank_xpm	gui_xmebw.c	/^static char * blank_xpm[] =$/;"	v	file:
blink_cb	gui_gtk_x11.c	/^blink_cb(gpointer data)$/;"	f	file:
blink_offtime	gui_gtk_x11.c	/^static long_u blink_offtime = 250;$/;"	v	file:
blink_offtime	gui_x11.c	/^static long_u		blink_offtime = 250;$/;"	v	file:
blink_ontime	gui_gtk_x11.c	/^static long_u blink_ontime = 400;$/;"	v	file:
blink_ontime	gui_x11.c	/^static long_u		blink_ontime = 400;$/;"	v	file:
blink_state	gui_gtk_x11.c	/^static int blink_state = BLINK_NONE;$/;"	v	file:
blink_state	gui_x11.c	/^static int		blink_state = BLINK_NONE;$/;"	v	file:
blink_timer	gui_gtk_x11.c	/^static guint blink_timer = 0;$/;"	v	file:
blink_timer	gui_x11.c	/^static XtIntervalId	blink_timer = (XtIntervalId)0;$/;"	v	file:
blink_waittime	gui_gtk_x11.c	/^static long_u blink_waittime = 700;$/;"	v	file:
blink_waittime	gui_x11.c	/^static long_u		blink_waittime = 700;$/;"	v	file:
blinkoff	structs.h	/^    long	blinkoff;	\/* blinking, off time *\/$/;"	m	struct:cursor_entry
blinkon	structs.h	/^    long	blinkon;	\/* blinking, on time *\/$/;"	m	struct:cursor_entry
blinkwait	structs.h	/^    long	blinkwait;	\/* blinking, wait time before blinking starts *\/$/;"	m	struct:cursor_entry
block0	memline.c	/^struct block0$/;"	s	file:
block_autocmds	fileio.c	/^block_autocmds()$/;"	f
block_def	ops.c	/^struct block_def$/;"	s	file:
block_hdr	structs.h	/^struct block_hdr$/;"	s
block_insert	ops.c	/^block_insert(oap, s, b_insert, bdp)$/;"	f	file:
block_mode	structs.h	/^    int		block_mode;	\/* current operator is Visual block mode *\/$/;"	m	struct:oparg_S
block_prep	ops.c	/^block_prep(oap, bdp, lnum, is_del)$/;"	f	file:
block_redo	getchar.c	/^static int	block_redo = FALSE;$/;"	v	file:
blocknr_T	structs.h	/^typedef long		    blocknr_T;$/;"	t
bold	structs.h	/^    int		bold;$/;"	m	struct:__anon99
bold_font	gui.h	/^    GuiFont	bold_font;	    \/* Bold font *\/$/;"	m	struct:Gui
boldital_font	gui.h	/^    GuiFont	boldital_font;	    \/* Bold-Italic font *\/$/;"	m	struct:Gui
bomb_size	mbyte.c	/^bomb_size()$/;"	f
bool	vim.h	/^#  undef bool$/;"	d
border_offset	gui.h	/^    int		border_offset;	    \/* Total pixel offset for all borders *\/$/;"	m	struct:Gui
border_width	gui.h	/^    int		border_width;	    \/* Width of our border around text area *\/$/;"	m	struct:Gui
bot_shadow_GC	gui_at_sb.h	/^    GC		bot_shadow_GC;$/;"	m	struct:__anon64
bot_shadow_contrast	gui_at_sb.h	/^    int		bot_shadow_contrast;$/;"	m	struct:__anon64
bot_shadow_pixel	gui_at_sb.h	/^    Pixel	bot_shadow_pixel;$/;"	m	struct:__anon64
bot_top_msg	globals.h	/^EXTERN char bot_top_msg[] INIT(= N_("search hit BOTTOM, continuing at TOP"));$/;"	v
botline_forw	move.c	/^botline_forw(lp)$/;"	f	file:
botline_topline	move.c	/^botline_topline(lp)$/;"	f	file:
bottom_sbar	gui.h	/^    scrollbar_T bottom_sbar;	    \/* Bottom scrollbar *\/$/;"	m	struct:Gui
bottommsg	tag.c	/^static char_u *bottommsg = (char_u *)N_("E555: at bottom of tag stack");$/;"	v	file:
bp_pos	regexp.c	/^    regsave_T	bp_pos;		\/* last input position *\/$/;"	m	struct:backpos_S	file:
bp_scan	regexp.c	/^    char_u	*bp_scan;	\/* "scan" where BACK was encountered *\/$/;"	m	struct:backpos_S	file:
brace_count	regexp.c	/^static int	brace_count[10]; \/* Current counts for complex brace repeats *\/$/;"	v	file:
brace_max	regexp.c	/^static long	brace_max[10];	\/* Maximums for complex brace repeats *\/$/;"	v	file:
brace_min	regexp.c	/^static long	brace_min[10];	\/* Minimums for complex brace repeats *\/$/;"	v	file:
breakat_flags	globals.h	/^EXTERN char	breakat_flags[256];	\/* which characters are in 'breakat' *\/$/;"	v
breakcheck_count	misc1.c	/^static int	breakcheck_count = 0;$/;"	v	file:
breakpoint	eval.c	/^    linenr_T	breakpoint;	\/* next line with breakpoint or zero *\/$/;"	m	struct:funccall_S	file:
breakpoint	ex_cmds2.c	/^    linenr_T	breakpoint;	\/* next line with breakpoint or zero *\/$/;"	m	struct:source_cookie	file:
browse	structs.h	/^    int		browse;			\/* TRUE to invoke file dialog *\/$/;"	m	struct:__anon83
browse_cancel_cb	gui_gtk.c	/^browse_cancel_cb(GtkWidget *widget, gpointer cbdata)$/;"	f	file:
browse_destroy_cb	gui_gtk.c	/^browse_destroy_cb(GtkWidget * widget)$/;"	f	file:
browse_fname	gui.h	/^    char_u	*browse_fname;	    \/* file name from filedlg *\/$/;"	m	struct:Gui
browse_fname	gui_motif.c	/^static char *browse_fname = NULL;$/;"	v	file:
browse_ok_cb	gui_gtk.c	/^browse_ok_cb(GtkWidget *widget, gpointer cbdata)$/;"	f	file:
browse_save_fname	ex_cmds2.c	/^browse_save_fname(buf)$/;"	f
bs_extmatch	structs.h	/^    reg_extmatch_T *bs_extmatch; \/* external matches from start pattern *\/$/;"	m	struct:buf_state
bs_flags	structs.h	/^    long	    bs_flags;	 \/* flags for pattern *\/$/;"	m	struct:buf_state
bs_idx	structs.h	/^    int		    bs_idx;	 \/* index of pattern *\/$/;"	m	struct:buf_state
bt_dontwrite	quickfix.c	/^bt_dontwrite(buf)$/;"	f
bt_dontwrite_msg	quickfix.c	/^bt_dontwrite_msg(buf)$/;"	f
bt_entry	term.c	/^    int		bt_entry;$/;"	m	struct:builtin_term	file:
bt_nofile	quickfix.c	/^bt_nofile(buf)$/;"	f
bt_quickfix	quickfix.c	/^bt_quickfix(buf)$/;"	f
bt_string	term.c	/^    char	*bt_string;$/;"	m	struct:builtin_term	file:
buf	if_mzsch.c	/^    buf_T	    *buf;$/;"	m	struct:__anon21	file:
buf	if_python.c	/^    BufferObject *buf;$/;"	m	struct:__anon32	file:
buf	if_python.c	/^    buf_T *buf;$/;"	m	struct:__anon31	file:
buf	structs.h	/^    buf_T	*buf;	\/* the buffer to search for a match *\/$/;"	m	struct:__anon96
bufIsChanged	undo.c	/^bufIsChanged(buf)$/;"	f
buf_T	os_unixx.h	/^#define buf_T /;"	d
buf_T	os_unixx.h	/^#undef buf_T$/;"	d
buf_T	pty.c	/^#define buf_T /;"	d	file:
buf_T	pty.c	/^#undef buf_T$/;"	d	file:
buf_T	structs.h	/^typedef struct file_buffer buf_T;$/;"	t	typeref:struct:file_buffer
buf_addsign	buffer.c	/^buf_addsign(buf, id, lnum, typenr)$/;"	f
buf_change_sign_type	buffer.c	/^buf_change_sign_type(buf, markId, typenr)$/;"	f
buf_check_timestamp	fileio.c	/^buf_check_timestamp(buf, focus)$/;"	f
buf_clear_file	buffer.c	/^buf_clear_file(buf)$/;"	f
buf_contents_changed	buffer.c	/^buf_contents_changed(buf)$/;"	f
buf_copy_options	option.c	/^buf_copy_options(buf, flags)$/;"	f
buf_delete_all_signs	buffer.c	/^buf_delete_all_signs()$/;"	f
buf_delete_signs	buffer.c	/^buf_delete_signs(buf)$/;"	f	file:
buf_delsign	buffer.c	/^buf_delsign(buf, id)$/;"	f
buf_findsign	buffer.c	/^buf_findsign(buf, id)$/;"	f
buf_findsign_id	buffer.c	/^buf_findsign_id(buf, lnum)$/;"	f
buf_findsigntype_id	buffer.c	/^buf_findsigntype_id(buf, lnum, typenr)$/;"	f
buf_freeall	buffer.c	/^buf_freeall(buf, del_buf, wipe_buf)$/;"	f
buf_getsigntype	buffer.c	/^buf_getsigntype(buf, lnum, type)$/;"	f
buf_hide	quickfix.c	/^buf_hide(buf)$/;"	f
buf_init_chartab	charset.c	/^buf_init_chartab(buf, global)$/;"	f
buf_jump_open_tab	window.c	/^buf_jump_open_tab(buf)$/;"	f
buf_jump_open_win	window.c	/^buf_jump_open_win(buf)$/;"	f
buf_list	netbeans.c	/^static nbbuf_T *buf_list = 0;$/;"	v	file:
buf_list_size	netbeans.c	/^static int buf_list_size = 0;	\/* size of buf_list *\/$/;"	v	file:
buf_list_used	netbeans.c	/^static int buf_list_used = 0;	\/* nr of entries in buf_list actually in use *\/$/;"	v	file:
buf_modname	fileio.c	/^buf_modname(shortname, fname, ext, prepend_dot)$/;"	f
buf_name_changed	buffer.c	/^buf_name_changed(buf)$/;"	f
buf_reload	fileio.c	/^buf_reload(buf, orig_mode)$/;"	f
buf_same_ino	buffer.c	/^buf_same_ino(buf, stp)$/;"	f	file:
buf_set_name	buffer.c	/^buf_set_name(fnum, name)$/;"	f
buf_setino	buffer.c	/^buf_setino(buf)$/;"	f
buf_signcount	buffer.c	/^buf_signcount(buf, lnum)$/;"	f
buf_spname	buffer.c	/^buf_spname(buf)$/;"	f
buf_state	structs.h	/^typedef struct buf_state$/;"	s
buf_store_time	fileio.c	/^buf_store_time(buf, st, fname)$/;"	f
buf_valid	buffer.c	/^buf_valid(buf)$/;"	f
buf_write	fileio.c	/^buf_write(buf, fname, sfname, start, end, eap, append, forceit,$/;"	f
buf_write_all	ex_cmds2.c	/^buf_write_all(buf, forceit)$/;"	f
buf_write_bytes	fileio.c	/^buf_write_bytes(ip)$/;"	f	file:
bufempty	macros.h	/^#define bufempty(/;"	d
buffblock	structs.h	/^struct buffblock$/;"	s
buffer	hardcopy.c	/^    char_u  buffer[PRT_FILE_BUFFER_LEN];$/;"	m	struct:prt_resfile_buffer_S	file:
buffer	if_python.c	/^static char_u *buffer = NULL;$/;"	v	file:
buffer	netbeans.c	/^    char_u	    *buffer;$/;"	m	struct:cmdqueue	file:
buffer_append	if_ruby.c	/^static VALUE buffer_append(VALUE self, VALUE num, VALUE str)$/;"	f	file:
buffer_aref	if_ruby.c	/^static VALUE buffer_aref(VALUE self, VALUE num)$/;"	f	file:
buffer_aset	if_ruby.c	/^static VALUE buffer_aset(VALUE self, VALUE num, VALUE str)$/;"	f	file:
buffer_count	if_ruby.c	/^static VALUE buffer_count(VALUE self)$/;"	f	file:
buffer_delete	if_ruby.c	/^static VALUE buffer_delete(VALUE self, VALUE num)$/;"	f	file:
buffer_ensure	if_python.c	/^buffer_ensure(PyInt n)$/;"	f	file:
buffer_len	if_python.c	/^static PyInt buffer_len = 0;$/;"	v	file:
buffer_name	if_ruby.c	/^static VALUE buffer_name(VALUE self)$/;"	f	file:
buffer_new	if_mzsch.c	/^buffer_new(buf_T *buf)$/;"	f	file:
buffer_new	if_ruby.c	/^static VALUE buffer_new(buf_T *buf)$/;"	f	file:
buffer_number	if_ruby.c	/^static VALUE buffer_number(VALUE self)$/;"	f	file:
buffer_s_aref	if_ruby.c	/^static VALUE buffer_s_aref(VALUE self, VALUE num)$/;"	f	file:
buffer_s_count	if_ruby.c	/^static VALUE buffer_s_count()$/;"	f	file:
buffer_s_current	if_ruby.c	/^static VALUE buffer_s_current()$/;"	f	file:
buffer_size	if_python.c	/^static PyInt buffer_size = 0;$/;"	v	file:
buffercmd	if_tcl.c	/^buffercmd(dummy, interp, objc, objv)$/;"	f	file:
buffheader	structs.h	/^struct buffheader$/;"	s
buflist_add	buffer.c	/^buflist_add(fname, flags)$/;"	f
buflist_altfpos	buffer.c	/^buflist_altfpos()$/;"	f
buflist_findfpos	buffer.c	/^buflist_findfpos(buf)$/;"	f
buflist_findlnum	buffer.c	/^buflist_findlnum(buf)$/;"	f
buflist_findname	buffer.c	/^buflist_findname(ffname)$/;"	f
buflist_findname_exp	buffer.c	/^buflist_findname_exp(fname)$/;"	f
buflist_findname_stat	buffer.c	/^buflist_findname_stat(ffname, stp)$/;"	f	file:
buflist_findnr	buffer.c	/^buflist_findnr(nr)$/;"	f
buflist_findpat	buffer.c	/^buflist_findpat(pattern, pattern_end, unlisted, diffmode)$/;"	f
buflist_getfile	buffer.c	/^buflist_getfile(n, lnum, options, forceit)$/;"	f
buflist_getfpos	buffer.c	/^buflist_getfpos()$/;"	f
buflist_list	buffer.c	/^buflist_list(eap)$/;"	f
buflist_list	ex_docmd.c	/^# define buflist_list	/;"	d	file:
buflist_match	buffer.c	/^buflist_match(prog, buf)$/;"	f	file:
buflist_name_nr	buffer.c	/^buflist_name_nr(fnum, fname, lnum)$/;"	f
buflist_new	buffer.c	/^buflist_new(ffname, sfname, lnum, flags)$/;"	f
buflist_nr2name	buffer.c	/^buflist_nr2name(n, fullname, helptail)$/;"	f
buflist_setfpos	buffer.c	/^buflist_setfpos(buf, win, lnum, col, copy_options)$/;"	f	file:
buflist_slash_adjust	buffer.c	/^buflist_slash_adjust()$/;"	f
buflocal_nr	fileio.c	/^    int		    buflocal_nr;	\/* !=0 for buffer-local AutoPat *\/$/;"	m	struct:AutoPat	file:
bufp	netbeans.c	/^    buf_T		*bufp;$/;"	m	struct:nbbuf_struct	file:
bufselfcmd	if_tcl.c	/^bufselfcmd(ref, interp, objc, objv)$/;"	f	file:
bufstate_T	structs.h	/^} bufstate_T;$/;"	t	typeref:struct:buf_state
build_drop_cmd	main.c	/^build_drop_cmd(filec, filev, tabs, sendReply)$/;"	f	file:
build_stl_str_hl	buffer.c	/^build_stl_str_hl(wp, out, outlen, fmt, use_sandbox, fillchar, maxwidth, hltab, tabtab)$/;"	f
built_in_pixmaps	gui_gtk.c	/^static char **(built_in_pixmaps[]) =$/;"	v	file:
built_in_pixmaps	gui_x11_pm.h	/^static char **(built_in_pixmaps[]) =$/;"	v
builtin_function	eval.c	/^builtin_function(name)$/;"	f	file:
builtin_term	term.c	/^struct builtin_term$/;"	s	file:
builtin_termcaps	term.c	/^static struct builtin_term builtin_termcaps[] =$/;"	v	typeref:struct:builtin_term	file:
bump_color	gui_xmebw.c	/^bump_color(unsigned short value)$/;"	f	file:
butproc	gui_athena.c	/^butproc(w, client_data, call_data)$/;"	f	file:
butproc	gui_motif.c	/^butproc(w, client_data, call_data)$/;"	f	file:
button	misc2.c	/^    int	    button;		\/* Which mouse button is it? *\/$/;"	m	struct:mousetable	file:
button_equal	gui_gtk.c	/^button_equal(const char *a, const char *b)$/;"	f	file:
button_press_event	gui_gtk_x11.c	/^button_press_event(GtkWidget *widget, GdkEventButton *event, gpointer data)$/;"	f	file:
button_release_event	gui_gtk_x11.c	/^button_release_event(GtkWidget *widget, GdkEventButton *event, gpointer data)$/;"	f	file:
bw_buf	fileio.c	/^    char_u	*bw_buf;	\/* buffer with data to be written *\/$/;"	m	struct:bw_info	file:
bw_conv_buf	fileio.c	/^    char_u	*bw_conv_buf;	\/* buffer for writing converted chars *\/$/;"	m	struct:bw_info	file:
bw_conv_buflen	fileio.c	/^    int		bw_conv_buflen; \/* size of bw_conv_buf *\/$/;"	m	struct:bw_info	file:
bw_conv_error	fileio.c	/^    int		bw_conv_error;	\/* set for conversion error *\/$/;"	m	struct:bw_info	file:
bw_fd	fileio.c	/^    int		bw_fd;		\/* file descriptor *\/$/;"	m	struct:bw_info	file:
bw_first	fileio.c	/^    int		bw_first;	\/* first write call *\/$/;"	m	struct:bw_info	file:
bw_flags	fileio.c	/^    int		bw_flags;	\/* FIO_ flags *\/$/;"	m	struct:bw_info	file:
bw_iconv_fd	fileio.c	/^    iconv_t	bw_iconv_fd;	\/* descriptor for iconv() or -1 *\/$/;"	m	struct:bw_info	file:
bw_info	fileio.c	/^struct bw_info$/;"	s	file:
bw_len	fileio.c	/^    int		bw_len;		\/* length of data *\/$/;"	m	struct:bw_info	file:
bw_rest	fileio.c	/^    char_u	bw_rest[CONV_RESTLEN]; \/* not converted bytes *\/$/;"	m	struct:bw_info	file:
bw_restlen	fileio.c	/^    int		bw_restlen;	\/* nr of bytes in bw_rest[] *\/$/;"	m	struct:bw_info	file:
byte2cells	charset.c	/^byte2cells(b)$/;"	f
byte_in_str	spell.c	/^byte_in_str(str, n)$/;"	f	file:
bytes2offset	spell.c	/^bytes2offset(pp)$/;"	f	file:
bytes_printed	hardcopy.c	/^    long_u	bytes_printed;	    \/* bytes printed so far *\/$/;"	m	struct:__anon20	file:
c	regexp.c	/^    int a, b, c;$/;"	m	struct:__anon52	file:
cBuffer	if_ruby.c	/^static VALUE cBuffer;$/;"	v	file:
cVimWindow	if_ruby.c	/^static VALUE cVimWindow;$/;"	v	file:
calc_hist_idx	ex_getln.c	/^calc_hist_idx(histype, num)$/;"	f	file:
call_func	eval.c	/^call_func(name, len, rettv, argcount, argvars, firstline, lastline,$/;"	f	file:
call_func_retlist	eval.c	/^call_func_retlist(func, argc, argv, safe)$/;"	f
call_func_retnr	eval.c	/^call_func_retnr(func, argc, argv, safe)$/;"	f
call_func_retstr	eval.c	/^call_func_retstr(func, argc, argv, safe)$/;"	f
call_shell	misc2.c	/^call_shell(cmd, opt)$/;"	f
call_user_expand_func	ex_getln.c	/^call_user_expand_func(user_expand_func, xp, num_file, file)$/;"	f	file:
call_user_func	eval.c	/^call_user_func(fp, argcount, argvars, rettv, firstline, lastline, selfdict)$/;"	f	file:
call_vim_function	eval.c	/^call_vim_function(func, argc, argv, safe, rettv)$/;"	f	file:
called_emsg	globals.h	/^EXTERN int	called_emsg;		    \/* always set by emsg() *\/$/;"	v
caller	eval.c	/^    funccall_T	*caller;	\/* calling function or NULL *\/$/;"	m	struct:funccall_S	file:
canF_Ljoin	farsi.c	/^canF_Ljoin(c)$/;"	f	file:
canF_Rjoin	farsi.c	/^canF_Rjoin(c)$/;"	f	file:
can_abandon	ex_cmds2.c	/^can_abandon(buf, forceit)$/;"	f
can_bs	option.c	/^can_bs(what)$/;"	f
can_cindent	edit.c	/^static int	can_cindent;		\/* may do cindenting on this line *\/$/;"	v	file:
can_clear	screen.c	/^can_clear(p)$/;"	f
can_compound	spell.c	/^can_compound(slang, word, flags)$/;"	f	file:
can_f_submatch	regexp.c	/^static int can_f_submatch = FALSE;	\/* TRUE when submatch() can be used *\/$/;"	v	file:
can_si	globals.h	/^EXTERN int	can_si INIT(= FALSE);$/;"	v
can_si_back	globals.h	/^EXTERN int	can_si_back INIT(= FALSE);$/;"	v
can_update_cursor	gui.c	/^static int can_update_cursor = TRUE; \/* can display the cursor *\/$/;"	v	file:
cancel	gui_motif.c	/^    Widget cancel;$/;"	m	struct:_SharedFindReplace	file:
cancel	gui_xmdlg.c	/^    Widget	cancel;$/;"	m	struct:_SharedFontSelData	file:
cancelBalloon	gui_beval.c	/^cancelBalloon(BalloonEval *beval)$/;"	f	file:
cancelBalloon	gui_beval.c	/^cancelBalloon(beval)$/;"	f	file:
cancel_callback	gui_xmdlg.c	/^cancel_callback(Widget w,$/;"	f	file:
canon	mbyte.c	/^{   char *name;		int canon;}$/;"	m	struct:__anon41	file:
cansplit	if_cscope.h	/^    int	    cansplit;		\/* if supports splitting window *\/$/;"	m	struct:__anon68
captype	spell.c	/^captype(word, end)$/;"	f	file:
case_args	syntax.c	/^static char *(case_args[]) = {"match", "ignore", NULL};$/;"	v	file:
cat_func_name	eval.c	/^cat_func_name(buf, fp)$/;"	f	file:
cat_prefix_varname	eval.c	/^cat_prefix_varname(prefix, name)$/;"	f	file:
catch_exception	ex_eval.c	/^catch_exception(excp)$/;"	f	file:
catch_int_signal	os_unix.c	/^catch_int_signal()$/;"	f	file:
catch_signals	os_unix.c	/^catch_signals(func_deadly, func_other)$/;"	f	file:
catchcmd	if_tcl.c	/^catchcmd(dummy, interp, objc, objv)$/;"	f	file:
caught	structs.h	/^    except_T		*caught;	\/* next exception on the caught stack *\/$/;"	m	struct:vim_exception
caught_stack	ex_docmd.c	/^    except_T	*caught_stack;$/;"	m	struct:dbg_stuff	file:
caught_stack	globals.h	/^EXTERN except_T *caught_stack INIT(= NULL);$/;"	v
cause_abort	ex_eval.c	/^static int cause_abort = FALSE;$/;"	v	file:
cause_errthrow	ex_eval.c	/^cause_errthrow(mesg, severe, ignore)$/;"	f
cb	structs.h	/^    void	(*cb) __ARGS((vimmenu_T *));	    \/* Call-back routine *\/$/;"	m	struct:VimMenu
ccheck_abbr	ex_getln.c	/^ccheck_abbr(c)$/;"	f	file:
ccline	ex_getln.c	/^static struct cmdline_info ccline;	\/* current cmdline_info *\/$/;"	v	typeref:struct:cmdline_info	file:
cedit_key	globals.h	/^EXTERN int	cedit_key INIT(= -1);	\/* key value of 'cedit' option *\/$/;"	v
change_compatible	option.c	/^change_compatible(on)$/;"	f
change_indent	edit.c	/^change_indent(type, amount, round, replaced, call_changed_bytes)$/;"	f
change_warning	misc1.c	/^change_warning(col)$/;"	f
changed	gui_at_fs.c	/^    int		changed;$/;"	m	struct:__anon14	file:
changed	misc1.c	/^changed()$/;"	f
changedOneline	misc1.c	/^changedOneline(buf, lnum)$/;"	f	file:
changed_bytes	misc1.c	/^changed_bytes(lnum, col)$/;"	f
changed_cline_bef_curs	move.c	/^changed_cline_bef_curs()$/;"	f
changed_cline_bef_curs_win	move.c	/^changed_cline_bef_curs_win(wp)$/;"	f
changed_common	misc1.c	/^changed_common(lnum, col, lnume, xtra)$/;"	f	file:
changed_line_abv_curs	move.c	/^changed_line_abv_curs()$/;"	f
changed_line_abv_curs_win	move.c	/^changed_line_abv_curs_win(wp)$/;"	f
changed_lines	misc1.c	/^changed_lines(lnum, col, lnume, xtra)$/;"	f
changed_lines_buf	misc1.c	/^changed_lines_buf(buf, lnum, lnume, xtra)$/;"	f	file:
changed_window_setting	move.c	/^changed_window_setting()$/;"	f
changed_window_setting_win	move.c	/^changed_window_setting_win(wp)$/;"	f
channel_close	if_tcl.c	/^channel_close(instance, interp)$/;"	f	file:
channel_gethandle	if_tcl.c	/^channel_gethandle(instance, direction, handleptr)$/;"	f	file:
channel_input	if_tcl.c	/^channel_input(instance, buf, bufsiz, errptr)$/;"	f	file:
channel_output	if_tcl.c	/^channel_output(instance, buf, bufsiz, errptr)$/;"	f	file:
channel_type	if_tcl.c	/^static Tcl_ChannelType channel_type =$/;"	v	file:
channel_watch	if_tcl.c	/^channel_watch(instance, mask)$/;"	f	file:
char1	digraph.c	/^    char_u	char1;$/;"	m	struct:digraph	file:
char2	digraph.c	/^    char_u	char2;$/;"	m	struct:digraph	file:
char2cells	charset.c	/^char2cells(c)$/;"	f
char_ascent	gui.h	/^    int		char_ascent;	    \/* Ascent of char in pixels *\/$/;"	m	struct:Gui
char_avail	getchar.c	/^char_avail()$/;"	f
char_height	gui.h	/^    int		char_height;	    \/* Height of char cell in pixels, includes$/;"	m	struct:Gui
char_needs_redraw	screen.c	/^char_needs_redraw(off_from, off_to, cols)$/;"	f	file:
char_to_long	memline.c	/^char_to_long(s)$/;"	f	file:
char_u	term.h	/^typedef unsigned char char_u;$/;"	t
char_u	vim.h	/^typedef unsigned char	char_u;$/;"	t
char_width	gui.h	/^    int		char_width;	    \/* Width of char cell in pixels *\/$/;"	m	struct:Gui
chars_per_line	structs.h	/^    int		chars_per_line;$/;"	m	struct:__anon100
charset	gui_motif.c	/^static XmStringCharSet charset = (XmStringCharSet) XmSTRING_DEFAULT_CHARSET;$/;"	v	file:
charset	hardcopy.c	/^    char	*charset;$/;"	m	struct:prt_ps_charset_S	file:
charsets	hardcopy.c	/^    struct prt_ps_charset_S	*charsets;$/;"	m	struct:prt_ps_mbfont_S	typeref:struct:prt_ps_mbfont_S::prt_ps_charset_S	file:
chartab	globals.h	/^EXTERN char_u	chartab[256];		\/* table used in charset.c; See$/;"	v
chartab_initialized	charset.c	/^static int    chartab_initialized = FALSE;$/;"	v	file:
chartabsize	charset.c	/^chartabsize(p, col)$/;"	f
chdir	vim.h	/^# define    chdir /;"	d
checkCloseRec	fold.c	/^checkCloseRec(gap, lnum, level)$/;"	f	file:
checkSmall	fold.c	/^checkSmall(wp, fp, lnum_off)$/;"	f	file:
check_abbr	getchar.c	/^check_abbr(c, ptr, col, mincol)$/;"	f
check_arg_idx	ex_cmds2.c	/^check_arg_idx(win)$/;"	f
check_auto_format	edit.c	/^check_auto_format(end_insert)$/;"	f	file:
check_buf_options	option.c	/^check_buf_options(buf)$/;"	f
check_cedit	option.c	/^check_cedit()$/;"	f	file:
check_changed	ex_cmds2.c	/^check_changed(buf, checkaw, mult_win, forceit, allbuf)$/;"	f
check_changed_any	ex_cmds2.c	/^check_changed_any(hidden)$/;"	f
check_changedtick	eval.c	/^check_changedtick(arg)$/;"	f	file:
check_clipboard_option	option.c	/^check_clipboard_option()$/;"	f	file:
check_closed	fold.c	/^check_closed(win, fp, use_levelp, level, maybe_smallp, lnum_off)$/;"	f	file:
check_col	ui.c	/^check_col(col)$/;"	f
check_connection	eval.c	/^check_connection()$/;"	f	file:
check_copy_area	gui_gtk_x11.c	/^check_copy_area(void)$/;"	f	file:
check_cstack	ex_docmd.c	/^    int		check_cstack;$/;"	m	struct:dbg_stuff	file:
check_cstack	globals.h	/^EXTERN int check_cstack INIT(= FALSE);$/;"	v
check_cursor	misc2.c	/^check_cursor()$/;"	f
check_cursor_col	misc2.c	/^check_cursor_col()$/;"	f
check_cursor_lnum	misc2.c	/^check_cursor_lnum()$/;"	f
check_cursor_moved	move.c	/^check_cursor_moved(wp)$/;"	f
check_ei	fileio.c	/^check_ei()$/;"	f
check_ff_value	option.c	/^check_ff_value(p)$/;"	f
check_file_readonly	fileio.c	/^check_file_readonly(fname, perm)$/;"	f
check_fname	ex_cmds2.c	/^check_fname()$/;"	f
check_fontset_sanity	gui_x11.c	/^check_fontset_sanity(fs)$/;"	f	file:
check_for_bom	fileio.c	/^check_for_bom(p, size, lenp, flags)$/;"	f	file:
check_for_codes	term.c	/^static int	check_for_codes = FALSE;    \/* check for key code response *\/$/;"	v	file:
check_for_codes_from_term	term.c	/^check_for_codes_from_term()$/;"	f	file:
check_for_cryptkey	fileio.c	/^check_for_cryptkey(cryptkey, ptr, sizep, filesizep, newfile)$/;"	f	file:
check_for_delay	screen.c	/^check_for_delay(check_msg_scroll)$/;"	f
check_help_lang	ex_cmds.c	/^check_help_lang(arg)$/;"	f
check_keepend	syntax.c	/^check_keepend()$/;"	f	file:
check_keyword_id	syntax.c	/^check_keyword_id(line, startcol, endcolp, flagsp, next_listp, cur_si)$/;"	f	file:
check_line_range	if_mzsch.c	/^check_line_range(linenr_T lnum, buf_T *buf)$/;"	f	file:
check_linecomment	search.c	/^check_linecomment(line)$/;"	f	file:
check_lnums	window.c	/^check_lnums(do_curwin)$/;"	f
check_map	getchar.c	/^check_map(keys, mode, exact, ign_mod, abbr)$/;"	f
check_map_keycodes	getchar.c	/^check_map_keycodes()$/;"	f
check_mark	mark.c	/^check_mark(pos)$/;"	f
check_marks_read	fileio.c	/^check_marks_read()$/;"	f	file:
check_menu_pointer	menu.c	/^check_menu_pointer(root, menu_to_check)$/;"	f
check_more	ex_docmd.c	/^check_more(message, forceit)$/;"	f	file:
check_mouse_termcode	os_unix.c	/^check_mouse_termcode()$/;"	f
check_mtime	fileio.c	/^check_mtime(buf, st)$/;"	f	file:
check_need_cap	spell.c	/^check_need_cap(lnum, col)$/;"	f	file:
check_need_swap	memline.c	/^check_need_swap(newfile)$/;"	f
check_nextcmd	ex_docmd.c	/^check_nextcmd(p)$/;"	f
check_opt_strings	option.c	/^check_opt_strings(val, values, list)$/;"	f	file:
check_opt_wim	option.c	/^check_opt_wim()$/;"	f	file:
check_options	option.c	/^check_options()$/;"	f
check_overwrite	ex_cmds.c	/^check_overwrite(eap, buf, fname, ffname, other)$/;"	f	file:
check_prevcol	search.c	/^check_prevcol(linep, col, ch, prevcol)$/;"	f	file:
check_readonly	ex_cmds.c	/^check_readonly(forceit, buf)$/;"	f	file:
check_redraw	option.c	/^check_redraw(flags)$/;"	f	file:
check_renumber	spell.c	/^check_renumber(spin)$/;"	f	file:
check_restricted	ex_cmds.c	/^check_restricted()$/;"	f
check_row	ui.c	/^check_row(row)$/;"	f
check_scrollbind	normal.c	/^check_scrollbind(topline_diff, leftcol_diff)$/;"	f
check_secure	ex_cmds.c	/^check_secure()$/;"	f
check_shellsize	term.c	/^check_shellsize()$/;"	f
check_snapshot_rec	window.c	/^check_snapshot_rec(sn, fr)$/;"	f	file:
check_spell_redraw	edit.c	/^check_spell_redraw()$/;"	f	file:
check_stack_growth	os_unix.c	/^check_stack_growth(p)$/;"	f	file:
check_startup_plug_hints	gui_gtk_x11.c	/^check_startup_plug_hints(gpointer data)$/;"	f	file:
check_state_ends	syntax.c	/^check_state_ends()$/;"	f	file:
check_status	misc1.c	/^check_status(buf)$/;"	f
check_stl_option	option.c	/^check_stl_option(s)$/;"	f
check_string_option	option.c	/^check_string_option(pp)$/;"	f	file:
check_suggestions	spell.c	/^check_suggestions(su, gap)$/;"	f	file:
check_swap_exists_action	main.c	/^check_swap_exists_action()$/;"	f	file:
check_termcode	term.c	/^check_termcode(max_offset, buf, buflen)$/;"	f
check_timestamps	fileio.c	/^check_timestamps(focus)$/;"	f
check_top_offset	move.c	/^check_top_offset()$/;"	f	file:
check_topfill	move.c	/^check_topfill(wp, down)$/;"	f
check_tty	main.c	/^check_tty(parmp)$/;"	f	file:
check_visual_highlight	normal.c	/^check_visual_highlight()$/;"	f
check_win_options	option.c	/^check_win_options(win)$/;"	f
check_winopt	option.c	/^check_winopt(wop)$/;"	f
check_xpm	gui_motif.c	/^check_xpm(path)$/;"	f	file:
checkclearop	normal.c	/^checkclearop(oap)$/;"	f	file:
checkclearopq	normal.c	/^checkclearopq(oap)$/;"	f	file:
checkforcmd	ex_docmd.c	/^checkforcmd(pp, cmd, len)$/;"	f
checkpcmark	mark.c	/^checkpcmark()$/;"	f
checkupdate	fold.c	/^checkupdate(wp)$/;"	f	file:
chg_c_a2f	arabic.c	/^chg_c_a2f(cur_c)$/;"	f	file:
chg_c_a2i	arabic.c	/^chg_c_a2i(cur_c)$/;"	f	file:
chg_c_a2m	arabic.c	/^chg_c_a2m(cur_c)$/;"	f	file:
chg_c_a2s	arabic.c	/^chg_c_a2s(cur_c)$/;"	f	file:
chg_c_f2m	arabic.c	/^chg_c_f2m(cur_c)$/;"	f	file:
chg_c_i2m	arabic.c	/^chg_c_i2m(cur_c)$/;"	f	file:
chg_c_laa2f	arabic.c	/^chg_c_laa2f(hid_c)$/;"	f	file:
chg_c_laa2i	arabic.c	/^chg_c_laa2i(hid_c)$/;"	f	file:
chg_c_toX_orX	farsi.c	/^chg_c_toX_orX()$/;"	f	file:
chg_c_to_X_orX_	farsi.c	/^chg_c_to_X_orX_()$/;"	f	file:
chg_c_to_X_or_X	farsi.c	/^chg_c_to_X_or_X ()$/;"	f	file:
chg_l_toXor_X	farsi.c	/^chg_l_toXor_X ()$/;"	f	file:
chg_l_to_X_orX_	farsi.c	/^chg_l_to_X_orX_ ()$/;"	f	file:
chg_r_to_Xor_X_	farsi.c	/^chg_r_to_Xor_X_()$/;"	f	file:
children	gui_gtk_f.h	/^    GList *children;$/;"	m	struct:_GtkForm
children	structs.h	/^    vimmenu_T	*children;	    \/* Children of sub-menu *\/$/;"	m	struct:VimMenu
chk_modeline	buffer.c	/^chk_modeline(lnum, flags)$/;"	f	file:
chunksize_T	structs.h	/^} chunksize_T;$/;"	t	typeref:struct:ml_chunksize
ci_flag	spell.c	/^    unsigned	ci_flag;	\/* affix name as number, uses "af_flagtype" *\/$/;"	m	struct:compitem_S	file:
ci_key	spell.c	/^    char_u	ci_key[AH_KEY_LEN]; \/* key for hashtab == name of compound *\/$/;"	m	struct:compitem_S	file:
ci_newID	spell.c	/^    int		ci_newID;	\/* affix ID after renumbering. *\/$/;"	m	struct:compitem_S	file:
cin_ends_in	misc1.c	/^cin_ends_in(s, find, ignore)$/;"	f	file:
cin_first_id_amount	misc1.c	/^cin_first_id_amount()$/;"	f	file:
cin_get_equal_amount	misc1.c	/^cin_get_equal_amount(lnum)$/;"	f	file:
cin_is_cinword	misc1.c	/^cin_is_cinword(line)$/;"	f	file:
cin_is_cpp_baseclass	misc1.c	/^cin_is_cpp_baseclass(col)$/;"	f	file:
cin_isbreak	misc1.c	/^cin_isbreak(p)$/;"	f	file:
cin_iscase	misc1.c	/^cin_iscase(s)$/;"	f
cin_iscomment	misc1.c	/^cin_iscomment(p)$/;"	f	file:
cin_isdefault	misc1.c	/^cin_isdefault(s)$/;"	f	file:
cin_isdo	misc1.c	/^cin_isdo(p)$/;"	f	file:
cin_iselse	misc1.c	/^cin_iselse(p)$/;"	f	file:
cin_isfuncdecl	misc1.c	/^cin_isfuncdecl(sp, first_lnum)$/;"	f	file:
cin_isif	misc1.c	/^cin_isif(p)$/;"	f	file:
cin_isinit	misc1.c	/^cin_isinit(void)$/;"	f	file:
cin_islabel	misc1.c	/^cin_islabel(ind_maxcomment)		\/* XXX *\/$/;"	f
cin_islabel_skip	misc1.c	/^cin_islabel_skip(s)$/;"	f	file:
cin_islinecomment	misc1.c	/^cin_islinecomment(p)$/;"	f	file:
cin_ispreproc	misc1.c	/^cin_ispreproc(s)$/;"	f	file:
cin_ispreproc_cont	misc1.c	/^cin_ispreproc_cont(pp, lnump)$/;"	f	file:
cin_isscopedecl	misc1.c	/^cin_isscopedecl(s)$/;"	f
cin_isterminated	misc1.c	/^cin_isterminated(s, incl_open, incl_comma)$/;"	f	file:
cin_iswhileofdo	misc1.c	/^cin_iswhileofdo(p, lnum, ind_maxparen)	    \/* XXX *\/$/;"	f	file:
cin_iswhileofdo_end	misc1.c	/^cin_iswhileofdo_end(terminated, ind_maxparen, ind_maxcomment)$/;"	f	file:
cin_nocode	misc1.c	/^cin_nocode(s)$/;"	f	file:
cin_skip2pos	misc1.c	/^cin_skip2pos(trypos)$/;"	f	file:
cin_skipcomment	misc1.c	/^cin_skipcomment(s)$/;"	f	file:
cindent_on	edit.c	/^cindent_on()$/;"	f	file:
class_tab	regexp.c	/^static short	class_tab[256];$/;"	v	file:
cleanup_T	structs.h	/^typedef struct cleanup_stuff cleanup_T;$/;"	t	typeref:struct:cleanup_stuff
cleanup_conditionals	ex_eval.c	/^cleanup_conditionals(cstack, searched_cond, inclusive)$/;"	f
cleanup_help_tags	ex_getln.c	/^cleanup_help_tags(num_file, file)$/;"	f	file:
cleanup_jumplist	mark.c	/^cleanup_jumplist()$/;"	f	file:
cleanup_stuff	structs.h	/^struct cleanup_stuff$/;"	s
cleanup_subexpr	regexp.c	/^cleanup_subexpr()$/;"	f	file:
cleanup_suggestions	spell.c	/^cleanup_suggestions(gap, maxscore, keep)$/;"	f	file:
cleanup_zsubexpr	regexp.c	/^cleanup_zsubexpr()$/;"	f	file:
clearFolding	fold.c	/^clearFolding(win)$/;"	f
clear_cmdline	globals.h	/^EXTERN int	clear_cmdline INIT(= FALSE);	\/* cmdline must be cleared *\/$/;"	v
clear_csinfo	if_cscope.c	/^clear_csinfo(i)$/;"	f	file:
clear_current_state	syntax.c	/^clear_current_state()$/;"	f	file:
clear_hl_tables	syntax.c	/^clear_hl_tables()$/;"	f
clear_keywtab	syntax.c	/^clear_keywtab(ht)$/;"	f	file:
clear_lval	eval.c	/^clear_lval(lp)$/;"	f	file:
clear_matches	window.c	/^clear_matches(wp)$/;"	f
clear_midword	spell.c	/^clear_midword(buf)$/;"	f	file:
clear_node	spell.c	/^clear_node(node)$/;"	f	file:
clear_oparg	ops.c	/^clear_oparg(oap)$/;"	f
clear_registers	ops.c	/^clear_registers()$/;"	f
clear_sb_text	message.c	/^clear_sb_text()$/;"	f
clear_showcmd	normal.c	/^clear_showcmd()$/;"	f
clear_snapshot	window.c	/^clear_snapshot(tp)$/;"	f	file:
clear_snapshot_rec	window.c	/^clear_snapshot_rec(fr)$/;"	f	file:
clear_spell_chartab	spell.c	/^clear_spell_chartab(sp)$/;"	f	file:
clear_string_option	option.c	/^clear_string_option(pp)$/;"	f
clear_syn_state	syntax.c	/^clear_syn_state(p)$/;"	f	file:
clear_termcodes	term.c	/^clear_termcodes()$/;"	f
clear_termoptions	option.c	/^clear_termoptions()$/;"	f
clear_tv	eval.c	/^clear_tv(varp)$/;"	f
clear_wininfo	buffer.c	/^clear_wininfo(buf)$/;"	f	file:
clear_winopt	option.c	/^clear_winopt(wop)$/;"	f
clear_xterm_clip	os_unix.c	/^clear_xterm_clip()$/;"	f
clearop	normal.c	/^clearop(oap)$/;"	f	file:
clearopbeep	normal.c	/^clearopbeep(oap)$/;"	f	file:
clearpos	macros.h	/^# define clearpos(/;"	d
clicked_page	gui_gtk_x11.c	/^static int clicked_page;	    \/* page clicked in tab line *\/$/;"	v	file:
clientData	gui_beval.h	/^    void		*clientData;	\/* For callback *\/$/;"	m	struct:BalloonEvalStruct
clientWindow	globals.h	/^EXTERN HWND	clientWindow INIT(= 0);$/;"	v
clientWindow	globals.h	/^EXTERN Window	clientWindow INIT(= None);$/;"	v
clientid	os_unix.c	/^    char *clientid;         \/* The client ID for the current smc session *\/$/;"	m	struct:__anon46	file:
clip_auto_select	ui.c	/^clip_auto_select()$/;"	f
clip_autoselect	globals.h	/^EXTERN int	clip_autoselect INIT(= FALSE);$/;"	v
clip_autoselectml	globals.h	/^EXTERN int	clip_autoselectml INIT(= FALSE);$/;"	v
clip_clear_selection	ui.c	/^clip_clear_selection()$/;"	f
clip_compare_pos	ui.c	/^clip_compare_pos(row1, col1, row2, col2)$/;"	f	file:
clip_convert_selection	ops.c	/^clip_convert_selection(str, len, cbd)$/;"	f
clip_copy_modeless_selection	ui.c	/^clip_copy_modeless_selection(both)$/;"	f
clip_copy_selection	ui.c	/^clip_copy_selection()$/;"	f
clip_exclude_prog	globals.h	/^EXTERN regprog_T *clip_exclude_prog INIT(= NULL);$/;"	v
clip_free_selection	ops.c	/^clip_free_selection(cbd)$/;"	f
clip_gen_lose_selection	ui.c	/^clip_gen_lose_selection(cbd)$/;"	f
clip_gen_own_selection	ui.c	/^clip_gen_own_selection(cbd)$/;"	f
clip_gen_request_selection	ui.c	/^clip_gen_request_selection(cbd)$/;"	f
clip_gen_set_selection	ui.c	/^clip_gen_set_selection(cbd)$/;"	f
clip_get_line_end	ui.c	/^clip_get_line_end(row)$/;"	f	file:
clip_get_selection	ops.c	/^clip_get_selection(cbd)$/;"	f
clip_get_word_boundaries	ui.c	/^clip_get_word_boundaries(cb, row, col)$/;"	f	file:
clip_init	ui.c	/^clip_init(can_use)$/;"	f
clip_invert_area	ui.c	/^clip_invert_area(row1, col1, row2, col2, how)$/;"	f	file:
clip_invert_rectangle	ui.c	/^clip_invert_rectangle(row, col, height, width, invert)$/;"	f	file:
clip_isautosel	ui.c	/^clip_isautosel()$/;"	f
clip_lose_selection	ui.c	/^clip_lose_selection(cbd)$/;"	f
clip_may_clear_selection	ui.c	/^clip_may_clear_selection(row1, row2)$/;"	f
clip_may_redraw_selection	ui.c	/^clip_may_redraw_selection(row, col, len)$/;"	f
clip_mch_lose_selection	gui_gtk_x11.c	/^clip_mch_lose_selection(VimClipboard *cbd)$/;"	f
clip_mch_lose_selection	gui_x11.c	/^clip_mch_lose_selection(cbd)$/;"	f
clip_mch_own_selection	gui_gtk_x11.c	/^clip_mch_own_selection(VimClipboard *cbd)$/;"	f
clip_mch_own_selection	gui_x11.c	/^clip_mch_own_selection(cbd)$/;"	f
clip_mch_request_selection	gui_gtk_x11.c	/^clip_mch_request_selection(VimClipboard *cbd)$/;"	f
clip_mch_request_selection	gui_x11.c	/^clip_mch_request_selection(cbd)$/;"	f
clip_mch_set_selection	gui_gtk_x11.c	/^clip_mch_set_selection(VimClipboard *cbd)$/;"	f
clip_mch_set_selection	gui_x11.c	/^clip_mch_set_selection(cbd)$/;"	f
clip_modeless	ui.c	/^clip_modeless(button, is_click, is_drag)$/;"	f
clip_own_selection	ui.c	/^clip_own_selection(cbd)$/;"	f
clip_plus	globals.h	/^#  define clip_plus /;"	d
clip_plus	globals.h	/^EXTERN VimClipboard clip_plus;	\/* CLIPBOARD selection in X11 *\/$/;"	v
clip_process_selection	ui.c	/^clip_process_selection(button, col, row, repeated_click)$/;"	f
clip_scroll_selection	ui.c	/^clip_scroll_selection(rows)$/;"	f
clip_star	globals.h	/^EXTERN VimClipboard clip_star;	\/* PRIMARY selection in X11 *\/$/;"	v
clip_start_selection	ui.c	/^clip_start_selection(col, row, repeated_click)$/;"	f
clip_unnamed	globals.h	/^EXTERN int	clip_unnamed INIT(= FALSE);$/;"	v
clip_update_modeless_selection	ui.c	/^clip_update_modeless_selection(cb, row1, col1, row2, col2)$/;"	f	file:
clip_update_selection	ui.c	/^clip_update_selection()$/;"	f
clip_x11_convert_selection_cb	ui.c	/^clip_x11_convert_selection_cb(w, sel_atom, target, type, value, length, format)$/;"	f	file:
clip_x11_lose_ownership_cb	ui.c	/^clip_x11_lose_ownership_cb(w, sel_atom)$/;"	f	file:
clip_x11_lose_selection	ui.c	/^clip_x11_lose_selection(myShell, cbd)$/;"	f
clip_x11_own_selection	ui.c	/^clip_x11_own_selection(myShell, cbd)$/;"	f
clip_x11_request_selection	ui.c	/^clip_x11_request_selection(myShell, dpy, cbd)$/;"	f
clip_x11_request_selection_cb	ui.c	/^clip_x11_request_selection_cb(w, success, sel_atom, type, value, length,$/;"	f	file:
clip_x11_set_selection	ui.c	/^clip_x11_set_selection(cbd)$/;"	f
clip_xterm_lose_selection	os_unix.c	/^clip_xterm_lose_selection(cbd)$/;"	f
clip_xterm_own_selection	os_unix.c	/^clip_xterm_own_selection(cbd)$/;"	f
clip_xterm_request_selection	os_unix.c	/^clip_xterm_request_selection(cbd)$/;"	f
clip_xterm_set_selection	os_unix.c	/^clip_xterm_set_selection(cbd)$/;"	f
clip_yank_selection	ops.c	/^clip_yank_selection(type, str, len, cbd)$/;"	f
cloneFoldGrowArray	fold.c	/^cloneFoldGrowArray(from, to)$/;"	f
closeFold	fold.c	/^closeFold(lnum, count)$/;"	f
closeFoldRecurse	fold.c	/^closeFoldRecurse(lnum)$/;"	f
close_all_scripts	getchar.c	/^close_all_scripts()$/;"	f
close_buffer	buffer.c	/^close_buffer(win, buf, action)$/;"	f
close_others	window.c	/^close_others(message, forceit)$/;"	f
close_redir	ex_docmd.c	/^close_redir()$/;"	f	file:
close_spellbuf	spell.c	/^close_spellbuf(buf)$/;"	f	file:
close_windows	window.c	/^close_windows(buf, keep_curwin)$/;"	f
closescript	getchar.c	/^closescript()$/;"	f	file:
clr_history	ex_getln.c	/^clr_history(histype)$/;"	f
clrallmarks	mark.c	/^clrallmarks(buf)$/;"	f
cls	search.c	/^cls()$/;"	f	file:
cls_bigword	search.c	/^static int	cls_bigword;	\/* TRUE for "W", "B" or "E" *\/$/;"	v	file:
cmap_charset	hardcopy.c	/^    char	*cmap_charset;$/;"	m	struct:prt_ps_charset_S	file:
cmap_encoding	hardcopy.c	/^    char	*cmap_encoding;$/;"	m	struct:prt_ps_encoding_S	file:
cmd	ex_cmds.h	/^    char_u	*cmd;		\/* the name of the command (except for :make) *\/$/;"	m	struct:exarg
cmd	fileio.c	/^    char_u	    *cmd;		\/* The command to be executed (NULL$/;"	m	struct:AutoCmd	file:
cmd	if_tcl.c	/^    Tcl_Command cmd;	    \/* Tcl command that represents this object *\/$/;"	m	struct:ref	file:
cmd_arg	normal.c	/^    short	cmd_arg;	\/* value for ca.arg *\/$/;"	m	struct:nv_cmd	file:
cmd_argt	ex_cmds.h	/^    long_u	cmd_argt;	\/* flags declared above *\/$/;"	m	struct:cmdname
cmd_char	normal.c	/^    int		cmd_char;	\/* (first) command character *\/$/;"	m	struct:nv_cmd	file:
cmd_exists	ex_docmd.c	/^cmd_exists(name)$/;"	f
cmd_fkmap	ex_getln.c	/^static int	cmd_fkmap = 0;	\/* Farsi mapping during command line *\/$/;"	v	file:
cmd_flags	normal.c	/^    short_u	cmd_flags;	\/* NV_ flags *\/$/;"	m	struct:nv_cmd	file:
cmd_func	ex_cmds.h	/^    ex_func_T   cmd_func;	\/* function for this command *\/$/;"	m	struct:cmdname
cmd_func	normal.c	/^    nv_func_T   cmd_func;	\/* function for this command *\/$/;"	m	struct:nv_cmd	file:
cmd_gchar	ex_getln.c	/^cmd_gchar(offset)$/;"	f
cmd_hkmap	ex_getln.c	/^static int	cmd_hkmap = 0;	\/* Hebrew mapping during command line *\/$/;"	v	file:
cmd_name	ex_cmds.h	/^    char_u	*cmd_name;	\/* name of the command *\/$/;"	m	struct:cmdname
cmd_pchar	ex_getln.c	/^cmd_pchar(c, offset)$/;"	f
cmd_showtail	ex_getln.c	/^static int	cmd_showtail;		\/* Only show path tail in lists ? *\/$/;"	v	file:
cmd_silent	globals.h	/^EXTERN int	cmd_silent INIT(= FALSE); \/* don't echo the command line *\/$/;"	v
cmd_source	ex_cmds2.c	/^cmd_source(fname, eap)$/;"	f	file:
cmdarg_S	structs.h	/^typedef struct cmdarg_S$/;"	s
cmdarg_T	structs.h	/^} cmdarg_T;$/;"	t	typeref:struct:cmdarg_S
cmdattr	ex_getln.c	/^    int		cmdattr;	\/* attributes for prompt *\/$/;"	m	struct:cmdline_info	file:
cmdbuff	ex_getln.c	/^    char_u	*cmdbuff;	\/* pointer to command line buffer *\/$/;"	m	struct:cmdline_info	file:
cmdbufflen	ex_getln.c	/^    int		cmdbufflen;	\/* length of cmdbuff *\/$/;"	m	struct:cmdline_info	file:
cmdchar	structs.h	/^    int		cmdchar;	\/* command character *\/$/;"	m	struct:cmdarg_S
cmdfirstc	ex_getln.c	/^    int		cmdfirstc;	\/* ':', '\/', '?', '=' or NUL *\/$/;"	m	struct:cmdline_info	file:
cmdidx	ex_cmds.h	/^    cmdidx_T	cmdidx;		\/* the index for the command *\/$/;"	m	struct:exarg
cmdidx_T	ex_cmds.h	/^typedef enum CMD_index cmdidx_T;$/;"	t	typeref:enum:CMD_index
cmdidxs	ex_docmd.c	/^static cmdidx_T cmdidxs[27] =$/;"	v	file:
cmdindent	ex_getln.c	/^    int		cmdindent;	\/* number of spaces before cmdline *\/$/;"	m	struct:cmdline_info	file:
cmdl_fkmap	farsi.c	/^cmdl_fkmap(c)$/;"	f
cmdlen	ex_getln.c	/^    int		cmdlen;		\/* number of chars in command line *\/$/;"	m	struct:cmdline_info	file:
cmdline_at_end	ex_getln.c	/^cmdline_at_end()$/;"	f
cmdline_charsize	ex_getln.c	/^cmdline_charsize(idx)$/;"	f	file:
cmdline_del	ex_getln.c	/^cmdline_del(from)$/;"	f	file:
cmdline_getvcol_cursor	ex_getln.c	/^cmdline_getvcol_cursor()$/;"	f
cmdline_info	ex_getln.c	/^struct cmdline_info$/;"	s	file:
cmdline_option_T	gui_gtk_x11.c	/^cmdline_option_T;$/;"	t	typeref:struct:__anon18	file:
cmdline_options	gui_gtk_x11.c	/^static const cmdline_option_T cmdline_options[] =$/;"	v	file:
cmdline_options	gui_x11.c	/^static XrmOptionDescRec cmdline_options[] =$/;"	v	file:
cmdline_overstrike	ex_getln.c	/^cmdline_overstrike()$/;"	f
cmdline_paste	ex_getln.c	/^cmdline_paste(regname, literally, remcr)$/;"	f	file:
cmdline_paste_reg	ops.c	/^cmdline_paste_reg(regname, literally, remcr)$/;"	f
cmdline_paste_str	ex_getln.c	/^cmdline_paste_str(s, literally)$/;"	f
cmdline_row	globals.h	/^EXTERN int	cmdline_row;$/;"	v
cmdline_star	globals.h	/^EXTERN int	cmdline_star INIT(= FALSE);	\/* cmdline is crypted *\/$/;"	v
cmdlinep	ex_cmds.h	/^    char_u	**cmdlinep;	\/* pointer to pointer of allocated cmdline *\/$/;"	m	struct:exarg
cmdmod	ex_docmd.c	/^static struct cmdmod$/;"	s	file:
cmdmod	globals.h	/^EXTERN cmdmod_T	cmdmod;			\/* Ex command modifiers *\/$/;"	v
cmdmod_T	structs.h	/^} cmdmod_T;$/;"	t	typeref:struct:__anon83
cmdmods	ex_docmd.c	/^} cmdmods[] = {$/;"	v	typeref:struct:cmdmod	file:
cmdmsg_rl	globals.h	/^EXTERN int	cmdmsg_rl INIT(= FALSE);    \/* cmdline is drawn right to left *\/$/;"	v
cmdname	ex_cmds.h	/^static struct cmdname$/;"	s
cmdnames	ex_cmds.h	/^cmdnames[] =$/;"	v	typeref:struct:cmdname
cmdpos	ex_getln.c	/^    int		cmdpos;		\/* current cursor position *\/$/;"	m	struct:cmdline_info	file:
cmdprompt	ex_getln.c	/^    char_u	*cmdprompt;	\/* message in front of cmdline *\/$/;"	m	struct:cmdline_info	file:
cmdqueue	netbeans.c	/^struct cmdqueue$/;"	s	file:
cmds	fileio.c	/^    AutoCmd	    *cmds;		\/* list of commands to do *\/$/;"	m	struct:AutoPat	file:
cmds_tofree	main.c	/^    char_u	cmds_tofree[MAX_ARG_CMDS];   \/* commands that need free() *\/$/;"	m	struct:__anon39	file:
cmdspos	ex_getln.c	/^    int		cmdspos;	\/* cursor column on screen *\/$/;"	m	struct:cmdline_info	file:
cmdsrv_main	main.c	/^cmdsrv_main(argc, argv, serverName_arg, serverStr)$/;"	f	file:
cmdwin_result	globals.h	/^EXTERN int	cmdwin_result INIT(= 0); \/* result of cmdline window or 0 *\/$/;"	v
cmdwin_type	globals.h	/^EXTERN int	cmdwin_type INIT(= 0);	\/* type of cmdline window or 0 *\/$/;"	v
cmp_flags	option.h	/^EXTERN unsigned	cmp_flags;$/;"	v
code	if_xcmdsrv.c	/^    int	    code;	\/* Result Code. 0 is OK *\/$/;"	m	struct:PendingCommand	file:
code	term.c	/^    char_u  *code;	    \/* terminal code (in allocated memory) *\/$/;"	m	struct:termcode	file:
code0	gui_gtk_x11.c	/^    char_u code0;$/;"	m	struct:special_key	file:
code1	gui_gtk_x11.c	/^    char_u code1;$/;"	m	struct:special_key	file:
codepage	mbyte.c	/^{   char *name;		int prop;		int codepage;}$/;"	m	struct:__anon40	file:
col	gui.h	/^    int		col;		    \/* Current cursor column in GUI display *\/$/;"	m	struct:Gui
col	structs.h	/^    colnr_T	col;	\/* column number *\/$/;"	m	struct:__anon79
col	structs.h	/^    colnr_T	col;	\/* column number *\/$/;"	m	struct:__anon80
col2tcl	if_tcl.c	/^#define col2tcl(/;"	d	file:
col2vim	if_tcl.c	/^#define col2vim(/;"	d	file:
col_adjust	mark.c	/^#define col_adjust(/;"	d	file:
col_print	buffer.c	/^col_print(buf, col, vcol)$/;"	f
coladd	structs.h	/^    colnr_T	coladd;$/;"	m	struct:__anon79
coladvance	misc2.c	/^coladvance(wcol)$/;"	f
coladvance2	misc2.c	/^coladvance2(pos, addspaces, finetune, wcol)$/;"	f	file:
coladvance_force	misc2.c	/^coladvance_force(wcol)$/;"	f
coll_get_char	regexp.c	/^coll_get_char()$/;"	f	file:
colnr_T	structs.h	/^typedef unsigned	colnr_T;$/;"	t
colnr_T	vim.h	/^typedef unsigned    colnr_T;		\/* column number type *\/$/;"	t
coloncmd	netbeans.c	/^coloncmd(char *cmd, ...)$/;"	f	file:
coloncmd	workshop.c	/^coloncmd($/;"	f	file:
color_approx	gui.h	/^    Bool	color_approx;	    \/* Some color was approximated *\/$/;"	m	struct:Gui
color_name2handle	syntax.c	/^color_name2handle(name)$/;"	f	file:
column	hardcopy.c	/^    colnr_T	column;		    \/* byte column *\/$/;"	m	struct:__anon20	file:
comcon2	hangulin.c	/^comcon2(k, c)$/;"	f	file:
comcon3	hangulin.c	/^comcon3(k, c)$/;"	f	file:
comfcon3	hangulin.c	/^comfcon3(v, c)$/;"	f	file:
commProperty	globals.h	/^EXTERN Atom	commProperty INIT(= None);$/;"	v
commWindow	globals.h	/^EXTERN Window	commWindow INIT(= None);$/;"	v
command	tag.c	/^    char_u	*command;	\/* first char of command *\/$/;"	m	struct:tag_pointers	file:
command_complete	ex_docmd.c	/^} command_complete[] =$/;"	v	typeref:struct:__anon10	file:
command_end	tag.c	/^    char_u	*command_end;	\/* first char after command *\/$/;"	m	struct:tag_pointers	file:
command_height	window.c	/^command_height()$/;"	f
command_line_scan	main.c	/^command_line_scan(parmp)$/;"	f	file:
commandcmd	if_tcl.c	/^commandcmd(dummy, interp, objc, objv)$/;"	f	file:
commands	main.c	/^    char_u	*commands[MAX_ARG_CMDS];     \/* commands from + or -c arg. *\/$/;"	m	struct:__anon39	file:
comp_botline	move.c	/^comp_botline(wp)$/;"	f	file:
comp_char_differs	screen.c	/^comp_char_differs(off_from, off_to)$/;"	f	file:
comp_col	option.c	/^comp_col()$/;"	f
comp_textwidth	edit.c	/^comp_textwidth(ff)$/;"	f
compat_hashtab	eval.c	/^static hashtab_T	compat_hashtab;$/;"	v	file:
compatible_set	option.c	/^compatible_set()$/;"	f	file:
compile_cap_prog	option.c	/^compile_cap_prog(buf)$/;"	f	file:
compitem_S	spell.c	/^typedef struct compitem_S$/;"	s	file:
compitem_T	spell.c	/^} compitem_T;$/;"	t	typeref:struct:compitem_S	file:
compl_S	edit.c	/^struct compl_S$/;"	s	file:
compl_T	edit.c	/^typedef struct compl_S compl_T;$/;"	t	typeref:struct:compl_S	file:
compl_col	edit.c	/^static colnr_T	  compl_col = 0;	    \/* column where the text starts$/;"	v	file:
compl_cont_mode	edit.c	/^static int	  compl_cont_mode = 0;$/;"	v	file:
compl_cont_status	globals.h	/^EXTERN int	compl_cont_status INIT(= 0);$/;"	v
compl_curr_match	edit.c	/^static compl_T    *compl_curr_match = NULL;$/;"	v	file:
compl_direction	edit.c	/^static int	  compl_direction = FORWARD;$/;"	v	file:
compl_enter_selects	edit.c	/^static int	  compl_enter_selects = FALSE;$/;"	v	file:
compl_first_match	edit.c	/^static compl_T    *compl_first_match = NULL;$/;"	v	file:
compl_get_longest	edit.c	/^static int	  compl_get_longest = FALSE;	\/* put longest common string$/;"	v	file:
compl_interrupted	globals.h	/^EXTERN int	compl_interrupted INIT(= FALSE);$/;"	v
compl_leader	edit.c	/^static char_u	  *compl_leader = NULL;$/;"	v	file:
compl_length	globals.h	/^EXTERN int	compl_length INIT(= 0);$/;"	v
compl_match_array	edit.c	/^static pumitem_T *compl_match_array = NULL;$/;"	v	file:
compl_match_arraysize	edit.c	/^static int compl_match_arraysize;$/;"	v	file:
compl_matches	edit.c	/^static int	  compl_matches = 0;$/;"	v	file:
compl_orig_text	edit.c	/^static char_u	  *compl_orig_text = NULL;  \/* text as it was before$/;"	v	file:
compl_pattern	edit.c	/^static char_u	  *compl_pattern = NULL;$/;"	v	file:
compl_pending	edit.c	/^static int	  compl_pending = 0;	    \/* > 1 for postponed CTRL-N *\/$/;"	v	file:
compl_restarting	edit.c	/^static int	  compl_restarting = FALSE;	\/* don't insert match *\/$/;"	v	file:
compl_shown_match	edit.c	/^static compl_T    *compl_shown_match = NULL;$/;"	v	file:
compl_shows_dir	edit.c	/^static int	  compl_shows_dir = FORWARD;$/;"	v	file:
compl_started	edit.c	/^static int	  compl_started = FALSE;$/;"	v	file:
compl_startpos	edit.c	/^static pos_T	  compl_startpos;$/;"	v	file:
compl_used_match	edit.c	/^static int	  compl_used_match;	\/* Selected one of the matches.  When$/;"	v	file:
compl_was_interrupted	edit.c	/^static int	  compl_was_interrupted = FALSE;  \/* didn't finish finding$/;"	v	file:
compl_xp	edit.c	/^static expand_T	  compl_xp;$/;"	v	file:
composing_hangul	globals.h	/^EXTERN int		composing_hangul INIT(= 0);$/;"	v
composing_hangul_buffer	globals.h	/^EXTERN char_u		composing_hangul_buffer[5];$/;"	v
compound_text_atom	gui_gtk_x11.c	/^static GdkAtom compound_text_atom = GDK_NONE;$/;"	v	file:
compound_text_atom	ui.c	/^static Atom	compound_text_atom;$/;"	v	file:
compress_added	spell.c	/^static long compress_added = 500000;	\/* word count *\/$/;"	v	file:
compress_inc	spell.c	/^static long compress_inc = 100;		\/* memory \/ SBLOCKSIZE *\/$/;"	v	file:
compress_start	spell.c	/^static long compress_start = 30000;	\/* memory \/ SBLOCKSIZE *\/$/;"	v	file:
computeIndex	workshop.c	/^computeIndex($/;"	f	file:
compute_cmdrow	ex_getln.c	/^compute_cmdrow()$/;"	f
comvow2	hangulin.c	/^comvow2(v, c)$/;"	f	file:
comvow3	hangulin.c	/^comvow3(v, c)$/;"	f	file:
concat_esc	gui.c	/^concat_esc(gap, text, what)$/;"	f	file:
concat_fnames	misc1.c	/^concat_fnames(fname1, fname2, sep)$/;"	f
concat_str	misc1.c	/^concat_str(str1, str2)$/;"	f
condstack	structs.h	/^struct condstack$/;"	s
configure_serial	gui_gtk_f.h	/^    gulong configure_serial;$/;"	m	struct:_GtkForm
confirm	structs.h	/^    int		confirm;		\/* TRUE to invoke yes\/no dialog *\/$/;"	m	struct:__anon83
confirm_msg	message.c	/^static char_u	*confirm_msg = NULL;		\/* ":confirm" message *\/$/;"	v	file:
confirm_msg_tail	message.c	/^static char_u	*confirm_msg_tail;		\/* tail of confirm_msg *\/$/;"	v	file:
confirm_msg_used	message.c	/^static int	confirm_msg_used = FALSE;	\/* displaying confirm_msg *\/$/;"	v	file:
cont_in_list	structs.h	/^    short	*cont_in_list;	\/* cont.in group IDs, if non-zero *\/$/;"	m	struct:sp_syn
cont_in_list	syntax.c	/^    short	*cont_in_list;	\/* group IDs for "containedin" argument *\/$/;"	m	struct:__anon58	file:
cont_list	syntax.c	/^    short	*cont_list;	\/* group IDs for "contains" argument *\/$/;"	m	struct:__anon58	file:
container	gui_gtk_f.h	/^    GtkContainer container;$/;"	m	struct:_GtkForm
conthere	quickfix.c	/^    int		    conthere;	\/* %> used *\/$/;"	m	struct:efm_S	file:
conv	ex_cmds2.c	/^    vimconv_T	conv;		\/* type of conversion *\/$/;"	m	struct:source_cookie	file:
conv_to_pstd	farsi.c	/^conv_to_pstd()$/;"	f
conv_to_pvim	farsi.c	/^conv_to_pvim()$/;"	f
convertStruct	mbyte.c	/^} convertStruct;$/;"	t	typeref:struct:__anon42	file:
convert_3_to_code	hangulin.c	/^#define convert_3_to_code /;"	d	file:
convert_3_to_ks	hangulin.c	/^convert_3_to_ks(fv, mv, lv, des)$/;"	f	file:
convert_input	mbyte.c	/^convert_input(ptr, len, maxlen)$/;"	f
convert_input_safe	mbyte.c	/^convert_input_safe(ptr, len, maxlen, restp, restlenp)$/;"	f
convert_ks_to_3	hangulin.c	/^convert_ks_to_3(src, fp, mp, lp)$/;"	f	file:
convert_localized_message	gui_gtk.c	/^convert_localized_message(char_u **buffer, const char *message)$/;"	f	file:
convert_setup	mbyte.c	/^convert_setup(vcp, from, to)$/;"	f
cookie	ex_cmds.h	/^    void	*cookie;	\/* argument for getline() *\/$/;"	m	struct:exarg
cookie	ex_docmd.c	/^    void	*cookie;$/;"	m	struct:loop_cookie	file:
copyFoldingState	fold.c	/^copyFoldingState(wp_from, wp_to)$/;"	f
copy_char	message.c	/^copy_char(from, to, lowercase)$/;"	f	file:
copy_chars	misc2.c	/^copy_chars(ptr, count, c)$/;"	f
copy_id_list	syntax.c	/^copy_id_list(list)$/;"	f	file:
copy_indent	misc1.c	/^copy_indent(size, src)$/;"	f	file:
copy_jumplist	mark.c	/^copy_jumplist(from, to)$/;"	f
copy_loclist	quickfix.c	/^copy_loclist(from, to)$/;"	f
copy_option_part	misc2.c	/^copy_option_part(option, buf, maxlen, sep_chars)$/;"	f
copy_redo	getchar.c	/^copy_redo(old_redo)$/;"	f	file:
copy_spaces	misc2.c	/^copy_spaces(ptr, count)$/;"	f
copy_text_attr	screen.c	/^copy_text_attr(off, buf, len, attr)$/;"	f	file:
copy_tv	eval.c	/^copy_tv(from, to)$/;"	f	file:
copy_viminfo_marks	mark.c	/^copy_viminfo_marks(virp, fp_out, count, eof)$/;"	f
copy_winopt	option.c	/^copy_winopt(from, to)$/;"	f
copy_yank_reg	ops.c	/^copy_yank_reg(reg)$/;"	f	file:
core	gui_at_sb.h	/^    CorePart		core;$/;"	m	struct:_ScrollbarRec
core	gui_xmebwp.h	/^    CorePart core;$/;"	m	struct:_XmEnhancedButtonRec
core_class	gui_at_sb.h	/^    CoreClassPart		core_class;$/;"	m	struct:_ScrollbarClassRec
core_class	gui_xmebwp.h	/^    CoreClassPart core_class;$/;"	m	struct:__anon67
corr_ind_maxparen	misc1.c	/^corr_ind_maxparen(ind_maxparen, startpos)$/;"	f	file:
correct_cmdspos	ex_getln.c	/^correct_cmdspos(idx, cells)$/;"	f	file:
correct_range	ex_docmd.c	/^correct_range(eap)$/;"	f	file:
count	gui_at_sb.c	/^    int count;$/;"	m	struct:EventData	file:
count	regexp.c	/^    long	count;$/;"	m	struct:regstar_S	file:
count0	structs.h	/^    long	count0;		\/* count before command, default 0 *\/$/;"	m	struct:cmdarg_S
count1	structs.h	/^    long	count1;		\/* count before command, default 1 *\/$/;"	m	struct:cmdarg_S
count_and_decode_uri_list	gui_gtk_x11.c	/^count_and_decode_uri_list(char_u *out, char_u *raw, int len)$/;"	f	file:
count_changed_buffers	netbeans.c	/^count_changed_buffers(void)$/;"	f	file:
count_cluster_cells	gui_gtk_x11.c	/^count_cluster_cells(char_u *s, PangoItem *item,$/;"	f	file:
count_common_word	spell.c	/^count_common_word(lp, word, len, count)$/;"	f	file:
count_syllables	spell.c	/^count_syllables(slang, word)$/;"	f	file:
cp_flags	edit.c	/^    int		cp_flags;	\/* ORIGINAL_TEXT, CONT_S_IPOS or FREE_FNAME *\/$/;"	m	struct:compl_S	file:
cp_fname	edit.c	/^    char_u	*cp_fname;	\/* file containing the match, allocated when$/;"	m	struct:compl_S	file:
cp_icase	edit.c	/^    char	cp_icase;	\/* TRUE or FALSE: ignore case *\/$/;"	m	struct:compl_S	file:
cp_next	edit.c	/^    compl_T	*cp_next;$/;"	m	struct:compl_S	file:
cp_number	edit.c	/^    int		cp_number;	\/* sequence number *\/$/;"	m	struct:compl_S	file:
cp_prev	edit.c	/^    compl_T	*cp_prev;$/;"	m	struct:compl_S	file:
cp_str	edit.c	/^    char_u	*cp_str;	\/* matched text *\/$/;"	m	struct:compl_S	file:
cp_text	edit.c	/^    char_u	*(cp_text[CPT_COUNT]);	\/* text for the menu *\/$/;"	m	struct:compl_S	file:
crc_32_tab	misc2.c	/^static ulg crc_32_tab[256];$/;"	v	file:
createBalloonEvalWindow	gui_beval.c	/^createBalloonEvalWindow(BalloonEval *beval)$/;"	f	file:
createBalloonEvalWindow	gui_beval.c	/^createBalloonEvalWindow(beval)$/;"	f	file:
createXpmImages	gui_athena.c	/^createXpmImages(path, xpm, sen)$/;"	f	file:
create_blank_pointer	gui_gtk_x11.c	/^create_blank_pointer(void)$/;"	f	file:
create_image_button	gui_gtk.c	/^create_image_button(const char *stock_id, const char *label)$/;"	f	file:
create_menu_icon	gui_gtk.c	/^create_menu_icon(vimmenu_T *menu, GtkIconSize icon_size)$/;"	f	file:
create_message_dialog	gui_gtk.c	/^create_message_dialog(int type, char_u *title, char_u *message)$/;"	f	file:
create_pixmap_label	gui_motif.c	/^create_pixmap_label(parent, name, data, args, arg)$/;"	f	file:
create_tabline_menu	gui_gtk_x11.c	/^create_tabline_menu(void)$/;"	f	file:
create_windows	main.c	/^create_windows(parmp)$/;"	f	file:
crv_status	term.c	/^static int crv_status = CRV_GET;$/;"	v	file:
crypt_init_keys	misc2.c	/^crypt_init_keys(passwd)$/;"	f
cs_add	if_cscope.c	/^cs_add(eap)$/;"	f	file:
cs_add_common	if_cscope.c	/^cs_add_common(arg1, arg2, flags)$/;"	f	file:
cs_check_for_connections	if_cscope.c	/^cs_check_for_connections()$/;"	f	file:
cs_check_for_tags	if_cscope.c	/^cs_check_for_tags()$/;"	f	file:
cs_cmds	if_cscope.c	/^static cscmd_T	    cs_cmds[] =$/;"	v	file:
cs_cnt_connections	if_cscope.c	/^cs_cnt_connections()$/;"	f	file:
cs_cnt_matches	if_cscope.c	/^cs_cnt_matches(idx)$/;"	f	file:
cs_connection	if_cscope.c	/^cs_connection(num, dbpath, ppath)$/;"	f
cs_create_cmd	if_cscope.c	/^cs_create_cmd(csoption, pattern)$/;"	f	file:
cs_create_connection	if_cscope.c	/^cs_create_connection(i)$/;"	f	file:
cs_emsg_silent_list	structs.h	/^    eslist_T	*cs_emsg_silent_list;	\/* saved values of "emsg_silent" *\/$/;"	m	struct:condstack
cs_end	if_cscope.c	/^cs_end()$/;"	f
cs_exception	structs.h	/^# define cs_exception	/;"	d
cs_fgets	if_cscope.c	/^cs_fgets(buf, size)$/;"	f
cs_file_results	if_cscope.c	/^cs_file_results(f, nummatches_a)$/;"	f	file:
cs_fill_results	if_cscope.c	/^cs_fill_results(tagstr, totmatches, nummatches_a, matches_p, cntxts_p, matched)$/;"	f	file:
cs_find	if_cscope.c	/^cs_find(eap)$/;"	f	file:
cs_find_common	if_cscope.c	/^cs_find_common(opt, pat, forceit, verbose, use_ll)$/;"	f	file:
cs_flags	structs.h	/^    short	cs_flags[CSTACK_LEN];	\/* CSF_ flags *\/$/;"	m	struct:condstack
cs_forinfo	structs.h	/^    void	*cs_forinfo[CSTACK_LEN]; \/* info used by ":for" *\/$/;"	m	struct:condstack
cs_free_tags	if_cscope.c	/^cs_free_tags()$/;"	f
cs_help	if_cscope.c	/^cs_help(eap)$/;"	f	file:
cs_idx	structs.h	/^    int		cs_idx;			\/* current entry, or -1 if none *\/$/;"	m	struct:condstack
cs_init	if_cscope.c	/^cs_init()$/;"	f	file:
cs_insert_filelist	if_cscope.c	/^cs_insert_filelist(fname, ppath, flags, sb)$/;"	f	file:
cs_kill	if_cscope.c	/^cs_kill(eap)$/;"	f	file:
cs_kill_execute	if_cscope.c	/^cs_kill_execute(i, cname)$/;"	f	file:
cs_lflags	structs.h	/^    char	cs_lflags;		\/* loop flags: CSL_ flags *\/$/;"	m	struct:condstack
cs_line	structs.h	/^    int		cs_line[CSTACK_LEN];	\/* line nr of ":while"\/":for" line *\/$/;"	m	struct:condstack
cs_lookup_cmd	if_cscope.c	/^cs_lookup_cmd(eap)$/;"	f	file:
cs_looplevel	structs.h	/^    int		cs_looplevel;		\/* nr of nested ":while"s and ":for"s *\/$/;"	m	struct:condstack
cs_make_vim_style_matches	if_cscope.c	/^cs_make_vim_style_matches(fname, slno, search, tagstr)$/;"	f	file:
cs_manage_matches	if_cscope.c	/^cs_manage_matches(matches, contexts, totmatches, cmd)$/;"	f	file:
cs_parse_results	if_cscope.c	/^cs_parse_results(cnumber, buf, bufsize, context, linenumber, search)$/;"	f	file:
cs_pathcomponents	if_cscope.c	/^cs_pathcomponents(path)$/;"	f	file:
cs_pend	structs.h	/^    }		cs_pend;$/;"	m	struct:condstack	typeref:union:condstack::__anon84
cs_pending	structs.h	/^    char	cs_pending[CSTACK_LEN];	\/* CSTP_: what's pending in ":finally"*\/$/;"	m	struct:condstack
cs_print_tags	if_cscope.c	/^cs_print_tags()$/;"	f
cs_print_tags_priv	if_cscope.c	/^cs_print_tags_priv(matches, cntxts, num_matches)$/;"	f	file:
cs_read_prompt	if_cscope.c	/^cs_read_prompt(i)$/;"	f	file:
cs_reading_emsg	if_cscope.c	/^cs_reading_emsg(idx)$/;"	f	file:
cs_release_csp	if_cscope.c	/^cs_release_csp(i, freefnpp)$/;"	f	file:
cs_reset	if_cscope.c	/^cs_reset(eap)$/;"	f	file:
cs_resolve_file	if_cscope.c	/^cs_resolve_file(i, name)$/;"	f	file:
cs_rettv	structs.h	/^# define cs_rettv	/;"	d
cs_show	if_cscope.c	/^cs_show(eap)$/;"	f	file:
cs_stat_emsg	if_cscope.c	/^cs_stat_emsg(fname)$/;"	f	file:
cs_trylevel	structs.h	/^    int		cs_trylevel;		\/* nr of nested ":try"s *\/$/;"	m	struct:condstack
cs_usage_msg	if_cscope.c	/^cs_usage_msg(x)$/;"	f	file:
cscmd_T	if_cscope.h	/^} cscmd_T;$/;"	t	typeref:struct:__anon68
csh_like_shell	misc2.c	/^csh_like_shell()$/;"	f
csi	if_cscope.h	/^typedef struct csi {$/;"	s
csid_e	if_cscope.h	/^typedef enum { Add, Find, Help, Kill, Reset, Show } csid_e;$/;"	t	typeref:enum:__anon69
csinfo	if_cscope.c	/^static csinfo_T	    csinfo[CSCOPE_MAX_CONNECTIONS];$/;"	v	file:
csinfo_T	if_cscope.h	/^} csinfo_T;$/;"	t	typeref:struct:csi
csp_ex	structs.h	/^	void	*csp_ex[CSTACK_LEN];	\/* exception for pending throw *\/$/;"	m	union:condstack::__anon84
csp_rv	structs.h	/^	void	*csp_rv[CSTACK_LEN];	\/* return typeval for pending return *\/$/;"	m	union:condstack::__anon84
cstack	ex_cmds.h	/^    struct condstack *cstack;	\/* condition stack for ":if" etc. *\/$/;"	m	struct:exarg	typeref:struct:exarg::condstack
cstrchr	regexp.c	/^cstrchr(s, c)$/;"	f	file:
cstrncmp	regexp.c	/^cstrncmp(s1, s2, n)$/;"	f	file:
cterm	structs.h	/^	} cterm;$/;"	m	union:attr_entry::__anon86	typeref:struct:attr_entry::__anon86::__anon88
cterm_attr_table	syntax.c	/^static garray_T	cterm_attr_table = {0, 0, 0, 0, NULL};$/;"	v	file:
cterm_color_16	hardcopy.c	/^static const long_u  cterm_color_16[16] =$/;"	v	file:
cterm_color_8	hardcopy.c	/^static const long_u  cterm_color_8[8] =$/;"	v	file:
cterm_normal_bg_color	globals.h	/^EXTERN int	cterm_normal_bg_color INIT(= 0);$/;"	v
cterm_normal_fg_bold	globals.h	/^EXTERN int	cterm_normal_fg_bold INIT(= 0);$/;"	v
cterm_normal_fg_color	globals.h	/^EXTERN int	cterm_normal_fg_color INIT(= 0);$/;"	v
ctrl_c_interrupts	globals.h	/^EXTERN int	ctrl_c_interrupts INIT(= TRUE);	\/* CTRL-C sets got_int *\/$/;"	v
ctrl_x_mode	globals.h	/^EXTERN int	ctrl_x_mode INIT(= 0);	\/* Which Ctrl-X mode are we in? *\/$/;"	v
ctrl_x_msgs	edit.c	/^static char *ctrl_x_msgs[] =$/;"	v	file:
curMenuName	workshop.c	/^char		 curMenuName[BUFSIZ];$/;"	v
curMenuPriority	workshop.c	/^char		 curMenuPriority[BUFSIZ];$/;"	v
curPCtype	netbeans.c	/^static int curPCtype = -1;$/;"	v	file:
cur_fnum	structs.h	/^    int		cur_fnum;	\/* buffer number used for cur_match *\/$/;"	m	struct:taggy
cur_match	structs.h	/^    int		cur_match;	\/* match number *\/$/;"	m	struct:taggy
cur_tmode	globals.h	/^EXTERN int	cur_tmode INIT(= TMODE_COOK);	\/* input terminal mode *\/$/;"	v
curbuf	globals.h	/^EXTERN buf_T	*curbuf INIT(= NULL);	\/* currently active buffer *\/$/;"	v
curbuf	if_tcl.c	/^    char *curbuf, *curwin;$/;"	m	struct:__anon37	file:
curbufIsChanged	undo.c	/^curbufIsChanged()$/;"	f
curbuf_lock	globals.h	/^EXTERN int	curbuf_lock INIT(= 0);$/;"	v
curbuf_locked	ex_getln.c	/^curbuf_locked()$/;"	f
curchr	regexp.c	/^static int	curchr;$/;"	v	file:
curerr	if_mzsch.c	/^static Scheme_Object *curerr = NULL;$/;"	v	file:
curout	if_mzsch.c	/^static Scheme_Object *curout = NULL;$/;"	v	file:
curpat	fileio.c	/^    AutoPat	*curpat;	\/* next AutoPat to examine *\/$/;"	m	struct:AutoPatCmd	file:
currBgColor	gui.h	/^    guicolor_T	currBgColor;	    \/* Current background text color *\/$/;"	m	struct:Gui
currFgColor	gui.h	/^    guicolor_T	currFgColor;	    \/* Current foreground text color *\/$/;"	m	struct:Gui
currFont	gui.h	/^    GuiFont	currFont;	    \/* Current font *\/$/;"	m	struct:Gui
currSpColor	gui.h	/^    guicolor_T	currSpColor;	    \/* Current special text color *\/$/;"	m	struct:Gui
curr_bg	hardcopy.c	/^static long_u	curr_bg;$/;"	v	file:
curr_bold	hardcopy.c	/^static int	curr_bold;$/;"	v	file:
curr_fg	hardcopy.c	/^static long_u	curr_fg;$/;"	v	file:
curr_italic	hardcopy.c	/^static int	curr_italic;$/;"	v	file:
curr_tmode	os_unix.c	/^static int curr_tmode = TMODE_COOK;	\/* contains current terminal mode *\/$/;"	v	file:
curr_underline	hardcopy.c	/^static int	curr_underline;$/;"	v	file:
current_SID	globals.h	/^EXTERN scid_T	current_SID INIT(= 0);$/;"	v
current_ScreenLine	screen.c	/^static schar_T	*current_ScreenLine;$/;"	v	file:
current_attr	syntax.c	/^static int current_attr = 0;	    \/* attr of current syntax word *\/$/;"	v	file:
current_augroup	fileio.c	/^static int current_augroup = AUGROUP_DEFAULT;$/;"	v	file:
current_beval	gui_beval.c	/^static BalloonEval *current_beval = NULL;$/;"	v	file:
current_block	search.c	/^current_block(oap, count, include, what, other)$/;"	f
current_col	syntax.c	/^static colnr_T	current_col = 0;	\/* column of current state *\/$/;"	v	file:
current_copyID	eval.c	/^static int current_copyID = 0;$/;"	v	file:
current_exception	ex_docmd.c	/^    except_T	*current_exception;$/;"	m	struct:dbg_stuff	file:
current_exception	globals.h	/^EXTERN except_T *current_exception;$/;"	v
current_finished	syntax.c	/^static int	current_finished = 0;	\/* current line has been finished *\/$/;"	v	file:
current_font	gui.h	/^    GuiFont	current_font;$/;"	m	struct:Gui
current_fontset	gui_x11.c	/^static XFontSet current_fontset = NULL;$/;"	v	file:
current_func_returned	eval.c	/^current_func_returned()$/;"	f
current_funccal	eval.c	/^funccall_T *current_funccal = NULL;$/;"	v
current_id	syntax.c	/^static int current_id = 0;	    \/* ID of current char for syn_get_id() *\/$/;"	v	file:
current_line	ex_docmd.c	/^    int		current_line;		\/* last read line from growarray *\/$/;"	m	struct:loop_cookie	file:
current_line_id	syntax.c	/^static int	current_line_id = 0;	\/* unique number for current line *\/$/;"	v	file:
current_line_number	if_ruby.c	/^static VALUE current_line_number()$/;"	f	file:
current_lnum	syntax.c	/^static linenr_T current_lnum = 0;	\/* lnum of current state *\/$/;"	v	file:
current_menu	globals.h	/^EXTERN vimmenu_T	*current_menu;$/;"	v
current_next_flags	syntax.c	/^static int	current_next_flags = 0; \/* flags for current_next_list *\/$/;"	v	file:
current_next_list	syntax.c	/^static short	*current_next_list = NULL; \/* when non-zero, nextgroup list *\/$/;"	v	file:
current_par	search.c	/^current_par(oap, count, include, type)$/;"	f
current_quote	search.c	/^current_quote(oap, count, include, quotechar)$/;"	f
current_scrollbar	globals.h	/^EXTERN int	current_scrollbar;$/;"	v
current_sent	search.c	/^current_sent(oap, count, include)$/;"	f
current_state	syntax.c	/^static garray_T current_state		\/* current stack of state_items *\/$/;"	v	file:
current_state_stored	syntax.c	/^static int	current_state_stored = 0; \/* TRUE if stored current state$/;"	v	file:
current_syn_id	hardcopy.c	/^static int		current_syn_id;$/;"	v	file:
current_syn_inc_tag	syntax.c	/^static int current_syn_inc_tag = 0;$/;"	v	file:
current_tab	globals.h	/^EXTERN int	    current_tab;$/;"	v
current_tabmenu	globals.h	/^EXTERN int	    current_tabmenu;$/;"	v
current_tagblock	search.c	/^current_tagblock(oap, count_arg, include)$/;"	f
current_trans_id	syntax.c	/^static int current_trans_id = 0;    \/* idem, transparancy removed *\/$/;"	v	file:
current_word	search.c	/^current_word(oap, count, include, bigword)$/;"	f
curs_columns	move.c	/^curs_columns(scroll)$/;"	f
curs_rows	move.c	/^curs_rows(wp, do_botline)$/;"	f	file:
curscript	globals.h	/^EXTERN int	curscript INIT(= 0);	    \/* index in scriptin[] *\/$/;"	v
cursor_col	gui.h	/^    int		cursor_col;	    \/* Physical cursor column in GUI display *\/$/;"	m	struct:Gui
cursor_correct	move.c	/^cursor_correct()$/;"	f
cursor_down	edit.c	/^cursor_down(n, upd_topline)$/;"	f
cursor_entry	structs.h	/^typedef struct cursor_entry$/;"	s
cursor_is_off	term.c	/^static int cursor_is_off = FALSE;$/;"	v	file:
cursor_is_valid	gui.h	/^    char	cursor_is_valid;    \/* There is a cursor at cursor_row\/col *\/$/;"	m	struct:Gui
cursor_off	term.c	/^cursor_off()$/;"	f
cursor_on	term.c	/^cursor_on()$/;"	f
cursor_pos_info	ops.c	/^cursor_pos_info()$/;"	f
cursor_row	gui.h	/^    int		cursor_row;	    \/* Physical cursor row in GUI display *\/$/;"	m	struct:Gui
cursor_start	structs.h	/^    pos_T	cursor_start;	\/* cursor position before motion for "gw" *\/$/;"	m	struct:oparg_S
cursor_up	edit.c	/^cursor_up(n, upd_topline)$/;"	f
cursor_valid	move.c	/^cursor_valid()$/;"	f
cursorcmd	ex_getln.c	/^cursorcmd()$/;"	f	file:
cursorentry_T	structs.h	/^} cursorentry_T;$/;"	t	typeref:struct:cursor_entry
curtab	globals.h	/^EXTERN tabpage_T    *curtab;$/;"	v
curwin	globals.h	/^EXTERN win_T	*curwin;	\/* currently active window *\/$/;"	v
curwin	if_tcl.c	/^    char *curbuf, *curwin;$/;"	m	struct:__anon37	file:
curwin_col_off	move.c	/^curwin_col_off()$/;"	f
curwin_col_off2	move.c	/^curwin_col_off2()$/;"	f
curwin_init	window.c	/^curwin_init()$/;"	f
darken_rgb	hardcopy.c	/^darken_rgb(rgb)$/;"	f	file:
data	if_mzsch.c	/^    void	*data;$/;"	m	struct:__anon25	file:
data_block	memline.c	/^struct data_block$/;"	s	file:
db_free	memline.c	/^    unsigned	db_free;	\/* free space available *\/$/;"	m	struct:data_block	file:
db_id	memline.c	/^    short_u	db_id;		\/* ID for data block: DATA_ID *\/$/;"	m	struct:data_block	file:
db_index	memline.c	/^    unsigned	db_index[1];	\/* index for start of line (actually bigger)$/;"	m	struct:data_block	file:
db_line_count	memline.c	/^    linenr_T	db_line_count;	\/* number of lines in this block *\/$/;"	m	struct:data_block	file:
db_txt_end	memline.c	/^    unsigned	db_txt_end;	\/* byte just after data block *\/$/;"	m	struct:data_block	file:
db_txt_start	memline.c	/^    unsigned	db_txt_start;	\/* byte where text starts *\/$/;"	m	struct:data_block	file:
dbcs_char2bytes	mbyte.c	/^dbcs_char2bytes(c, buf)$/;"	f	file:
dbcs_char2cells	mbyte.c	/^dbcs_char2cells(c)$/;"	f	file:
dbcs_char2len	mbyte.c	/^dbcs_char2len(c)$/;"	f	file:
dbcs_class	mbyte.c	/^dbcs_class(lead, trail)$/;"	f
dbcs_head_off	mbyte.c	/^dbcs_head_off(base, p)$/;"	f
dbcs_off2cells	mbyte.c	/^dbcs_off2cells(off, max_off)$/;"	f
dbcs_ptr2cells	mbyte.c	/^dbcs_ptr2cells(p)$/;"	f
dbcs_ptr2char	mbyte.c	/^dbcs_ptr2char(p)$/;"	f	file:
dbcs_ptr2len	mbyte.c	/^dbcs_ptr2len(p)$/;"	f	file:
dbcs_screen_head_off	mbyte.c	/^dbcs_screen_head_off(base, p)$/;"	f
dbcs_screen_tail_off	mbyte.c	/^dbcs_screen_tail_off(base, p)$/;"	f
dbg_breakp	ex_cmds2.c	/^static garray_T dbg_breakp = {0, 0, sizeof(struct debuggy), 4, NULL};$/;"	v	file:
dbg_breakpoint	ex_cmds2.c	/^dbg_breakpoint(name, lnum)$/;"	f
dbg_check_breakpoint	ex_cmds2.c	/^dbg_check_breakpoint(eap)$/;"	f
dbg_check_skipped	ex_cmds2.c	/^dbg_check_skipped(eap)$/;"	f
dbg_find_breakpoint	ex_cmds2.c	/^dbg_find_breakpoint(file, fname, after)$/;"	f
dbg_forceit	ex_cmds2.c	/^    int		dbg_forceit;	\/* ! used *\/$/;"	m	struct:debuggy	file:
dbg_lnum	ex_cmds2.c	/^    linenr_T	dbg_lnum;	\/* line number in function or file *\/$/;"	m	struct:debuggy	file:
dbg_name	ex_cmds2.c	/^    char_u	*dbg_name;	\/* function or file name *\/$/;"	m	struct:debuggy	file:
dbg_nr	ex_cmds2.c	/^    int		dbg_nr;		\/* breakpoint number *\/$/;"	m	struct:debuggy	file:
dbg_parsearg	ex_cmds2.c	/^dbg_parsearg(arg, gap)$/;"	f	file:
dbg_prog	ex_cmds2.c	/^    regprog_T	*dbg_prog;	\/* regexp program *\/$/;"	m	struct:debuggy	file:
dbg_stuff	ex_docmd.c	/^struct dbg_stuff$/;"	s	file:
dbg_tick	eval.c	/^    int		dbg_tick;	\/* debug_tick when breakpoint was set *\/$/;"	m	struct:funccall_S	file:
dbg_tick	ex_cmds2.c	/^    int		dbg_tick;	\/* debug_tick when breakpoint was set *\/$/;"	m	struct:source_cookie	file:
dbg_type	ex_cmds2.c	/^    int		dbg_type;	\/* DBG_FUNC or DBG_FILE *\/$/;"	m	struct:debuggy	file:
dcbarg_T	gui_motif.c	/^} dcbarg_T;$/;"	t	typeref:struct:dialog_callback_arg	file:
deadly	os_unix.c	/^    char    deadly;	\/* Catch as a deadly signal? *\/$/;"	m	struct:signalinfo	file:
deadly_signal	os_unix.c	/^static int	deadly_signal = 0;	    \/* The signal we caught *\/$/;"	v	file:
debug_break_level	globals.h	/^EXTERN int	debug_break_level INIT(= -1);	\/* break below this level *\/$/;"	v
debug_breakpoint_lnum	ex_cmds2.c	/^static linenr_T	debug_breakpoint_lnum;$/;"	v	file:
debug_breakpoint_name	ex_cmds2.c	/^static char_u	*debug_breakpoint_name = NULL;$/;"	v	file:
debug_did_msg	globals.h	/^EXTERN int	debug_did_msg INIT(= FALSE);	\/* did "debug mode" message *\/$/;"	v
debug_greedy	ex_cmds2.c	/^static int debug_greedy = FALSE;	\/* batch mode debugging: don't save$/;"	v	file:
debug_skipped	ex_cmds2.c	/^static int	debug_skipped;$/;"	v	file:
debug_skipped_name	ex_cmds2.c	/^static char_u	*debug_skipped_name;$/;"	v	file:
debug_tick	globals.h	/^EXTERN int	debug_tick INIT(= 0);		\/* breakpoint change count *\/$/;"	v
debuggy	ex_cmds2.c	/^struct debuggy$/;"	s	file:
debuggy_find	ex_cmds2.c	/^debuggy_find(file, fname, after, gap, fp)$/;"	f	file:
dec	misc2.c	/^dec(lp)$/;"	f
dec_cursor	misc2.c	/^dec_cursor()$/;"	f
decl	misc2.c	/^decl(lp)$/;"	f
decomp_T	regexp.c	/^} decomp_T;$/;"	t	typeref:struct:__anon52	file:
decomp_table	regexp.c	/^static decomp_T decomp_table[0xfb4f-0xfb20+1] =$/;"	v	file:
decrypt_byte	misc2.c	/^decrypt_byte()$/;"	f
def_back_pixel	gui.h	/^    guicolor_T	def_back_pixel;	    \/* default Color of background *\/$/;"	m	struct:Gui
def_norm_pixel	gui.h	/^    guicolor_T	def_norm_pixel;	    \/* default Color of normal text *\/$/;"	m	struct:Gui
def_val	option.c	/^    char_u	*def_val[2];	\/* default values for variable (vi and vim) *\/$/;"	m	struct:vimoption	file:
defaultTranslations	gui_at_sb.c	/^static char defaultTranslations[] =$/;"	v	file:
default_fileformat	misc2.c	/^default_fileformat()$/;"	f
default_shape_engine	gui_gtk_x11.c	/^static PangoEngineShape *default_shape_engine = NULL;$/;"	v	file:
defcs	hardcopy.c	/^    char			*defcs;$/;"	m	struct:prt_ps_mbfont_S	file:
del_bytes	misc1.c	/^del_bytes(count, fixpos_arg, use_delcombine)$/;"	f
del_char	misc1.c	/^del_char(fixpos)$/;"	f
del_chars	misc1.c	/^del_chars(count, fixpos)$/;"	f
del_from_showcmd	normal.c	/^del_from_showcmd(len)$/;"	f	file:
del_history_entry	ex_getln.c	/^del_history_entry(histype, str)$/;"	f
del_history_idx	ex_getln.c	/^del_history_idx(histype, idx)$/;"	f
del_lines	misc1.c	/^del_lines(nlines, undo)$/;"	f
del_menutrans_vars	eval.c	/^del_menutrans_vars()$/;"	f
del_mouse_termcode	term.c	/^del_mouse_termcode(n)$/;"	f
del_termcode	term.c	/^del_termcode(name)$/;"	f
del_termcode_idx	term.c	/^del_termcode_idx(idx)$/;"	f	file:
del_trailing_spaces	misc2.c	/^del_trailing_spaces(ptr)$/;"	f
del_typebuf	getchar.c	/^del_typebuf(len, offset)$/;"	f
delbuf_msg	ex_cmds.c	/^delbuf_msg(name)$/;"	f	file:
delcmd	if_tcl.c	/^    Tcl_Obj	*delcmd;    \/* Tcl command to call when object is being del. *\/$/;"	m	struct:ref	file:
deleteFold	fold.c	/^deleteFold(start, end, recursive, had_visual)$/;"	f
deleteFoldEntry	fold.c	/^deleteFoldEntry(gap, idx, recursive)$/;"	f	file:
deleteFoldMarkers	fold.c	/^deleteFoldMarkers(fp, recursive, lnum_off)$/;"	f	file:
deleteFoldRecurse	fold.c	/^deleteFoldRecurse(gap)$/;"	f
delete_event_cb	gui_gtk_x11.c	/^delete_event_cb(GtkWidget *widget, GdkEventAny *event, gpointer data)$/;"	f	file:
delete_first_msg	message.c	/^delete_first_msg()$/;"	f
delete_var	eval.c	/^delete_var(ht, hi)$/;"	f	file:
deleted_lines	misc1.c	/^deleted_lines(lnum, count)$/;"	f
deleted_lines_mark	misc1.c	/^deleted_lines_mark(lnum, count)$/;"	f
delref	if_tcl.c	/^delref(cref)$/;"	f	file:
deref_func_name	eval.c	/^deref_func_name(name, lenp)$/;"	f	file:
deref_wordnode	spell.c	/^deref_wordnode(spin, node)$/;"	f	file:
detected_8bit	term.c	/^static int  detected_8bit = FALSE;	\/* detected 8-bit terminal *\/$/;"	v	file:
dev_T	buffer.c	/^# define dev_T /;"	d	file:
df_count	structs.h	/^    linenr_T	df_count[DB_COUNT];	\/* nr of inserted\/changed lines *\/$/;"	m	struct:diffblock_S
df_lnum	structs.h	/^    linenr_T	df_lnum[DB_COUNT];	\/* line number in buffer *\/$/;"	m	struct:diffblock_S
df_next	structs.h	/^    diff_T	*df_next;$/;"	m	struct:diffblock_S
dfd	integration.c	/^static FILE *dfd;$/;"	v	file:
di_flags	structs.h	/^    char_u	di_flags;	\/* flags (only used for variable) *\/$/;"	m	struct:dictitem_S
di_key	structs.h	/^    char_u	di_key[1];	\/* key (actually longer!) *\/$/;"	m	struct:dictitem_S
di_tv	structs.h	/^    typval_T	di_tv;		\/* type and value of the variable *\/$/;"	m	struct:dictitem_S
dialog	gui_gtk.c	/^    GtkDialog	*dialog;	    \/* Widget of the dialog *\/$/;"	m	struct:_DialogInfo	file:
dialog	gui_gtk.c	/^    GtkWidget	*dialog;$/;"	m	struct:_ButtonData	file:
dialog	gui_gtk.c	/^    GtkWidget	*dialog;$/;"	m	struct:_CancelData	file:
dialog	gui_gtk.c	/^    GtkWidget *dialog;	\/* the main dialog widget *\/$/;"	m	struct:_SharedFindReplace	file:
dialog	gui_motif.c	/^    Widget dialog;	\/* the main dialog widget *\/$/;"	m	struct:_SharedFindReplace	file:
dialog	gui_xmdlg.c	/^    Widget	dialog;$/;"	m	struct:_SharedFontSelData	file:
dialogStatus	gui_athena.c	/^static int	dialogStatus;$/;"	v	file:
dialogStatus	gui_motif.c	/^static int	dialogStatus;$/;"	v	file:
dialog_add_buttons	gui_gtk.c	/^dialog_add_buttons(GtkDialog *dialog, char_u *button_string)$/;"	f	file:
dialog_callback_arg	gui_motif.c	/^typedef struct dialog_callback_arg$/;"	s	file:
dialog_changed	ex_cmds2.c	/^dialog_changed(buf, checkall)$/;"	f
dialog_key_press_event_cb	gui_gtk.c	/^dialog_key_press_event_cb(GtkWidget *widget, GdkEventKey *event, gpointer data)$/;"	f	file:
dialog_msg	ex_docmd.c	/^dialog_msg(buff, format, fname)$/;"	f
dialog_textentry	gui_gtk.c	/^static GtkWidget *dialog_textentry;$/;"	v	file:
dialog_textfield	gui_gtk.c	/^static char_u *dialog_textfield = NULL;$/;"	v	file:
dialog_wgt	gui_motif.c	/^static Widget dialog_wgt;$/;"	v	file:
dialog_wm_handler	gui_athena.c	/^dialog_wm_handler(w, client_data, event, dum)$/;"	f	file:
dialogatom	gui_athena.c	/^static Atom	dialogatom;$/;"	v	file:
dict2string	eval.c	/^dict2string(tv, copyID)$/;"	f	file:
dict_T	structs.h	/^typedef struct dictvar_S dict_T;$/;"	t	typeref:struct:dictvar_S
dict_add	eval.c	/^dict_add(d, item)$/;"	f	file:
dict_add_nr_str	eval.c	/^dict_add_nr_str(d, key, nr, str)$/;"	f
dict_alloc	eval.c	/^dict_alloc()$/;"	f
dict_copy	eval.c	/^dict_copy(orig, deep, copyID)$/;"	f	file:
dict_equal	eval.c	/^dict_equal(d1, d2, ic)$/;"	f	file:
dict_find	eval.c	/^dict_find(d, key, len)$/;"	f	file:
dict_free	eval.c	/^dict_free(d, recurse)$/;"	f	file:
dict_len	eval.c	/^dict_len(d)$/;"	f	file:
dict_list	eval.c	/^dict_list(argvars, rettv, what)$/;"	f	file:
dict_lookup	eval.c	/^dict_lookup(hi)$/;"	f
dict_unref	eval.c	/^dict_unref(d)$/;"	f	file:
dictitem_S	structs.h	/^struct dictitem_S$/;"	s
dictitem_T	structs.h	/^typedef struct dictitem_S dictitem_T;$/;"	t	typeref:struct:dictitem_S
dictitem_alloc	eval.c	/^dictitem_alloc(key)$/;"	f	file:
dictitem_copy	eval.c	/^dictitem_copy(org)$/;"	f	file:
dictitem_free	eval.c	/^dictitem_free(item)$/;"	f	file:
dictitem_remove	eval.c	/^dictitem_remove(dict, item)$/;"	f	file:
dictvar_S	structs.h	/^struct dictvar_S$/;"	s
did_add_space	edit.c	/^static int	did_add_space = FALSE;	\/* auto_format() added an extra space$/;"	v	file:
did_ai	globals.h	/^EXTERN int     did_ai INIT(= FALSE);$/;"	v
did_check_timestamps	globals.h	/^EXTERN int	did_check_timestamps INIT(= FALSE); \/* did check timestamps$/;"	v
did_cursorhold	globals.h	/^EXTERN int	did_cursorhold INIT(= FALSE); \/* set when CursorHold t'gerd *\/$/;"	v
did_emsg	ex_docmd.c	/^    int		did_emsg;$/;"	m	struct:dbg_stuff	file:
did_emsg	globals.h	/^EXTERN int	did_emsg;		    \/* set by emsg() when the message$/;"	v
did_endif	globals.h	/^EXTERN int	did_endif INIT(= FALSE);    \/* just had ":endif" *\/$/;"	v
did_filetype	globals.h	/^EXTERN int	did_filetype INIT(= FALSE);	\/* FileType event found *\/$/;"	v
did_lcd	ex_docmd.c	/^static int	did_lcd;	\/* whether ":lcd" was produced for a session *\/$/;"	v	file:
did_match_already	syntax.c	/^did_match_already(idx, gap)$/;"	f	file:
did_outofmem_msg	globals.h	/^EXTERN int	did_outofmem_msg INIT(= FALSE);$/;"	v
did_restart_edit	edit.c	/^static int	did_restart_edit;	\/* "restart_edit" when calling edit() *\/$/;"	v	file:
did_set_icon	os_unix.c	/^static int	did_set_icon = FALSE;$/;"	v	file:
did_set_option	option.c	/^did_set_option(opt_idx, opt_flags, new_value)$/;"	f	file:
did_set_spelllang	spell.c	/^did_set_spelllang(buf)$/;"	f
did_set_spelltab	spell.c	/^static int	    did_set_spelltab;$/;"	v	file:
did_set_string_option	option.c	/^did_set_string_option(opt_idx, varp, new_value_alloced, oldval, errbuf,$/;"	f	file:
did_set_title	option.c	/^did_set_title(icon)$/;"	f	file:
did_set_title	os_unix.c	/^static int	did_set_title = FALSE;$/;"	v	file:
did_si	globals.h	/^EXTERN int	did_si INIT(= FALSE);$/;"	v
did_swapwrite_msg	globals.h	/^EXTERN int	did_swapwrite_msg INIT(= FALSE);$/;"	v
did_syncbind	globals.h	/^EXTERN int     did_syncbind INIT(= FALSE);$/;"	v
did_throw	ex_docmd.c	/^    int		did_throw;$/;"	m	struct:dbg_stuff	file:
did_throw	globals.h	/^EXTERN int did_throw INIT(= FALSE);$/;"	v
did_wait_return	globals.h	/^EXTERN int	did_wait_return INIT(= FALSE);	\/* wait_return() was used and$/;"	v
didset_options	option.c	/^didset_options()$/;"	f	file:
didset_vim	globals.h	/^EXTERN int	didset_vim INIT(= FALSE);   \/* did set $VIM ourselves *\/$/;"	v
didset_vimruntime	globals.h	/^EXTERN int	didset_vimruntime INIT(= FALSE);   \/* idem for $VIMRUNTIME *\/$/;"	v
diff_T	structs.h	/^typedef struct diffblock_S diff_T;$/;"	t	typeref:struct:diffblock_S
diff_a_works	diff.c	/^static int diff_a_works = MAYBE; \/* TRUE when "diff -a" works, FALSE when it$/;"	v	file:
diff_alloc_new	diff.c	/^diff_alloc_new(tp, dprev, dp)$/;"	f	file:
diff_bin_works	diff.c	/^static int diff_bin_works = MAYBE; \/* TRUE when "diff --binary" works, FALSE$/;"	v	file:
diff_buf_add	diff.c	/^diff_buf_add(buf)$/;"	f
diff_buf_adjust	diff.c	/^diff_buf_adjust(win)$/;"	f
diff_buf_delete	diff.c	/^diff_buf_delete(buf)$/;"	f
diff_buf_idx	diff.c	/^diff_buf_idx(buf)$/;"	f	file:
diff_buf_idx_tp	diff.c	/^diff_buf_idx_tp(buf, tp)$/;"	f	file:
diff_busy	diff.c	/^static int	diff_busy = FALSE;	\/* ex_diffgetput() is busy *\/$/;"	v	file:
diff_check	diff.c	/^diff_check(wp, lnum)$/;"	f
diff_check_fill	diff.c	/^diff_check_fill(wp, lnum)$/;"	f
diff_check_sanity	diff.c	/^diff_check_sanity(tp, dp)$/;"	f	file:
diff_check_unchanged	diff.c	/^diff_check_unchanged(tp, dp)$/;"	f	file:
diff_clear	diff.c	/^diff_clear(tp)$/;"	f
diff_cmp	diff.c	/^diff_cmp(s1, s2)$/;"	f	file:
diff_context	globals.h	/^EXTERN int	diff_context INIT(= 6);		\/* context for folds *\/$/;"	v
diff_copy_entry	diff.c	/^diff_copy_entry(dprev, dp, idx_orig, idx_new)$/;"	f	file:
diff_equal_entry	diff.c	/^diff_equal_entry(dp, idx1, idx2)$/;"	f	file:
diff_file	diff.c	/^diff_file(tmp_orig, tmp_new, tmp_diff)$/;"	f	file:
diff_find_change	diff.c	/^diff_find_change(wp, lnum, startp, endp)$/;"	f
diff_flags	diff.c	/^static int	diff_flags = DIFF_FILLER;$/;"	v	file:
diff_fold_update	diff.c	/^diff_fold_update(dp, skip_idx)$/;"	f	file:
diff_foldcolumn	globals.h	/^EXTERN int	diff_foldcolumn INIT(= 2);	\/* 'foldcolumn' for diff mode *\/$/;"	v
diff_infold	diff.c	/^diff_infold(wp, lnum)$/;"	f
diff_invalidate	diff.c	/^diff_invalidate(buf)$/;"	f
diff_lnum_win	diff.c	/^diff_lnum_win(lnum, wp)$/;"	f
diff_mark_adjust	diff.c	/^diff_mark_adjust(line1, line2, amount, amount_after)$/;"	f
diff_mark_adjust_tp	diff.c	/^diff_mark_adjust_tp(tp, idx, line1, line2, amount, amount_after)$/;"	f	file:
diff_mode	main.c	/^    int		diff_mode;		\/* start with 'diff' set *\/$/;"	m	struct:__anon39	file:
diff_mode_buf	diff.c	/^diff_mode_buf(buf)$/;"	f
diff_move_to	diff.c	/^diff_move_to(dir, count)$/;"	f
diff_need_scrollbind	globals.h	/^EXTERN int	diff_need_scrollbind INIT(= FALSE);$/;"	v
diff_read	diff.c	/^diff_read(idx_orig, idx_new, fname)$/;"	f	file:
diff_redraw	diff.c	/^diff_redraw(dofold)$/;"	f	file:
diff_set_topline	diff.c	/^diff_set_topline(fromwin, towin)$/;"	f
diff_win_options	diff.c	/^diff_win_options(wp, addbuf)$/;"	f
diff_write	diff.c	/^diff_write(buf, fname)$/;"	f	file:
diffblock_S	structs.h	/^struct diffblock_S$/;"	s
diffopt_changed	diff.c	/^diffopt_changed()$/;"	f
diffopt_horizontal	diff.c	/^diffopt_horizontal()$/;"	f
digr_T	digraph.c	/^} digr_T;$/;"	t	typeref:struct:digraph	file:
digraph	digraph.c	/^typedef struct digraph$/;"	s	file:
digraphdefault	digraph.c	/^static digr_T digraphdefault[] =$/;"	v	file:
dir	gui_at_fs.c	/^    char	*dir;$/;"	m	struct:__anon14	file:
dir	gui_at_fs.c	/^    char	*dir;$/;"	m	struct:__anon15	file:
dir	search.c	/^    int		dir;		\/* search direction, '\/' or '?' *\/$/;"	m	struct:soffset	file:
dir_of_file_exists	misc1.c	/^dir_of_file_exists(fname)$/;"	f
dir_stack	quickfix.c	/^static struct dir_stack_T   *dir_stack = NULL;$/;"	v	typeref:struct:dir_stack_T	file:
dir_stack_T	quickfix.c	/^struct dir_stack_T$/;"	s	file:
dirent	os_unix.h	/^# define dirent /;"	d
dirname	quickfix.c	/^    char_u		*dirname;$/;"	m	struct:dir_stack_T	file:
dis_msg	ops.c	/^dis_msg(p, skip_esc)$/;"	f	file:
disallow_gui	globals.h	/^EXTERN short disallow_gui	INIT(= FALSE);$/;"	v
discard_current_exception	ex_eval.c	/^discard_current_exception()$/;"	f
discard_exception	ex_eval.c	/^discard_exception(excp, was_finished)$/;"	f	file:
discard_pending_return	eval.c	/^discard_pending_return(rettv)$/;"	f
disp_sb_line	message.c	/^disp_sb_line(row, smp)$/;"	f	file:
display_confirm_msg	message.c	/^display_confirm_msg()$/;"	f
display_dollar	edit.c	/^display_dollar(col)$/;"	f
display_errors	gui.c	/^display_errors()$/;"	f
display_errors	vim.h	/^# define display_errors(/;"	d
display_sample	gui_xmdlg.c	/^display_sample(SharedFontSelData *data)$/;"	f	file:
display_showcmd	normal.c	/^display_showcmd()$/;"	f	file:
display_tick	globals.h	/^EXTERN disptick_T	display_tick INIT(= 0);$/;"	v
displayname	netbeans.c	/^    char		*displayname;$/;"	m	struct:nbbuf_struct	file:
disptick_T	vim.h	/^typedef unsigned short disptick_T;	\/* display tick type *\/$/;"	t
dlg_button_clicked	gui_gtk.c	/^dlg_button_clicked(GtkWidget * widget, ButtonData *data)$/;"	f	file:
dlg_destroy	gui_gtk.c	/^dlg_destroy(GtkWidget *dlg)$/;"	f	file:
dlg_destroy_cb	gui_gtk.c	/^dlg_destroy_cb(int *p)$/;"	f	file:
dlg_key_press_event	gui_gtk.c	/^dlg_key_press_event(GtkWidget *widget, GdkEventKey *event, CancelData *data)$/;"	f	file:
dll_GC_malloc	if_mzsch.c	/^static void *(*dll_GC_malloc)(size_t size_in_bytes);$/;"	v	file:
dll_GC_malloc_atomic	if_mzsch.c	/^static void *(*dll_GC_malloc_atomic)(size_t size_in_bytes);$/;"	v	file:
dll_PyArg_Parse	if_python.c	/^static int(*dll_PyArg_Parse)(PyObject *, char *, ...);$/;"	v	file:
dll_PyArg_ParseTuple	if_python.c	/^static int(*dll_PyArg_ParseTuple)(PyObject *, char *, ...);$/;"	v	file:
dll_PyDict_GetItemString	if_python.c	/^static PyObject*(*dll_PyDict_GetItemString)(PyObject *, const char *);$/;"	v	file:
dll_PyDict_New	if_python.c	/^static PyObject*(*dll_PyDict_New)(void);$/;"	v	file:
dll_PyDict_SetItemString	if_python.c	/^static int(*dll_PyDict_SetItemString)(PyObject *dp, char *key, PyObject *item);$/;"	v	file:
dll_PyErr_BadArgument	if_python.c	/^static int(*dll_PyErr_BadArgument)(void);$/;"	v	file:
dll_PyErr_Clear	if_python.c	/^static void(*dll_PyErr_Clear)(void);$/;"	v	file:
dll_PyErr_NoMemory	if_python.c	/^static PyObject*(*dll_PyErr_NoMemory)(void);$/;"	v	file:
dll_PyErr_Occurred	if_python.c	/^static PyObject*(*dll_PyErr_Occurred)(void);$/;"	v	file:
dll_PyErr_SetNone	if_python.c	/^static void(*dll_PyErr_SetNone)(PyObject *);$/;"	v	file:
dll_PyErr_SetString	if_python.c	/^static void(*dll_PyErr_SetString)(PyObject *, const char *);$/;"	v	file:
dll_PyEval_InitThreads	if_python.c	/^static void(*dll_PyEval_InitThreads)(void);$/;"	v	file:
dll_PyEval_RestoreThread	if_python.c	/^static void(*dll_PyEval_RestoreThread)(PyThreadState *);$/;"	v	file:
dll_PyEval_SaveThread	if_python.c	/^static PyThreadState*(*dll_PyEval_SaveThread)(void);$/;"	v	file:
dll_PyGILState_Ensure	if_python.c	/^static PyGILState_STATE	(*dll_PyGILState_Ensure)(void);$/;"	v	file:
dll_PyGILState_Release	if_python.c	/^static void (*dll_PyGILState_Release)(PyGILState_STATE);$/;"	v	file:
dll_PyImport_ImportModule	if_python.c	/^static PyObject*(*dll_PyImport_ImportModule)(const char *);$/;"	v	file:
dll_PyInt_AsLong	if_python.c	/^static long(*dll_PyInt_AsLong)(PyObject *);$/;"	v	file:
dll_PyInt_FromLong	if_python.c	/^static PyObject*(*dll_PyInt_FromLong)(long);$/;"	v	file:
dll_PyInt_Type	if_python.c	/^static PyTypeObject* dll_PyInt_Type;$/;"	v	file:
dll_PyList_Append	if_python.c	/^static PyObject*(*dll_PyList_Append)(PyObject *, PyObject *);$/;"	v	file:
dll_PyList_GetItem	if_python.c	/^static PyObject*(*dll_PyList_GetItem)(PyObject *, PyInt);$/;"	v	file:
dll_PyList_New	if_python.c	/^static PyObject*(*dll_PyList_New)(PyInt size);$/;"	v	file:
dll_PyList_SetItem	if_python.c	/^static int(*dll_PyList_SetItem)(PyObject *, PyInt, PyObject *);$/;"	v	file:
dll_PyList_Size	if_python.c	/^static PyInt(*dll_PyList_Size)(PyObject *);$/;"	v	file:
dll_PyList_Type	if_python.c	/^static PyTypeObject* dll_PyList_Type;$/;"	v	file:
dll_PyModule_GetDict	if_python.c	/^static PyObject*(*dll_PyModule_GetDict)(PyObject *);$/;"	v	file:
dll_PyObject_Free	if_python.c	/^static void (*dll_PyObject_Free)(void*);$/;"	v	file:
dll_PyObject_Malloc	if_python.c	/^static void* (*dll_PyObject_Malloc)(size_t);$/;"	v	file:
dll_PyRun_SimpleString	if_python.c	/^static int(*dll_PyRun_SimpleString)(char *);$/;"	v	file:
dll_PyString_AsString	if_python.c	/^static char*(*dll_PyString_AsString)(PyObject *);$/;"	v	file:
dll_PyString_FromString	if_python.c	/^static PyObject*(*dll_PyString_FromString)(const char *);$/;"	v	file:
dll_PyString_FromStringAndSize	if_python.c	/^static PyObject*(*dll_PyString_FromStringAndSize)(const char *, PyInt);$/;"	v	file:
dll_PyString_Size	if_python.c	/^static PyInt(*dll_PyString_Size)(PyObject *);$/;"	v	file:
dll_PyString_Type	if_python.c	/^static PyTypeObject* dll_PyString_Type;$/;"	v	file:
dll_PySys_SetArgv	if_python.c	/^static int(*dll_PySys_SetArgv)(int, char **);$/;"	v	file:
dll_PySys_SetObject	if_python.c	/^static int(*dll_PySys_SetObject)(char *, PyObject *);$/;"	v	file:
dll_PyType_IsSubtype	if_python.c	/^static int (*dll_PyType_IsSubtype)(PyTypeObject *, PyTypeObject *);$/;"	v	file:
dll_PyType_Type	if_python.c	/^static PyTypeObject* dll_PyType_Type;$/;"	v	file:
dll_Py_BuildValue	if_python.c	/^static PyObject*(*dll_Py_BuildValue)(char *, ...);$/;"	v	file:
dll_Py_Finalize	if_python.c	/^static void(*dll_Py_Finalize)(void);$/;"	v	file:
dll_Py_FindMethod	if_python.c	/^static PyObject*(*dll_Py_FindMethod)(struct PyMethodDef[], PyObject *, char *);$/;"	v	file:
dll_Py_InitModule4	if_python.c	/^static PyObject*(*dll_Py_InitModule4)(char *, struct PyMethodDef *, char *, PyObject *, int);$/;"	v	file:
dll_Py_Initialize	if_python.c	/^static void(*dll_Py_Initialize)(void);$/;"	v	file:
dll_Py_IsInitialized	if_python.c	/^static int(*dll_Py_IsInitialized)(void);$/;"	v	file:
dll_Tcl_CreateInterp	if_tcl.c	/^Tcl_Interp* (*dll_Tcl_CreateInterp)();$/;"	v
dll__PyObject_Init	if_python.c	/^static PyObject*(*dll__PyObject_Init)(PyObject *, PyTypeObject *);$/;"	v	file:
dll__PyObject_New	if_python.c	/^static PyObject*(*dll__PyObject_New)(PyTypeObject *, PyObject *);$/;"	v	file:
dll__Py_NoneStruct	if_python.c	/^static PyObject* dll__Py_NoneStruct;$/;"	v	file:
dll_rb_assoc_new	if_ruby.c	/^static VALUE (*dll_rb_assoc_new) (VALUE, VALUE);$/;"	v	file:
dll_rb_cFalseClass	if_ruby.c	/^static VALUE *dll_rb_cFalseClass;$/;"	v	file:
dll_rb_cFixnum	if_ruby.c	/^static VALUE *dll_rb_cFixnum;$/;"	v	file:
dll_rb_cNilClass	if_ruby.c	/^static VALUE *dll_rb_cNilClass;$/;"	v	file:
dll_rb_cObject	if_ruby.c	/^static VALUE *dll_rb_cObject;$/;"	v	file:
dll_rb_cSymbol	if_ruby.c	/^static VALUE *dll_rb_cSymbol;$/;"	v	file:
dll_rb_cTrueClass	if_ruby.c	/^static VALUE *dll_rb_cTrueClass;$/;"	v	file:
dll_rb_check_type	if_ruby.c	/^static void (*dll_rb_check_type) (VALUE,int);$/;"	v	file:
dll_rb_class_path	if_ruby.c	/^static VALUE (*dll_rb_class_path) (VALUE);$/;"	v	file:
dll_rb_data_object_alloc	if_ruby.c	/^static VALUE (*dll_rb_data_object_alloc) (VALUE, void*, RUBY_DATA_FUNC, RUBY_DATA_FUNC);$/;"	v	file:
dll_rb_define_class_under	if_ruby.c	/^static VALUE (*dll_rb_define_class_under) (VALUE, const char*, VALUE);$/;"	v	file:
dll_rb_define_const	if_ruby.c	/^static void (*dll_rb_define_const) (VALUE,const char*,VALUE);$/;"	v	file:
dll_rb_define_global_function	if_ruby.c	/^static void (*dll_rb_define_global_function) (const char*,VALUE(*)(),int);$/;"	v	file:
dll_rb_define_method	if_ruby.c	/^static void (*dll_rb_define_method) (VALUE,const char*,VALUE(*)(),int);$/;"	v	file:
dll_rb_define_module	if_ruby.c	/^static VALUE (*dll_rb_define_module) (const char*);$/;"	v	file:
dll_rb_define_module_function	if_ruby.c	/^static void (*dll_rb_define_module_function) (VALUE,const char*,VALUE(*)(),int);$/;"	v	file:
dll_rb_define_singleton_method	if_ruby.c	/^static void (*dll_rb_define_singleton_method) (VALUE,const char*,VALUE(*)(),int);$/;"	v	file:
dll_rb_define_virtual_variable	if_ruby.c	/^static void (*dll_rb_define_virtual_variable) (const char*,VALUE(*)(),void(*)());$/;"	v	file:
dll_rb_eArgError	if_ruby.c	/^static VALUE *dll_rb_eArgError;$/;"	v	file:
dll_rb_eIndexError	if_ruby.c	/^static VALUE *dll_rb_eIndexError;$/;"	v	file:
dll_rb_eRuntimeError	if_ruby.c	/^static VALUE *dll_rb_eRuntimeError;$/;"	v	file:
dll_rb_eStandardError	if_ruby.c	/^static VALUE *dll_rb_eStandardError;$/;"	v	file:
dll_rb_eval_string_protect	if_ruby.c	/^static VALUE (*dll_rb_eval_string_protect) (const char*, int*);$/;"	v	file:
dll_rb_global_variable	if_ruby.c	/^static void (*dll_rb_global_variable) (VALUE*);$/;"	v	file:
dll_rb_hash_aset	if_ruby.c	/^static VALUE (*dll_rb_hash_aset) (VALUE, VALUE, VALUE);$/;"	v	file:
dll_rb_hash_new	if_ruby.c	/^static VALUE (*dll_rb_hash_new) (void);$/;"	v	file:
dll_rb_inspect	if_ruby.c	/^static VALUE (*dll_rb_inspect) (VALUE);$/;"	v	file:
dll_rb_int2inum	if_ruby.c	/^static VALUE (*dll_rb_int2inum) (long);$/;"	v	file:
dll_rb_lastline_get	if_ruby.c	/^static VALUE (*dll_rb_lastline_get) (void);$/;"	v	file:
dll_rb_lastline_set	if_ruby.c	/^static void (*dll_rb_lastline_set) (VALUE);$/;"	v	file:
dll_rb_load_protect	if_ruby.c	/^static void (*dll_rb_load_protect) (VALUE, int, int*);$/;"	v	file:
dll_rb_num2long	if_ruby.c	/^static long (*dll_rb_num2long) (VALUE);$/;"	v	file:
dll_rb_num2ulong	if_ruby.c	/^static unsigned long (*dll_rb_num2ulong) (VALUE);$/;"	v	file:
dll_rb_obj_alloc	if_ruby.c	/^static VALUE (*dll_rb_obj_alloc) (VALUE);$/;"	v	file:
dll_rb_obj_as_string	if_ruby.c	/^static VALUE (*dll_rb_obj_as_string) (VALUE);$/;"	v	file:
dll_rb_obj_id	if_ruby.c	/^static VALUE (*dll_rb_obj_id) (VALUE);$/;"	v	file:
dll_rb_raise	if_ruby.c	/^static void (*dll_rb_raise) (VALUE, const char*, ...);$/;"	v	file:
dll_rb_stdout	if_ruby.c	/^static VALUE *dll_rb_stdout;$/;"	v	file:
dll_rb_str2cstr	if_ruby.c	/^static char *(*dll_rb_str2cstr) (VALUE,int*);$/;"	v	file:
dll_rb_str_cat	if_ruby.c	/^static VALUE (*dll_rb_str_cat) (VALUE, const char*, long);$/;"	v	file:
dll_rb_str_concat	if_ruby.c	/^static VALUE (*dll_rb_str_concat) (VALUE, VALUE);$/;"	v	file:
dll_rb_str_new	if_ruby.c	/^static VALUE (*dll_rb_str_new) (const char*, long);$/;"	v	file:
dll_rb_str_new2	if_ruby.c	/^static VALUE (*dll_rb_str_new2) (const char*);$/;"	v	file:
dll_rb_w32_snprintf	if_ruby.c	/^static int (*dll_rb_w32_snprintf)(char*, size_t, const char*, ...);$/;"	v	file:
dll_ruby_errinfo	if_ruby.c	/^static VALUE *dll_ruby_errinfo;$/;"	v	file:
dll_ruby_init	if_ruby.c	/^static void (*dll_ruby_init) (void);$/;"	v	file:
dll_ruby_init_loadpath	if_ruby.c	/^static void (*dll_ruby_init_loadpath) (void);$/;"	v	file:
dll_scheme_add_global	if_mzsch.c	/^static void (*dll_scheme_add_global)(const char *name, Scheme_Object *val,$/;"	v	file:
dll_scheme_add_global_symbol	if_mzsch.c	/^static void (*dll_scheme_add_global_symbol)(Scheme_Object *name,$/;"	v	file:
dll_scheme_apply	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_apply)(Scheme_Object *rator, int num_rands,$/;"	v	file:
dll_scheme_basic_env	if_mzsch.c	/^static Scheme_Env *(*dll_scheme_basic_env)(void);$/;"	v	file:
dll_scheme_builtin_value	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_builtin_value)(const char *name);$/;"	v	file:
dll_scheme_byte_string_to_char_string	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_byte_string_to_char_string)(Scheme_Object *s);$/;"	v	file:
dll_scheme_char_string_to_byte_string	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_char_string_to_byte_string)$/;"	v	file:
dll_scheme_char_string_to_path	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_char_string_to_path)$/;"	v	file:
dll_scheme_check_threads	if_mzsch.c	/^static void (*dll_scheme_check_threads)(void);$/;"	v	file:
dll_scheme_close_input_port	if_mzsch.c	/^static void (*dll_scheme_close_input_port)(Scheme_Object *port);$/;"	v	file:
dll_scheme_console_output_ptr	if_mzsch.c	/^static void (**dll_scheme_console_output_ptr)(char *str, long len);$/;"	v	file:
dll_scheme_console_printf_ptr	if_mzsch.c	/^static void (**dll_scheme_console_printf_ptr)(char *str, ...);$/;"	v	file:
dll_scheme_count_lines	if_mzsch.c	/^static void (*dll_scheme_count_lines)(Scheme_Object *port);$/;"	v	file:
dll_scheme_current_config	if_mzsch.c	/^static Scheme_Config *(*dll_scheme_current_config)(void);$/;"	v	file:
dll_scheme_current_continuation_marks	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_current_continuation_marks)(Scheme_Object *prompt_tag);$/;"	v	file:
dll_scheme_current_continuation_marks	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_current_continuation_marks)(void);$/;"	v	file:
dll_scheme_current_thread_ptr	if_mzsch.c	/^static Scheme_Thread **dll_scheme_current_thread_ptr;$/;"	v	file:
dll_scheme_display	if_mzsch.c	/^static void (*dll_scheme_display)(Scheme_Object *obj, Scheme_Object *port);$/;"	v	file:
dll_scheme_display_to_string	if_mzsch.c	/^static char *(*dll_scheme_display_to_string)(Scheme_Object *obj, long *len);$/;"	v	file:
dll_scheme_do_eval	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_do_eval)(Scheme_Object *obj,$/;"	v	file:
dll_scheme_dont_gc_ptr	if_mzsch.c	/^static void (*dll_scheme_dont_gc_ptr)(void *p);$/;"	v	file:
dll_scheme_eof	if_mzsch.c	/^static Scheme_Object *dll_scheme_eof;$/;"	v	file:
dll_scheme_eq	if_mzsch.c	/^static int (*dll_scheme_eq)(Scheme_Object *obj1, Scheme_Object *obj2);$/;"	v	file:
dll_scheme_eval	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_eval)(Scheme_Object *obj, Scheme_Env *env);$/;"	v	file:
dll_scheme_eval_string	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_eval_string)(const char *str,$/;"	v	file:
dll_scheme_eval_string_all	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_eval_string_all)(const char *str,$/;"	v	file:
dll_scheme_false	if_mzsch.c	/^static Scheme_Object *dll_scheme_false;$/;"	v	file:
dll_scheme_finish_primitive_module	if_mzsch.c	/^static void (*dll_scheme_finish_primitive_module)(Scheme_Env *env);$/;"	v	file:
dll_scheme_format	if_mzsch.c	/^static char *(*dll_scheme_format)(char *format, int flen, int argc,$/;"	v	file:
dll_scheme_format_utf8	if_mzsch.c	/^static char *(*dll_scheme_format_utf8)(char *format, int flen, int argc,$/;"	v	file:
dll_scheme_gc_ptr_ok	if_mzsch.c	/^static void (*dll_scheme_gc_ptr_ok)(void *p);$/;"	v	file:
dll_scheme_get_param	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_get_param)(Scheme_Config *c, int pos);$/;"	v	file:
dll_scheme_get_sized_byte_string_output	if_mzsch.c	/^static char *(*dll_scheme_get_sized_byte_string_output)(Scheme_Object *,$/;"	v	file:
dll_scheme_get_sized_string_output	if_mzsch.c	/^static char *(*dll_scheme_get_sized_string_output)(Scheme_Object *,$/;"	v	file:
dll_scheme_intern_symbol	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_intern_symbol)(const char *name);$/;"	v	file:
dll_scheme_lookup_global	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_lookup_global)(Scheme_Object *symbol,$/;"	v	file:
dll_scheme_make_byte_string	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_byte_string)(const char *chars);$/;"	v	file:
dll_scheme_make_byte_string_output_port	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_byte_string_output_port)();$/;"	v	file:
dll_scheme_make_closed_prim_w_arity	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_closed_prim_w_arity)$/;"	v	file:
dll_scheme_make_integer_value	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_integer_value)(long i);$/;"	v	file:
dll_scheme_make_namespace	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_namespace)(int argc,$/;"	v	file:
dll_scheme_make_pair	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_pair)(Scheme_Object *car,$/;"	v	file:
dll_scheme_make_prim_w_arity	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_prim_w_arity)(Scheme_Prim *prim,$/;"	v	file:
dll_scheme_make_string	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_string)(const char *chars);$/;"	v	file:
dll_scheme_make_string_output_port	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_string_output_port)();$/;"	v	file:
dll_scheme_make_struct_instance	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_struct_instance)(Scheme_Object *stype,$/;"	v	file:
dll_scheme_make_struct_names	if_mzsch.c	/^static Scheme_Object **(*dll_scheme_make_struct_names)(Scheme_Object *base,$/;"	v	file:
dll_scheme_make_struct_type	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_struct_type)(Scheme_Object *base,$/;"	v	file:
dll_scheme_make_struct_values	if_mzsch.c	/^static Scheme_Object **(*dll_scheme_make_struct_values)($/;"	v	file:
dll_scheme_make_type	if_mzsch.c	/^static Scheme_Type (*dll_scheme_make_type)(const char *name);$/;"	v	file:
dll_scheme_make_vector	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_make_vector)(int size,$/;"	v	file:
dll_scheme_malloc_fail_ok	if_mzsch.c	/^static void *(*dll_scheme_malloc_fail_ok)(void *(*f)(size_t), size_t);$/;"	v	file:
dll_scheme_notify_multithread_ptr	if_mzsch.c	/^static void (**dll_scheme_notify_multithread_ptr)(int on);$/;"	v	file:
dll_scheme_null	if_mzsch.c	/^static Scheme_Object *dll_scheme_null;$/;"	v	file:
dll_scheme_open_input_file	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_open_input_file)(const char *name,$/;"	v	file:
dll_scheme_primitive_module	if_mzsch.c	/^static Scheme_Env *(*dll_scheme_primitive_module)(Scheme_Object *name,$/;"	v	file:
dll_scheme_proper_list_length	if_mzsch.c	/^static int (*dll_scheme_proper_list_length)(Scheme_Object *list);$/;"	v	file:
dll_scheme_raise	if_mzsch.c	/^static void (*dll_scheme_raise)(Scheme_Object *exn);$/;"	v	file:
dll_scheme_read	if_mzsch.c	/^static Scheme_Object *(*dll_scheme_read)(Scheme_Object *port);$/;"	v	file:
dll_scheme_register_static	if_mzsch.c	/^static void (*dll_scheme_register_static)(void *ptr, long size);$/;"	v	file:
dll_scheme_set_param	if_mzsch.c	/^static void (*dll_scheme_set_param)(Scheme_Config *c, int pos,$/;"	v	file:
dll_scheme_set_stack_base	if_mzsch.c	/^static void (*dll_scheme_set_stack_base)(void *base, int no_auto_statics);$/;"	v	file:
dll_scheme_signal_error	if_mzsch.c	/^static void (*dll_scheme_signal_error)(const char *msg, ...);$/;"	v	file:
dll_scheme_true	if_mzsch.c	/^static Scheme_Object *dll_scheme_true;$/;"	v	file:
dll_scheme_void	if_mzsch.c	/^static Scheme_Object *dll_scheme_void;$/;"	v	file:
dll_scheme_wrong_type	if_mzsch.c	/^static void (*dll_scheme_wrong_type)(const char *name, const char *expected,$/;"	v	file:
dname	structs.h	/^    char_u	*dname;		    \/* Displayed Name (without '&') *\/$/;"	m	struct:VimMenu
dnd_targets	gui_gtk_x11.c	/^static const GtkTargetEntry dnd_targets[] =$/;"	v	file:
dnd_yank_drag_data	ops.c	/^dnd_yank_drag_data(str, len)$/;"	f
do_Lower	regexp.c	/^do_Lower(d, c)$/;"	f	file:
do_Upper	regexp.c	/^do_Upper(d, c)$/;"	f	file:
do_addsub	ops.c	/^do_addsub(command, Prenum1)$/;"	f
do_apply	if_mzsch.c	/^do_apply(void *a, int noargc, Scheme_Object **noargv)$/;"	f	file:
do_arg_all	buffer.c	/^do_arg_all(count, forceit, keep_tabs)$/;"	f
do_argfile	ex_cmds2.c	/^do_argfile(eap, argn)$/;"	f
do_arglist	ex_cmds2.c	/^do_arglist(str, what, after)$/;"	f	file:
do_ascii	ex_cmds.c	/^do_ascii(eap)$/;"	f
do_augroup	fileio.c	/^do_augroup(arg, del_group)$/;"	f
do_autochdir	buffer.c	/^do_autochdir()$/;"	f
do_autocmd	fileio.c	/^do_autocmd(arg, forceit)$/;"	f
do_autocmd_event	fileio.c	/^do_autocmd_event(event, pat, nested, cmd, forceit, group)$/;"	f	file:
do_bang	ex_cmds.c	/^do_bang(addr_count, eap, forceit, do_in, do_out)$/;"	f
do_browse	message.c	/^do_browse(flags, title, dflt, ext, initdir, filter, buf)$/;"	f
do_bufdel	buffer.c	/^do_bufdel(command, arg, addr_count, start_bnr, end_bnr, forceit)$/;"	f
do_buffer	buffer.c	/^do_buffer(action, start, dir, count, forceit)$/;"	f
do_c_expr_indent	misc1.c	/^do_c_expr_indent()$/;"	f
do_check_scrollbind	normal.c	/^do_check_scrollbind(check)$/;"	f
do_choice	gui_xmdlg.c	/^do_choice(Widget w,$/;"	f	file:
do_clear_sb_text	message.c	/^static int do_clear_sb_text = FALSE;	\/* clear text on next msg *\/$/;"	v	file:
do_cmdline	ex_docmd.c	/^do_cmdline(cmdline, getline, cookie, flags)$/;"	f
do_cmdline_cmd	ex_docmd.c	/^do_cmdline_cmd(cmd)$/;"	f
do_cscope	ex_docmd.c	/^# define do_cscope	/;"	d	file:
do_cscope	if_cscope.c	/^do_cscope(eap)$/;"	f
do_cscope_general	if_cscope.c	/^do_cscope_general(eap, make_split)$/;"	f	file:
do_cstag	ex_docmd.c	/^# define do_cstag	/;"	d	file:
do_cstag	if_cscope.c	/^do_cstag(eap)$/;"	f
do_debug	ex_cmds2.c	/^do_debug(cmd)$/;"	f
do_dialog	message.c	/^do_dialog(type, title, message, buttons, dfltbutton, textfield)$/;"	f
do_dialog	vim.h	/^# define do_dialog /;"	d
do_digraph	digraph.c	/^do_digraph(c)$/;"	f
do_do_join	ops.c	/^do_do_join(count, insert_space)$/;"	f
do_doautocmd	fileio.c	/^do_doautocmd(arg, do_msg)$/;"	f
do_ecmd	ex_cmds.c	/^do_ecmd(fnum, ffname, sfname, eap, newlnum, flags)$/;"	f
do_ecmd_cmd	ex_cmds.h	/^    char_u	*do_ecmd_cmd;	\/* +command arg to be used in edited file *\/$/;"	m	struct:exarg
do_ecmd_lnum	ex_cmds.h	/^    linenr_T	do_ecmd_lnum;	\/* the line number in an edited file *\/$/;"	m	struct:exarg
do_err_output	if_mzsch.c	/^do_err_output(char *mesg, long len)$/;"	f	file:
do_errthrow	ex_eval.c	/^do_errthrow(cstack, cmdname)$/;"	f
do_eval	if_mzsch.c	/^do_eval(void *s, int noargc, Scheme_Object **noargv)$/;"	f	file:
do_execreg	ops.c	/^do_execreg(regname, colon, addcr, silent)$/;"	f
do_exedit	ex_docmd.c	/^do_exedit(eap, old_curwin)$/;"	f
do_exmap	ex_docmd.c	/^do_exmap(eap, isabbrev)$/;"	f	file:
do_exmode	ex_docmd.c	/^do_exmode(improved)$/;"	f
do_filter	ex_cmds.c	/^do_filter(line1, line2, eap, cmd, do_in, do_out)$/;"	f	file:
do_finish	ex_cmds2.c	/^do_finish(eap, reanimate)$/;"	f
do_fixdel	ex_cmds.c	/^do_fixdel(eap)$/;"	f
do_flush	if_mzsch.c	/^do_flush(void)$/;"	f	file:
do_highlight	syntax.c	/^do_highlight(line, forceit, init)$/;"	f
do_in_runtimepath	ex_cmds2.c	/^do_in_runtimepath(name, all, callback, cookie)$/;"	f
do_intrnl_output	if_mzsch.c	/^do_intrnl_output(char *mesg, long len, int error)$/;"	f	file:
do_intro_line	version.c	/^do_intro_line(row, mesg, add_version, attr)$/;"	f	file:
do_intthrow	ex_eval.c	/^do_intthrow(cstack)$/;"	f
do_join	ops.c	/^do_join(insert_space)$/;"	f
do_load	if_mzsch.c	/^do_load(void *data, int noargc, Scheme_Object **noargv)$/;"	f	file:
do_lock_var	eval.c	/^do_lock_var(lp, name_end, deep, lock)$/;"	f	file:
do_lower	regexp.c	/^do_lower(d, c)$/;"	f	file:
do_map	getchar.c	/^do_map(maptype, arg, mode, abbrev)$/;"	f
do_marks	mark.c	/^do_marks(eap)$/;"	f
do_mnemonic	gui_motif.c	/^do_mnemonic(Widget w, unsigned int keycode)$/;"	f	file:
do_modelines	buffer.c	/^do_modelines(flags)$/;"	f
do_more_prompt	message.c	/^do_more_prompt(typed_char)$/;"	f	file:
do_mouse	normal.c	/^do_mouse(oap, c, dir, count, fixindent)$/;"	f
do_move	ex_cmds.c	/^do_move(line1, line2, dest)$/;"	f
do_mzscheme_command	if_mzsch.c	/^do_mzscheme_command(exarg_T *eap, void *data, Scheme_Closed_Prim *what)$/;"	f	file:
do_nv_ident	normal.c	/^do_nv_ident(c1, c2)$/;"	f
do_one_arg	ex_cmds2.c	/^do_one_arg(str)$/;"	f	file:
do_one_cmd	ex_docmd.c	/^do_one_cmd(cmdlinep, sourcing,$/;"	f	file:
do_outofmem_msg	misc2.c	/^do_outofmem_msg(size)$/;"	f
do_output	if_mzsch.c	/^do_output(char *mesg, long len)$/;"	f	file:
do_pending_operator	normal.c	/^do_pending_operator(cap, old_col, gui_yank)$/;"	f
do_printf	if_mzsch.c	/^do_printf(char *format, ...)$/;"	f	file:
do_profiling	globals.h	/^EXTERN int	do_profiling INIT(= PROF_NONE);	\/* PROF_ values *\/$/;"	v
do_put	ops.c	/^do_put(regname, dir, count, flags)$/;"	f
do_record	ops.c	/^do_record(c)$/;"	f
do_redraw	globals.h	/^EXTERN int	do_redraw INIT(= FALSE);    \/* extra redraw once *\/$/;"	v
do_resize	os_unix.c	/^static int	do_resize = FALSE;$/;"	v	file:
do_return	eval.c	/^do_return(eap, reanimate, is_cmd, rettv)$/;"	f
do_scscope	ex_docmd.c	/^# define do_scscope	/;"	d	file:
do_scscope	if_cscope.c	/^do_scscope(eap)$/;"	f
do_search	search.c	/^do_search(oap, dirc, pat, count, options, tm)$/;"	f
do_searchpair	eval.c	/^do_searchpair(spat, mpat, epat, dir, skip, flags, match_pos,$/;"	f
do_set	option.c	/^do_set(arg, opt_flags)$/;"	f
do_set_mnemonics	gui_motif.c	/^do_set_mnemonics(enable)$/;"	f	file:
do_shell	ex_cmds.c	/^do_shell(cmd, flags)$/;"	f
do_sleep	ex_docmd.c	/^do_sleep(msec)$/;"	f
do_source	ex_cmds2.c	/^do_source(fname, check_other, is_vimrc)$/;"	f
do_string_sub	eval.c	/^do_string_sub(str, pat, sub, flags)$/;"	f
do_sub	ex_cmds.c	/^do_sub(eap)$/;"	f
do_sub_msg	ex_cmds.c	/^do_sub_msg(count_only)$/;"	f
do_swapexists	memline.c	/^do_swapexists(buf, fname)$/;"	f	file:
do_syntax	structs.h	/^    int		do_syntax;$/;"	m	struct:__anon100
do_tag	tag.c	/^do_tag(tag, type, count, forceit, verbose)$/;"	f
do_tags	tag.c	/^do_tags(eap)$/;"	f
do_throw	ex_eval.c	/^do_throw(cstack)$/;"	f
do_ucmd	ex_docmd.c	/^do_ucmd(eap)$/;"	f	file:
do_unlet	eval.c	/^do_unlet(name, forceit)$/;"	f
do_unlet_var	eval.c	/^do_unlet_var(lp, name_end, forceit)$/;"	f	file:
do_upper	regexp.c	/^do_upper(d, c)$/;"	f	file:
do_viminfo	ex_cmds.c	/^do_viminfo(fp_in, fp_out, want_info, want_marks, force_read)$/;"	f	file:
do_window	window.c	/^do_window(nchar, Prenum, xchar)$/;"	f
do_wqall	ex_cmds.c	/^do_wqall(eap)$/;"	f
do_write	ex_cmds.c	/^do_write(eap)$/;"	f
do_xterm_trace	os_unix.c	/^do_xterm_trace()$/;"	f	file:
dofork	gui.h	/^    int		dofork;		    \/* Use fork() when GUI is starting *\/$/;"	m	struct:Gui
doing_destroy	gui_xmebwp.h	/^    int doing_destroy;$/;"	m	struct:_XmEnhancedButtonPart
doing_setvalues	gui_xmebwp.h	/^    int doing_setvalues;$/;"	m	struct:_XmEnhancedButtonPart
dollar_command	ex_docmd.c	/^static char_u dollar_command[2] = {'$', 0};$/;"	v	file:
dollar_vcol	globals.h	/^EXTERN colnr_T	dollar_vcol INIT(= 0);$/;"	v
dont_scroll	globals.h	/^EXTERN int	dont_scroll INIT(= FALSE);\/* don't use scrollbars when TRUE *\/$/;"	v
dos_expandpath	misc1.c	/^dos_expandpath($/;"	f	file:
dosetvisible	netbeans.c	/^static int dosetvisible = FALSE;$/;"	v	file:
down	gui_gtk.c	/^    GtkWidget *down;	\/* search direction 'Down' radio button *\/$/;"	m	struct:_SharedFindReplace	file:
down	gui_motif.c	/^    Widget down;	\/* search direction 'Down' radio button *\/$/;"	m	struct:_SharedFindReplace	file:
dpy	gui.h	/^    Display	*dpy;		    \/* X display *\/$/;"	m	struct:Gui
drag_data_received_cb	gui_gtk_x11.c	/^drag_data_received_cb(GtkWidget		*widget,$/;"	f	file:
drag_handle_text	gui_gtk_x11.c	/^drag_handle_text(GdkDragContext	    *context,$/;"	f	file:
drag_handle_uri_list	gui_gtk_x11.c	/^drag_handle_uri_list(GdkDragContext	*context,$/;"	f	file:
drag_sep_line	globals.h	/^EXTERN int	drag_sep_line INIT(= FALSE);	\/* dragging vert separator *\/$/;"	v
drag_status_line	globals.h	/^EXTERN int	drag_status_line INIT(= FALSE);	\/* dragging the status line *\/$/;"	v
dragged_sb	gui.h	/^    int		dragged_sb;	    \/* Which scrollbar being dragged, if any? *\/$/;"	m	struct:Gui
dragged_wp	gui.h	/^    win_T	*dragged_wp;	    \/* Which WIN's sb being dragged, if any? *\/$/;"	m	struct:Gui
drawBalloon	gui_beval.c	/^drawBalloon(BalloonEval *beval)$/;"	f	file:
drawBalloon	gui_beval.c	/^drawBalloon(beval)$/;"	f	file:
draw_cmdline	ex_getln.c	/^draw_cmdline(start, len)$/;"	f	file:
draw_curl	gui_x11.c	/^draw_curl(row, col, cells)$/;"	f	file:
draw_feedback	globals.h	/^EXTERN char		*draw_feedback INIT(= NULL);$/;"	v
draw_glyph_string	gui_gtk_x11.c	/^draw_glyph_string(int row, int col, int num_cells, int flags,$/;"	f	file:
draw_highlight	gui_xmebw.c	/^draw_highlight(XmEnhancedButtonWidget eb)$/;"	f	file:
draw_label	gui_xmebw.c	/^draw_label(XmEnhancedButtonWidget eb, XEvent *event, Region region)$/;"	f	file:
draw_pixmap	gui_xmebw.c	/^draw_pixmap(XmEnhancedButtonWidget eb, XEvent *event, Region region)$/;"	f	file:
draw_shadows	gui_xmebw.c	/^draw_shadows(XmEnhancedButtonWidget eb)$/;"	f	file:
draw_signcolumn	screen.c	/^draw_signcolumn(wp)$/;"	f	file:
draw_tabline	screen.c	/^draw_tabline()$/;"	f	file:
draw_under	gui_gtk_x11.c	/^draw_under(int flags, int row, int col, int cells)$/;"	f	file:
draw_unhighlight	gui_xmebw.c	/^draw_unhighlight(XmEnhancedButtonWidget eb)$/;"	f	file:
draw_vsep_win	screen.c	/^draw_vsep_win(wp, row)$/;"	f	file:
drawarea	gui.h	/^    GtkWidget	*drawarea;	    \/* the "text" area *\/$/;"	m	struct:Gui
drawarea_realize_cb	gui_gtk_x11.c	/^drawarea_realize_cb(GtkWidget *widget, gpointer data)$/;"	f	file:
drawarea_style_set_cb	gui_gtk_x11.c	/^drawarea_style_set_cb(GtkWidget	*widget,$/;"	f	file:
drawarea_unrealize_cb	gui_gtk_x11.c	/^drawarea_unrealize_cb(GtkWidget *widget, gpointer data)$/;"	f	file:
dumdi	eval.c	/^static dictitem_T dumdi;$/;"	v	file:
dumkey	syntax.c	/^static keyentry_T dumkey;$/;"	v	file:
dummy	os_unix.c	/^static int dummy;$/;"	v	file:
dump_prefixes	spell.c	/^dump_prefixes(slang, word, pat, dir, dumpflags, flags, startlnum)$/;"	f	file:
dump_word	spell.c	/^dump_word(slang, word, pat, dir, dumpflags, wordflags, lnum)$/;"	f	file:
dumsft	spell.c	/^static sftword_T dumsft;$/;"	v	file:
dumuf	eval.c	/^static ufunc_T dumuf;$/;"	v	file:
dumwc	spell.c	/^static wordcount_T dumwc;$/;"	v	file:
duplex	structs.h	/^    int		duplex;$/;"	m	struct:__anon100
dv_copyID	structs.h	/^    int		dv_copyID;	\/* ID used by deepcopy() *\/$/;"	m	struct:dictvar_S
dv_copydict	structs.h	/^    dict_T	*dv_copydict;	\/* copied dict used by deepcopy() *\/$/;"	m	struct:dictvar_S
dv_hashtab	structs.h	/^    hashtab_T	dv_hashtab;	\/* hashtab that refers to the items *\/$/;"	m	struct:dictvar_S
dv_lock	structs.h	/^    char	dv_lock;	\/* zero, VAR_LOCKED, VAR_FIXED *\/$/;"	m	struct:dictvar_S
dv_refcount	structs.h	/^    int		dv_refcount;	\/* reference count *\/$/;"	m	struct:dictvar_S
dv_used_next	structs.h	/^    dict_T	*dv_used_next;	\/* next dict in used dicts list *\/$/;"	m	struct:dictvar_S
dv_used_prev	structs.h	/^    dict_T	*dv_used_prev;	\/* previous dict in used dicts list *\/$/;"	m	struct:dictvar_S
dy_flags	option.h	/^EXTERN unsigned	dy_flags;$/;"	v
dying	gui.h	/^    int		dying;		    \/* Is vim dying? Then output to terminal *\/$/;"	m	struct:Gui
dynamic_mzscheme_end	if_mzsch.c	/^dynamic_mzscheme_end(void)$/;"	f	file:
eDeletedBufferError	if_ruby.c	/^static VALUE eDeletedBufferError;$/;"	v	file:
eDeletedWindowError	if_ruby.c	/^static VALUE eDeletedWindowError;$/;"	v	file:
e_abort	globals.h	/^EXTERN char_u e_abort[]		INIT(= N_("E470: Command aborted"));$/;"	v
e_affform	spell.c	/^static char *e_affform = N_("E761: Format error in affix file FOL, LOW or UPP");$/;"	v	file:
e_affname	spell.c	/^static char *e_affname = N_("Affix name too long in %s line %d: %s");$/;"	v	file:
e_affrange	spell.c	/^static char *e_affrange = N_("E762: Character in FOL, LOW or UPP is out of range");$/;"	v	file:
e_afftrailing	spell.c	/^static char *e_afftrailing = N_("Trailing text in %s line %d: %s");$/;"	v	file:
e_argreq	globals.h	/^EXTERN char_u e_argreq[]	INIT(= N_("E471: Argument required"));$/;"	v
e_backslash	globals.h	/^EXTERN char_u e_backslash[]	INIT(= N_("E10: \\\\ should be followed by \/, ? or &"));$/;"	v
e_bufloaded	globals.h	/^EXTERN char_u e_bufloaded[]	INIT(= N_("E139: File is loaded in another buffer"));$/;"	v
e_cmdwin	globals.h	/^EXTERN char_u e_cmdwin[]	INIT(= N_("E11: Invalid in command-line window; <CR> executes, CTRL-C quits"));$/;"	v
e_curdir	globals.h	/^EXTERN char_u e_curdir[]	INIT(= N_("E12: Command not allowed from exrc\/vimrc in current dir or tag search"));$/;"	v
e_dictkey	eval.c	/^static char *e_dictkey = N_("E716: Key not present in Dictionary: %s");$/;"	v	file:
e_dictrange	eval.c	/^static char *e_dictrange = N_("E719: Cannot use [:] with a Dictionary");$/;"	v	file:
e_dictreq	eval.c	/^static char *e_dictreq = N_("E715: Dictionary required");$/;"	v	file:
e_emptybuf	globals.h	/^EXTERN char_u e_emptybuf[]	INIT(= N_("E749: empty buffer"));$/;"	v
e_emptykey	eval.c	/^static char *e_emptykey = N_("E713: Cannot use empty key for Dictionary");$/;"	v	file:
e_endfor	globals.h	/^EXTERN char_u e_endfor[]	INIT(= N_("E170: Missing :endfor"));$/;"	v
e_endif	globals.h	/^EXTERN char_u e_endif[]		INIT(= N_("E171: Missing :endif"));$/;"	v
e_endtry	globals.h	/^EXTERN char_u e_endtry[]	INIT(= N_("E600: Missing :endtry"));$/;"	v
e_endwhile	globals.h	/^EXTERN char_u e_endwhile[]	INIT(= N_("E170: Missing :endwhile"));$/;"	v
e_exists	globals.h	/^EXTERN char_u e_exists[]	INIT(= N_("E13: File exists (add ! to override)"));$/;"	v
e_failed	globals.h	/^EXTERN char_u e_failed[]	INIT(= N_("E472: Command failed"));$/;"	v
e_font	globals.h	/^EXTERN char_u e_font[]		INIT(= N_("E235: Unknown font: %s"));$/;"	v
e_fontset	globals.h	/^EXTERN char_u e_fontset[]	INIT(= N_("E234: Unknown fontset: %s"));$/;"	v
e_fontwidth	globals.h	/^EXTERN char_u e_fontwidth[]	INIT(= N_("E236: Font \\"%s\\" is not fixed-width"));$/;"	v
e_for	globals.h	/^EXTERN char_u e_for[]		INIT(= N_("E588: :endfor without :for"));$/;"	v
e_format	spell.c	/^static char *e_format = N_("E759: Format error in spell file");$/;"	v	file:
e_funcdict	eval.c	/^static char *e_funcdict = N_("E717: Dictionary entry already exists");$/;"	v	file:
e_funcexts	eval.c	/^static char *e_funcexts = N_("E122: Function %s already exists, add ! to replace it");$/;"	v	file:
e_funcref	eval.c	/^static char *e_funcref = N_("E718: Funcref required");$/;"	v	file:
e_guarded	globals.h	/^EXTERN char_u e_guarded[]	INIT(= N_("E463: Region is guarded, cannot modify"));$/;"	v
e_hitend	edit.c	/^static char_u e_hitend[] = N_("Hit end of paragraph");$/;"	v	file:
e_illvar	eval.c	/^static char *e_illvar = N_("E461: Illegal variable name: %s");$/;"	v	file:
e_intern2	globals.h	/^EXTERN char_u e_intern2[]	INIT(= N_("E685: Internal error: %s"));$/;"	v
e_internal	globals.h	/^EXTERN char_u e_internal[]	INIT(= N_("E473: Internal error"));$/;"	v
e_interr	globals.h	/^EXTERN char_u e_interr[]	INIT(= N_("Interrupted"));$/;"	v
e_invaddr	globals.h	/^EXTERN char_u e_invaddr[]	INIT(= N_("E14: Invalid address"));$/;"	v
e_invalpat	globals.h	/^EXTERN char_u e_invalpat[]	INIT(= N_("E682: Invalid search pattern or delimiter"));$/;"	v
e_invarg	globals.h	/^EXTERN char_u e_invarg[]	INIT(= N_("E474: Invalid argument"));$/;"	v
e_invarg2	globals.h	/^EXTERN char_u e_invarg2[]	INIT(= N_("E475: Invalid argument: %s"));$/;"	v
e_invcmd	globals.h	/^EXTERN char_u e_invcmd[]	INIT(= N_("E476: Invalid command"));$/;"	v
e_invexpr2	globals.h	/^EXTERN char_u e_invexpr2[]	INIT(= N_("E15: Invalid expression: %s"));$/;"	v
e_invexprmsg	globals.h	/^EXTERN char_u e_invexprmsg[]	INIT(= N_("E449: Invalid expression received"));$/;"	v
e_invrange	globals.h	/^EXTERN char_u e_invrange[]	INIT(= N_("E16: Invalid range"));$/;"	v
e_isadir2	globals.h	/^EXTERN char_u e_isadir2[]	INIT(= N_("E17: \\"%s\\" is a directory"));$/;"	v
e_letunexp	eval.c	/^static char *e_letunexp	= N_("E18: Unexpected characters in :let");$/;"	v	file:
e_letwrong	eval.c	/^static char *e_letwrong = N_("E734: Wrong variable type for %s=");$/;"	v	file:
e_libcall	globals.h	/^EXTERN char_u e_libcall[]	INIT(= N_("E364: Library call failed for \\"%s()\\""));$/;"	v
e_listarg	eval.c	/^static char *e_listarg = N_("E686: Argument of %s must be a List");$/;"	v	file:
e_listdictarg	eval.c	/^static char *e_listdictarg = N_("E712: Argument of %s must be a List or Dictionary");$/;"	v	file:
e_listidx	eval.c	/^static char *e_listidx = N_("E684: list index out of range: %ld");$/;"	v	file:
e_listreq	eval.c	/^static char *e_listreq = N_("E714: List required");$/;"	v	file:
e_loadfunc	globals.h	/^EXTERN char_u e_loadfunc[]	INIT(= N_("E448: Could not load library function %s"));$/;"	v
e_loadlib	globals.h	/^EXTERN char_u e_loadlib[]	INIT(= N_("E370: Could not load library %s"));$/;"	v
e_loclist	globals.h	/^EXTERN char_u e_loclist[]	INIT(= N_("E776: No location list"));$/;"	v
e_longname	globals.h	/^EXTERN char_u e_longname[]	INIT(= N_("E75: Name too long"));$/;"	v
e_markinval	globals.h	/^EXTERN char_u e_markinval[]	INIT(= N_("E19: Mark has invalid line number"));$/;"	v
e_marknotset	globals.h	/^EXTERN char_u e_marknotset[]	INIT(= N_("E20: Mark not set"));$/;"	v
e_maxmempat	globals.h	/^EXTERN char_u e_maxmempat[]	INIT(= N_("E363: pattern uses more memory than 'maxmempattern'"));$/;"	v
e_missbrac	eval.c	/^static char *e_missbrac = N_("E111: Missing ']'");$/;"	v	file:
e_modifiable	globals.h	/^EXTERN char_u e_modifiable[]	INIT(= N_("E21: Cannot make changes, 'modifiable' is off"));$/;"	v
e_nbreadonly	globals.h	/^EXTERN char_u e_nbreadonly[]	INIT(= N_("E744: NetBeans does not allow changes in read-only files"));$/;"	v
e_nesting	globals.h	/^EXTERN char_u e_nesting[]	INIT(= N_("E22: Scripts nested too deep"));$/;"	v
e_noabbr	globals.h	/^EXTERN char_u e_noabbr[]	INIT(= N_("E24: No such abbreviation"));$/;"	v
e_noalt	globals.h	/^EXTERN char_u e_noalt[]		INIT(= N_("E23: No alternate file"));$/;"	v
e_noarabic	globals.h	/^EXTERN char_u e_noarabic[]	INIT(= N_("E800: Arabic cannot be used: Not enabled at compile time\\n"));$/;"	v
e_nobang	globals.h	/^EXTERN char_u e_nobang[]	INIT(= N_("E477: No ! allowed"));$/;"	v
e_nofarsi	globals.h	/^EXTERN char_u e_nofarsi[]	INIT(= N_("E27: Farsi cannot be used: Not enabled at compile time\\n"));$/;"	v
e_nofold	fold.c	/^static char *e_nofold = N_("E490: No fold found");$/;"	v	file:
e_nofunc	eval.c	/^static char *e_nofunc = N_("E130: Unknown function: %s");$/;"	v	file:
e_nogroup	globals.h	/^EXTERN char_u e_nogroup[]	INIT(= N_("E28: No such highlight group name: %s"));$/;"	v
e_nogvim	globals.h	/^EXTERN char_u e_nogvim[]	INIT(= N_("E25: GUI cannot be used: Not enabled at compile time"));$/;"	v
e_nohebrew	globals.h	/^EXTERN char_u e_nohebrew[]	INIT(= N_("E26: Hebrew cannot be used: Not enabled at compile time\\n"));$/;"	v
e_noinstext	globals.h	/^EXTERN char_u e_noinstext[]	INIT(= N_("E29: No inserted text yet"));$/;"	v
e_nolastcmd	globals.h	/^EXTERN char_u e_nolastcmd[]	INIT(= N_("E30: No previous command line"));$/;"	v
e_nomap	globals.h	/^EXTERN char_u e_nomap[]		INIT(= N_("E31: No such mapping"));$/;"	v
e_nomatch	globals.h	/^EXTERN char_u e_nomatch[]	INIT(= N_("E479: No match"));$/;"	v
e_nomatch2	globals.h	/^EXTERN char_u e_nomatch2[]	INIT(= N_("E480: No match: %s"));$/;"	v
e_nomenu	menu.c	/^static char_u e_nomenu[] = N_("E329: No menu \\"%s\\"");$/;"	v	file:
e_noname	globals.h	/^EXTERN char_u e_noname[]	INIT(= N_("E32: No file name"));$/;"	v
e_nopresub	globals.h	/^EXTERN char_u e_nopresub[]	INIT(= N_("E33: No previous substitute regular expression"));$/;"	v
e_noprev	globals.h	/^EXTERN char_u e_noprev[]	INIT(= N_("E34: No previous command"));$/;"	v
e_noprevre	globals.h	/^EXTERN char_u e_noprevre[]	INIT(= N_("E35: No previous regular expression"));$/;"	v
e_norange	globals.h	/^EXTERN char_u e_norange[]	INIT(= N_("E481: No range allowed"));$/;"	v
e_noroom	globals.h	/^EXTERN char_u e_noroom[]	INIT(= N_("E36: Not enough room"));$/;"	v
e_noserver	globals.h	/^EXTERN char_u e_noserver[]	INIT(= N_("E247: no registered server named \\"%s\\""));$/;"	v
e_notcreate	globals.h	/^EXTERN char_u e_notcreate[]	INIT(= N_("E482: Can't create file %s"));$/;"	v
e_notmp	globals.h	/^EXTERN char_u e_notmp[]		INIT(= N_("E483: Can't get temp file name"));$/;"	v
e_notopen	globals.h	/^EXTERN char_u e_notopen[]	INIT(= N_("E484: Can't open file %s"));$/;"	v
e_notread	globals.h	/^EXTERN char_u e_notread[]	INIT(= N_("E485: Can't read file %s"));$/;"	v
e_notset	globals.h	/^EXTERN char_u e_notset[]	INIT(= N_("E764: Option '%s' is not set"));$/;"	v
e_notsubmenu	menu.c	/^static char_u e_notsubmenu[] = N_("E327: Part of menu-item path is not sub-menu");$/;"	v	file:
e_nowrtmsg	globals.h	/^EXTERN char_u e_nowrtmsg[]	INIT(= N_("E37: No write since last change (add ! to override)"));$/;"	v
e_null	globals.h	/^EXTERN char_u e_null[]		INIT(= N_("E38: Null argument"));$/;"	v
e_number_exp	globals.h	/^EXTERN char_u e_number_exp[]	INIT(= N_("E39: Number expected"));$/;"	v
e_opendisp	globals.h	/^EXTERN char_u e_opendisp[]	INIT(= N_("E233: cannot open display"));$/;"	v
e_openerrf	globals.h	/^EXTERN char_u e_openerrf[]	INIT(= N_("E40: Can't open errorfile %s"));$/;"	v
e_othermode	menu.c	/^static char_u e_othermode[] = N_("E328: Menu only exists in another mode");$/;"	v	file:
e_outofmem	globals.h	/^EXTERN char_u e_outofmem[]	INIT(= N_("E41: Out of memory!"));$/;"	v
e_overthespot	mbyte.c	/^static char e_overthespot[] = N_("E290: over-the-spot style requires fontset");$/;"	v	file:
e_patnotf	globals.h	/^EXTERN char_u e_patnotf[]	INIT(= N_("Pattern not found"));$/;"	v
e_patnotf2	globals.h	/^EXTERN char_u e_patnotf2[]	INIT(= N_("E486: Pattern not found: %s"));$/;"	v
e_positive	globals.h	/^EXTERN char_u e_positive[]	INIT(= N_("E487: Argument must be positive"));$/;"	v
e_prev_dir	globals.h	/^EXTERN char_u e_prev_dir[]	INIT(= N_("E459: Cannot go back to previous directory"));$/;"	v
e_printf	message.c	/^static char *e_printf = N_("E766: Insufficient arguments for printf()");$/;"	v	file:
e_quickfix	globals.h	/^EXTERN char_u e_quickfix[]	INIT(= N_("E42: No Errors"));$/;"	v
e_re_corr	globals.h	/^EXTERN char_u e_re_corr[]	INIT(= N_("E44: Corrupted regexp program"));$/;"	v
e_re_damg	globals.h	/^EXTERN char_u e_re_damg[]	INIT(= N_("E43: Damaged match string"));$/;"	v
e_readerrf	globals.h	/^EXTERN char_u e_readerrf[]	INIT(= N_("E47: Error while reading errorfile"));$/;"	v
e_readonly	globals.h	/^EXTERN char_u e_readonly[]	INIT(= N_("E45: 'readonly' option is set (add ! to override)"));$/;"	v
e_readonlysbx	globals.h	/^EXTERN char_u e_readonlysbx[]	INIT(= N_("E794: Cannot set variable in the sandbox: \\"%s\\""));$/;"	v
e_readonlyvar	globals.h	/^EXTERN char_u e_readonlyvar[]	INIT(= N_("E46: Cannot change read-only variable \\"%s\\""));$/;"	v
e_sandbox	globals.h	/^EXTERN char_u e_sandbox[]	INIT(= N_("E48: Not allowed in sandbox"));$/;"	v
e_screenmode	globals.h	/^EXTERN char_u e_screenmode[]	INIT(= N_("E359: Screen mode setting not supported"));$/;"	v
e_scroll	globals.h	/^EXTERN char_u e_scroll[]	INIT(= N_("E49: Invalid scroll size"));$/;"	v
e_secure	globals.h	/^EXTERN char_u e_secure[]	INIT(= N_("E523: Not allowed here"));$/;"	v
e_shellempty	globals.h	/^EXTERN char_u e_shellempty[]	INIT(= N_("E91: 'shell' option is empty"));$/;"	v
e_signdata	globals.h	/^EXTERN char_u e_signdata[]	INIT(= N_("E255: Couldn't read in sign data!"));$/;"	v
e_spell_trunc	spell.c	/^static char *e_spell_trunc = N_("E758: Truncated spell file");$/;"	v	file:
e_swapclose	globals.h	/^EXTERN char_u e_swapclose[]	INIT(= N_("E72: Close error on swap file"));$/;"	v
e_tagstack	globals.h	/^EXTERN char_u e_tagstack[]	INIT(= N_("E73: tag stack empty"));$/;"	v
e_toocompl	globals.h	/^EXTERN char_u e_toocompl[]	INIT(= N_("E74: Command too complex"));$/;"	v
e_toomany	globals.h	/^EXTERN char_u e_toomany[]	INIT(= N_("E77: Too many file names"));$/;"	v
e_toomanyarg	eval.c	/^static char *e_toomanyarg = N_("E118: Too many arguments for function: %s");$/;"	v	file:
e_toomsbra	globals.h	/^EXTERN char_u e_toomsbra[]	INIT(= N_("E76: Too many ["));$/;"	v
e_trailing	globals.h	/^EXTERN char_u e_trailing[]	INIT(= N_("E488: Trailing characters"));$/;"	v
e_umark	globals.h	/^EXTERN char_u e_umark[]		INIT(= N_("E78: Unknown mark"));$/;"	v
e_undefvar	eval.c	/^static char *e_undefvar = N_("E121: Undefined variable: %s");$/;"	v	file:
e_usingsid	globals.h	/^EXTERN char_u e_usingsid[]	INIT(= N_("E81: Using <SID> not in a script context"));$/;"	v
e_while	globals.h	/^EXTERN char_u e_while[]		INIT(= N_("E588: :endwhile without :while"));$/;"	v
e_wildexpand	globals.h	/^EXTERN char_u e_wildexpand[]	INIT(= N_("E79: Cannot expand wildcards"));$/;"	v
e_winheight	globals.h	/^EXTERN char_u e_winheight[]	INIT(= N_("E591: 'winheight' cannot be smaller than 'winminheight'"));$/;"	v
e_winwidth	globals.h	/^EXTERN char_u e_winwidth[]	INIT(= N_("E592: 'winwidth' cannot be smaller than 'winminwidth'"));$/;"	v
e_write	globals.h	/^EXTERN char_u e_write[]		INIT(= N_("E80: Error while writing"));$/;"	v
e_xim	mbyte.c	/^static char e_xim[] = N_("E285: Failed to create input context");$/;"	v	file:
e_zerocount	globals.h	/^EXTERN char_u e_zerocount[]	INIT(= N_("Zero count"));$/;"	v
eap_arg_len	if_cscope.c	/^static int	    eap_arg_len;    \/* length of eap->arg, set in$/;"	v	file:
early_arg_scan	main.c	/^early_arg_scan(parmp)$/;"	f	file:
ebcdic2ascii	charset.c	/^ebcdic2ascii(buffer, len)$/;"	f
ebcdic2ascii_tab	charset.c	/^static char_u ebcdic2ascii_tab[256] =$/;"	v	file:
echeck_abbr	edit.c	/^echeck_abbr(c)$/;"	f	file:
echo_attr	eval.c	/^static int echo_attr = 0;   \/* attributes used for ":echo" *\/$/;"	v	file:
echo_string	eval.c	/^echo_string(tv, tofree, numbuf, copyID)$/;"	f	file:
echo_wid_arg	globals.h	/^EXTERN int	echo_wid_arg INIT(= FALSE);	\/* --echo-wid argument *\/$/;"	v
edit	edit.c	/^edit(cmdchar, startln, count)$/;"	f
edit_buffers	main.c	/^edit_buffers(parmp)$/;"	f	file:
edit_putchar	edit.c	/^edit_putchar(c, highlight)$/;"	f
edit_submode	globals.h	/^EXTERN char_u	*edit_submode INIT(= NULL); \/* msg for CTRL-X submode *\/$/;"	v
edit_submode_extra	globals.h	/^EXTERN char_u	*edit_submode_extra INIT(= NULL);\/* appended to edit_submode *\/$/;"	v
edit_submode_highl	globals.h	/^EXTERN hlf_T	edit_submode_highl;	\/* highl. method for extra info *\/$/;"	v
edit_submode_pre	globals.h	/^EXTERN char_u	*edit_submode_pre INIT(= NULL); \/* prepended to edit_submode *\/$/;"	v
edit_type	main.c	/^    int		edit_type;		\/* type of editing to do *\/$/;"	m	struct:__anon39	file:
edit_unputchar	edit.c	/^edit_unputchar()$/;"	f
editing_arg_idx	ex_cmds2.c	/^editing_arg_idx(win)$/;"	f	file:
efm_S	quickfix.c	/^struct efm_S$/;"	s	file:
efm_T	quickfix.c	/^typedef struct efm_S efm_T;$/;"	t	typeref:struct:efm_S	file:
empty	gui_at_sb.h	/^typedef struct {int empty;} ScrollbarClassPart;$/;"	m	struct:__anon65
empty	structs.h	/^    int		empty;		\/* op_start and op_end the same (only used by$/;"	m	struct:oparg_S
empty_option	globals.h	/^EXTERN char_u	*empty_option INIT(= (char_u *)"");$/;"	v
empty_prop	if_xcmdsrv.c	/^static char_u	*empty_prop = (char_u *)"";	\/* empty GetRegProp() result *\/$/;"	v	file:
emsg	message.c	/^emsg(s)$/;"	f
emsg2	message.c	/^emsg2(s, a1)$/;"	f
emsg3	misc2.c	/^emsg3(s, a1, a2)$/;"	f
emsg_funcname	eval.c	/^emsg_funcname(ermsg, name)$/;"	f	file:
emsg_invreg	message.c	/^emsg_invreg(name)$/;"	f
emsg_not_now	message.c	/^emsg_not_now()$/;"	f
emsg_off	globals.h	/^EXTERN int	emsg_off INIT(= 0);	    \/* don't display errors for now,$/;"	v
emsg_on_display	globals.h	/^EXTERN int	emsg_on_display INIT(= FALSE);	\/* there is an error message *\/$/;"	v
emsg_severe	globals.h	/^EXTERN int	emsg_severe INIT(= FALSE);   \/* use message of next of several$/;"	v
emsg_silent	globals.h	/^EXTERN int	emsg_silent INIT(= 0);	\/* don't print error messages *\/$/;"	v
emsg_skip	globals.h	/^EXTERN int	emsg_skip INIT(= 0);	    \/* don't display errors for$/;"	v
emsgn	misc2.c	/^emsgn(s, n)$/;"	f
enabled	structs.h	/^    int		enabled;	    \/* for which modes the menu is enabled *\/$/;"	m	struct:VimMenu
enc_alias_search	mbyte.c	/^enc_alias_search(name)$/;"	f	file:
enc_alias_table	mbyte.c	/^enc_alias_table[] =$/;"	v	typeref:struct:__anon41	file:
enc_canon_props	mbyte.c	/^enc_canon_props(name)$/;"	f
enc_canon_search	mbyte.c	/^enc_canon_search(name)$/;"	f	file:
enc_canon_table	mbyte.c	/^enc_canon_table[] =$/;"	v	typeref:struct:__anon40	file:
enc_canonize	mbyte.c	/^enc_canonize(enc)$/;"	f
enc_codepage	globals.h	/^EXTERN int	enc_codepage INIT(= -1);$/;"	v
enc_dbcs	globals.h	/^EXTERN int	enc_dbcs INIT(= 0);		\/* One of DBCS_xxx values if$/;"	v
enc_latin1like	globals.h	/^EXTERN int	enc_latin1like INIT(= TRUE);	\/* 'encoding' is latin1 comp. *\/$/;"	v
enc_latin9	globals.h	/^EXTERN int	enc_latin9 INIT(= FALSE);	\/* 'encoding' is latin9 *\/$/;"	v
enc_locale	mbyte.c	/^enc_locale()$/;"	f
enc_skip	mbyte.c	/^enc_skip(p)$/;"	f
enc_unicode	globals.h	/^EXTERN int	enc_unicode INIT(= 0);	\/* 2: UCS-2 or UTF-16, 4: UCS-4 *\/$/;"	v
enc_utf8	globals.h	/^EXTERN int	enc_utf8 INIT(= FALSE);		\/* UTF-8 encoded Unicode *\/$/;"	v
encname2codepage	mbyte.c	/^encname2codepage(name)$/;"	f
encoding	hardcopy.c	/^    char	*encoding;$/;"	m	struct:prt_ps_encoding_S	file:
encoding_callback	gui_xmdlg.c	/^encoding_callback(Widget w,$/;"	f	file:
encoding_menu	gui_xmdlg.c	/^    Widget	encoding_menu;$/;"	m	struct:_SharedFontSelData	file:
encoding_part	gui_xmdlg.c	/^encoding_part(char *font, char *buf)$/;"	f	file:
encoding_pulldown	gui_xmdlg.c	/^    Widget	encoding_pulldown;$/;"	m	struct:_SharedFontSelData	file:
encodings	hardcopy.c	/^    struct prt_ps_encoding_S	*encodings;$/;"	m	struct:prt_ps_mbfont_S	typeref:struct:prt_ps_mbfont_S::prt_ps_encoding_S	file:
end	fold.c	/^    int		end;		\/* level of fold that is forced to end below$/;"	m	struct:__anon12	file:
end	if_python.c	/^    PyInt end;$/;"	m	struct:__anon32	file:
end	search.c	/^    int		end;		\/* search set cursor at end *\/$/;"	m	struct:soffset	file:
end	structs.h	/^    pos_T	end;		\/* end of the operator *\/$/;"	m	struct:oparg_S
end	vim.h	/^    pos_T	end;		\/* End of selected area *\/$/;"	m	struct:VimClipboard
endSelection	gui_at_fs.c	/^    int		endSelection;$/;"	m	struct:__anon14	file:
end_adjusted	structs.h	/^    int		end_adjusted;	\/* backuped b_op_end one char (only used by$/;"	m	struct:oparg_S
end_char_vcols	ops.c	/^    colnr_T	end_char_vcols;	\/* number of vcols of post-block char *\/$/;"	m	struct:block_def	file:
end_col_nr	ex_cmds.c	/^    long	end_col_nr;		\/* ending column number *\/$/;"	m	struct:__anon8	file:
end_comment_pending	globals.h	/^EXTERN int     end_comment_pending INIT(= NUL);$/;"	v
end_dynamic_python	if_python.c	/^end_dynamic_python(void)$/;"	f	file:
end_dynamic_ruby	if_ruby.c	/^end_dynamic_ruby()$/;"	f	file:
end_search_hl	screen.c	/^end_search_hl()$/;"	f	file:
end_vcol	ops.c	/^    colnr_T	end_vcol;	\/* start col of 1st char wholly after block *\/$/;"	m	struct:block_def	file:
end_vcol	structs.h	/^    colnr_T	end_vcol;	\/* end col for block mode operator *\/$/;"	m	struct:oparg_S
end_visual_mode	normal.c	/^end_visual_mode()$/;"	f
end_word	search.c	/^end_word(count, bigword, stop, empty)$/;"	f
endcol	structs.h	/^    colnr_T	endcol;	 \/* in win_line() points to char where HL ends *\/$/;"	m	struct:__anon96
endp	regexp.h	/^    char_u		*endp[NSUBEXP];$/;"	m	struct:__anon76
endpos	regexp.h	/^    lpos_T		endpos[NSUBEXP];$/;"	m	struct:__anon77
ends_excmd	ex_docmd.c	/^ends_excmd(c)$/;"	f
ends_in_white	ops.c	/^ends_in_white(lnum)$/;"	f	file:
endspaces	ops.c	/^    int		endspaces;	\/* 'extra' cols of first char *\/$/;"	m	struct:block_def	file:
enhancedbutton	gui_xmebwp.h	/^    XmEnhancedButtonPart enhancedbutton;$/;"	m	struct:_XmEnhancedButtonRec
enhancedbutton_class	gui_xmebwp.h	/^    XmEnhancedButtonClassPart enhancedbutton_class;$/;"	m	struct:__anon67
ensure_ruby_initialized	if_ruby.c	/^static int ensure_ruby_initialized(void)$/;"	f	file:
enter_buffer	buffer.c	/^enter_buffer(buf)$/;"	f
enter_cleanup	ex_eval.c	/^enter_cleanup(csp)$/;"	f
enter_notify_event	gui_gtk_x11.c	/^enter_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)$/;"	f	file:
enter_tabpage	window.c	/^enter_tabpage(tp, old_curbuf)$/;"	f	file:
entries	gui_at_fs.c	/^    SFEntry	*entries;$/;"	m	struct:__anon14	file:
entry_activate_callback	gui_motif.c	/^entry_activate_callback(w, client_data, call_data)$/;"	f	file:
entry_activate_cb	gui_gtk.c	/^entry_activate_cb(GtkWidget *widget, gpointer data)$/;"	f	file:
entry_changed_cb	gui_gtk.c	/^entry_changed_cb(GtkWidget * entry, GtkWidget * dialog)$/;"	f	file:
env	if_mzsch.c	/^    Scheme_Env	    *env;$/;"	m	struct:__anon21	file:
env	if_mzsch.c	/^    Scheme_Env	*env;$/;"	m	struct:__anon25	file:
environment	if_mzsch.c	/^static Scheme_Env    *environment = NULL;$/;"	v	file:
envsize	misc2.c	/^static int  envsize = -1;	\/* current size of environment *\/$/;"	v	file:
equalpos	macros.h	/^# define equalpos(/;"	d
errmsg	ex_cmds.h	/^    char_u	*errmsg;	\/* returned error message *\/$/;"	m	struct:exarg
error	ex_cmds2.c	/^    int		error;		\/* TRUE if LF found after CR-LF *\/$/;"	m	struct:source_cookie	file:
error	if_python.c	/^    long error;$/;"	m	struct:__anon29	file:
errorHandler	nbdebug.c	/^errorHandler($/;"	f	file:
errorHandler	wsdebug.c	/^errorHandler($/;"	f	file:
error_ga	globals.h	/^EXTERN garray_T error_ga$/;"	v
error_print	if_ruby.c	/^static void error_print(int state)$/;"	f	file:
escape_chars	globals.h	/^EXTERN char_u	*escape_chars INIT(= (char_u *)" \\t\\\\\\"|");$/;"	v
escape_fname	ex_getln.c	/^escape_fname(pp)$/;"	f	file:
eslist_T	structs.h	/^typedef struct eslist_elem eslist_T;$/;"	t	typeref:struct:eslist_elem
eslist_elem	structs.h	/^struct eslist_elem$/;"	s
eval0	eval.c	/^eval0(arg, rettv, nextcmd, evaluate)$/;"	f	file:
eval1	eval.c	/^eval1(arg, rettv, evaluate)$/;"	f	file:
eval2	eval.c	/^eval2(arg, rettv, evaluate)$/;"	f	file:
eval3	eval.c	/^eval3(arg, rettv, evaluate)$/;"	f	file:
eval4	eval.c	/^eval4(arg, rettv, evaluate)$/;"	f	file:
eval5	eval.c	/^eval5(arg, rettv, evaluate)$/;"	f	file:
eval6	eval.c	/^eval6(arg, rettv, evaluate, want_string)$/;"	f	file:
eval7	eval.c	/^eval7(arg, rettv, evaluate, want_string)$/;"	f	file:
eval_charconvert	eval.c	/^eval_charconvert(enc_from, enc_to, fname_from, fname_to)$/;"	f
eval_clear	eval.c	/^eval_clear()$/;"	f
eval_client_expr_to_string	main.c	/^eval_client_expr_to_string(expr)$/;"	f
eval_diff	eval.c	/^eval_diff(origfile, newfile, outfile)$/;"	f
eval_expr	eval.c	/^eval_expr(arg, nextcmd)$/;"	f
eval_fname_script	eval.c	/^eval_fname_script(p)$/;"	f	file:
eval_fname_sid	eval.c	/^eval_fname_sid(p)$/;"	f	file:
eval_foldexpr	eval.c	/^eval_foldexpr(arg, cp)$/;"	f
eval_for_line	eval.c	/^eval_for_line(arg, errp, nextcmdp, skip)$/;"	f
eval_in_namespace	if_mzsch.c	/^eval_in_namespace(void *data, Scheme_Closed_Prim *what, Scheme_Env *env,$/;"	f	file:
eval_includeexpr	window.c	/^eval_includeexpr(ptr, len)$/;"	f	file:
eval_index	eval.c	/^eval_index(arg, rettv, evaluate, verbose)$/;"	f	file:
eval_init	eval.c	/^eval_init()$/;"	f
eval_input	if_python.c	/^#define eval_input	/;"	d	file:
eval_isnamec	eval.c	/^eval_isnamec(c)$/;"	f	file:
eval_isnamec1	eval.c	/^eval_isnamec1(c)$/;"	f	file:
eval_map_expr	getchar.c	/^eval_map_expr(str)$/;"	f	file:
eval_patch	eval.c	/^eval_patch(origfile, difffile, outfile)$/;"	f
eval_printexpr	eval.c	/^eval_printexpr(fname, args)$/;"	f
eval_soundfold	spell.c	/^eval_soundfold(word)$/;"	f
eval_spell_expr	eval.c	/^eval_spell_expr(badword, expr)$/;"	f
eval_to_bool	eval.c	/^eval_to_bool(arg, error, nextcmd, skip)$/;"	f
eval_to_number	eval.c	/^eval_to_number(expr)$/;"	f
eval_to_string	eval.c	/^eval_to_string(arg, nextcmd, dolist)$/;"	f
eval_to_string_safe	eval.c	/^eval_to_string_safe(arg, nextcmd, use_sandbox)$/;"	f
eval_to_string_skip	eval.c	/^eval_to_string_skip(arg, nextcmd, skip)$/;"	f
eval_vars	ex_docmd.c	/^eval_vars(src, srcstart, usedlen, lnump, errormsg, escaped)$/;"	f
event	fileio.c	/^    event_T	event;		\/* current event *\/$/;"	m	struct:AutoPatCmd	file:
event	fileio.c	/^    event_T	event;	\/* event number *\/$/;"	m	struct:event_name	file:
event_T	vim.h	/^typedef enum auto_event event_T;$/;"	t	typeref:enum:auto_event
event_buffer	gui.h	/^    PhEvent_t	*event_buffer;$/;"	m	struct:Gui
event_ignored	fileio.c	/^event_ignored(event)$/;"	f	file:
event_name	fileio.c	/^static struct event_name$/;"	s	file:
event_name2nr	fileio.c	/^event_name2nr(start, end)$/;"	f	file:
event_names	fileio.c	/^} event_names[] =$/;"	v	typeref:struct:event_name	file:
event_nr2name	fileio.c	/^event_nr2name(event)$/;"	f	file:
evim_mode	main.c	/^    int		evim_mode;		\/* started as "evim" *\/$/;"	m	struct:__anon39	file:
ex_X	ex_docmd.c	/^# define ex_X	/;"	d	file:
ex_X	ex_docmd.c	/^ex_X(eap)$/;"	f	file:
ex_abbreviate	ex_docmd.c	/^ex_abbreviate(eap)$/;"	f	file:
ex_abclear	ex_docmd.c	/^ex_abclear(eap)$/;"	f	file:
ex_align	ex_cmds.c	/^ex_align(eap)$/;"	f
ex_align	ex_docmd.c	/^# define ex_align	/;"	d	file:
ex_all	ex_docmd.c	/^# define ex_all	/;"	d	file:
ex_all	ex_docmd.c	/^ex_all(eap)$/;"	f
ex_append	ex_cmds.c	/^ex_append(eap)$/;"	f
ex_argadd	ex_cmds2.c	/^ex_argadd(eap)$/;"	f
ex_argadd	ex_docmd.c	/^# define ex_argadd	/;"	d	file:
ex_argdelete	ex_cmds2.c	/^ex_argdelete(eap)$/;"	f
ex_argdelete	ex_docmd.c	/^# define ex_argdelete	/;"	d	file:
ex_argedit	ex_cmds2.c	/^ex_argedit(eap)$/;"	f
ex_argedit	ex_docmd.c	/^# define ex_argedit	/;"	d	file:
ex_args	ex_cmds2.c	/^ex_args(eap)$/;"	f
ex_argument	ex_cmds2.c	/^ex_argument(eap)$/;"	f
ex_at	ex_docmd.c	/^ex_at(eap)$/;"	f	file:
ex_autocmd	ex_docmd.c	/^# define ex_autocmd	/;"	d	file:
ex_autocmd	ex_docmd.c	/^ex_autocmd(eap)$/;"	f	file:
ex_bang	ex_docmd.c	/^ex_bang(eap)$/;"	f	file:
ex_behave	ex_docmd.c	/^ex_behave(eap)$/;"	f	file:
ex_blast	ex_docmd.c	/^# define ex_blast	/;"	d	file:
ex_blast	ex_docmd.c	/^ex_blast(eap)$/;"	f	file:
ex_bmodified	ex_docmd.c	/^# define ex_bmodified	/;"	d	file:
ex_bmodified	ex_docmd.c	/^ex_bmodified(eap)$/;"	f	file:
ex_bnext	ex_docmd.c	/^# define ex_bnext	/;"	d	file:
ex_bnext	ex_docmd.c	/^ex_bnext(eap)$/;"	f	file:
ex_bprevious	ex_docmd.c	/^# define ex_bprevious	/;"	d	file:
ex_bprevious	ex_docmd.c	/^ex_bprevious(eap)$/;"	f	file:
ex_break	ex_docmd.c	/^# define ex_break	/;"	d	file:
ex_break	ex_eval.c	/^ex_break(eap)$/;"	f
ex_breakadd	ex_cmds2.c	/^ex_breakadd(eap)$/;"	f
ex_breakadd	ex_docmd.c	/^# define ex_breakadd	/;"	d	file:
ex_breakdel	ex_cmds2.c	/^ex_breakdel(eap)$/;"	f
ex_breakdel	ex_docmd.c	/^# define ex_breakdel	/;"	d	file:
ex_breaklist	ex_cmds2.c	/^ex_breaklist(eap)$/;"	f
ex_breaklist	ex_docmd.c	/^# define ex_breaklist	/;"	d	file:
ex_brewind	ex_docmd.c	/^# define ex_brewind	/;"	d	file:
ex_brewind	ex_docmd.c	/^ex_brewind(eap)$/;"	f	file:
ex_buffer	ex_docmd.c	/^# define ex_buffer	/;"	d	file:
ex_buffer	ex_docmd.c	/^ex_buffer(eap)$/;"	f	file:
ex_buffer_all	buffer.c	/^ex_buffer_all(eap)$/;"	f
ex_buffer_all	ex_docmd.c	/^# define ex_buffer_all	/;"	d	file:
ex_bunload	ex_docmd.c	/^# define ex_bunload	/;"	d	file:
ex_bunload	ex_docmd.c	/^ex_bunload(eap)$/;"	f	file:
ex_call	eval.c	/^ex_call(eap)$/;"	f
ex_call	ex_docmd.c	/^# define ex_call	/;"	d	file:
ex_catch	ex_docmd.c	/^# define ex_catch	/;"	d	file:
ex_catch	ex_eval.c	/^ex_catch(eap)$/;"	f
ex_cbuffer	ex_docmd.c	/^# define ex_cbuffer	/;"	d	file:
ex_cbuffer	quickfix.c	/^ex_cbuffer(eap)$/;"	f
ex_cc	ex_docmd.c	/^# define ex_cc	/;"	d	file:
ex_cc	quickfix.c	/^ex_cc(eap)$/;"	f
ex_cclose	ex_docmd.c	/^# define ex_cclose	/;"	d	file:
ex_cclose	quickfix.c	/^ex_cclose(eap)$/;"	f
ex_cd	ex_docmd.c	/^ex_cd(eap)$/;"	f
ex_cexpr	ex_docmd.c	/^# define ex_cexpr	/;"	d	file:
ex_cexpr	quickfix.c	/^ex_cexpr(eap)$/;"	f
ex_cfile	ex_docmd.c	/^# define ex_cfile	/;"	d	file:
ex_cfile	quickfix.c	/^ex_cfile(eap)$/;"	f
ex_change	ex_cmds.c	/^ex_change(eap)$/;"	f
ex_changes	ex_docmd.c	/^# define ex_changes	/;"	d	file:
ex_changes	mark.c	/^ex_changes(eap)$/;"	f
ex_checkpath	ex_docmd.c	/^# define ex_checkpath	/;"	d	file:
ex_checkpath	ex_docmd.c	/^ex_checkpath(eap)$/;"	f	file:
ex_checktime	ex_cmds2.c	/^ex_checktime(eap)$/;"	f
ex_checktime	ex_docmd.c	/^# define ex_checktime	/;"	d	file:
ex_close	ex_docmd.c	/^# define ex_close	/;"	d	file:
ex_close	ex_docmd.c	/^ex_close(eap)$/;"	f	file:
ex_cnext	ex_docmd.c	/^# define ex_cnext	/;"	d	file:
ex_cnext	quickfix.c	/^ex_cnext(eap)$/;"	f
ex_colorscheme	ex_docmd.c	/^ex_colorscheme(eap)$/;"	f	file:
ex_comclear	ex_docmd.c	/^# define ex_comclear	/;"	d	file:
ex_comclear	ex_docmd.c	/^ex_comclear(eap)$/;"	f
ex_command	ex_docmd.c	/^# define ex_command	/;"	d	file:
ex_command	ex_docmd.c	/^ex_command(eap)$/;"	f	file:
ex_compiler	ex_cmds2.c	/^ex_compiler(eap)$/;"	f
ex_compiler	ex_docmd.c	/^# define ex_compiler	/;"	d	file:
ex_continue	ex_docmd.c	/^# define ex_continue	/;"	d	file:
ex_continue	ex_eval.c	/^ex_continue(eap)$/;"	f
ex_copen	ex_docmd.c	/^# define ex_copen	/;"	d	file:
ex_copen	quickfix.c	/^ex_copen(eap)$/;"	f
ex_copy	ex_cmds.c	/^ex_copy(line1, line2, n)$/;"	f
ex_copymove	ex_docmd.c	/^ex_copymove(eap)$/;"	f	file:
ex_cquit	ex_docmd.c	/^ex_cquit(eap)$/;"	f	file:
ex_cwindow	ex_docmd.c	/^# define ex_cwindow	/;"	d	file:
ex_cwindow	quickfix.c	/^ex_cwindow(eap)$/;"	f
ex_debug	ex_cmds2.c	/^ex_debug(eap)$/;"	f
ex_debug	ex_docmd.c	/^# define ex_debug	/;"	d	file:
ex_debuggreedy	ex_cmds2.c	/^ex_debuggreedy(eap)$/;"	f
ex_debuggreedy	ex_docmd.c	/^# define ex_debuggreedy	/;"	d	file:
ex_delcommand	ex_docmd.c	/^# define ex_delcommand	/;"	d	file:
ex_delcommand	ex_docmd.c	/^ex_delcommand(eap)$/;"	f	file:
ex_delfunction	eval.c	/^ex_delfunction(eap)$/;"	f
ex_delfunction	ex_docmd.c	/^# define ex_delfunction	/;"	d	file:
ex_delmarks	mark.c	/^ex_delmarks(eap)$/;"	f
ex_diffgetput	diff.c	/^ex_diffgetput(eap)$/;"	f
ex_diffgetput	ex_docmd.c	/^# define ex_diffgetput	/;"	d	file:
ex_diffoff	diff.c	/^ex_diffoff(eap)$/;"	f
ex_diffoff	ex_docmd.c	/^# define ex_diffoff	/;"	d	file:
ex_diffpatch	diff.c	/^ex_diffpatch(eap)$/;"	f
ex_diffpatch	ex_docmd.c	/^# define ex_diffpatch	/;"	d	file:
ex_diffsplit	diff.c	/^ex_diffsplit(eap)$/;"	f
ex_diffsplit	ex_docmd.c	/^# define ex_diffsplit	/;"	d	file:
ex_diffthis	diff.c	/^ex_diffthis(eap)$/;"	f
ex_diffthis	ex_docmd.c	/^# define ex_diffthis	/;"	d	file:
ex_diffupdate	diff.c	/^ex_diffupdate(eap)$/;"	f
ex_diffupdate	ex_docmd.c	/^# define ex_diffupdate	/;"	d	file:
ex_digraphs	ex_docmd.c	/^ex_digraphs(eap)$/;"	f	file:
ex_display	ops.c	/^ex_display(eap)$/;"	f
ex_doautoall	ex_docmd.c	/^# define ex_doautoall	/;"	d	file:
ex_doautoall	fileio.c	/^ex_doautoall(eap)$/;"	f
ex_doautocmd	ex_docmd.c	/^# define ex_doautocmd	/;"	d	file:
ex_doautocmd	ex_docmd.c	/^ex_doautocmd(eap)$/;"	f	file:
ex_drop	ex_cmds.c	/^ex_drop(eap)$/;"	f
ex_drop	ex_docmd.c	/^# define ex_drop	/;"	d	file:
ex_echo	eval.c	/^ex_echo(eap)$/;"	f
ex_echo	ex_docmd.c	/^# define ex_echo	/;"	d	file:
ex_echohl	eval.c	/^ex_echohl(eap)$/;"	f
ex_echohl	ex_docmd.c	/^# define ex_echohl	/;"	d	file:
ex_edit	ex_docmd.c	/^ex_edit(eap)$/;"	f	file:
ex_else	ex_docmd.c	/^# define ex_else	/;"	d	file:
ex_else	ex_eval.c	/^ex_else(eap)$/;"	f
ex_emenu	ex_docmd.c	/^# define ex_emenu	/;"	d	file:
ex_emenu	menu.c	/^ex_emenu(eap)$/;"	f
ex_endfor	ex_docmd.c	/^# define ex_endfor	/;"	d	file:
ex_endfunction	ex_docmd.c	/^# define ex_endfunction	/;"	d	file:
ex_endfunction	ex_eval.c	/^ex_endfunction(eap)$/;"	f
ex_endif	ex_docmd.c	/^# define ex_endif	/;"	d	file:
ex_endif	ex_eval.c	/^ex_endif(eap)$/;"	f
ex_endtry	ex_docmd.c	/^# define ex_endtry	/;"	d	file:
ex_endtry	ex_eval.c	/^ex_endtry(eap)$/;"	f
ex_endwhile	ex_docmd.c	/^# define ex_endwhile	/;"	d	file:
ex_endwhile	ex_eval.c	/^ex_endwhile(eap)$/;"	f
ex_equal	ex_docmd.c	/^ex_equal(eap)$/;"	f	file:
ex_execute	eval.c	/^ex_execute(eap)$/;"	f
ex_execute	ex_docmd.c	/^# define ex_execute	/;"	d	file:
ex_exit	ex_docmd.c	/^ex_exit(eap)$/;"	f	file:
ex_exitval	globals.h	/^EXTERN int	ex_exitval INIT(= 0);	    \/* exit value for ex mode *\/$/;"	v
ex_exusage	ex_cmds.c	/^ex_exusage(eap)$/;"	f
ex_file	ex_cmds.c	/^ex_file(eap)$/;"	f
ex_filetype	ex_docmd.c	/^# define ex_filetype	/;"	d	file:
ex_filetype	ex_docmd.c	/^ex_filetype(eap)$/;"	f	file:
ex_finally	ex_docmd.c	/^# define ex_finally	/;"	d	file:
ex_finally	ex_eval.c	/^ex_finally(eap)$/;"	f
ex_find	ex_docmd.c	/^ex_find(eap)$/;"	f	file:
ex_findpat	ex_docmd.c	/^# define ex_findpat	/;"	d	file:
ex_findpat	ex_docmd.c	/^ex_findpat(eap)$/;"	f	file:
ex_finish	ex_cmds2.c	/^ex_finish(eap)$/;"	f
ex_finish	ex_docmd.c	/^# define ex_finish	/;"	d	file:
ex_fold	ex_docmd.c	/^# define ex_fold	/;"	d	file:
ex_fold	ex_docmd.c	/^ex_fold(eap)$/;"	f	file:
ex_folddo	ex_docmd.c	/^# define ex_folddo	/;"	d	file:
ex_folddo	ex_docmd.c	/^ex_folddo(eap)$/;"	f	file:
ex_foldopen	ex_docmd.c	/^# define ex_foldopen	/;"	d	file:
ex_foldopen	ex_docmd.c	/^ex_foldopen(eap)$/;"	f	file:
ex_for	ex_docmd.c	/^# define ex_for	/;"	d	file:
ex_func_T	ex_cmds.h	/^typedef void (*ex_func_T) __ARGS((exarg_T *eap));$/;"	t
ex_function	eval.c	/^ex_function(eap)$/;"	f
ex_function	ex_docmd.c	/^# define ex_function	/;"	d	file:
ex_global	ex_cmds.c	/^ex_global(eap)$/;"	f
ex_goto	ex_docmd.c	/^# define ex_goto	/;"	d	file:
ex_goto	ex_docmd.c	/^ex_goto(eap)$/;"	f	file:
ex_gui	ex_docmd.c	/^# define ex_gui	/;"	d	file:
ex_gui	gui.c	/^ex_gui(eap)$/;"	f
ex_hardcopy	ex_docmd.c	/^# define ex_hardcopy	/;"	d	file:
ex_hardcopy	hardcopy.c	/^ex_hardcopy(eap)$/;"	f
ex_help	ex_cmds.c	/^ex_help(eap)$/;"	f
ex_helpfind	ex_docmd.c	/^# define ex_helpfind	/;"	d	file:
ex_helpfind	gui_gtk.c	/^ex_helpfind(eap)$/;"	f
ex_helpgrep	ex_docmd.c	/^# define ex_helpgrep	/;"	d	file:
ex_helpgrep	quickfix.c	/^ex_helpgrep(eap)$/;"	f
ex_helptags	ex_cmds.c	/^ex_helptags(eap)$/;"	f
ex_helptags	ex_docmd.c	/^# define ex_helptags	/;"	d	file:
ex_hide	ex_docmd.c	/^ex_hide(eap)$/;"	f	file:
ex_highlight	ex_docmd.c	/^ex_highlight(eap)$/;"	f	file:
ex_history	ex_docmd.c	/^# define ex_history	/;"	d	file:
ex_history	ex_getln.c	/^ex_history(eap)$/;"	f
ex_if	ex_docmd.c	/^# define ex_if	/;"	d	file:
ex_if	ex_eval.c	/^ex_if(eap)$/;"	f
ex_intro	version.c	/^ex_intro(eap)$/;"	f
ex_join	ex_docmd.c	/^ex_join(eap)$/;"	f	file:
ex_jumps	ex_docmd.c	/^# define ex_jumps	/;"	d	file:
ex_jumps	mark.c	/^ex_jumps(eap)$/;"	f
ex_keep_indent	globals.h	/^EXTERN int	ex_keep_indent INIT(= FALSE); \/* getexmodeline(): keep indent *\/$/;"	v
ex_language	ex_cmds2.c	/^ex_language(eap)$/;"	f
ex_language	ex_docmd.c	/^# define ex_language	/;"	d	file:
ex_last	ex_cmds2.c	/^ex_last(eap)$/;"	f
ex_later	ex_docmd.c	/^ex_later(eap)$/;"	f	file:
ex_let	eval.c	/^ex_let(eap)$/;"	f
ex_let	ex_docmd.c	/^# define ex_let	/;"	d	file:
ex_let_one	eval.c	/^ex_let_one(arg, tv, copy, endchars, op)$/;"	f	file:
ex_let_vars	eval.c	/^ex_let_vars(arg_start, tv, copy, semicolon, var_count, nextchars)$/;"	f	file:
ex_listdo	ex_cmds2.c	/^ex_listdo(eap)$/;"	f
ex_listdo	ex_docmd.c	/^# define ex_listdo	/;"	d	file:
ex_loadkeymap	digraph.c	/^ex_loadkeymap(eap)$/;"	f
ex_loadkeymap	ex_docmd.c	/^# define ex_loadkeymap	/;"	d	file:
ex_loadview	ex_docmd.c	/^# define ex_loadview	/;"	d	file:
ex_loadview	ex_docmd.c	/^ex_loadview(eap)$/;"	f	file:
ex_lockvar	eval.c	/^ex_lockvar(eap)$/;"	f
ex_lockvar	ex_docmd.c	/^# define ex_lockvar	/;"	d	file:
ex_make	ex_docmd.c	/^# define ex_make	/;"	d	file:
ex_make	quickfix.c	/^ex_make(eap)$/;"	f
ex_map	ex_docmd.c	/^ex_map(eap)$/;"	f	file:
ex_mapclear	ex_docmd.c	/^ex_mapclear(eap)$/;"	f	file:
ex_mark	ex_docmd.c	/^ex_mark(eap)$/;"	f	file:
ex_match	ex_docmd.c	/^# define ex_match	/;"	d	file:
ex_match	ex_docmd.c	/^ex_match(eap)$/;"	f	file:
ex_may_print	ex_docmd.c	/^ex_may_print(eap)$/;"	f	file:
ex_menu	ex_docmd.c	/^# define ex_menu	/;"	d	file:
ex_menu	menu.c	/^ex_menu(eap)$/;"	f
ex_menutranslate	ex_docmd.c	/^# define ex_menutranslate	/;"	d	file:
ex_menutranslate	menu.c	/^ex_menutranslate(eap)$/;"	f
ex_messages	message.c	/^ex_messages(eap)$/;"	f
ex_mkrc	ex_docmd.c	/^ex_mkrc(eap)$/;"	f	file:
ex_mkspell	ex_docmd.c	/^# define ex_mkspell	/;"	d	file:
ex_mkspell	spell.c	/^ex_mkspell(eap)$/;"	f
ex_mode	ex_docmd.c	/^ex_mode(eap)$/;"	f	file:
ex_mzfile	ex_docmd.c	/^# define ex_mzfile	/;"	d	file:
ex_mzfile	if_mzsch.c	/^ex_mzfile(exarg_T *eap)$/;"	f
ex_mzscheme	ex_docmd.c	/^# define ex_mzscheme	/;"	d	file:
ex_mzscheme	if_mzsch.c	/^ex_mzscheme(exarg_T *eap)$/;"	f
ex_nbkey	ex_docmd.c	/^# define ex_nbkey	/;"	d	file:
ex_nbkey	netbeans.c	/^ex_nbkey(eap)$/;"	f
ex_nesting_level	globals.h	/^EXTERN int	ex_nesting_level INIT(= 0);	\/* nesting level *\/$/;"	v
ex_next	ex_cmds2.c	/^ex_next(eap)$/;"	f
ex_ni	ex_docmd.c	/^ex_ni(eap)$/;"	f
ex_no_reprint	globals.h	/^EXTERN int ex_no_reprint INIT(= FALSE); \/* no need to print after z or p *\/$/;"	v
ex_nogui	ex_docmd.c	/^ex_nogui(eap)$/;"	f	file:
ex_nohlsearch	ex_docmd.c	/^# define ex_nohlsearch	/;"	d	file:
ex_nohlsearch	ex_docmd.c	/^ex_nohlsearch(eap)$/;"	f	file:
ex_normal	ex_docmd.c	/^# define ex_normal	/;"	d	file:
ex_normal	ex_docmd.c	/^ex_normal(eap)$/;"	f	file:
ex_normal_busy	globals.h	/^EXTERN int	ex_normal_busy INIT(= 0); \/* recursiveness of ex_normal() *\/$/;"	v
ex_normal_lock	globals.h	/^EXTERN int	ex_normal_lock INIT(= 0); \/* forbid use of ex_normal() *\/$/;"	v
ex_only	ex_docmd.c	/^# define ex_only	/;"	d	file:
ex_only	ex_docmd.c	/^ex_only(eap)$/;"	f	file:
ex_open	ex_docmd.c	/^ex_open(eap)$/;"	f	file:
ex_operators	ex_docmd.c	/^ex_operators(eap)$/;"	f	file:
ex_options	ex_cmds2.c	/^ex_options(eap)$/;"	f
ex_options	ex_docmd.c	/^# define ex_options	/;"	d	file:
ex_pclose	ex_docmd.c	/^# define ex_pclose	/;"	d	file:
ex_pclose	ex_docmd.c	/^ex_pclose(eap)$/;"	f	file:
ex_pedit	ex_docmd.c	/^# define ex_pedit	/;"	d	file:
ex_pedit	ex_docmd.c	/^ex_pedit(eap)$/;"	f	file:
ex_perl	ex_docmd.c	/^# define ex_perl	/;"	d	file:
ex_perldo	ex_docmd.c	/^# define ex_perldo	/;"	d	file:
ex_popup	ex_docmd.c	/^# define ex_popup	/;"	d	file:
ex_popup	ex_docmd.c	/^ex_popup(eap)$/;"	f	file:
ex_preserve	ex_docmd.c	/^ex_preserve(eap)$/;"	f	file:
ex_pressedreturn	ex_docmd.c	/^static int	ex_pressedreturn = FALSE;$/;"	v	file:
ex_previous	ex_cmds2.c	/^ex_previous(eap)$/;"	f
ex_print	ex_docmd.c	/^ex_print(eap)$/;"	f	file:
ex_profile	ex_cmds2.c	/^ex_profile(eap)$/;"	f
ex_profile	ex_docmd.c	/^# define ex_profile	/;"	d	file:
ex_psearch	ex_docmd.c	/^# define ex_psearch	/;"	d	file:
ex_psearch	ex_docmd.c	/^ex_psearch(eap)$/;"	f	file:
ex_ptag	ex_docmd.c	/^# define ex_ptag	/;"	d	file:
ex_ptag	ex_docmd.c	/^ex_ptag(eap)$/;"	f	file:
ex_put	ex_docmd.c	/^ex_put(eap)$/;"	f	file:
ex_pwd	ex_docmd.c	/^ex_pwd(eap)$/;"	f	file:
ex_pyfile	ex_docmd.c	/^# define ex_pyfile	/;"	d	file:
ex_pyfile	if_python.c	/^ex_pyfile(exarg_T *eap)$/;"	f
ex_python	ex_docmd.c	/^# define ex_python	/;"	d	file:
ex_python	if_python.c	/^ex_python(exarg_T *eap)$/;"	f
ex_quit	ex_docmd.c	/^ex_quit(eap)$/;"	f	file:
ex_quit_all	ex_docmd.c	/^ex_quit_all(eap)$/;"	f	file:
ex_read	ex_docmd.c	/^ex_read(eap)$/;"	f	file:
ex_recover	ex_docmd.c	/^ex_recover(eap)$/;"	f	file:
ex_redir	ex_docmd.c	/^ex_redir(eap)$/;"	f	file:
ex_redo	ex_docmd.c	/^ex_redo(eap)$/;"	f	file:
ex_redraw	ex_docmd.c	/^ex_redraw(eap)$/;"	f	file:
ex_redrawstatus	ex_docmd.c	/^ex_redrawstatus(eap)$/;"	f	file:
ex_resize	ex_docmd.c	/^# define ex_resize	/;"	d	file:
ex_resize	ex_docmd.c	/^ex_resize(eap)$/;"	f	file:
ex_retab	ex_cmds.c	/^ex_retab(eap)$/;"	f
ex_retab	ex_docmd.c	/^# define ex_retab	/;"	d	file:
ex_return	eval.c	/^ex_return(eap)$/;"	f
ex_return	ex_docmd.c	/^# define ex_return	/;"	d	file:
ex_rewind	ex_cmds2.c	/^ex_rewind(eap)$/;"	f
ex_ruby	ex_docmd.c	/^# define ex_ruby	/;"	d	file:
ex_ruby	if_ruby.c	/^void ex_ruby(exarg_T *eap)$/;"	f
ex_rubydo	ex_docmd.c	/^# define ex_rubydo	/;"	d	file:
ex_rubydo	if_ruby.c	/^void ex_rubydo(exarg_T *eap)$/;"	f
ex_rubyfile	ex_docmd.c	/^# define ex_rubyfile	/;"	d	file:
ex_rubyfile	if_ruby.c	/^void ex_rubyfile(exarg_T *eap)$/;"	f
ex_runtime	ex_cmds2.c	/^ex_runtime(eap)$/;"	f
ex_script_ni	ex_docmd.c	/^ex_script_ni(eap)$/;"	f	file:
ex_scriptencoding	ex_cmds2.c	/^ex_scriptencoding(eap)$/;"	f
ex_scriptnames	ex_cmds2.c	/^ex_scriptnames(eap)$/;"	f
ex_scriptnames	ex_docmd.c	/^# define ex_scriptnames	/;"	d	file:
ex_set	ex_docmd.c	/^ex_set(eap)$/;"	f	file:
ex_setfiletype	ex_docmd.c	/^# define ex_setfiletype	/;"	d	file:
ex_setfiletype	ex_docmd.c	/^ex_setfiletype(eap)$/;"	f	file:
ex_shell	ex_docmd.c	/^ex_shell(eap)$/;"	f	file:
ex_sign	ex_cmds.c	/^ex_sign(eap)$/;"	f
ex_sign	ex_docmd.c	/^# define ex_sign	/;"	d	file:
ex_simalt	ex_docmd.c	/^# define ex_simalt	/;"	d	file:
ex_sleep	ex_docmd.c	/^ex_sleep(eap)$/;"	f	file:
ex_sniff	ex_docmd.c	/^# define ex_sniff	/;"	d	file:
ex_sort	ex_cmds.c	/^ex_sort(eap)$/;"	f
ex_sort	ex_docmd.c	/^# define ex_sort	/;"	d	file:
ex_source	ex_cmds2.c	/^ex_source(eap)$/;"	f
ex_spell	ex_docmd.c	/^# define ex_spell	/;"	d	file:
ex_spell	spell.c	/^ex_spell(eap)$/;"	f
ex_spelldump	ex_docmd.c	/^# define ex_spelldump	/;"	d	file:
ex_spelldump	spell.c	/^ex_spelldump(eap)$/;"	f
ex_spellinfo	ex_docmd.c	/^# define ex_spellinfo	/;"	d	file:
ex_spellinfo	spell.c	/^ex_spellinfo(eap)$/;"	f
ex_spellrepall	ex_docmd.c	/^# define ex_spellrepall	/;"	d	file:
ex_spellrepall	spell.c	/^ex_spellrepall(eap)$/;"	f
ex_splitview	ex_docmd.c	/^# define ex_splitview	/;"	d	file:
ex_splitview	ex_docmd.c	/^ex_splitview(eap)$/;"	f
ex_stag	ex_docmd.c	/^# define ex_stag	/;"	d	file:
ex_stag	ex_docmd.c	/^ex_stag(eap)$/;"	f	file:
ex_startinsert	ex_docmd.c	/^# define ex_startinsert	/;"	d	file:
ex_startinsert	ex_docmd.c	/^ex_startinsert(eap)$/;"	f	file:
ex_stop	ex_docmd.c	/^ex_stop(eap)$/;"	f	file:
ex_stopinsert	ex_docmd.c	/^# define ex_stopinsert	/;"	d	file:
ex_stopinsert	ex_docmd.c	/^ex_stopinsert(eap)$/;"	f	file:
ex_submagic	ex_docmd.c	/^ex_submagic(eap)$/;"	f	file:
ex_swapname	ex_docmd.c	/^ex_swapname(eap)$/;"	f	file:
ex_syncbind	ex_docmd.c	/^ex_syncbind(eap)$/;"	f	file:
ex_syntax	ex_docmd.c	/^# define ex_syntax	/;"	d	file:
ex_syntax	syntax.c	/^ex_syntax(eap)$/;"	f
ex_tabclose	ex_docmd.c	/^# define ex_tabclose	/;"	d	file:
ex_tabclose	ex_docmd.c	/^ex_tabclose(eap)$/;"	f	file:
ex_tabmove	ex_docmd.c	/^# define ex_tabmove	/;"	d	file:
ex_tabmove	ex_docmd.c	/^ex_tabmove(eap)$/;"	f	file:
ex_tabnext	ex_docmd.c	/^# define ex_tabnext	/;"	d	file:
ex_tabnext	ex_docmd.c	/^ex_tabnext(eap)$/;"	f	file:
ex_tabonly	ex_docmd.c	/^# define ex_tabonly	/;"	d	file:
ex_tabonly	ex_docmd.c	/^ex_tabonly(eap)$/;"	f	file:
ex_tabs	ex_docmd.c	/^# define ex_tabs	/;"	d	file:
ex_tabs	ex_docmd.c	/^ex_tabs(eap)$/;"	f	file:
ex_tag	ex_docmd.c	/^ex_tag(eap)$/;"	f	file:
ex_tag_cmd	ex_docmd.c	/^ex_tag_cmd(eap, name)$/;"	f	file:
ex_tcl	ex_docmd.c	/^# define ex_tcl	/;"	d	file:
ex_tcl	if_tcl.c	/^ex_tcl(eap)$/;"	f
ex_tcldo	ex_docmd.c	/^# define ex_tcldo	/;"	d	file:
ex_tcldo	if_tcl.c	/^ex_tcldo(eap)$/;"	f
ex_tclfile	ex_docmd.c	/^# define ex_tclfile	/;"	d	file:
ex_tclfile	if_tcl.c	/^ex_tclfile(eap)$/;"	f
ex_tearoff	ex_docmd.c	/^# define ex_tearoff	/;"	d	file:
ex_tearoff	ex_docmd.c	/^ex_tearoff(eap)$/;"	f	file:
ex_throw	ex_docmd.c	/^# define ex_throw	/;"	d	file:
ex_throw	ex_eval.c	/^ex_throw(eap)$/;"	f
ex_try	ex_docmd.c	/^# define ex_try	/;"	d	file:
ex_try	ex_eval.c	/^ex_try(eap)$/;"	f
ex_undo	ex_docmd.c	/^ex_undo(eap)$/;"	f	file:
ex_undojoin	undo.c	/^ex_undojoin(eap)$/;"	f
ex_undolist	undo.c	/^ex_undolist(eap)$/;"	f
ex_unlet	eval.c	/^ex_unlet(eap)$/;"	f
ex_unlet	ex_docmd.c	/^# define ex_unlet	/;"	d	file:
ex_unletlock	eval.c	/^ex_unletlock(eap, argstart, deep)$/;"	f	file:
ex_unlockvar	ex_docmd.c	/^# define ex_unlockvar	/;"	d	file:
ex_unmap	ex_docmd.c	/^ex_unmap(eap)$/;"	f	file:
ex_update	ex_cmds.c	/^ex_update(eap)$/;"	f
ex_version	version.c	/^ex_version(eap)$/;"	f
ex_vimgrep	ex_docmd.c	/^# define ex_vimgrep	/;"	d	file:
ex_vimgrep	quickfix.c	/^ex_vimgrep(eap)$/;"	f
ex_viminfo	ex_docmd.c	/^# define ex_viminfo	/;"	d	file:
ex_viminfo	ex_docmd.c	/^ex_viminfo(eap)$/;"	f	file:
ex_viusage	ex_cmds.c	/^ex_viusage(eap)$/;"	f
ex_while	ex_docmd.c	/^# define ex_while	/;"	d	file:
ex_while	ex_eval.c	/^ex_while(eap)$/;"	f
ex_win_close	ex_docmd.c	/^ex_win_close(forceit, win, tp)$/;"	f	file:
ex_wincmd	ex_docmd.c	/^# define ex_wincmd	/;"	d	file:
ex_wincmd	ex_docmd.c	/^ex_wincmd(eap)$/;"	f	file:
ex_window	ex_getln.c	/^ex_window()$/;"	f	file:
ex_winpos	ex_docmd.c	/^# define ex_winpos	/;"	d	file:
ex_winpos	ex_docmd.c	/^ex_winpos(eap)$/;"	f	file:
ex_winsize	ex_docmd.c	/^ex_winsize(eap)$/;"	f	file:
ex_wnext	ex_cmds.c	/^ex_wnext(eap)$/;"	f
ex_write	ex_cmds.c	/^ex_write(eap)$/;"	f
ex_wrongmodifier	ex_docmd.c	/^ex_wrongmodifier(eap)$/;"	f	file:
ex_wsverb	ex_docmd.c	/^# define ex_wsverb	/;"	d	file:
ex_wsverb	workshop.c	/^ex_wsverb(exarg_T *eap)$/;"	f
ex_z	ex_cmds.c	/^ex_z(eap)$/;"	f
exarg	ex_cmds.h	/^struct exarg$/;"	s
exarg_T	ex_cmds.h	/^typedef struct exarg exarg_T;$/;"	t	typeref:struct:exarg
except_T	structs.h	/^typedef struct vim_exception except_T;$/;"	t	typeref:struct:vim_exception
exception	structs.h	/^    except_T *exception;	\/* exception value *\/$/;"	m	struct:cleanup_stuff
exe_commands	main.c	/^exe_commands(parmp)$/;"	f	file:
exe_name	globals.h	/^EXTERN char_u	*exe_name;		\/* the name of the executable *\/$/;"	v
exe_pre_commands	main.c	/^exe_pre_commands(parmp)$/;"	f	file:
exec_from_reg	globals.h	/^EXTERN int	exec_from_reg INIT(= FALSE);	\/* executing register *\/$/;"	v
exec_normal_cmd	ex_docmd.c	/^exec_normal_cmd(cmd, remap, silent)$/;"	f
exec_on_server	main.c	/^exec_on_server(parmp)$/;"	f	file:
executable_file	os_unix.c	/^executable_file(name)$/;"	f	file:
exit	gui_xmdlg.c	/^    Boolean	exit;		\/* used for program exit control *\/$/;"	m	struct:_SharedFontSelData	file:
exit_scroll	os_unix.c	/^exit_scroll()$/;"	f	file:
exitcmd	if_tcl.c	/^exitcmd(dummy, interp, objc, objv)$/;"	f	file:
exiting	globals.h	/^EXTERN int	exiting INIT(= FALSE);$/;"	v
exmode_active	globals.h	/^EXTERN int exmode_active INIT(= 0);	\/* zero, EXMODE_NORMAL or EXMODE_VIM *\/$/;"	v
exn_catching_apply	if_mzsch.c	/^static Scheme_Object *exn_catching_apply = NULL;$/;"	v	file:
exn_message	if_mzsch.c	/^static Scheme_Object *exn_message = NULL;$/;"	v	file:
exn_p	if_mzsch.c	/^static Scheme_Object *exn_p = NULL;$/;"	v	file:
expand	ex_docmd.c	/^    int	    expand;$/;"	m	struct:__anon10	file:
expand	structs.h	/^typedef struct expand$/;"	s
expand_T	structs.h	/^} expand_T;$/;"	t	typeref:struct:expand
expand_backtick	misc1.c	/^expand_backtick(gap, pat, flags)$/;"	f	file:
expand_buffer	getchar.c	/^static int	expand_buffer = FALSE;$/;"	v	file:
expand_by_function	edit.c	/^expand_by_function(type, base)$/;"	f	file:
expand_cmdline	ex_getln.c	/^expand_cmdline(xp, str, col, matchcount, matches)$/;"	f
expand_emenu	menu.c	/^static int		expand_emenu;	\/* TRUE for ":emenu" command *\/$/;"	v	file:
expand_env	misc1.c	/^expand_env(src, dst, dstlen)$/;"	f
expand_env_esc	misc1.c	/^expand_env_esc(srcp, dst, dstlen, esc, one, startstr)$/;"	f
expand_env_save	misc1.c	/^expand_env_save(src)$/;"	f
expand_env_save_opt	misc1.c	/^expand_env_save_opt(src, one)$/;"	f
expand_filename	ex_docmd.c	/^expand_filename(eap, cmdlinep, errormsgp)$/;"	f
expand_isabbrev	getchar.c	/^static int	expand_isabbrev = 0;$/;"	v	file:
expand_mapmodes	getchar.c	/^static int	expand_mapmodes = 0;$/;"	v	file:
expand_menu	menu.c	/^static vimmenu_T	*expand_menu = NULL;$/;"	v	file:
expand_modes	menu.c	/^static int		expand_modes = 0x0;$/;"	v	file:
expand_option_flags	option.c	/^static int expand_option_flags = 0;$/;"	v	file:
expand_option_idx	option.c	/^static int expand_option_idx = -1;$/;"	v	file:
expand_option_name	option.c	/^static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};$/;"	v	file:
expand_sfile	ex_docmd.c	/^expand_sfile(arg)$/;"	f
expand_shellcmd	ex_getln.c	/^expand_shellcmd(filepat, num_file, file, flagsarg)$/;"	f	file:
expand_showtail	ex_getln.c	/^expand_showtail(xp)$/;"	f	file:
expand_spelling	spell.c	/^expand_spelling(lnum, col, pat, matchp)$/;"	f
expand_tag_fname	tag.c	/^expand_tag_fname(fname, tag_fname, expand)$/;"	f	file:
expand_tags	tag.c	/^expand_tags(tagnames, pat, num_file, file)$/;"	f
expand_what	syntax.c	/^} expand_what;$/;"	v	typeref:enum:__anon59	file:
expand_wildcards	misc1.c	/^expand_wildcards(num_pat, pat, num_file, file, flags)$/;"	f
expose_event	gui_gtk_x11.c	/^expose_event(GtkWidget *widget, GdkEventExpose *event, gpointer data)$/;"	f	file:
expr_line	ops.c	/^static char_u	*expr_line = NULL;$/;"	v	file:
exprcmd	if_tcl.c	/^exprcmd(dummy, interp, objc, objv)$/;"	f	file:
exptype_T	eval.c	/^} exptype_T;$/;"	t	typeref:enum:__anon6	file:
extra_char	structs.h	/^    int		extra_char;	\/* yet another character (optional) *\/$/;"	m	struct:cmdarg_S
extra_shell_arg	os_unix.c	/^static char_u	*extra_shell_arg = NULL;$/;"	v	file:
extract_exn_message	if_mzsch.c	/^extract_exn_message(Scheme_Object *v)$/;"	f	file:
extract_modifiers	misc2.c	/^extract_modifiers(key, modp)$/;"	f
f	hangulin.c	/^static int f=F_NULL, m=M_NULL, l=L_NULL;$/;"	v	file:
f_abs	eval.c	/^f_abs(argvars, rettv)$/;"	f	file:
f_add	eval.c	/^f_add(argvars, rettv)$/;"	f	file:
f_append	eval.c	/^f_append(argvars, rettv)$/;"	f	file:
f_argc	eval.c	/^f_argc(argvars, rettv)$/;"	f	file:
f_argidx	eval.c	/^f_argidx(argvars, rettv)$/;"	f	file:
f_argv	eval.c	/^f_argv(argvars, rettv)$/;"	f	file:
f_atan	eval.c	/^f_atan(argvars, rettv)$/;"	f	file:
f_browse	eval.c	/^f_browse(argvars, rettv)$/;"	f	file:
f_browsedir	eval.c	/^f_browsedir(argvars, rettv)$/;"	f	file:
f_bufexists	eval.c	/^f_bufexists(argvars, rettv)$/;"	f	file:
f_buflisted	eval.c	/^f_buflisted(argvars, rettv)$/;"	f	file:
f_bufloaded	eval.c	/^f_bufloaded(argvars, rettv)$/;"	f	file:
f_bufname	eval.c	/^f_bufname(argvars, rettv)$/;"	f	file:
f_bufnr	eval.c	/^f_bufnr(argvars, rettv)$/;"	f	file:
f_bufwinnr	eval.c	/^f_bufwinnr(argvars, rettv)$/;"	f	file:
f_byte2line	eval.c	/^f_byte2line(argvars, rettv)$/;"	f	file:
f_byteidx	eval.c	/^f_byteidx(argvars, rettv)$/;"	f	file:
f_call	eval.c	/^f_call(argvars, rettv)$/;"	f	file:
f_ceil	eval.c	/^f_ceil(argvars, rettv)$/;"	f	file:
f_changenr	eval.c	/^f_changenr(argvars, rettv)$/;"	f	file:
f_char2nr	eval.c	/^f_char2nr(argvars, rettv)$/;"	f	file:
f_cindent	eval.c	/^f_cindent(argvars, rettv)$/;"	f	file:
f_clearmatches	eval.c	/^f_clearmatches(argvars, rettv)$/;"	f	file:
f_col	eval.c	/^f_col(argvars, rettv)$/;"	f	file:
f_complete	eval.c	/^f_complete(argvars, rettv)$/;"	f	file:
f_complete_add	eval.c	/^f_complete_add(argvars, rettv)$/;"	f	file:
f_complete_check	eval.c	/^f_complete_check(argvars, rettv)$/;"	f	file:
f_confirm	eval.c	/^f_confirm(argvars, rettv)$/;"	f	file:
f_copy	eval.c	/^f_copy(argvars, rettv)$/;"	f	file:
f_cos	eval.c	/^f_cos(argvars, rettv)$/;"	f	file:
f_count	eval.c	/^f_count(argvars, rettv)$/;"	f	file:
f_cscope_connection	eval.c	/^f_cscope_connection(argvars, rettv)$/;"	f	file:
f_cursor	eval.c	/^f_cursor(argvars, rettv)$/;"	f	file:
f_deepcopy	eval.c	/^f_deepcopy(argvars, rettv)$/;"	f	file:
f_delete	eval.c	/^f_delete(argvars, rettv)$/;"	f	file:
f_did_filetype	eval.c	/^f_did_filetype(argvars, rettv)$/;"	f	file:
f_diff_filler	eval.c	/^f_diff_filler(argvars, rettv)$/;"	f	file:
f_diff_hlID	eval.c	/^f_diff_hlID(argvars, rettv)$/;"	f	file:
f_empty	eval.c	/^f_empty(argvars, rettv)$/;"	f	file:
f_escape	eval.c	/^f_escape(argvars, rettv)$/;"	f	file:
f_eval	eval.c	/^f_eval(argvars, rettv)$/;"	f	file:
f_eventhandler	eval.c	/^f_eventhandler(argvars, rettv)$/;"	f	file:
f_executable	eval.c	/^f_executable(argvars, rettv)$/;"	f	file:
f_exists	eval.c	/^f_exists(argvars, rettv)$/;"	f	file:
f_expand	eval.c	/^f_expand(argvars, rettv)$/;"	f	file:
f_extend	eval.c	/^f_extend(argvars, rettv)$/;"	f	file:
f_feedkeys	eval.c	/^f_feedkeys(argvars, rettv)$/;"	f	file:
f_filereadable	eval.c	/^f_filereadable(argvars, rettv)$/;"	f	file:
f_filewritable	eval.c	/^f_filewritable(argvars, rettv)$/;"	f	file:
f_filter	eval.c	/^f_filter(argvars, rettv)$/;"	f	file:
f_finddir	eval.c	/^f_finddir(argvars, rettv)$/;"	f	file:
f_findfile	eval.c	/^f_findfile(argvars, rettv)$/;"	f	file:
f_float2nr	eval.c	/^f_float2nr(argvars, rettv)$/;"	f	file:
f_floor	eval.c	/^f_floor(argvars, rettv)$/;"	f	file:
f_fnameescape	eval.c	/^f_fnameescape(argvars, rettv)$/;"	f	file:
f_fnamemodify	eval.c	/^f_fnamemodify(argvars, rettv)$/;"	f	file:
f_foldclosed	eval.c	/^f_foldclosed(argvars, rettv)$/;"	f	file:
f_foldclosedend	eval.c	/^f_foldclosedend(argvars, rettv)$/;"	f	file:
f_foldlevel	eval.c	/^f_foldlevel(argvars, rettv)$/;"	f	file:
f_foldtext	eval.c	/^f_foldtext(argvars, rettv)$/;"	f	file:
f_foldtextresult	eval.c	/^f_foldtextresult(argvars, rettv)$/;"	f	file:
f_foreground	eval.c	/^f_foreground(argvars, rettv)$/;"	f	file:
f_func	eval.c	/^    void	(*f_func) __ARGS((typval_T *args, typval_T *rvar));$/;"	m	struct:fst	file:
f_function	eval.c	/^f_function(argvars, rettv)$/;"	f	file:
f_garbagecollect	eval.c	/^f_garbagecollect(argvars, rettv)$/;"	f	file:
f_get	eval.c	/^f_get(argvars, rettv)$/;"	f	file:
f_getbufline	eval.c	/^f_getbufline(argvars, rettv)$/;"	f	file:
f_getbufvar	eval.c	/^f_getbufvar(argvars, rettv)$/;"	f	file:
f_getchar	eval.c	/^f_getchar(argvars, rettv)$/;"	f	file:
f_getcharmod	eval.c	/^f_getcharmod(argvars, rettv)$/;"	f	file:
f_getcmdline	eval.c	/^f_getcmdline(argvars, rettv)$/;"	f	file:
f_getcmdpos	eval.c	/^f_getcmdpos(argvars, rettv)$/;"	f	file:
f_getcmdtype	eval.c	/^f_getcmdtype(argvars, rettv)$/;"	f	file:
f_getcwd	eval.c	/^f_getcwd(argvars, rettv)$/;"	f	file:
f_getfontname	eval.c	/^f_getfontname(argvars, rettv)$/;"	f	file:
f_getfperm	eval.c	/^f_getfperm(argvars, rettv)$/;"	f	file:
f_getfsize	eval.c	/^f_getfsize(argvars, rettv)$/;"	f	file:
f_getftime	eval.c	/^f_getftime(argvars, rettv)$/;"	f	file:
f_getftype	eval.c	/^f_getftype(argvars, rettv)$/;"	f	file:
f_getline	eval.c	/^f_getline(argvars, rettv)$/;"	f	file:
f_getmatches	eval.c	/^f_getmatches(argvars, rettv)$/;"	f	file:
f_getpid	eval.c	/^f_getpid(argvars, rettv)$/;"	f	file:
f_getpos	eval.c	/^f_getpos(argvars, rettv)$/;"	f	file:
f_getqflist	eval.c	/^f_getqflist(argvars, rettv)$/;"	f	file:
f_getreg	eval.c	/^f_getreg(argvars, rettv)$/;"	f	file:
f_getregtype	eval.c	/^f_getregtype(argvars, rettv)$/;"	f	file:
f_gettabwinvar	eval.c	/^f_gettabwinvar(argvars, rettv)$/;"	f	file:
f_getwinposx	eval.c	/^f_getwinposx(argvars, rettv)$/;"	f	file:
f_getwinposy	eval.c	/^f_getwinposy(argvars, rettv)$/;"	f	file:
f_getwinvar	eval.c	/^f_getwinvar(argvars, rettv)$/;"	f	file:
f_glob	eval.c	/^f_glob(argvars, rettv)$/;"	f	file:
f_globpath	eval.c	/^f_globpath(argvars, rettv)$/;"	f	file:
f_has	eval.c	/^f_has(argvars, rettv)$/;"	f	file:
f_has_key	eval.c	/^f_has_key(argvars, rettv)$/;"	f	file:
f_haslocaldir	eval.c	/^f_haslocaldir(argvars, rettv)$/;"	f	file:
f_hasmapto	eval.c	/^f_hasmapto(argvars, rettv)$/;"	f	file:
f_histadd	eval.c	/^f_histadd(argvars, rettv)$/;"	f	file:
f_histdel	eval.c	/^f_histdel(argvars, rettv)$/;"	f	file:
f_histget	eval.c	/^f_histget(argvars, rettv)$/;"	f	file:
f_histnr	eval.c	/^f_histnr(argvars, rettv)$/;"	f	file:
f_hlID	eval.c	/^f_hlID(argvars, rettv)$/;"	f	file:
f_hlexists	eval.c	/^f_hlexists(argvars, rettv)$/;"	f	file:
f_hostname	eval.c	/^f_hostname(argvars, rettv)$/;"	f	file:
f_iconv	eval.c	/^f_iconv(argvars, rettv)$/;"	f	file:
f_indent	eval.c	/^f_indent(argvars, rettv)$/;"	f	file:
f_index	eval.c	/^f_index(argvars, rettv)$/;"	f	file:
f_input	eval.c	/^f_input(argvars, rettv)$/;"	f	file:
f_inputdialog	eval.c	/^f_inputdialog(argvars, rettv)$/;"	f	file:
f_inputlist	eval.c	/^f_inputlist(argvars, rettv)$/;"	f	file:
f_inputrestore	eval.c	/^f_inputrestore(argvars, rettv)$/;"	f	file:
f_inputsave	eval.c	/^f_inputsave(argvars, rettv)$/;"	f	file:
f_inputsecret	eval.c	/^f_inputsecret(argvars, rettv)$/;"	f	file:
f_insert	eval.c	/^f_insert(argvars, rettv)$/;"	f	file:
f_isdirectory	eval.c	/^f_isdirectory(argvars, rettv)$/;"	f	file:
f_islocked	eval.c	/^f_islocked(argvars, rettv)$/;"	f	file:
f_items	eval.c	/^f_items(argvars, rettv)$/;"	f	file:
f_join	eval.c	/^f_join(argvars, rettv)$/;"	f	file:
f_keys	eval.c	/^f_keys(argvars, rettv)$/;"	f	file:
f_last_buffer_nr	eval.c	/^f_last_buffer_nr(argvars, rettv)$/;"	f	file:
f_len	eval.c	/^f_len(argvars, rettv)$/;"	f	file:
f_libcall	eval.c	/^f_libcall(argvars, rettv)$/;"	f	file:
f_libcallnr	eval.c	/^f_libcallnr(argvars, rettv)$/;"	f	file:
f_line	eval.c	/^f_line(argvars, rettv)$/;"	f	file:
f_line2byte	eval.c	/^f_line2byte(argvars, rettv)$/;"	f	file:
f_lispindent	eval.c	/^f_lispindent(argvars, rettv)$/;"	f	file:
f_localtime	eval.c	/^f_localtime(argvars, rettv)$/;"	f	file:
f_log10	eval.c	/^f_log10(argvars, rettv)$/;"	f	file:
f_map	eval.c	/^f_map(argvars, rettv)$/;"	f	file:
f_maparg	eval.c	/^f_maparg(argvars, rettv)$/;"	f	file:
f_mapcheck	eval.c	/^f_mapcheck(argvars, rettv)$/;"	f	file:
f_match	eval.c	/^f_match(argvars, rettv)$/;"	f	file:
f_matchadd	eval.c	/^f_matchadd(argvars, rettv)$/;"	f	file:
f_matcharg	eval.c	/^f_matcharg(argvars, rettv)$/;"	f	file:
f_matchdelete	eval.c	/^f_matchdelete(argvars, rettv)$/;"	f	file:
f_matchend	eval.c	/^f_matchend(argvars, rettv)$/;"	f	file:
f_matchlist	eval.c	/^f_matchlist(argvars, rettv)$/;"	f	file:
f_matchstr	eval.c	/^f_matchstr(argvars, rettv)$/;"	f	file:
f_max	eval.c	/^f_max(argvars, rettv)$/;"	f	file:
f_max_argc	eval.c	/^    char	f_max_argc;	\/* maximal number of arguments *\/$/;"	m	struct:fst	file:
f_min	eval.c	/^f_min(argvars, rettv)$/;"	f	file:
f_min_argc	eval.c	/^    char	f_min_argc;	\/* minimal number of arguments *\/$/;"	m	struct:fst	file:
f_mkdir	eval.c	/^f_mkdir(argvars, rettv)$/;"	f	file:
f_mode	eval.c	/^f_mode(argvars, rettv)$/;"	f	file:
f_name	eval.c	/^    char	*f_name;	\/* function name *\/$/;"	m	struct:fst	file:
f_nextnonblank	eval.c	/^f_nextnonblank(argvars, rettv)$/;"	f	file:
f_nr2char	eval.c	/^f_nr2char(argvars, rettv)$/;"	f	file:
f_p	if_ruby.c	/^static VALUE f_p(int argc, VALUE *argv, VALUE self)$/;"	f	file:
f_pathshorten	eval.c	/^f_pathshorten(argvars, rettv)$/;"	f	file:
f_pow	eval.c	/^f_pow(argvars, rettv)$/;"	f	file:
f_prevnonblank	eval.c	/^f_prevnonblank(argvars, rettv)$/;"	f	file:
f_printf	eval.c	/^f_printf(argvars, rettv)$/;"	f	file:
f_pumvisible	eval.c	/^f_pumvisible(argvars, rettv)$/;"	f	file:
f_range	eval.c	/^f_range(argvars, rettv)$/;"	f	file:
f_readfile	eval.c	/^f_readfile(argvars, rettv)$/;"	f	file:
f_reltime	eval.c	/^f_reltime(argvars, rettv)$/;"	f	file:
f_reltimestr	eval.c	/^f_reltimestr(argvars, rettv)$/;"	f	file:
f_remote_expr	eval.c	/^f_remote_expr(argvars, rettv)$/;"	f	file:
f_remote_foreground	eval.c	/^f_remote_foreground(argvars, rettv)$/;"	f	file:
f_remote_peek	eval.c	/^f_remote_peek(argvars, rettv)$/;"	f	file:
f_remote_read	eval.c	/^f_remote_read(argvars, rettv)$/;"	f	file:
f_remote_send	eval.c	/^f_remote_send(argvars, rettv)$/;"	f	file:
f_remove	eval.c	/^f_remove(argvars, rettv)$/;"	f	file:
f_rename	eval.c	/^f_rename(argvars, rettv)$/;"	f	file:
f_repeat	eval.c	/^f_repeat(argvars, rettv)$/;"	f	file:
f_resolve	eval.c	/^f_resolve(argvars, rettv)$/;"	f	file:
f_reverse	eval.c	/^f_reverse(argvars, rettv)$/;"	f	file:
f_round	eval.c	/^f_round(argvars, rettv)$/;"	f	file:
f_search	eval.c	/^f_search(argvars, rettv)$/;"	f	file:
f_searchdecl	eval.c	/^f_searchdecl(argvars, rettv)$/;"	f	file:
f_searchpair	eval.c	/^f_searchpair(argvars, rettv)$/;"	f	file:
f_searchpairpos	eval.c	/^f_searchpairpos(argvars, rettv)$/;"	f	file:
f_searchpos	eval.c	/^f_searchpos(argvars, rettv)$/;"	f	file:
f_server2client	eval.c	/^f_server2client(argvars, rettv)$/;"	f	file:
f_serverlist	eval.c	/^f_serverlist(argvars, rettv)$/;"	f	file:
f_setbufvar	eval.c	/^f_setbufvar(argvars, rettv)$/;"	f	file:
f_setcmdpos	eval.c	/^f_setcmdpos(argvars, rettv)$/;"	f	file:
f_setline	eval.c	/^f_setline(argvars, rettv)$/;"	f	file:
f_setloclist	eval.c	/^f_setloclist(argvars, rettv)$/;"	f	file:
f_setmatches	eval.c	/^f_setmatches(argvars, rettv)$/;"	f	file:
f_setpos	eval.c	/^f_setpos(argvars, rettv)$/;"	f	file:
f_setqflist	eval.c	/^f_setqflist(argvars, rettv)$/;"	f	file:
f_setreg	eval.c	/^f_setreg(argvars, rettv)$/;"	f	file:
f_settabwinvar	eval.c	/^f_settabwinvar(argvars, rettv)$/;"	f	file:
f_setwinvar	eval.c	/^f_setwinvar(argvars, rettv)$/;"	f	file:
f_shellescape	eval.c	/^f_shellescape(argvars, rettv)$/;"	f	file:
f_simplify	eval.c	/^f_simplify(argvars, rettv)$/;"	f	file:
f_sin	eval.c	/^f_sin(argvars, rettv)$/;"	f	file:
f_sort	eval.c	/^f_sort(argvars, rettv)$/;"	f	file:
f_soundfold	eval.c	/^f_soundfold(argvars, rettv)$/;"	f	file:
f_spellbadword	eval.c	/^f_spellbadword(argvars, rettv)$/;"	f	file:
f_spellsuggest	eval.c	/^f_spellsuggest(argvars, rettv)$/;"	f	file:
f_split	eval.c	/^f_split(argvars, rettv)$/;"	f	file:
f_sqrt	eval.c	/^f_sqrt(argvars, rettv)$/;"	f	file:
f_str2float	eval.c	/^f_str2float(argvars, rettv)$/;"	f	file:
f_str2nr	eval.c	/^f_str2nr(argvars, rettv)$/;"	f	file:
f_strftime	eval.c	/^f_strftime(argvars, rettv)$/;"	f	file:
f_stridx	eval.c	/^f_stridx(argvars, rettv)$/;"	f	file:
f_string	eval.c	/^f_string(argvars, rettv)$/;"	f	file:
f_strlen	eval.c	/^f_strlen(argvars, rettv)$/;"	f	file:
f_strpart	eval.c	/^f_strpart(argvars, rettv)$/;"	f	file:
f_strridx	eval.c	/^f_strridx(argvars, rettv)$/;"	f	file:
f_strtrans	eval.c	/^f_strtrans(argvars, rettv)$/;"	f	file:
f_submatch	eval.c	/^f_submatch(argvars, rettv)$/;"	f	file:
f_substitute	eval.c	/^f_substitute(argvars, rettv)$/;"	f	file:
f_synID	eval.c	/^f_synID(argvars, rettv)$/;"	f	file:
f_synIDattr	eval.c	/^f_synIDattr(argvars, rettv)$/;"	f	file:
f_synIDtrans	eval.c	/^f_synIDtrans(argvars, rettv)$/;"	f	file:
f_synstack	eval.c	/^f_synstack(argvars, rettv)$/;"	f	file:
f_system	eval.c	/^f_system(argvars, rettv)$/;"	f	file:
f_tabpagebuflist	eval.c	/^f_tabpagebuflist(argvars, rettv)$/;"	f	file:
f_tabpagenr	eval.c	/^f_tabpagenr(argvars, rettv)$/;"	f	file:
f_tabpagewinnr	eval.c	/^f_tabpagewinnr(argvars, rettv)$/;"	f	file:
f_tagfiles	eval.c	/^f_tagfiles(argvars, rettv)$/;"	f	file:
f_taglist	eval.c	/^f_taglist(argvars, rettv)$/;"	f	file:
f_tempname	eval.c	/^f_tempname(argvars, rettv)$/;"	f	file:
f_test	eval.c	/^f_test(argvars, rettv)$/;"	f	file:
f_tolower	eval.c	/^f_tolower(argvars, rettv)$/;"	f	file:
f_toupper	eval.c	/^f_toupper(argvars, rettv)$/;"	f	file:
f_tr	eval.c	/^f_tr(argvars, rettv)$/;"	f	file:
f_trunc	eval.c	/^f_trunc(argvars, rettv)$/;"	f	file:
f_type	eval.c	/^f_type(argvars, rettv)$/;"	f	file:
f_values	eval.c	/^f_values(argvars, rettv)$/;"	f	file:
f_virtcol	eval.c	/^f_virtcol(argvars, rettv)$/;"	f	file:
f_visualmode	eval.c	/^f_visualmode(argvars, rettv)$/;"	f	file:
f_winbufnr	eval.c	/^f_winbufnr(argvars, rettv)$/;"	f	file:
f_wincol	eval.c	/^f_wincol(argvars, rettv)$/;"	f	file:
f_winheight	eval.c	/^f_winheight(argvars, rettv)$/;"	f	file:
f_winline	eval.c	/^f_winline(argvars, rettv)$/;"	f	file:
f_winnr	eval.c	/^f_winnr(argvars, rettv)$/;"	f	file:
f_winrestcmd	eval.c	/^f_winrestcmd(argvars, rettv)$/;"	f	file:
f_winrestview	eval.c	/^f_winrestview(argvars, rettv)$/;"	f	file:
f_winsaveview	eval.c	/^f_winsaveview(argvars, rettv)$/;"	f	file:
f_winwidth	eval.c	/^f_winwidth(argvars, rettv)$/;"	f	file:
f_writefile	eval.c	/^f_writefile(argvars, rettv)$/;"	f	file:
farsi_fkey	farsi.c	/^farsi_fkey(cap)$/;"	f
farsi_text_1	farsi.h	/^EXTERN char_u farsi_text_1[]$/;"	v
farsi_text_2	farsi.h	/^EXTERN char_u farsi_text_2[]$/;"	v
farsi_text_3	farsi.h	/^EXTERN char_u farsi_text_3[]$/;"	v
farsi_text_5	farsi.h	/^EXTERN char_u farsi_text_5[]$/;"	v
fast_breakcheck	misc1.c	/^fast_breakcheck()$/;"	f
fcon	hangulin.c	/^fcon(c)$/;"	f	file:
fd_di	eval.c	/^    dictitem_T	*fd_di;		\/* Dictionary item used *\/$/;"	m	struct:__anon5	file:
fd_dict	eval.c	/^    dict_T	*fd_dict;	\/* Dictionary used *\/$/;"	m	struct:__anon5	file:
fd_flags	fold.c	/^    char	fd_flags;	\/* see below *\/$/;"	m	struct:__anon11	file:
fd_len	fold.c	/^    linenr_T	fd_len;		\/* number of lines in the fold *\/$/;"	m	struct:__anon11	file:
fd_nested	fold.c	/^    garray_T	fd_nested;	\/* array of nested folds *\/$/;"	m	struct:__anon11	file:
fd_newkey	eval.c	/^    char_u	*fd_newkey;	\/* new key in "dict" in allocated memory *\/$/;"	m	struct:__anon5	file:
fd_small	fold.c	/^    char	fd_small;	\/* TRUE, FALSE or MAYBE: fold smaller than$/;"	m	struct:__anon11	file:
fd_top	fold.c	/^    linenr_T	fd_top;		\/* first line of fold; for nested fold$/;"	m	struct:__anon11	file:
fdip_search_ctx	misc2.c	/^static void	*fdip_search_ctx = NULL;$/;"	v	file:
fdo_flags	option.h	/^EXTERN unsigned	fdo_flags;$/;"	v
fdtofh	memfile.c	/^fdtofh(int filedescriptor)$/;"	f	file:
features	version.c	/^static char *(features[]) =$/;"	v	file:
fex_format	ops.c	/^fex_format(lnum, count, c)$/;"	f
ff	hardcopy.c	/^    int		ff;		    \/* seen form feed character *\/$/;"	m	struct:__anon20	file:
ff_check_visited	misc2.c	/^ff_check_visited(visited_list, fname$/;"	f	file:
ff_clear	misc2.c	/^ff_clear(search_ctx)$/;"	f	file:
ff_create_stack_element	misc2.c	/^ff_create_stack_element(fix_part,$/;"	f	file:
ff_expand_buffer	misc2.c	/^static char_u	*ff_expand_buffer = NULL; \/* used for expanding filenames *\/$/;"	v	file:
ff_file_to_find	misc2.c	/^static char_u	*ff_file_to_find = NULL;$/;"	v	file:
ff_free_stack_element	misc2.c	/^ff_free_stack_element(stack_ptr)$/;"	f	file:
ff_free_visited_list	misc2.c	/^ff_free_visited_list(vl)$/;"	f	file:
ff_get_visited_list	misc2.c	/^ff_get_visited_list(filename, list_headp)$/;"	f	file:
ff_path_in_stoplist	misc2.c	/^ff_path_in_stoplist(path, path_len, stopdirs_v)$/;"	f	file:
ff_pop	misc2.c	/^ff_pop(search_ctx)$/;"	f	file:
ff_push	misc2.c	/^ff_push(search_ctx, stack_ptr)$/;"	f	file:
ff_search_ctx_T	misc2.c	/^typedef struct ff_search_ctx_T$/;"	s	file:
ff_search_ctx_T	misc2.c	/^} ff_search_ctx_T;$/;"	t	typeref:struct:ff_search_ctx_T	file:
ff_stack	misc2.c	/^typedef struct ff_stack$/;"	s	file:
ff_stack_T	misc2.c	/^} ff_stack_T;$/;"	t	typeref:struct:ff_stack	file:
ff_visited	misc2.c	/^typedef struct ff_visited$/;"	s	file:
ff_visited_T	misc2.c	/^} ff_visited_T;$/;"	t	typeref:struct:ff_visited	file:
ff_visited_list_hdr	misc2.c	/^typedef struct ff_visited_list_hdr$/;"	s	file:
ff_visited_list_hdr_T	misc2.c	/^} ff_visited_list_hdr_T;$/;"	t	typeref:struct:ff_visited_list_hdr	file:
ff_wc_equal	misc2.c	/^ff_wc_equal(s1, s2)$/;"	f	file:
ffs_filearray	misc2.c	/^    char_u		**ffs_filearray;$/;"	m	struct:ff_stack	file:
ffs_filearray_cur	misc2.c	/^    char_u		ffs_filearray_cur;   \/* needed for partly handled dirs *\/$/;"	m	struct:ff_stack	file:
ffs_filearray_size	misc2.c	/^    int			ffs_filearray_size;$/;"	m	struct:ff_stack	file:
ffs_fix_path	misc2.c	/^    char_u		*ffs_fix_path;$/;"	m	struct:ff_stack	file:
ffs_level	misc2.c	/^    int			ffs_level;$/;"	m	struct:ff_stack	file:
ffs_prev	misc2.c	/^    struct ff_stack	*ffs_prev;$/;"	m	struct:ff_stack	typeref:struct:ff_stack::ff_stack	file:
ffs_stage	misc2.c	/^    int			ffs_stage;$/;"	m	struct:ff_stack	file:
ffs_star_star_empty	misc2.c	/^    int			ffs_star_star_empty;$/;"	m	struct:ff_stack	file:
ffs_wc_path	misc2.c	/^    char_u		*ffs_wc_path;$/;"	m	struct:ff_stack	file:
ffsc_dir_visited_list	misc2.c	/^     ff_visited_list_hdr_T	*ffsc_dir_visited_list;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_dir_visited_lists_list	misc2.c	/^     ff_visited_list_hdr_T	*ffsc_dir_visited_lists_list;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_file_to_search	misc2.c	/^     char_u			*ffsc_file_to_search;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_find_what	misc2.c	/^     int			ffsc_find_what;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_fix_path	misc2.c	/^     char_u			*ffsc_fix_path;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_level	misc2.c	/^     int			ffsc_level;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_stack_ptr	misc2.c	/^     ff_stack_T			*ffsc_stack_ptr;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_start_dir	misc2.c	/^     char_u			*ffsc_start_dir;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_stopdirs_v	misc2.c	/^     char_u			**ffsc_stopdirs_v;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_visited_list	misc2.c	/^     ff_visited_list_hdr_T	*ffsc_visited_list;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_visited_lists_list	misc2.c	/^     ff_visited_list_hdr_T	*ffsc_visited_lists_list;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_wc_path	misc2.c	/^     char_u			*ffsc_wc_path;$/;"	m	struct:ff_search_ctx_T	file:
ffv_dev	misc2.c	/^    int			ffv_dev;	\/* device number (-1 if not set) *\/$/;"	m	struct:ff_visited	file:
ffv_fname	misc2.c	/^    char_u		ffv_fname[1];	\/* actually longer *\/$/;"	m	struct:ff_visited	file:
ffv_ino	misc2.c	/^    ino_t		ffv_ino;	\/* inode number *\/$/;"	m	struct:ff_visited	file:
ffv_next	misc2.c	/^    struct ff_visited	*ffv_next;$/;"	m	struct:ff_visited	typeref:struct:ff_visited::ff_visited	file:
ffv_wc_path	misc2.c	/^    char_u		*ffv_wc_path;$/;"	m	struct:ff_visited	file:
ffvl_filename	misc2.c	/^    char_u			*ffvl_filename;$/;"	m	struct:ff_visited_list_hdr	file:
ffvl_next	misc2.c	/^    struct ff_visited_list_hdr	*ffvl_next;$/;"	m	struct:ff_visited_list_hdr	typeref:struct:ff_visited_list_hdr::ff_visited_list_hdr	file:
ffvl_visited_list	misc2.c	/^    ff_visited_T		*ffvl_visited_list;$/;"	m	struct:ff_visited_list_hdr	file:
fg_color	structs.h	/^	    guicolor_T	    fg_color;	\/* foreground color handle *\/$/;"	m	struct:attr_entry::__anon86::__anon89
fg_color	structs.h	/^	    short_u	    fg_color;	\/* foreground color number *\/$/;"	m	struct:attr_entry::__anon86::__anon88
fg_color	structs.h	/^    long_u	fg_color;$/;"	m	struct:__anon99
fg_colour	gui.h	/^    int		fg_colour;		\/* in 0xBBGGRR format *\/$/;"	m	struct:Gui
fgcolor	gui.h	/^    GdkColor	*fgcolor;	    \/* GDK-styled foreground color *\/$/;"	m	struct:Gui
fgets_cr	ex_cmds2.c	/^fgets_cr(s, n, stream)$/;"	f
fi_level	structs.h	/^    int		fi_level;	\/* level of the fold; when this is zero the$/;"	m	struct:foldinfo
fi_list	eval.c	/^    list_T	*fi_list;	\/* list being used *\/$/;"	m	struct:__anon4	file:
fi_lnum	structs.h	/^    int		fi_lnum;	\/* line number where fold starts *\/$/;"	m	struct:foldinfo
fi_low_level	structs.h	/^    int		fi_low_level;	\/* lowest fold level that starts in the same$/;"	m	struct:foldinfo
fi_lw	eval.c	/^    listwatch_T	fi_lw;		\/* keep an eye on the item used. *\/$/;"	m	struct:__anon4	file:
fi_semicolon	eval.c	/^    int		fi_semicolon;	\/* TRUE if ending in '; var]' *\/$/;"	m	struct:__anon4	file:
fi_varcount	eval.c	/^    int		fi_varcount;	\/* nr of variables in the list *\/$/;"	m	struct:__anon4	file:
file_buffer	structs.h	/^struct file_buffer$/;"	s
file_ff_differs	option.c	/^file_ff_differs(buf)$/;"	f
file_input	if_python.c	/^#define file_input	/;"	d	file:
file_line	hardcopy.c	/^    linenr_T	file_line;	    \/* line nr in the buffer *\/$/;"	m	struct:__anon20	file:
file_name_at_cursor	window.c	/^file_name_at_cursor(options, count, file_lnum)$/;"	f
file_name_in_line	window.c	/^file_name_in_line(line, col, options, count, rel_fname, file_lnum)$/;"	f
file_owned	main.c	/^file_owned(fname)$/;"	f	file:
file_pat_to_reg_pat	fileio.c	/^file_pat_to_reg_pat(pat, pat_end, allow_dirs, no_bslash)$/;"	f
filedlg	gui.h	/^    GtkWidget	*filedlg;	    \/* file selection dialog *\/$/;"	m	struct:Gui
fileformat	ex_cmds2.c	/^    int		fileformat;	\/* EOL_UNKNOWN, EOL_UNIX or EOL_DOS *\/$/;"	m	struct:source_cookie	file:
fileinfo	buffer.c	/^fileinfo(fullname, shorthelp, dont_truncate)$/;"	f
filemark	structs.h	/^typedef struct filemark$/;"	s
filemess	fileio.c	/^filemess(buf, name, s, attr)$/;"	f
filename	hardcopy.c	/^    char_u  filename[MAXPATHL + 1];$/;"	m	struct:prt_ps_resource_S	file:
filetype_detect	ex_docmd.c	/^static int filetype_detect = FALSE;$/;"	v	file:
filetype_indent	ex_docmd.c	/^static int filetype_indent = FALSE;$/;"	v	file:
filetype_plugin	ex_docmd.c	/^static int filetype_plugin = FALSE;$/;"	v	file:
filewritable	misc2.c	/^filewritable(fname)$/;"	f
fill	move.c	/^    int		    fill;	\/* filler lines *\/$/;"	m	struct:__anon44	file:
fill_breakat_flags	option.c	/^fill_breakat_flags()$/;"	f	file:
fill_diff	globals.h	/^EXTERN int	fill_diff INIT(= '-');$/;"	v
fill_fold	globals.h	/^EXTERN int	fill_fold INIT(= '-');$/;"	v
fill_foldcolumn	screen.c	/^fill_foldcolumn(p, wp, closed, lnum)$/;"	f	file:
fill_input_buf	ui.c	/^fill_input_buf(exit_on_error)$/;"	f
fill_lists	gui_xmdlg.c	/^fill_lists(enum ListSpecifier fix, SharedFontSelData *data)$/;"	f	file:
fill_mouse_coord	gui.c	/^fill_mouse_coord(p, col, row)$/;"	f	file:
fill_stl	globals.h	/^EXTERN int	fill_stl INIT(= ' ');$/;"	v
fill_stlnc	globals.h	/^EXTERN int	fill_stlnc INIT(= ' ');$/;"	v
fill_vert	globals.h	/^EXTERN int	fill_vert INIT(= ' ');$/;"	v
fillchar_status	screen.c	/^fillchar_status(attr, is_curwin)$/;"	f	file:
fillchar_vsep	screen.c	/^fillchar_vsep(attr)$/;"	f	file:
filter_map	eval.c	/^filter_map(argvars, rettv, map)$/;"	f	file:
filter_map_one	eval.c	/^filter_map_one(tv, expr, map, remp)$/;"	f	file:
filter_uri_list	gui_gtk_x11.c	/^filter_uri_list(char_u **outlist, int max, char_u *src)$/;"	f	file:
find	gui_gtk.c	/^    GtkWidget *find;	\/* 'Find Next' action button *\/$/;"	m	struct:_SharedFindReplace	file:
find	gui_motif.c	/^    Widget find;	\/* 'Find Next' action button *\/$/;"	m	struct:_SharedFindReplace	file:
findYourself	workshop.c	/^findYourself($/;"	f
find_buffer	eval.c	/^find_buffer(avar)$/;"	f	file:
find_builtin_term	term.c	/^find_builtin_term(term)$/;"	f	file:
find_closest_color	gui_x11.c	/^find_closest_color(colormap, colorPtr)$/;"	f	file:
find_cmdline_var	ex_docmd.c	/^find_cmdline_var(src, usedlen)$/;"	f
find_command	ex_docmd.c	/^find_command(eap, full)$/;"	f	file:
find_command	normal.c	/^find_command(cmdchar)$/;"	f	file:
find_decl	normal.c	/^find_decl(ptr, len, locally, thisblock, searchflags)$/;"	f
find_directory_in_path	misc2.c	/^find_directory_in_path(ptr, len, options, rel_fname)$/;"	f
find_end_event	fileio.c	/^find_end_event(arg, have_group)$/;"	f	file:
find_end_of_word	normal.c	/^find_end_of_word(pos)$/;"	f	file:
find_endpos	syntax.c	/^find_endpos(idx, startpos, m_endpos, hl_endpos, flagsp, end_endpos,$/;"	f	file:
find_executable_arg	if_tcl.c	/^static char *find_executable_arg = NULL;$/;"	v	file:
find_extra	tag.c	/^find_extra(pp)$/;"	f	file:
find_file_in_path	misc2.c	/^find_file_in_path(ptr, len, options, first, rel_fname)$/;"	f
find_file_in_path_option	misc2.c	/^find_file_in_path_option(ptr, len, options, first, path_option, find_what, rel_fname, suffixes)$/;"	f
find_file_name_in_path	window.c	/^find_file_name_in_path(ptr, len, options, count, rel_fname)$/;"	f
find_first_blank	search.c	/^find_first_blank(posp)$/;"	f	file:
find_func	eval.c	/^find_func(name)$/;"	f	file:
find_help_tags	ex_cmds.c	/^find_help_tags(arg, num_matches, matches, keep_lang)$/;"	f
find_ident_at_pos	normal.c	/^find_ident_at_pos(wp, lnum, startcol, string, find_type)$/;"	f
find_ident_under_cursor	normal.c	/^find_ident_under_cursor(string, find_type)$/;"	f
find_internal_func	eval.c	/^find_internal_func(name)$/;"	f	file:
find_is_eval_item	normal.c	/^find_is_eval_item(ptr, colp, bnp, dir)$/;"	f	file:
find_keepcap_word	spell.c	/^find_keepcap_word(slang, fword, kword)$/;"	f	file:
find_key_option	option.c	/^find_key_option(arg)$/;"	f	file:
find_key_press_event	gui_gtk.c	/^find_key_press_event($/;"	f	file:
find_last_paren	misc1.c	/^find_last_paren(l, start, end)$/;"	f	file:
find_line_comment	misc1.c	/^find_line_comment() \/* XXX *\/$/;"	f	file:
find_line_end	edit.c	/^find_line_end(ptr)$/;"	f	file:
find_match	misc1.c	/^find_match(lookfor, ourscope, ind_maxparen, ind_maxcomment)$/;"	f	file:
find_match_paren	misc1.c	/^find_match_paren(ind_maxparen, ind_maxcomment)	    \/* XXX *\/$/;"	f	file:
find_name_end	eval.c	/^find_name_end(arg, expr_start, expr_end, flags)$/;"	f	file:
find_next_quote	search.c	/^find_next_quote(line, col, quotechar, escape)$/;"	f	file:
find_nextcmd	ex_docmd.c	/^find_nextcmd(p)$/;"	f
find_option_end	eval.c	/^find_option_end(arg, opt_flags)$/;"	f	file:
find_pattern_in_path	search.c	/^find_pattern_in_path(ptr, dir, len, whole, skip_comments,$/;"	f
find_prefix	spell.c	/^find_prefix(mip, mode)$/;"	f	file:
find_prev_quote	search.c	/^find_prev_quote(line, col_start, quotechar, escape)$/;"	f	file:
find_region	spell.c	/^find_region(rp, region)$/;"	f	file:
find_replace_callback	gui_motif.c	/^find_replace_callback(w, client_data, call_data)$/;"	f	file:
find_replace_cb	gui_gtk.c	/^find_replace_cb(GtkWidget *widget, gpointer data)$/;"	f	file:
find_replace_destroy_callback	gui_motif.c	/^find_replace_destroy_callback(w, client_data, call_data)$/;"	f	file:
find_replace_dialog_create	gui_gtk.c	/^find_replace_dialog_create(char_u *arg, int do_replace)$/;"	f	file:
find_replace_dialog_create	gui_motif.c	/^find_replace_dialog_create(arg, do_replace)$/;"	f	file:
find_replace_dismiss_callback	gui_motif.c	/^find_replace_dismiss_callback(w, client_data, call_data)$/;"	f	file:
find_replace_keypress	gui_motif.c	/^find_replace_keypress(w, frdp, event)$/;"	f	file:
find_some_match	eval.c	/^find_some_match(argvars, rettv, type)$/;"	f	file:
find_special_key	misc2.c	/^find_special_key(srcp, modp, keycode)$/;"	f
find_special_key_in_table	misc2.c	/^find_special_key_in_table(c)$/;"	f
find_start_brace	misc1.c	/^find_start_brace(ind_maxcomment)	    \/* XXX *\/$/;"	f	file:
find_start_comment	misc1.c	/^find_start_comment(ind_maxcomment)	    \/* XXX *\/$/;"	f
find_start_of_word	normal.c	/^find_start_of_word(pos)$/;"	f	file:
find_tabpage	window.c	/^find_tabpage(n)$/;"	f
find_tags	tag.c	/^find_tags(pat, num_matches, matchesp, flags, mincount, buf_ffname)$/;"	f
find_term_bykeys	term.c	/^find_term_bykeys(src)$/;"	f
find_termcode	term.c	/^find_termcode(name)$/;"	f
find_ucmd	ex_docmd.c	/^find_ucmd(eap, p, full, xp, compl)$/;"	f	file:
find_var	eval.c	/^find_var(name, htp)$/;"	f	file:
find_var_ht	eval.c	/^find_var_ht(name, varname)$/;"	f	file:
find_var_in_ht	eval.c	/^find_var_in_ht(ht, varname, writing)$/;"	f	file:
find_viminfo_parameter	option.c	/^find_viminfo_parameter(type)$/;"	f
find_widgets	gui_gtk.c	/^static SharedFindReplace find_widgets = { NULL, };$/;"	v	file:
find_widgets	gui_motif.c	/^static SharedFindReplace find_widgets = { NULL };$/;"	v	file:
find_win_by_nr	eval.c	/^find_win_by_nr(vp, tp)$/;"	f	file:
find_wininfo	buffer.c	/^find_wininfo(buf)$/;"	f	file:
find_wl_entry	fold.c	/^find_wl_entry(win, lnum)$/;"	f
find_word	spell.c	/^find_word(mip, mode)$/;"	f	file:
find_word_end	edit.c	/^find_word_end(ptr)$/;"	f
find_word_start	edit.c	/^find_word_start(ptr)$/;"	f
findenv	misc2.c	/^findenv(name)$/;"	f	file:
findfilendir	eval.c	/^findfilendir(argvars, rettv, find_what)$/;"	f	file:
findmatch	search.c	/^findmatch(oap, initc)$/;"	f
findmatchlimit	search.c	/^findmatchlimit(oap, initc, flags, maxtravel)$/;"	f
findoption	option.c	/^findoption(arg)$/;"	f	file:
findpar	search.c	/^findpar(pincl, dir, count, what, both)$/;"	f
findsent	search.c	/^findsent(dir, count)$/;"	f
findsent_forward	search.c	/^findsent_forward(count, at_start_sent)$/;"	f	file:
findswapname	memline.c	/^findswapname(buf, dirp, old_fname)$/;"	f	file:
finish_exception	ex_eval.c	/^finish_exception(excp)$/;"	f	file:
finish_op	globals.h	/^EXTERN int	finish_op INIT(= FALSE);\/* TRUE while an operator is pending *\/$/;"	v
finish_viminfo_history	ex_getln.c	/^finish_viminfo_history()$/;"	f
finished	ex_cmds2.c	/^    int		finished;	\/* ":finish" used *\/$/;"	m	struct:source_cookie	file:
fireChanges	netbeans.c	/^    unsigned int	 fireChanges:1;$/;"	m	struct:nbbuf_struct	file:
first	mbyte.c	/^    unsigned short first;$/;"	m	struct:interval	file:
first_abbr	getchar.c	/^static mapblock_T	*first_abbr = NULL; \/* first entry in abbrlist *\/$/;"	v	file:
first_autopat	fileio.c	/^static AutoPat *first_autopat[NUM_EVENTS] =$/;"	v	file:
first_dict	eval.c	/^static dict_T		*first_dict = NULL;	\/* list of all dicts *\/$/;"	v	file:
first_lang	spell.c	/^static slang_T *first_lang = NULL;$/;"	v	file:
first_list	eval.c	/^static list_T		*first_list = NULL;	\/* list of all lists *\/$/;"	v	file:
first_lnum	structs.h	/^    linenr_T	first_lnum;	\/* first lnum to search for multi-line pat *\/$/;"	m	struct:__anon96
first_msg_hist	message.c	/^static struct msg_hist *first_msg_hist = NULL;$/;"	v	typeref:struct:msg_hist	file:
first_sign	ex_cmds.c	/^static sign_T	*first_sign = NULL;$/;"	v	file:
first_submatch	search.c	/^first_submatch(rp)$/;"	f	file:
first_tabpage	globals.h	/^EXTERN tabpage_T    *first_tabpage;$/;"	v
firstbuf	globals.h	/^EXTERN buf_T	*firstbuf INIT(= NULL);	\/* first buffer *\/$/;"	v
firstwin	globals.h	/^# define firstwin /;"	d
firstwin	globals.h	/^EXTERN win_T	*firstwin;		\/* first window *\/$/;"	v
fixAccelText	workshop.c	/^fixAccelText($/;"	f	file:
fix_fname	buffer.c	/^fix_fname(fname)$/;"	f
fix_help_buffer	ex_cmds.c	/^fix_help_buffer()$/;"	f
fix_indent	edit.c	/^fix_indent()$/;"	f
fix_input_buffer	getchar.c	/^fix_input_buffer(buf, len, script)$/;"	f
fixthisline	edit.c	/^fixthisline(get_the_indent)$/;"	f
fixup	workshop.c	/^fixup($/;"	f	file:
fixvar	eval.c	/^    } fixvar[FIXVAR_CNT];$/;"	m	struct:funccall_S	typeref:struct:funccall_S::__anon3	file:
fkmap	farsi.c	/^fkmap(c)$/;"	f
flag	syntax.c	/^    int		flag;$/;"	m	struct:name_list	file:
flag_in_afflist	spell.c	/^flag_in_afflist(flagtype, afflist, flag)$/;"	f	file:
flags	ex_cmds.h	/^    int		flags;		\/* extra flags after count: EXFLAG_ *\/$/;"	m	struct:exarg
flags	gui_gtk_x11.c	/^    unsigned int    flags;$/;"	m	struct:__anon18	file:
flags	if_cscope.h	/^    char *	    flags;	\/* additional cscope flags\/options (e.g, -p2) *\/$/;"	m	struct:csi
flags	option.c	/^    long_u	flags;		\/* see below *\/$/;"	m	struct:vimoption	file:
flags	quickfix.c	/^    char_u	    flags;	\/* additional flags given in prefix *\/$/;"	m	struct:efm_S	file:
flags	structs.h	/^    short	flags;		\/* see syntax.c *\/$/;"	m	struct:keyentry
flags	syntax.c	/^    int		flags;		\/* flags for contained and transparent *\/$/;"	m	struct:__anon58	file:
fline_T	fold.c	/^} fline_T;$/;"	t	typeref:struct:__anon12	file:
floatZero	gui_at_sb.c	/^static float floatZero = 0.0;$/;"	v	file:
float_T	structs.h	/^typedef double	float_T;$/;"	t
flush_buffers	getchar.c	/^flush_buffers(typeahead)$/;"	f
fm_getname	mark.c	/^fm_getname(fmark, lead_len)$/;"	f
fmark	structs.h	/^    fmark_T	fmark;		\/* cursor position BEFORE ":tag" *\/$/;"	m	struct:taggy
fmark	structs.h	/^    fmark_T	fmark;$/;"	m	struct:xfilemark
fmark_T	structs.h	/^} fmark_T;$/;"	t	typeref:struct:filemark
fmarks_check_names	mark.c	/^fmarks_check_names(buf)$/;"	f
fmarks_check_one	mark.c	/^fmarks_check_one(fm, name, buf)$/;"	f	file:
fmt_check_par	ops.c	/^fmt_check_par(lnum)$/;"	f	file:
fmt_check_par	ops.c	/^fmt_check_par(lnum, leader_len, leader_flags, do_comments)$/;"	f	file:
fn	gui_xmdlg.c	/^fn(SharedFontSelData *data, int i)$/;"	f	file:
fname	ex_cmds2.c	/^    char_u	*fname;		\/* name of sourced file *\/$/;"	m	struct:source_cookie	file:
fname	fileio.c	/^    char_u	*fname;		\/* fname to match with *\/$/;"	m	struct:AutoPatCmd	file:
fname	if_cscope.h	/^    char *	    fname;	\/* cscope db name *\/$/;"	m	struct:csi
fname	structs.h	/^    char_u	*fname;		\/* file name, used when fnum == 0 *\/$/;"	m	struct:xfilemark
fname	tag.c	/^    char_u	*fname;		\/* first char of file name *\/$/;"	m	struct:tag_pointers	file:
fname2fnum	mark.c	/^fname2fnum(fm)$/;"	f	file:
fname_case	os_unix.c	/^fname_case(name, len)$/;"	f
fname_end	tag.c	/^    char_u	*fname_end;	\/* char after file name *\/$/;"	m	struct:tag_pointers	file:
fname_expand	buffer.c	/^fname_expand(buf, ffname, sfname)$/;"	f
fname_match	buffer.c	/^fname_match(prog, name)$/;"	f	file:
fnamecmp	vim.h	/^#  define fnamecmp(/;"	d
fnamecmp	vim.h	/^# define fnamecmp(/;"	d
fnamecmp_ino	memline.c	/^fnamecmp_ino(fname_c, fname_s, ino_block0)$/;"	f	file:
fnamencmp	vim.h	/^#  define fnamencmp(/;"	d
fnamencmp	vim.h	/^# define fnamencmp(/;"	d
fnum	structs.h	/^    int		fnum;		\/* file number *\/$/;"	m	struct:filemark
focus_in_event	gui_gtk_x11.c	/^focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)$/;"	f	file:
focus_out_event	gui_gtk_x11.c	/^focus_out_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)$/;"	f	file:
foldAddMarker	fold.c	/^foldAddMarker(lnum, marker, markerlen)$/;"	f	file:
foldAdjustCursor	fold.c	/^foldAdjustCursor()$/;"	f
foldAdjustVisual	fold.c	/^foldAdjustVisual()$/;"	f
foldCase	mbyte.c	/^static convertStruct foldCase[] =$/;"	v	file:
foldCheckClose	fold.c	/^foldCheckClose()$/;"	f
foldCreate	fold.c	/^foldCreate(start, end)$/;"	f
foldCreateMarkers	fold.c	/^foldCreateMarkers(start, end)$/;"	f	file:
foldDelMarker	fold.c	/^foldDelMarker(lnum, marker, markerlen)$/;"	f	file:
foldFind	fold.c	/^foldFind(gap, lnum, fpp)$/;"	f	file:
foldInitWin	fold.c	/^foldInitWin(newwin)$/;"	f
foldInsert	fold.c	/^foldInsert(gap, i)$/;"	f	file:
foldLevel	fold.c	/^foldLevel(lnum)$/;"	f
foldLevelWin	fold.c	/^foldLevelWin(wp, lnum)$/;"	f	file:
foldManualAllowed	fold.c	/^foldManualAllowed(create)$/;"	f
foldMarkAdjust	fold.c	/^foldMarkAdjust(wp, line1, line2, amount, amount_after)$/;"	f
foldMarkAdjustRecurse	fold.c	/^foldMarkAdjustRecurse(gap, line1, line2, amount, amount_after)$/;"	f	file:
foldMerge	fold.c	/^foldMerge(fp1, gap, fp2)$/;"	f	file:
foldMoveTo	fold.c	/^foldMoveTo(updown, dir, count)$/;"	f
foldOpenCursor	fold.c	/^foldOpenCursor()$/;"	f
foldOpenNested	fold.c	/^foldOpenNested(fpr)$/;"	f	file:
foldRemove	fold.c	/^foldRemove(gap, top, bot)$/;"	f	file:
foldSplit	fold.c	/^foldSplit(gap, i, top, bot)$/;"	f	file:
foldUpdate	fold.c	/^foldUpdate(wp, top, bot)$/;"	f
foldUpdateAll	fold.c	/^foldUpdateAll(win)$/;"	f
foldUpdateIEMS	fold.c	/^foldUpdateIEMS(wp, top, bot)$/;"	f	file:
foldUpdateIEMSRecurse	fold.c	/^foldUpdateIEMSRecurse(gap, level, startlnum, flp, getlevel, bot, topflags)$/;"	f	file:
fold_T	fold.c	/^} fold_T;$/;"	t	typeref:struct:__anon11	file:
fold_changed	fold.c	/^static int fold_changed;$/;"	v	file:
fold_line	screen.c	/^fold_line(wp, fold_count, foldinfo, lnum, row)$/;"	f	file:
fold_more	spell.c	/^fold_more(mip)$/;"	f	file:
foldclosed_both	eval.c	/^foldclosed_both(argvars, rettv, end)$/;"	f	file:
foldedCount	fold.c	/^foldedCount(win, lnum, infop)$/;"	f
foldendmarker	fold.c	/^static char_u *foldendmarker;$/;"	v	file:
foldendmarkerlen	fold.c	/^static int foldendmarkerlen;$/;"	v	file:
foldinfo	structs.h	/^typedef struct foldinfo$/;"	s
foldinfo_T	structs.h	/^} foldinfo_T;$/;"	t	typeref:struct:foldinfo
foldlevelDiff	fold.c	/^foldlevelDiff(flp)$/;"	f	file:
foldlevelExpr	fold.c	/^foldlevelExpr(flp)$/;"	f	file:
foldlevelIndent	fold.c	/^foldlevelIndent(flp)$/;"	f	file:
foldlevelMarker	fold.c	/^foldlevelMarker(flp)$/;"	f	file:
foldlevelSyntax	fold.c	/^foldlevelSyntax(flp)$/;"	f	file:
foldmethodIsDiff	fold.c	/^foldmethodIsDiff(wp)$/;"	f
foldmethodIsExpr	fold.c	/^foldmethodIsExpr(wp)$/;"	f
foldmethodIsIndent	fold.c	/^foldmethodIsIndent(wp)$/;"	f
foldmethodIsManual	fold.c	/^foldmethodIsManual(wp)$/;"	f
foldmethodIsMarker	fold.c	/^foldmethodIsMarker(wp)$/;"	f
foldmethodIsSyntax	fold.c	/^foldmethodIsSyntax(wp)$/;"	f
foldstartmarkerlen	fold.c	/^static int foldstartmarkerlen;$/;"	v	file:
foldtext_cleanup	fold.c	/^foldtext_cleanup(str)$/;"	f
font	structs.h	/^	    GuiFont	    font;	\/* font handle *\/$/;"	m	struct:attr_entry::__anon86::__anon89
font_argument	globals.h	/^EXTERN char	*font_argument INIT(= NULL);$/;"	v
font_can_bold	gui.h	/^    int		font_can_bold;	    \/* Whether norm_font supports bold weight.$/;"	m	struct:Gui
font_name	gui_xmdlg.c	/^    char	*font_name;	\/* current font name *\/$/;"	m	struct:_SharedFontSelData	file:
font_name2handle	syntax.c	/^font_name2handle(name)$/;"	f	file:
font_sel_cancel	gui_gtk_x11.c	/^font_sel_cancel(GtkWidget *wgt, gpointer cbdata)$/;"	f	file:
font_sel_destroy	gui_gtk_x11.c	/^font_sel_destroy(GtkWidget *wgt, gpointer cbdata)$/;"	f	file:
font_sel_ok	gui_gtk_x11.c	/^font_sel_ok(GtkWidget *wgt, gpointer cbdata)$/;"	f	file:
fontdlg	gui.h	/^    GtkWidget	*fontdlg;	    \/* font selection dialog window *\/$/;"	m	struct:Gui
fontname	gui.h	/^    char_u	*fontname;	    \/* font name from font selection dialog *\/$/;"	m	struct:Gui
fontname	gui_at_fs.c	/^    char *fontname;$/;"	m	struct:__anon16	file:
fontset	gui.h	/^    GuiFontset	fontset;	    \/* set of fonts for multi-byte chars *\/$/;"	m	struct:Gui
fontset	structs.h	/^	    GuiFontset	    fontset;	\/* fontset handle *\/$/;"	m	struct:attr_entry::__anon86::__anon89
fontset_ascent	gui_x11.c	/^fontset_ascent(fs)$/;"	f	file:
fontset_height	gui_x11.c	/^fontset_height(fs)$/;"	f
fontset_height2	gui_x11.c	/^fontset_height2(fs)$/;"	f
fontset_name2handle	syntax.c	/^fontset_name2handle(name, fixed_width)$/;"	f	file:
fontset_width	gui_x11.c	/^fontset_width(fs)$/;"	f	file:
footer	gui_motif.c	/^static Widget footer;$/;"	v	file:
footer_height	gui.h	/^    int		footer_height;	    \/* height of the message footer *\/$/;"	m	struct:Gui
fopen_noinh_readbin	ex_cmds2.c	/^fopen_noinh_readbin(filename)$/;"	f	file:
force_abort	ex_docmd.c	/^    int		force_abort;$/;"	m	struct:dbg_stuff	file:
force_abort	globals.h	/^EXTERN int force_abort INIT(= FALSE);$/;"	v
force_bin	ex_cmds.h	/^    int		force_bin;	\/* 0, FORCE_BIN or FORCE_NOBIN *\/$/;"	m	struct:exarg
force_enc	ex_cmds.h	/^    int		force_enc;	\/* ++enc= argument (index in cmd[]) *\/$/;"	m	struct:exarg
force_ff	ex_cmds.h	/^    int		force_ff;	\/* ++ff= argument (index in cmd[]) *\/$/;"	m	struct:exarg
force_menu_update	globals.h	/^EXTERN int force_menu_update INIT(= FALSE);$/;"	v
forceit	ex_cmds.h	/^    int		forceit;	\/* TRUE if ! present *\/$/;"	m	struct:exarg
foreground	gui_at_sb.h	/^    Pixel	  foreground;	\/* thumb foreground color *\/$/;"	m	struct:__anon64
foreground_argument	globals.h	/^EXTERN char	*foreground_argument INIT(= NULL);$/;"	v
forinfo_T	eval.c	/^} forinfo_T;$/;"	t	typeref:struct:__anon4	file:
form_configure_event	gui_gtk_x11.c	/^form_configure_event(GtkWidget *widget, GdkEventConfigure *event,$/;"	f	file:
format	vim.h	/^    int_u	format;		\/* Vim's own special clipboard format *\/$/;"	m	struct:VimClipboard
format_lines	ops.c	/^format_lines(line_count, avoid_fex)$/;"	f
format_raw	vim.h	/^    int_u	format_raw;	\/* Vim's raw text clipboard format *\/$/;"	m	struct:VimClipboard
formwin	gui.h	/^    GtkWidget	*formwin;	    \/* manages all the windows below *\/$/;"	m	struct:Gui
forward_slash	fileio.c	/^forward_slash(fname)$/;"	f
found_iconic_arg	gui_gtk_x11.c	/^static int found_iconic_arg = FALSE;$/;"	v	file:
found_reverse_arg	globals.h	/^EXTERN int	found_reverse_arg INIT(= FALSE);$/;"	v
found_tagfile_cb	tag.c	/^found_tagfile_cb(fname, cookie)$/;"	f	file:
fp	ex_cmds2.c	/^    FILE	*fp;		\/* opened file for sourcing *\/$/;"	m	struct:source_cookie	file:
fp	search.c	/^    FILE	*fp;		\/* File pointer *\/$/;"	m	struct:SearchedFile	file:
fr_child	structs.h	/^    frame_T	*fr_child;	\/* first contained frame *\/$/;"	m	struct:frame_S
fr_fp	if_cscope.h	/^    FILE *	    fr_fp;	\/* from cscope: FILE. *\/$/;"	m	struct:csi
fr_height	structs.h	/^    int		fr_height;$/;"	m	struct:frame_S
fr_layout	structs.h	/^    char	fr_layout;	\/* FR_LEAF, FR_COL or FR_ROW *\/$/;"	m	struct:frame_S
fr_newheight	structs.h	/^    int		fr_newheight;	\/* new height used in win_equal_rec() *\/$/;"	m	struct:frame_S
fr_newwidth	structs.h	/^    int		fr_newwidth;	\/* new width used in win_equal_rec() *\/$/;"	m	struct:frame_S
fr_next	structs.h	/^    frame_T	*fr_next;	\/* frame right or below in same parent, NULL$/;"	m	struct:frame_S
fr_parent	structs.h	/^    frame_T	*fr_parent;	\/* containing frame or NULL *\/$/;"	m	struct:frame_S
fr_prev	structs.h	/^    frame_T	*fr_prev;	\/* frame left or above in same parent, NULL$/;"	m	struct:frame_S
fr_width	structs.h	/^    int		fr_width;$/;"	m	struct:frame_S
fr_win	structs.h	/^    win_T	*fr_win;	\/* window that fills this frame *\/$/;"	m	struct:frame_S
frame2win	window.c	/^frame2win(frp)$/;"	f	file:
frame_S	structs.h	/^struct frame_S$/;"	s
frame_T	structs.h	/^typedef struct frame_S		frame_T;$/;"	t	typeref:struct:frame_S
frame_add_height	window.c	/^frame_add_height(frp, n)$/;"	f	file:
frame_add_statusline	window.c	/^frame_add_statusline(frp)$/;"	f	file:
frame_add_vsep	window.c	/^frame_add_vsep(frp)$/;"	f	file:
frame_append	window.c	/^frame_append(after, frp)$/;"	f	file:
frame_comp_pos	window.c	/^frame_comp_pos(topfrp, row, col)$/;"	f	file:
frame_fix_height	window.c	/^frame_fix_height(wp)$/;"	f	file:
frame_fix_width	window.c	/^frame_fix_width(wp)$/;"	f	file:
frame_fixed_height	window.c	/^frame_fixed_height(frp)$/;"	f	file:
frame_fixed_width	window.c	/^frame_fixed_width(frp)$/;"	f	file:
frame_has_win	window.c	/^frame_has_win(frp, wp)$/;"	f	file:
frame_insert	window.c	/^frame_insert(before, frp)$/;"	f	file:
frame_minheight	window.c	/^frame_minheight(topfrp, next_curwin)$/;"	f	file:
frame_minwidth	window.c	/^frame_minwidth(topfrp, next_curwin)$/;"	f	file:
frame_new_height	window.c	/^frame_new_height(topfrp, height, topfirst, wfh)$/;"	f	file:
frame_new_width	window.c	/^frame_new_width(topfrp, width, leftfirst, wfw)$/;"	f	file:
frame_remove	window.c	/^frame_remove(frp)$/;"	f	file:
frame_setheight	window.c	/^frame_setheight(curfrp, height)$/;"	f	file:
frame_setwidth	window.c	/^frame_setwidth(curfrp, width)$/;"	f	file:
free_all_autocmds	fileio.c	/^free_all_autocmds()$/;"	f
free_all_functions	eval.c	/^free_all_functions()$/;"	f
free_all_marks	mark.c	/^free_all_marks()$/;"	f
free_all_mem	misc2.c	/^free_all_mem()$/;"	f
free_all_options	option.c	/^free_all_options()$/;"	f
free_blocks	spell.c	/^free_blocks(bl)$/;"	f	file:
free_buf_options	buffer.c	/^free_buf_options(buf, free_p_ff)$/;"	f
free_buff	getchar.c	/^free_buff(buf)$/;"	f
free_buffer	buffer.c	/^free_buffer(buf)$/;"	f	file:
free_buffer_stuff	buffer.c	/^free_buffer_stuff(buf, free_options)$/;"	f	file:
free_cd_dir	ex_docmd.c	/^free_cd_dir()$/;"	f
free_cmdline_buf	ex_getln.c	/^free_cmdline_buf()$/;"	f
free_cmdlines	ex_docmd.c	/^free_cmdlines(gap)$/;"	f	file:
free_findfile	misc2.c	/^free_findfile()$/;"	f	file:
free_for_info	eval.c	/^free_for_info(fi_void)$/;"	f
free_highlight	syntax.c	/^free_highlight()$/;"	f
free_highlight_fonts	syntax.c	/^free_highlight_fonts()$/;"	f
free_homedir	misc1.c	/^free_homedir()$/;"	f
free_jumplist	mark.c	/^free_jumplist(wp)$/;"	f
free_last_insert	edit.c	/^free_last_insert()$/;"	f
free_menu	menu.c	/^free_menu(menup)$/;"	f	file:
free_menu_string	menu.c	/^free_menu_string(menu, idx)$/;"	f	file:
free_msglist	ex_eval.c	/^free_msglist(l)$/;"	f	file:
free_old_sub	ex_cmds.c	/^free_old_sub()$/;"	f
free_pixmaps	gui_xmebw.c	/^free_pixmaps(XmEnhancedButtonWidget eb)$/;"	f	file:
free_prev_shellcmd	ex_cmds.c	/^free_prev_shellcmd()$/;"	f
free_regexp_stuff	regexp.c	/^free_regexp_stuff()$/;"	f
free_screenlines	screen.c	/^free_screenlines()$/;"	f
free_scriptnames	ex_cmds2.c	/^free_scriptnames()$/;"	f
free_search_patterns	search.c	/^free_search_patterns()$/;"	f
free_string_option	option.c	/^free_string_option(p)$/;"	f
free_tabpage	window.c	/^free_tabpage(tp)$/;"	f
free_tag_stuff	tag.c	/^free_tag_stuff()$/;"	f
free_termoptions	option.c	/^free_termoptions()$/;"	f
free_titles	buffer.c	/^free_titles()$/;"	f
free_tv	eval.c	/^free_tv(varp)$/;"	f
free_typebuf	getchar.c	/^free_typebuf()$/;"	f
free_wordnode	spell.c	/^free_wordnode(spin, n)$/;"	f	file:
free_yank	ops.c	/^free_yank(n)$/;"	f	file:
free_yank_all	ops.c	/^free_yank_all()$/;"	f	file:
freeze_count	gui_gtk_f.h	/^    gint freeze_count;$/;"	m	struct:_GtkForm
from	digraph.c	/^    char_u	*from;$/;"	m	struct:__anon1	file:
from	menu.c	/^    char_u	*from;		\/* English name *\/$/;"	m	struct:__anon43	file:
from_noamp	menu.c	/^    char_u	*from_noamp;	\/* same, without '&' *\/$/;"	m	struct:__anon43	file:
fromto_S	spell.c	/^typedef struct fromto_S$/;"	s	file:
fromto_T	spell.c	/^} fromto_T;$/;"	t	typeref:struct:fromto_S	file:
fst	eval.c	/^static struct fst$/;"	s	file:
fstatfs	memfile.c	/^#   define fstatfs(/;"	d	file:
fstatfs	memfile.c	/^# define fstatfs(/;"	d	file:
ft_from	spell.c	/^    char_u	*ft_from;$/;"	m	struct:fromto_S	file:
ft_to	spell.c	/^    char_u	*ft_to;$/;"	m	struct:fromto_S	file:
ftell	tag.c	/^# define ftell /;"	d	file:
full_path	main.c	/^    int		full_path;		\/* file name argument was full path *\/$/;"	m	struct:__anon39	file:
full_screen	globals.h	/^EXTERN int	full_screen INIT(= FALSE);$/;"	v
fullname	option.c	/^    char	*fullname;	\/* full option name *\/$/;"	m	struct:vimoption	file:
fullpathcmp	misc1.c	/^fullpathcmp(s1, s2, checkname)$/;"	f
func	eval.c	/^    ufunc_T	*func;		\/* function being called *\/$/;"	m	struct:funccall_S	file:
func	if_cscope.h	/^    int     (*func) __ARGS((exarg_T *eap));$/;"	m	struct:__anon68
func	syntax.c	/^    void    (*func)__ARGS((exarg_T *, int));	\/* function to call *\/$/;"	m	struct:subcommand	file:
func_breakpoint	eval.c	/^func_breakpoint(cookie)$/;"	f
func_dbg_tick	eval.c	/^func_dbg_tick(cookie)$/;"	f
func_do_profile	eval.c	/^func_do_profile(fp)$/;"	f	file:
func_dump_profile	eval.c	/^func_dump_profile(fd)$/;"	f
func_free	eval.c	/^func_free(fp)$/;"	f	file:
func_has_abort	eval.c	/^func_has_abort(cookie)$/;"	f
func_has_ended	eval.c	/^func_has_ended(cookie)$/;"	f
func_hashtab	eval.c	/^static hashtab_T	func_hashtab;$/;"	v	file:
func_level	eval.c	/^func_level(cookie)$/;"	f
func_line_end	eval.c	/^func_line_end(cookie)$/;"	f
func_line_exec	eval.c	/^func_line_exec(cookie)$/;"	f
func_line_start	eval.c	/^func_line_start(cookie)$/;"	f
func_name	eval.c	/^func_name(cookie)$/;"	f
func_ref	eval.c	/^func_ref(name)$/;"	f	file:
func_unref	eval.c	/^func_unref(name)$/;"	f	file:
funccall_S	eval.c	/^struct funccall_S$/;"	s	file:
funccall_T	eval.c	/^typedef struct funccall_S funccall_T;$/;"	t	typeref:struct:funccall_S	file:
funcdict_T	eval.c	/^} funcdict_T;$/;"	t	typeref:struct:__anon5	file:
function_exists	eval.c	/^function_exists(name)$/;"	f	file:
functions	eval.c	/^} functions[] =$/;"	v	typeref:struct:fst	file:
fwd_word	search.c	/^fwd_word(count, bigword, eol)$/;"	f
g_do_tagpreview	globals.h	/^EXTERN int	g_do_tagpreview INIT(= 0);  \/* for tag preview commands:$/;"	v
ga_append	misc2.c	/^ga_append(gap, c)$/;"	f
ga_clear	misc2.c	/^ga_clear(gap)$/;"	f
ga_clear_strings	misc2.c	/^ga_clear_strings(gap)$/;"	f
ga_concat	misc2.c	/^ga_concat(gap, s)$/;"	f
ga_data	structs.h	/^    void    *ga_data;		    \/* pointer to the first item *\/$/;"	m	struct:growarray
ga_grow	misc2.c	/^ga_grow(gap, n)$/;"	f
ga_growsize	structs.h	/^    int	    ga_growsize;	    \/* number of items to grow each time *\/$/;"	m	struct:growarray
ga_init	misc2.c	/^ga_init(gap)$/;"	f
ga_init2	misc2.c	/^ga_init2(gap, itemsize, growsize)$/;"	f
ga_itemsize	structs.h	/^    int	    ga_itemsize;	    \/* sizeof(item) *\/$/;"	m	struct:growarray
ga_len	structs.h	/^    int	    ga_len;		    \/* current number of items used *\/$/;"	m	struct:growarray
ga_loaded	eval.c	/^static garray_T		ga_loaded = {0, 0, sizeof(char_u *), 4, NULL};$/;"	v	file:
ga_maxlen	structs.h	/^    int	    ga_maxlen;		    \/* maximum number of items possible *\/$/;"	m	struct:growarray
ga_scripts	eval.c	/^static garray_T	    ga_scripts = {0, 0, sizeof(scriptvar_T), 4, NULL};$/;"	v	file:
ga_userinput	eval.c	/^static garray_T	    ga_userinput = {0, 0, sizeof(tasave_T), 4, NULL};$/;"	v	file:
garbage_collect	eval.c	/^garbage_collect()$/;"	f
garbage_collect_at_exit	globals.h	/^EXTERN int	garbage_collect_at_exit INIT(= FALSE);$/;"	v
garray_T	structs.h	/^} garray_T;$/;"	t	typeref:struct:growarray
gather_termleader	term.c	/^gather_termleader()$/;"	f	file:
gboolean	gui_gtk.c	/^# define gboolean /;"	d	file:
gboolean	mbyte.c	/^#  define gboolean /;"	d	file:
gboolean	mbyte.c	/^# define gboolean /;"	d	file:
gc	gui_at_sb.h	/^    GC		  gc;		\/* a (shared) gc *\/$/;"	m	struct:__anon64
gchar_cursor	misc1.c	/^gchar_cursor()$/;"	f
gchar_pos	misc1.c	/^gchar_pos(pos)$/;"	f
gdk_wm_protocols_filter	gui_gtk_x11.c	/^gdk_wm_protocols_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)$/;"	f	file:
gen_expand_wildcards	misc1.c	/^gen_expand_wildcards(num_pat, pat, num_file, file, flags)$/;"	f
gen_expand_wildcards	vim.h	/^# define gen_expand_wildcards /;"	d
general_beval_cb	gui_beval.c	/^general_beval_cb(beval, state)$/;"	f
geom	gui.h	/^    char_u	*geom;		    \/* Geometry, eg "80x24" *\/$/;"	m	struct:Gui
get2c	spell.c	/^get2c(fd)$/;"	f	file:
get3c	spell.c	/^get3c(fd)$/;"	f	file:
get4c	spell.c	/^get4c(fd)$/;"	f	file:
get8c	spell.c	/^get8c(fd)$/;"	f	file:
getCommand	integration.c	/^getCommand(void)$/;"	f	file:
getConnInfo	netbeans.c	/^getConnInfo(char *file, char **host, char **port, char **auth)$/;"	f	file:
getDeepestNesting	fold.c	/^getDeepestNesting()$/;"	f
getDeepestNestingRecurse	fold.c	/^getDeepestNestingRecurse(gap)$/;"	f	file:
get_address	ex_docmd.c	/^get_address(ptr, skip, to_other_file)$/;"	f	file:
get_affitem	spell.c	/^get_affitem(flagtype, pp)$/;"	f	file:
get_affix_flags	spell.c	/^get_affix_flags(affile, afflist)$/;"	f	file:
get_arglist	ex_cmds2.c	/^get_arglist(gap, str)$/;"	f
get_arglist_exp	ex_cmds2.c	/^get_arglist_exp(str, fcountp, fnamesp)$/;"	f
get_attr_entry	syntax.c	/^get_attr_entry(table, aep)$/;"	f	file:
get_augroup_name	fileio.c	/^get_augroup_name(xp, idx)$/;"	f
get_baseclass_amount	misc1.c	/^get_baseclass_amount(col, ind_maxparen, ind_maxcomment, ind_cpp_baseclass)$/;"	f	file:
get_beval_info	gui_beval.c	/^get_beval_info(beval, getword, winp, lnump, textp, colp)$/;"	f
get_buf	if_ruby.c	/^static buf_T *get_buf(VALUE obj)$/;"	f	file:
get_buf_size	netbeans.c	/^get_buf_size(buf_T *bufp)$/;"	f	file:
get_buf_tv	eval.c	/^get_buf_tv(tv)$/;"	f	file:
get_buffcont	getchar.c	/^get_buffcont(buffer, dozero)$/;"	f	file:
get_buffer_arg	if_mzsch.c	/^get_buffer_arg(const char *fname, int argnum, int argc, Scheme_Object **argv)$/;"	f	file:
get_buffer_by_name	if_mzsch.c	/^get_buffer_by_name(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_buffer_by_num	if_mzsch.c	/^get_buffer_by_num(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_buffer_count	if_mzsch.c	/^get_buffer_count(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_buffer_line	if_mzsch.c	/^get_buffer_line(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_buffer_line	if_ruby.c	/^static VALUE get_buffer_line(buf_T *buf, linenr_T n)$/;"	f	file:
get_buffer_line_list	if_mzsch.c	/^get_buffer_line_list(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_buffer_lines	eval.c	/^get_buffer_lines(buf, start, end, retlist, rettv)$/;"	f	file:
get_buffer_name	if_mzsch.c	/^get_buffer_name(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_buffer_namespace	if_mzsch.c	/^get_buffer_namespace(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_buffer_num	if_mzsch.c	/^get_buffer_num(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_buffer_size	if_mzsch.c	/^get_buffer_size(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_bytes_from_buf	term.c	/^get_bytes_from_buf(buf, bytes, num_bytes)$/;"	f	file:
get_c_indent	misc1.c	/^get_c_indent()$/;"	f
get_ccline_ptr	ex_getln.c	/^get_ccline_ptr()$/;"	f	file:
get_char_class	regexp.c	/^get_char_class(pp)$/;"	f	file:
get_cmd_output	misc1.c	/^get_cmd_output(cmd, infile, flags)$/;"	f
get_cmdline_pos	ex_getln.c	/^get_cmdline_pos()$/;"	f
get_cmdline_str	ex_getln.c	/^get_cmdline_str()$/;"	f
get_cmdline_type	ex_getln.c	/^get_cmdline_type()$/;"	f
get_coll_element	regexp.c	/^get_coll_element(pp)$/;"	f	file:
get_command_name	ex_docmd.c	/^get_command_name(xp, idx)$/;"	f
get_compflags	spell.c	/^get_compflags(affile, afflist, store_afflist)$/;"	f	file:
get_crypt_key	misc2.c	/^get_crypt_key(store, twice)$/;"	f
get_curr_buffer	if_mzsch.c	/^get_curr_buffer(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_curr_win	if_mzsch.c	/^get_curr_win(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_cursor	if_mzsch.c	/^get_cursor(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_dict_number	eval.c	/^get_dict_number(d, key)$/;"	f
get_dict_string	eval.c	/^get_dict_string(d, key, save)$/;"	f
get_dict_tv	eval.c	/^get_dict_tv(arg, rettv, evaluate)$/;"	f	file:
get_digraph	digraph.c	/^get_digraph(cmdline)$/;"	f
get_emsg_lnum	message.c	/^get_emsg_lnum()$/;"	f	file:
get_emsg_source	message.c	/^get_emsg_source()$/;"	f	file:
get_encoding_default	option.c	/^get_encoding_default()$/;"	f
get_end_emsg	ex_eval.c	/^get_end_emsg(cstack)$/;"	f	file:
get_env_len	eval.c	/^get_env_len(arg)$/;"	f	file:
get_env_name	misc1.c	/^get_env_name(xp, idx)$/;"	f
get_env_tv	eval.c	/^get_env_tv(arg, rettv, evaluate)$/;"	f	file:
get_equalprg	option.c	/^get_equalprg()$/;"	f
get_equi_class	regexp.c	/^get_equi_class(pp)$/;"	f	file:
get_errorlist	quickfix.c	/^get_errorlist(wp, list)$/;"	f
get_event_name	fileio.c	/^get_event_name(xp, idx)$/;"	f
get_exceptions	if_python.c	/^get_exceptions()$/;"	f	file:
get_expr_indent	misc1.c	/^get_expr_indent()$/;"	f
get_expr_line	ops.c	/^get_expr_line()$/;"	f
get_expr_line_src	ops.c	/^get_expr_line_src()$/;"	f
get_expr_name	eval.c	/^get_expr_name(xp, idx)$/;"	f
get_expr_register	ops.c	/^get_expr_register()$/;"	f
get_extra_op_char	ops.c	/^get_extra_op_char(optype)$/;"	f
get_file_in_dir	memline.c	/^get_file_in_dir(fname, dname)$/;"	f
get_fileformat	misc2.c	/^get_fileformat(buf)$/;"	f
get_fileformat_force	misc2.c	/^get_fileformat_force(buf, eap)$/;"	f
get_find_dialog_text	gui.c	/^get_find_dialog_text(arg, wwordp, mcasep)$/;"	f
get_fio_flags	fileio.c	/^get_fio_flags(ptr)$/;"	f	file:
get_flags	ex_docmd.c	/^get_flags(eap)$/;"	f	file:
get_float_arg	eval.c	/^get_float_arg(argvars, f)$/;"	f	file:
get_foldtext	fold.c	/^get_foldtext(wp, lnum, lnume, foldinfo, buf)$/;"	f
get_fpos_of_mouse	ui.c	/^get_fpos_of_mouse(mpos)$/;"	f
get_func_line	eval.c	/^get_func_line(c, cookie, indent)$/;"	f
get_func_tv	eval.c	/^get_func_tv(name, len, rettv, arg, firstline, lastline, doesrange,$/;"	f	file:
get_function_name	eval.c	/^get_function_name(xp, idx)$/;"	f
get_group_name	syntax.c	/^get_group_name(arg, name_end)$/;"	f	file:
get_highlight_default	option.c	/^get_highlight_default()$/;"	f
get_highlight_name	syntax.c	/^get_highlight_name(xp, idx)$/;"	f
get_history_entry	ex_getln.c	/^get_history_entry(histype, idx)$/;"	f
get_history_idx	ex_getln.c	/^get_history_idx(histype)$/;"	f
get_histtype	ex_getln.c	/^get_histtype(name)$/;"	f
get_id_len	eval.c	/^get_id_len(arg)$/;"	f	file:
get_id_list	syntax.c	/^get_id_list(arg, keylen, list)$/;"	f	file:
get_indent	misc1.c	/^get_indent()$/;"	f
get_indent_buf	misc1.c	/^get_indent_buf(buf, lnum)$/;"	f
get_indent_lnum	misc1.c	/^get_indent_lnum(lnum)$/;"	f
get_indent_nolabel	misc1.c	/^get_indent_nolabel(lnum)		\/* XXX *\/$/;"	f	file:
get_indent_str	misc1.c	/^get_indent_str(ptr, ts)$/;"	f
get_input_buf	ui.c	/^get_input_buf()$/;"	f
get_inserted	getchar.c	/^get_inserted()$/;"	f
get_item_dimensions	gui_gtk_x11.c	/^get_item_dimensions(GtkWidget *widget, GtkOrientation orientation)$/;"	f	file:
get_key_name	misc2.c	/^get_key_name(i)$/;"	f
get_keymap_str	screen.c	/^get_keymap_str(wp, buf, len)$/;"	f
get_keystroke	misc1.c	/^get_keystroke()$/;"	f
get_lang_arg	ex_cmds2.c	/^get_lang_arg(xp, idx)$/;"	f
get_last_insert	edit.c	/^get_last_insert()$/;"	f
get_last_insert_save	edit.c	/^get_last_insert_save()$/;"	f
get_leader_len	misc1.c	/^get_leader_len(line, flags, backward)$/;"	f
get_lisp_indent	misc1.c	/^get_lisp_indent()$/;"	f
get_list_range	ex_getln.c	/^get_list_range(str, num1, num2)$/;"	f
get_list_tv	eval.c	/^get_list_tv(arg, rettv, evaluate)$/;"	f	file:
get_lit_string_tv	eval.c	/^get_lit_string_tv(arg, rettv, evaluate)$/;"	f	file:
get_literal	edit.c	/^get_literal()$/;"	f
get_locale_val	ex_cmds2.c	/^get_locale_val(what)$/;"	f	file:
get_long_from_buf	term.c	/^get_long_from_buf(buf, val)$/;"	f	file:
get_loop_line	ex_docmd.c	/^get_loop_line(c, cookie, indent)$/;"	f	file:
get_lval	eval.c	/^get_lval(name, rettv, lp, unlet, skip, quiet, fne_flags)$/;"	f	file:
get_mac_fio_flags	fileio.c	/^get_mac_fio_flags(ptr)$/;"	f	file:
get_map_mode	getchar.c	/^get_map_mode(cmdp, forceit)$/;"	f
get_maparg	eval.c	/^get_maparg(argvars, rettv, exact)$/;"	f	file:
get_match	window.c	/^get_match(wp, id)$/;"	f
get_mef_name	quickfix.c	/^get_mef_name()$/;"	f	file:
get_menu_cmd_modes	menu.c	/^get_menu_cmd_modes(cmd, forceit, noremap, unmenu)$/;"	f	file:
get_menu_index	menu.c	/^get_menu_index(menu, state)$/;"	f
get_menu_mode	menu.c	/^get_menu_mode()$/;"	f	file:
get_menu_name	menu.c	/^get_menu_name(xp, idx)$/;"	f
get_menu_names	menu.c	/^get_menu_names(xp, idx)$/;"	f
get_menu_position	gui_gtk.c	/^get_menu_position(vimmenu_T *menu)$/;"	f	file:
get_menu_tool_height	gui_gtk_x11.c	/^get_menu_tool_height(void)$/;"	f	file:
get_menu_tool_width	gui_gtk_x11.c	/^get_menu_tool_width(void)$/;"	f	file:
get_mess_env	ex_cmds2.c	/^get_mess_env()$/;"	f	file:
get_mess_lang	ex_cmds2.c	/^get_mess_lang()$/;"	f
get_mouse_button	misc2.c	/^get_mouse_button(code, is_click, is_drag)$/;"	f
get_mouse_class	normal.c	/^get_mouse_class(p)$/;"	f	file:
get_name_len	eval.c	/^get_name_len(arg, alias, evaluate, verbose)$/;"	f	file:
get_next_buffer	if_mzsch.c	/^get_next_buffer(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_nolist_virtcol	edit.c	/^get_nolist_virtcol()$/;"	f	file:
get_number	misc1.c	/^get_number(colon, mouse_used)$/;"	f
get_number_arg	main.c	/^get_number_arg(p, idx, def)$/;"	f	file:
get_number_indent	misc1.c	/^get_number_indent(lnum)$/;"	f
get_off_or_lnum	netbeans.c	/^get_off_or_lnum(buf_T *buf, char_u **argp)$/;"	f	file:
get_one_sourceline	ex_cmds2.c	/^get_one_sourceline(sp)$/;"	f	file:
get_op_char	ops.c	/^get_op_char(optype)$/;"	f
get_op_type	ops.c	/^get_op_type(char1, char2)$/;"	f
get_option	if_mzsch.c	/^get_option(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_option_tv	eval.c	/^get_option_tv(arg, rettv, evaluate)$/;"	f	file:
get_option_value	option.c	/^get_option_value(name, numval, stringval, opt_flags)$/;"	f
get_part	gui_xmdlg.c	/^get_part(char *in, int pos, char *out)$/;"	f	file:
get_past_head	misc1.c	/^get_past_head(path)$/;"	f
get_pfxlist	spell.c	/^get_pfxlist(affile, afflist, store_afflist)$/;"	f	file:
get_popup_entry	gui_athena.c	/^get_popup_entry(w)$/;"	f	file:
get_prev_buffer	if_mzsch.c	/^get_prev_buffer(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_pseudo_mouse_code	misc2.c	/^get_pseudo_mouse_code(button, is_click, is_drag)$/;"	f
get_range_end	if_mzsch.c	/^get_range_end(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_range_start	if_mzsch.c	/^get_range_start(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_real_state	misc2.c	/^get_real_state()$/;"	f
get_recorded	getchar.c	/^get_recorded()$/;"	f
get_reg_contents	ops.c	/^get_reg_contents(regname, allowexpr, expr_src)$/;"	f
get_reg_type	ops.c	/^get_reg_type(regname, reglen)$/;"	f
get_register	ops.c	/^get_register(name, copy)$/;"	f
get_register_name	ops.c	/^get_register_name(num)$/;"	f
get_rel_pos	buffer.c	/^get_rel_pos(wp, str)$/;"	f
get_return_cmd	eval.c	/^get_return_cmd(rettv)$/;"	f
get_scriptname	ex_cmds2.c	/^get_scriptname(id)$/;"	f
get_scroll_overlap	move.c	/^get_scroll_overlap(lp, dir)$/;"	f	file:
get_search_arg	eval.c	/^get_search_arg(varp, flagsp)$/;"	f	file:
get_search_pat	search.c	/^get_search_pat()$/;"	f
get_selection	workshop.c	/^get_selection($/;"	f	file:
get_shape_idx	misc2.c	/^get_shape_idx(mouse)$/;"	f
get_short_pathname	eval.c	/^get_short_pathname(fnamep, bufp, fnamelen)$/;"	f	file:
get_spec_reg	ops.c	/^get_spec_reg(regname, argp, allocated, errmsg)$/;"	f
get_special_key_code	misc2.c	/^get_special_key_code(name)$/;"	f
get_special_key_name	misc2.c	/^get_special_key_name(c, modifiers)$/;"	f
get_spellword	eval.c	/^get_spellword(list, pp)$/;"	f
get_stack_limit	os_unix.c	/^get_stack_limit()$/;"	f	file:
get_string_tv	eval.c	/^get_string_tv(arg, rettv, evaluate)$/;"	f	file:
get_stty	os_unix.c	/^get_stty()$/;"	f
get_styled_font_variants	gui_gtk_x11.c	/^get_styled_font_variants(char_u * font_name)$/;"	f	file:
get_styled_font_variants	gui_gtk_x11.c	/^get_styled_font_variants(void)$/;"	f	file:
get_syn_options	syntax.c	/^get_syn_options(arg, opt)$/;"	f	file:
get_syn_pattern	syntax.c	/^get_syn_pattern(arg, ci)$/;"	f	file:
get_syntax_attr	syntax.c	/^get_syntax_attr(col, can_spell, keep_state)$/;"	f
get_syntax_name	syntax.c	/^get_syntax_name(xp, idx)$/;"	f
get_tabline_label	gui.c	/^get_tabline_label(tp, tooltip)$/;"	f
get_tagfname	tag.c	/^get_tagfname(tnp, first, buf)$/;"	f
get_tags	tag.c	/^get_tags(list, pat)$/;"	f
get_term_code	option.c	/^get_term_code(tname)$/;"	f
get_termcode	term.c	/^get_termcode(i)$/;"	f
get_toolbar_pixmap	gui_athena.c	/^get_toolbar_pixmap(menu, sen)$/;"	f	file:
get_toolbar_pixmap	gui_motif.c	/^get_toolbar_pixmap(menu, fname)$/;"	f	file:
get_trans_bufname	screen.c	/^get_trans_bufname(buf)$/;"	f
get_tv_lnum	eval.c	/^get_tv_lnum(argvars)$/;"	f	file:
get_tv_lnum_buf	eval.c	/^get_tv_lnum_buf(argvars, buf)$/;"	f	file:
get_tv_number	eval.c	/^get_tv_number(varp)$/;"	f	file:
get_tv_number_chk	eval.c	/^get_tv_number_chk(varp, denote)$/;"	f
get_tv_string	eval.c	/^get_tv_string(varp)$/;"	f	file:
get_tv_string_buf	eval.c	/^get_tv_string_buf(varp, buf)$/;"	f	file:
get_tv_string_buf_chk	eval.c	/^get_tv_string_buf_chk(varp, buf)$/;"	f	file:
get_tv_string_chk	eval.c	/^get_tv_string_chk(varp)$/;"	f
get_user_cmd_complete	ex_docmd.c	/^get_user_cmd_complete(xp, idx)$/;"	f
get_user_cmd_flags	ex_docmd.c	/^get_user_cmd_flags(xp, idx)$/;"	f
get_user_cmd_nargs	ex_docmd.c	/^get_user_cmd_nargs(xp, idx)$/;"	f
get_user_command_name	ex_docmd.c	/^get_user_command_name(idx)$/;"	f	file:
get_user_commands	ex_docmd.c	/^get_user_commands(xp, idx)$/;"	f
get_user_func_name	eval.c	/^get_user_func_name(xp, idx)$/;"	f
get_user_input	eval.c	/^get_user_input(argvars, rettv, inputdialog)$/;"	f	file:
get_user_name	misc2.c	/^get_user_name(buf, len)$/;"	f
get_user_var_name	eval.c	/^get_user_var_name(xp, idx)$/;"	f
get_valid_buffer	if_mzsch.c	/^buf_T *get_valid_buffer(void *obj)$/;"	f
get_valid_window	if_mzsch.c	/^win_T *get_valid_window(void *obj)$/;"	f
get_var_tv	eval.c	/^get_var_tv(name, len, rettv, verbose)$/;"	f	file:
get_var_value	eval.c	/^get_var_value(name)$/;"	f
get_varp	option.c	/^get_varp(p)$/;"	f	file:
get_varp_scope	option.c	/^get_varp_scope(p, opt_flags)$/;"	f	file:
get_view_file	ex_docmd.c	/^get_view_file(c)$/;"	f	file:
get_vim_curr_buffer	if_mzsch.c	/^get_vim_curr_buffer(void)$/;"	f	file:
get_vim_curr_window	if_mzsch.c	/^get_vim_curr_window(void)$/;"	f	file:
get_vim_var_nr	eval.c	/^get_vim_var_nr(idx)$/;"	f
get_vim_var_str	eval.c	/^get_vim_var_str(idx)$/;"	f
get_viminfo_parameter	option.c	/^get_viminfo_parameter(type)$/;"	f
get_visual_text	normal.c	/^get_visual_text(cap, pp, lenp)$/;"	f
get_win	if_ruby.c	/^static win_T *get_win(VALUE obj)$/;"	f	file:
get_win_fio_flags	fileio.c	/^get_win_fio_flags(ptr)$/;"	f	file:
get_window	workshop.c	/^get_window($/;"	f	file:
get_window_arg	if_mzsch.c	/^get_window_arg(const char *fname, int argnum, int argc, Scheme_Object **argv)$/;"	f	file:
get_window_buffer	if_mzsch.c	/^get_window_buffer(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_window_by_num	if_mzsch.c	/^get_window_by_num(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_window_count	if_mzsch.c	/^get_window_count(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_window_height	if_mzsch.c	/^get_window_height(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_window_list	if_mzsch.c	/^get_window_list(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_window_num	if_mzsch.c	/^get_window_num(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_window_width	if_mzsch.c	/^get_window_width(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
get_winnr	eval.c	/^get_winnr(tp, argvar)$/;"	f	file:
get_winopts	buffer.c	/^get_winopts(buf)$/;"	f
get_wordnode	spell.c	/^get_wordnode(spin)$/;"	f	file:
get_x11_icon	os_unix.c	/^get_x11_icon(test_only)$/;"	f	file:
get_x11_thing	os_unix.c	/^get_x11_thing(get_title, test_only)$/;"	f	file:
get_x11_title	os_unix.c	/^get_x11_title(test_only)$/;"	f	file:
get_x11_windis	os_unix.c	/^get_x11_windis()$/;"	f	file:
get_yank_register	ops.c	/^get_yank_register(regname, writing)$/;"	f
getaltfname	buffer.c	/^getaltfname(errmsg)$/;"	f
getargcmd	ex_docmd.c	/^getargcmd(argp)$/;"	f	file:
getargopt	ex_docmd.c	/^getargopt(eap)$/;"	f	file:
getchr	regexp.c	/^getchr()$/;"	f	file:
getcmdline	ex_getln.c	/^getcmdline(firstc, count, indent)$/;"	f
getcmdline_prompt	ex_getln.c	/^getcmdline_prompt(firstc, prompt, attr, xp_context, xp_arg)$/;"	f
getcwd	vim.h	/^# define    getcwd /;"	d
getdecchrs	regexp.c	/^getdecchrs()$/;"	f	file:
getdigits	charset.c	/^getdigits(pp)$/;"	f
getdigraph	digraph.c	/^getdigraph(char1, char2, meta)$/;"	f
getent	termlib.c	/^getent(tbuf, term, termcap, buflen)$/;"	f	file:
getexactdigraph	digraph.c	/^getexactdigraph(char1, char2, meta)$/;"	f	file:
getexline	ex_getln.c	/^getexline(c, dummy, indent)$/;"	f
getexmodeline	ex_getln.c	/^getexmodeline(promptc, dummy, indent)$/;"	f
getfile	ex_cmds.c	/^getfile(fnum, ffname, sfname, setpm, lnum, forceit)$/;"	f
gethexchrs	regexp.c	/^gethexchrs(maxinputlen)$/;"	f	file:
gethostname	os_unix.c	/^#  define gethostname(/;"	d	file:
getline	ex_cmds.h	/^    char_u	*(*getline) __ARGS((int, void *, int));$/;"	m	struct:exarg
getline	ex_docmd.c	/^    char_u	*(*getline) __ARGS((int, void *, int));$/;"	m	struct:loop_cookie	file:
getline_cookie	ex_docmd.c	/^getline_cookie(fgetline, cookie)$/;"	f
getline_equal	ex_docmd.c	/^getline_equal(fgetline, cookie, func)$/;"	f
getlinecol	term.c	/^getlinecol(cp, rp)$/;"	f
getmark	mark.c	/^getmark(c, changefile)$/;"	f
getmark_fnum	mark.c	/^getmark_fnum(c, changefile, fnum)$/;"	f
getnextac	fileio.c	/^getnextac(c, cookie, indent)$/;"	f	file:
getnextcomp	misc1.c	/^getnextcomp(fname)$/;"	f
getnextmark	mark.c	/^getnextmark(startpos, dir, begin_line)$/;"	f
getoctchrs	regexp.c	/^getoctchrs()$/;"	f	file:
getout	main.c	/^getout(exitval)$/;"	f
getout_preserve_modified	main.c	/^getout_preserve_modified(exitval)$/;"	f
getroom	spell.c	/^getroom(spin, len, align)$/;"	f	file:
getroom_save	spell.c	/^getroom_save(spin, s)$/;"	f	file:
getsourceline	ex_cmds2.c	/^getsourceline(c, cookie, indent)$/;"	f
gettail	misc1.c	/^gettail(fname)$/;"	f
gettail_sep	misc1.c	/^gettail_sep(fname)$/;"	f
gettext_lang	ex_cmds2.c	/^gettext_lang(char_u *name)$/;"	f	file:
gettimeofday	main.c	/^gettimeofday(struct timeval *tv, char *dummy)$/;"	f
getvcol	charset.c	/^getvcol(wp, pos, start, cursor, end)$/;"	f
getvcol_nolist	charset.c	/^getvcol_nolist(posp)$/;"	f
getvcols	charset.c	/^getvcols(wp, pos1, pos2, left, right)$/;"	f
getviscol	misc2.c	/^getviscol()$/;"	f
getviscol2	misc2.c	/^getviscol2(col, coladd)$/;"	f
getvpos	misc2.c	/^getvpos(pos, wcol)$/;"	f
getvvcol	charset.c	/^getvvcol(wp, pos, start, cursor, end)$/;"	f
getvvcol	vim.h	/^# define getvvcol(/;"	d
getwinvar	eval.c	/^getwinvar(argvars, rettv, off)$/;"	f	file:
gfp_setname	gui.c	/^gfp_setname(fname, cookie)$/;"	f	file:
gint	gui_gtk_x11.c	/^# define gint /;"	d	file:
give_warning	message.c	/^give_warning(message, hl)$/;"	f
global_alist	globals.h	/^EXTERN alist_T	global_alist;	\/* global argument list *\/$/;"	v
global_busy	globals.h	/^EXTERN int	global_busy INIT(= 0);	    \/* set when :global is executing *\/$/;"	v
global_event_filter	gui_gtk_x11.c	/^global_event_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)$/;"	f	file:
global_exe	ex_cmds.c	/^global_exe(cmd)$/;"	f
global_need_beginline	ex_cmds.c	/^static int	global_need_beginline;	\/* call beginline() after ":g" *\/$/;"	v	file:
globaldir	globals.h	/^EXTERN char_u	*globaldir INIT(= NULL);$/;"	v
globalsignmap	netbeans.c	/^static char **globalsignmap;$/;"	v	file:
globalsignmaplen	netbeans.c	/^static int globalsignmaplen;$/;"	v	file:
globalsignmapused	netbeans.c	/^static int globalsignmapused;$/;"	v	file:
globpath	ex_getln.c	/^globpath(path, file)$/;"	f
globvardict	eval.c	/^static dict_T		globvardict;$/;"	v	file:
globvarht	eval.c	/^#define globvarht /;"	d	file:
globvars_var	eval.c	/^static dictitem_T	globvars_var;$/;"	v	file:
go_deeper	spell.c	/^go_deeper(stack, depth, score_add)$/;"	f	file:
goodi	spell.c	/^    int		goodi;$/;"	m	struct:__anon57	file:
got_code_from_term	term.c	/^got_code_from_term(code, len)$/;"	f	file:
got_int	ex_docmd.c	/^    int		got_int;$/;"	m	struct:dbg_stuff	file:
got_int	globals.h	/^EXTERN int	got_int INIT(= FALSE);	    \/* set to TRUE when interrupt$/;"	v
got_x_error	if_xcmdsrv.c	/^static int	got_x_error = FALSE;$/;"	v	file:
got_x_error	os_unix.c	/^static int	got_x_error = FALSE;$/;"	v	file:
gotchars	getchar.c	/^gotchars(chars, len)$/;"	f	file:
goto_buffer	buffer.c	/^goto_buffer(eap, start, dir, count)$/;"	f
goto_byte	memline.c	/^goto_byte(cnt)$/;"	f
goto_im	misc1.c	/^goto_im()$/;"	f
goto_tabpage	window.c	/^goto_tabpage(n)$/;"	f
goto_tabpage_tp	window.c	/^goto_tabpage_tp(tp)$/;"	f
goto_tabpage_win	window.c	/^goto_tabpage_win(tp, wp)$/;"	f
gotocmdline	ex_getln.c	/^gotocmdline(clr)$/;"	f
gpm_close	os_unix.c	/^gpm_close()$/;"	f	file:
gpm_open	os_unix.c	/^gpm_open()$/;"	f	file:
gpointer	gui_gtk.c	/^# define gpointer /;"	d	file:
gpointer	gui_gtk_x11.c	/^# define gpointer /;"	d	file:
grab_file_name	window.c	/^grab_file_name(count, file_lnum)$/;"	f
grep_internal	quickfix.c	/^grep_internal(cmdidx)$/;"	f
greyed_out	structs.h	/^    int		greyed_out;	    \/* Flag *\/$/;"	m	struct:VimMenu
group	fileio.c	/^    int		    group;		\/* group ID *\/$/;"	m	struct:AutoPat	file:
group	fileio.c	/^    int		group;		\/* group being used *\/$/;"	m	struct:AutoPatCmd	file:
growarray	structs.h	/^typedef struct growarray$/;"	s
gtk_form_attach_child_window	gui_gtk_f.c	/^gtk_form_attach_child_window(GtkForm *form, GtkFormChild *child)$/;"	f	file:
gtk_form_child_map	gui_gtk_f.c	/^gtk_form_child_map(GtkWidget *widget, gpointer user_data)$/;"	f	file:
gtk_form_child_unmap	gui_gtk_f.c	/^gtk_form_child_unmap(GtkWidget *widget, gpointer user_data)$/;"	f	file:
gtk_form_class_init	gui_gtk_f.c	/^gtk_form_class_init(GtkFormClass *klass)$/;"	f	file:
gtk_form_draw	gui_gtk_f.c	/^gtk_form_draw(GtkWidget *widget, GdkRectangle *area)$/;"	f	file:
gtk_form_expose	gui_gtk_f.c	/^gtk_form_expose(GtkWidget *widget, GdkEventExpose *event)$/;"	f	file:
gtk_form_filter	gui_gtk_f.c	/^gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)$/;"	f	file:
gtk_form_forall	gui_gtk_f.c	/^gtk_form_forall(GtkContainer	*container,$/;"	f	file:
gtk_form_freeze	gui_gtk_f.c	/^gtk_form_freeze(GtkForm *form)$/;"	f
gtk_form_get_type	gui_gtk_f.c	/^gtk_form_get_type(void)$/;"	f
gtk_form_init	gui_gtk_f.c	/^gtk_form_init(GtkForm *form)$/;"	f	file:
gtk_form_main_filter	gui_gtk_f.c	/^gtk_form_main_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)$/;"	f	file:
gtk_form_map	gui_gtk_f.c	/^gtk_form_map(GtkWidget *widget)$/;"	f	file:
gtk_form_move	gui_gtk_f.c	/^gtk_form_move(GtkForm	*form,$/;"	f
gtk_form_move_resize	gui_gtk_f.c	/^gtk_form_move_resize(GtkForm *form, GtkWidget *widget,$/;"	f
gtk_form_new	gui_gtk_f.c	/^gtk_form_new(void)$/;"	f
gtk_form_position_child	gui_gtk_f.c	/^gtk_form_position_child(GtkForm *form, GtkFormChild *child,$/;"	f	file:
gtk_form_position_children	gui_gtk_f.c	/^gtk_form_position_children(GtkForm *form)$/;"	f	file:
gtk_form_put	gui_gtk_f.c	/^gtk_form_put(GtkForm	*form,$/;"	f
gtk_form_realize	gui_gtk_f.c	/^gtk_form_realize(GtkWidget *widget)$/;"	f	file:
gtk_form_realize_child	gui_gtk_f.c	/^gtk_form_realize_child(GtkForm *form, GtkFormChild *child)$/;"	f	file:
gtk_form_remove	gui_gtk_f.c	/^gtk_form_remove(GtkContainer *container, GtkWidget *widget)$/;"	f	file:
gtk_form_send_configure	gui_gtk_f.c	/^gtk_form_send_configure(GtkForm *form)$/;"	f	file:
gtk_form_set_size	gui_gtk_f.c	/^gtk_form_set_size(GtkForm *form, guint width, guint height)$/;"	f
gtk_form_set_static_gravity	gui_gtk_f.c	/^gtk_form_set_static_gravity(GdkWindow *window, gboolean use_static)$/;"	f	file:
gtk_form_size_allocate	gui_gtk_f.c	/^gtk_form_size_allocate(GtkWidget *widget, GtkAllocation *allocation)$/;"	f	file:
gtk_form_size_request	gui_gtk_f.c	/^gtk_form_size_request(GtkWidget *widget, GtkRequisition *requisition)$/;"	f	file:
gtk_form_thaw	gui_gtk_f.c	/^gtk_form_thaw(GtkForm *form)$/;"	f
gtk_form_unrealize	gui_gtk_f.c	/^gtk_form_unrealize(GtkWidget *widget)$/;"	f	file:
gtk_sel_atom	vim.h	/^    GdkAtom     gtk_sel_atom;	\/* PRIMARY\/CLIPBOARD selection ID *\/$/;"	m	struct:VimClipboard
gtk_socket_id	globals.h	/^EXTERN guint32	gtk_socket_id INIT(= 0);$/;"	v
gui	gui.c	/^gui_T gui;$/;"	v
gui	structs.h	/^	} gui;$/;"	m	union:attr_entry::__anon86	typeref:struct:attr_entry::__anon86::__anon89
gui_T	gui.h	/^} gui_T;$/;"	t	typeref:struct:Gui
gui_add_tearoff	menu.c	/^gui_add_tearoff(tearpath, pri_tab, pri_idx)$/;"	f	file:
gui_argc	gui_gtk_x11.c	/^static int    gui_argc = 0;$/;"	v	file:
gui_argc	gui_x11.c	/^static int gui_argc = 0;$/;"	v	file:
gui_argv	gui_gtk_x11.c	/^static char **gui_argv = NULL;$/;"	v	file:
gui_argv	gui_x11.c	/^static char **gui_argv = NULL;$/;"	v	file:
gui_athena_create_pullright_pixmap	gui_athena.c	/^gui_athena_create_pullright_pixmap(w)$/;"	f	file:
gui_athena_delayed_arm_action	gui_athena.c	/^gui_athena_delayed_arm_action(w, event, args, nargs)$/;"	f	file:
gui_athena_menu_colors	gui_athena.c	/^gui_athena_menu_colors(id)$/;"	f	file:
gui_athena_menu_font	gui_athena.c	/^gui_athena_menu_font(id)$/;"	f	file:
gui_athena_menu_has_submenus	gui_athena.c	/^gui_athena_menu_has_submenus(id, ignore)$/;"	f	file:
gui_athena_menu_timeout	gui_athena.c	/^gui_athena_menu_timeout(client_data, id)$/;"	f	file:
gui_athena_popdown_submenus_action	gui_athena.c	/^gui_athena_popdown_submenus_action(w, event, args, nargs)$/;"	f	file:
gui_athena_popup_callback	gui_athena.c	/^gui_athena_popup_callback(w, client_data, call_data)$/;"	f	file:
gui_athena_scroll_cb_jump	gui_athena.c	/^gui_athena_scroll_cb_jump(w, client_data, call_data)$/;"	f	file:
gui_athena_scroll_cb_scroll	gui_athena.c	/^gui_athena_scroll_cb_scroll(w, client_data, call_data)$/;"	f	file:
gui_athena_scroll_colors	gui_athena.c	/^gui_athena_scroll_colors(id)$/;"	f	file:
gui_attr_table	syntax.c	/^static garray_T	gui_attr_table = {0, 0, 0, 0, NULL};$/;"	v	file:
gui_bg_default	option.c	/^gui_bg_default()$/;"	f	file:
gui_can_update_cursor	gui.c	/^gui_can_update_cursor()$/;"	f
gui_check_colors	gui.c	/^gui_check_colors()$/;"	f
gui_check_pos	gui.c	/^gui_check_pos()$/;"	f	file:
gui_clear_block	gui.c	/^gui_clear_block(row1, col1, row2, col2)$/;"	f
gui_create_initial_menus	menu.c	/^gui_create_initial_menus(menu)$/;"	f
gui_create_scrollbar	gui.c	/^gui_create_scrollbar(sb, type, wp)$/;"	f
gui_create_tearoffs_recurse	menu.c	/^gui_create_tearoffs_recurse(menu, pname, pri_tab, pri_idx)$/;"	f	file:
gui_delete_lines	gui.c	/^gui_delete_lines(row, count)$/;"	f	file:
gui_destroy_tearoffs_recurse	menu.c	/^gui_destroy_tearoffs_recurse(menu)$/;"	f	file:
gui_do_findrepl	gui.c	/^gui_do_findrepl(flags, find_text, repl_text, down)$/;"	f
gui_do_horiz_scroll	gui.c	/^gui_do_horiz_scroll()$/;"	f
gui_do_one_color	syntax.c	/^gui_do_one_color(idx, do_menu, do_tooltip)$/;"	f	file:
gui_do_scroll	gui.c	/^gui_do_scroll()$/;"	f
gui_do_scrollbar	gui.c	/^gui_do_scrollbar(wp, which, enable)$/;"	f	file:
gui_dont_update_cursor	gui.c	/^gui_dont_update_cursor()$/;"	f
gui_drag_scrollbar	gui.c	/^gui_drag_scrollbar(sb, value, still_dragging)$/;"	f
gui_exit	gui.c	/^gui_exit(rc)$/;"	f
gui_find_bitmap	gui.c	/^gui_find_bitmap(name, buffer, ext)$/;"	f
gui_find_iconfile	gui.c	/^gui_find_iconfile(name, buffer, ext)$/;"	f
gui_find_menu	menu.c	/^gui_find_menu(path_name)$/;"	f
gui_find_scrollbar	gui.c	/^gui_find_scrollbar(ident)$/;"	f
gui_focus_change	gui.c	/^gui_focus_change(in_focus)$/;"	f
gui_get_base_height	gui.c	/^gui_get_base_height()$/;"	f
gui_get_base_width	gui.c	/^gui_get_base_width()$/;"	f
gui_get_color	gui.c	/^gui_get_color(name)$/;"	f
gui_get_lightness	gui.c	/^gui_get_lightness(pixel)$/;"	f
gui_get_shellsize	gui.c	/^gui_get_shellsize()$/;"	f
gui_get_wide_font	gui.c	/^gui_get_wide_font()$/;"	f
gui_get_x11_windis	gui_gtk_x11.c	/^gui_get_x11_windis(Window *win, Display **dis)$/;"	f
gui_get_x11_windis	gui_x11.c	/^gui_get_x11_windis(win, dis)$/;"	f
gui_gnome_dialog	gui_gtk.c	/^gui_gnome_dialog( int	type,$/;"	f	file:
gui_gtk2_draw_string	gui_gtk_x11.c	/^gui_gtk2_draw_string(int row, int col, char_u *s, int len, int flags)$/;"	f
gui_gtk_position_in_parent	gui_gtk.c	/^gui_gtk_position_in_parent($/;"	f	file:
gui_gtk_register_stock_icons	gui_gtk.c	/^gui_gtk_register_stock_icons(void)$/;"	f
gui_gtk_set_mnemonics	gui_gtk.c	/^gui_gtk_set_mnemonics(int enable)$/;"	f
gui_gtk_synch_fonts	gui_gtk.c	/^gui_gtk_synch_fonts(void)$/;"	f
gui_handle_drop	gui.c	/^gui_handle_drop(x, y, modifiers, fnames, count)$/;"	f
gui_has_tabline	gui.c	/^gui_has_tabline()$/;"	f	file:
gui_init	gui.c	/^gui_init()$/;"	f
gui_init_check	gui.c	/^gui_init_check()$/;"	f
gui_init_font	gui.c	/^gui_init_font(font_list, fontset)$/;"	f
gui_init_menu_font	gui_x11.c	/^gui_init_menu_font()$/;"	f
gui_init_tooltip_font	gui_x11.c	/^gui_init_tooltip_font()$/;"	f
gui_init_which_components	gui.c	/^gui_init_which_components(oldval)$/;"	f
gui_insert_lines	gui.c	/^gui_insert_lines(row, count)$/;"	f	file:
gui_is_menu_shortcut	menu.c	/^gui_is_menu_shortcut(key)$/;"	f
gui_make_popup	gui_gtk.c	/^gui_make_popup(char_u *path_name, int mouse_pos)$/;"	f
gui_may_resize_shell	gui.c	/^gui_may_resize_shell()$/;"	f
gui_mch_add_menu	gui_athena.c	/^gui_mch_add_menu(menu, idx)$/;"	f
gui_mch_add_menu	gui_gtk.c	/^gui_mch_add_menu(vimmenu_T *menu, int idx)$/;"	f
gui_mch_add_menu	gui_motif.c	/^gui_mch_add_menu(menu, idx)$/;"	f
gui_mch_add_menu_item	gui_athena.c	/^gui_mch_add_menu_item(menu, idx)$/;"	f
gui_mch_add_menu_item	gui_gtk.c	/^gui_mch_add_menu_item(vimmenu_T *menu, int idx)$/;"	f
gui_mch_add_menu_item	gui_motif.c	/^gui_mch_add_menu_item(menu, idx)$/;"	f
gui_mch_adjust_charheight	gui_gtk_x11.c	/^gui_mch_adjust_charheight(void)$/;"	f
gui_mch_adjust_charheight	gui_x11.c	/^gui_mch_adjust_charheight()$/;"	f
gui_mch_beep	gui_gtk_x11.c	/^gui_mch_beep(void)$/;"	f
gui_mch_beep	gui_x11.c	/^gui_mch_beep()$/;"	f
gui_mch_browse	gui_athena.c	/^gui_mch_browse(saving, title, dflt, ext, initdir, filter)$/;"	f
gui_mch_browse	gui_gtk.c	/^gui_mch_browse(int saving,$/;"	f
gui_mch_browse	gui_motif.c	/^gui_mch_browse(saving, title, dflt, ext, initdir, filter)$/;"	f
gui_mch_browsedir	gui_gtk.c	/^gui_mch_browsedir($/;"	f
gui_mch_clear_all	gui_gtk_x11.c	/^gui_mch_clear_all(void)$/;"	f
gui_mch_clear_all	gui_x11.c	/^gui_mch_clear_all()$/;"	f
gui_mch_clear_block	gui_gtk_x11.c	/^gui_mch_clear_block(int row1, int col1, int row2, int col2)$/;"	f
gui_mch_clear_block	gui_x11.c	/^gui_mch_clear_block(row1, col1, row2, col2)$/;"	f
gui_mch_compute_footer_height	gui_motif.c	/^gui_mch_compute_footer_height()$/;"	f	file:
gui_mch_compute_menu_height	gui_motif.c	/^gui_mch_compute_menu_height(id)$/;"	f
gui_mch_compute_toolbar_height	gui_athena.c	/^gui_mch_compute_toolbar_height()$/;"	f
gui_mch_compute_toolbar_height	gui_motif.c	/^gui_mch_compute_toolbar_height()$/;"	f
gui_mch_create_beval_area	gui_beval.c	/^gui_mch_create_beval_area(target, mesg, mesgCB, clientData)$/;"	f
gui_mch_create_scrollbar	gui_athena.c	/^gui_mch_create_scrollbar(sb, orient)$/;"	f
gui_mch_create_scrollbar	gui_gtk.c	/^gui_mch_create_scrollbar(scrollbar_T *sb, int orient)$/;"	f
gui_mch_create_scrollbar	gui_motif.c	/^gui_mch_create_scrollbar(sb, orient)$/;"	f
gui_mch_currently_showing_beval	gui_beval.c	/^gui_mch_currently_showing_beval()$/;"	f
gui_mch_def_colors	gui_athena.c	/^gui_mch_def_colors()$/;"	f
gui_mch_def_colors	gui_motif.c	/^gui_mch_def_colors()$/;"	f
gui_mch_delete_lines	gui_gtk_x11.c	/^gui_mch_delete_lines(int row, int num_lines)$/;"	f
gui_mch_delete_lines	gui_x11.c	/^gui_mch_delete_lines(row, num_lines)$/;"	f
gui_mch_destroy_beval_area	gui_beval.c	/^gui_mch_destroy_beval_area(beval)$/;"	f
gui_mch_destroy_menu	gui_athena.c	/^gui_mch_destroy_menu(menu)$/;"	f
gui_mch_destroy_menu	gui_gtk.c	/^gui_mch_destroy_menu(vimmenu_T *menu)$/;"	f
gui_mch_destroy_menu	gui_motif.c	/^gui_mch_destroy_menu(menu)$/;"	f
gui_mch_destroy_scrollbar	gui_athena.c	/^gui_mch_destroy_scrollbar(sb)$/;"	f
gui_mch_destroy_scrollbar	gui_gtk.c	/^gui_mch_destroy_scrollbar(scrollbar_T *sb)$/;"	f
gui_mch_destroy_scrollbar	gui_motif.c	/^gui_mch_destroy_scrollbar(sb)$/;"	f
gui_mch_destroy_sign	gui_gtk_x11.c	/^gui_mch_destroy_sign(void *sign)$/;"	f
gui_mch_destroy_sign	gui_x11.c	/^gui_mch_destroy_sign(sign)$/;"	f
gui_mch_dialog	gui_athena.c	/^gui_mch_dialog(type, title, message, buttons, dfltbutton, textfield)$/;"	f
gui_mch_dialog	gui_gtk.c	/^gui_mch_dialog(	int	type,		\/* type of dialog *\/$/;"	f
gui_mch_dialog	gui_gtk.c	/^gui_mch_dialog(int	type,	    \/* type of dialog *\/$/;"	f
gui_mch_dialog	gui_motif.c	/^gui_mch_dialog(type, title, message, button_names, dfltbutton, textfield)$/;"	f
gui_mch_disable_beval_area	gui_beval.c	/^gui_mch_disable_beval_area(beval)$/;"	f
gui_mch_draw_hollow_cursor	gui_gtk_x11.c	/^gui_mch_draw_hollow_cursor(guicolor_T color)$/;"	f
gui_mch_draw_hollow_cursor	gui_x11.c	/^gui_mch_draw_hollow_cursor(color)$/;"	f
gui_mch_draw_menubar	gui_gtk_x11.c	/^gui_mch_draw_menubar(void)$/;"	f
gui_mch_draw_menubar	gui_x11.c	/^gui_mch_draw_menubar()$/;"	f
gui_mch_draw_part_cursor	gui_gtk_x11.c	/^gui_mch_draw_part_cursor(int w, int h, guicolor_T color)$/;"	f
gui_mch_draw_part_cursor	gui_x11.c	/^gui_mch_draw_part_cursor(w, h, color)$/;"	f
gui_mch_draw_string	gui_gtk_x11.c	/^gui_mch_draw_string(int row, int col, char_u *s, int len, int flags)$/;"	f
gui_mch_draw_string	gui_x11.c	/^gui_mch_draw_string(row, col, s, len, flags)$/;"	f
gui_mch_drawsign	gui_gtk_x11.c	/^gui_mch_drawsign(int row, int col, int typenr)$/;"	f
gui_mch_drawsign	gui_x11.c	/^gui_mch_drawsign(row, col, typenr)$/;"	f
gui_mch_enable_beval_area	gui_beval.c	/^gui_mch_enable_beval_area(beval)$/;"	f
gui_mch_enable_footer	gui_motif.c	/^gui_mch_enable_footer(showit)$/;"	f
gui_mch_enable_menu	gui_athena.c	/^gui_mch_enable_menu(flag)$/;"	f
gui_mch_enable_menu	gui_gtk_x11.c	/^gui_mch_enable_menu(int showit)$/;"	f
gui_mch_enable_menu	gui_motif.c	/^gui_mch_enable_menu(flag)$/;"	f
gui_mch_enable_scrollbar	gui_athena.c	/^gui_mch_enable_scrollbar(sb, flag)$/;"	f
gui_mch_enable_scrollbar	gui_gtk_x11.c	/^gui_mch_enable_scrollbar(scrollbar_T *sb, int flag)$/;"	f
gui_mch_enable_scrollbar	gui_motif.c	/^gui_mch_enable_scrollbar(sb, flag)$/;"	f
gui_mch_exit	gui_gtk_x11.c	/^gui_mch_exit(int rc)$/;"	f
gui_mch_exit	gui_x11.c	/^gui_mch_exit(rc)$/;"	f
gui_mch_find_dialog	ex_docmd.c	/^# define gui_mch_find_dialog	/;"	d	file:
gui_mch_find_dialog	gui_gtk.c	/^gui_mch_find_dialog(exarg_T *eap)$/;"	f
gui_mch_find_dialog	gui_motif.c	/^gui_mch_find_dialog(eap)$/;"	f
gui_mch_flash	gui_gtk_x11.c	/^gui_mch_flash(int msec)$/;"	f
gui_mch_flash	gui_x11.c	/^gui_mch_flash(msec)$/;"	f
gui_mch_flush	gui_gtk_x11.c	/^gui_mch_flush(void)$/;"	f
gui_mch_flush	gui_x11.c	/^gui_mch_flush()$/;"	f
gui_mch_font_dialog	gui_gtk_x11.c	/^gui_mch_font_dialog(char_u *oldval)$/;"	f
gui_mch_forked	gui_gtk_x11.c	/^gui_mch_forked(void)$/;"	f
gui_mch_free_all	gui_gtk_x11.c	/^gui_mch_free_all()$/;"	f
gui_mch_free_font	gui_gtk_x11.c	/^gui_mch_free_font(GuiFont font)$/;"	f
gui_mch_free_font	gui_x11.c	/^gui_mch_free_font(font)$/;"	f
gui_mch_free_fontset	gui_gtk_x11.c	/^gui_mch_free_fontset(GuiFontset fontset)$/;"	f
gui_mch_free_fontset	gui_x11.c	/^gui_mch_free_fontset(fontset)$/;"	f
gui_mch_get_color	gui_gtk_x11.c	/^gui_mch_get_color(char_u *name)$/;"	f
gui_mch_get_color	gui_x11.c	/^gui_mch_get_color(reqname)$/;"	f
gui_mch_get_display	gui_gtk_x11.c	/^gui_mch_get_display(void)$/;"	f
gui_mch_get_font	gui_gtk_x11.c	/^gui_mch_get_font(char_u *name, int report_error)$/;"	f
gui_mch_get_font	gui_x11.c	/^gui_mch_get_font(name, giveErrorIfMissing)$/;"	f
gui_mch_get_fontname	gui_gtk_x11.c	/^gui_mch_get_fontname(GuiFont font, char_u *name)$/;"	f
gui_mch_get_fontname	gui_x11.c	/^gui_mch_get_fontname(font, name)$/;"	f
gui_mch_get_fontset	gui_gtk_x11.c	/^gui_mch_get_fontset(char_u *name, int report_error, int fixed_width)$/;"	f
gui_mch_get_fontset	gui_x11.c	/^gui_mch_get_fontset(name, giveErrorIfMissing, fixed_width)$/;"	f
gui_mch_get_rgb	gui_gtk_x11.c	/^gui_mch_get_rgb(guicolor_T pixel)$/;"	f
gui_mch_get_rgb	gui_x11.c	/^gui_mch_get_rgb(pixel)$/;"	f
gui_mch_get_screen_dimensions	gui_gtk_x11.c	/^gui_mch_get_screen_dimensions(int *screen_w, int *screen_h)$/;"	f
gui_mch_get_screen_dimensions	gui_x11.c	/^gui_mch_get_screen_dimensions(screen_w, screen_h)$/;"	f
gui_mch_get_toolbar_colors	gui_athena.c	/^gui_mch_get_toolbar_colors(bgp, fgp, bsp, tsp, hsp)$/;"	f
gui_mch_get_winpos	gui_gtk_x11.c	/^gui_mch_get_winpos(int *x, int *y)$/;"	f
gui_mch_get_winpos	gui_x11.c	/^gui_mch_get_winpos(x, y)$/;"	f
gui_mch_getmouse	gui_gtk_x11.c	/^gui_mch_getmouse(int *x, int *y)$/;"	f
gui_mch_getmouse	gui_x11.c	/^gui_mch_getmouse(int *x, int *y)$/;"	f
gui_mch_haskey	gui_gtk_x11.c	/^gui_mch_haskey(char_u *name)$/;"	f
gui_mch_haskey	gui_x11.c	/^gui_mch_haskey(name)$/;"	f
gui_mch_iconify	gui_gtk_x11.c	/^gui_mch_iconify(void)$/;"	f
gui_mch_iconify	gui_x11.c	/^gui_mch_iconify()$/;"	f
gui_mch_init	gui_gtk_x11.c	/^gui_mch_init(void)$/;"	f
gui_mch_init	gui_x11.c	/^gui_mch_init()$/;"	f
gui_mch_init_check	gui_gtk_x11.c	/^gui_mch_init_check(void)$/;"	f
gui_mch_init_check	gui_x11.c	/^gui_mch_init_check()$/;"	f
gui_mch_init_font	gui_gtk_x11.c	/^gui_mch_init_font(char_u *font_name, int fontset)$/;"	f
gui_mch_init_font	gui_x11.c	/^gui_mch_init_font(font_name, do_fontset)$/;"	f
gui_mch_insert_lines	gui_gtk_x11.c	/^gui_mch_insert_lines(int row, int num_lines)$/;"	f
gui_mch_insert_lines	gui_x11.c	/^gui_mch_insert_lines(row, num_lines)$/;"	f
gui_mch_invert_rectangle	gui_gtk_x11.c	/^gui_mch_invert_rectangle(int r, int c, int nr, int nc)$/;"	f
gui_mch_invert_rectangle	gui_x11.c	/^gui_mch_invert_rectangle(r, c, nr, nc)$/;"	f
gui_mch_menu_grey	gui_gtk_x11.c	/^gui_mch_menu_grey(vimmenu_T *menu, int grey)$/;"	f
gui_mch_menu_grey	gui_x11.c	/^gui_mch_menu_grey(menu, grey)$/;"	f
gui_mch_menu_hidden	gui_gtk_x11.c	/^gui_mch_menu_hidden(vimmenu_T *menu, int hidden)$/;"	f
gui_mch_menu_hidden	gui_x11.c	/^gui_mch_menu_hidden(menu, hidden)$/;"	f
gui_mch_menu_set_tip	gui_gtk.c	/^gui_mch_menu_set_tip(vimmenu_T *menu)$/;"	f
gui_mch_menu_set_tip	gui_x11.c	/^gui_mch_menu_set_tip(menu)$/;"	f
gui_mch_mousehide	gui_gtk_x11.c	/^gui_mch_mousehide(int hide)$/;"	f
gui_mch_mousehide	gui_x11.c	/^gui_mch_mousehide(hide)$/;"	f
gui_mch_new_colors	gui_gtk_x11.c	/^gui_mch_new_colors(void)$/;"	f
gui_mch_new_colors	gui_x11.c	/^gui_mch_new_colors()$/;"	f
gui_mch_new_menu_colors	gui_athena.c	/^gui_mch_new_menu_colors()$/;"	f
gui_mch_new_menu_colors	gui_motif.c	/^gui_mch_new_menu_colors()$/;"	f
gui_mch_new_menu_font	gui_athena.c	/^gui_mch_new_menu_font()$/;"	f
gui_mch_new_menu_font	gui_motif.c	/^gui_mch_new_menu_font()$/;"	f
gui_mch_new_tooltip_colors	gui_athena.c	/^gui_mch_new_tooltip_colors()$/;"	f
gui_mch_new_tooltip_colors	gui_motif.c	/^gui_mch_new_tooltip_colors()$/;"	f
gui_mch_new_tooltip_font	gui_athena.c	/^gui_mch_new_tooltip_font()$/;"	f
gui_mch_new_tooltip_font	gui_motif.c	/^gui_mch_new_tooltip_font()$/;"	f
gui_mch_open	gui_gtk_x11.c	/^gui_mch_open(void)$/;"	f
gui_mch_open	gui_x11.c	/^gui_mch_open()$/;"	f
gui_mch_post_balloon	gui_beval.c	/^gui_mch_post_balloon(beval, mesg)$/;"	f
gui_mch_prepare	gui_gtk_x11.c	/^gui_mch_prepare(int *argc, char **argv)$/;"	f
gui_mch_prepare	gui_x11.c	/^gui_mch_prepare(argc, argv)$/;"	f
gui_mch_recurse_tearoffs	gui_motif.c	/^gui_mch_recurse_tearoffs(menu)$/;"	f	file:
gui_mch_register_sign	gui_gtk_x11.c	/^gui_mch_register_sign(char_u *signfile)$/;"	f
gui_mch_register_sign	gui_x11.c	/^gui_mch_register_sign(signfile)$/;"	f
gui_mch_replace_dialog	ex_docmd.c	/^# define gui_mch_replace_dialog /;"	d	file:
gui_mch_replace_dialog	gui_gtk.c	/^gui_mch_replace_dialog(exarg_T *eap)$/;"	f
gui_mch_replace_dialog	gui_motif.c	/^gui_mch_replace_dialog(eap)$/;"	f
gui_mch_reset_focus	gui_athena.c	/^gui_mch_reset_focus()$/;"	f	file:
gui_mch_set_bg_color	gui_gtk_x11.c	/^gui_mch_set_bg_color(guicolor_T color)$/;"	f
gui_mch_set_bg_color	gui_x11.c	/^gui_mch_set_bg_color(color)$/;"	f
gui_mch_set_blinking	gui_gtk_x11.c	/^gui_mch_set_blinking(long waittime, long on, long off)$/;"	f
gui_mch_set_blinking	gui_x11.c	/^gui_mch_set_blinking(waittime, on, off)$/;"	f
gui_mch_set_curtab	gui_gtk_x11.c	/^gui_mch_set_curtab(nr)$/;"	f
gui_mch_set_curtab	gui_motif.c	/^gui_mch_set_curtab(nr)$/;"	f
gui_mch_set_fg_color	gui_gtk_x11.c	/^gui_mch_set_fg_color(guicolor_T color)$/;"	f
gui_mch_set_fg_color	gui_x11.c	/^gui_mch_set_fg_color(color)$/;"	f
gui_mch_set_font	gui_gtk_x11.c	/^gui_mch_set_font(GuiFont font)$/;"	f
gui_mch_set_font	gui_x11.c	/^gui_mch_set_font(font)$/;"	f
gui_mch_set_fontset	gui_gtk_x11.c	/^gui_mch_set_fontset(GuiFontset fontset)$/;"	f
gui_mch_set_fontset	gui_x11.c	/^gui_mch_set_fontset(fontset)$/;"	f
gui_mch_set_footer	gui_motif.c	/^gui_mch_set_footer(s)$/;"	f
gui_mch_set_foreground	gui_gtk_x11.c	/^gui_mch_set_foreground(void)$/;"	f
gui_mch_set_foreground	gui_x11.c	/^gui_mch_set_foreground()$/;"	f
gui_mch_set_menu_pos	gui_athena.c	/^gui_mch_set_menu_pos(x, y, w, h)$/;"	f
gui_mch_set_scrollbar_colors	gui_athena.c	/^gui_mch_set_scrollbar_colors(sb)$/;"	f
gui_mch_set_scrollbar_colors	gui_motif.c	/^gui_mch_set_scrollbar_colors(sb)$/;"	f
gui_mch_set_scrollbar_pos	gui_athena.c	/^gui_mch_set_scrollbar_pos(sb, x, y, w, h)$/;"	f
gui_mch_set_scrollbar_pos	gui_gtk.c	/^gui_mch_set_scrollbar_pos(scrollbar_T *sb, int x, int y, int w, int h)$/;"	f
gui_mch_set_scrollbar_pos	gui_motif.c	/^gui_mch_set_scrollbar_pos(sb, x, y, w, h)$/;"	f
gui_mch_set_scrollbar_thumb	gui_athena.c	/^gui_mch_set_scrollbar_thumb(sb, val, size, max)$/;"	f
gui_mch_set_scrollbar_thumb	gui_gtk.c	/^gui_mch_set_scrollbar_thumb(scrollbar_T *sb, long val, long size, long max)$/;"	f
gui_mch_set_scrollbar_thumb	gui_motif.c	/^gui_mch_set_scrollbar_thumb(sb, val, size, max)$/;"	f
gui_mch_set_shellsize	gui_gtk_x11.c	/^gui_mch_set_shellsize(int width, int height,$/;"	f
gui_mch_set_shellsize	gui_x11.c	/^gui_mch_set_shellsize(width, height, min_width, min_height,$/;"	f
gui_mch_set_sp_color	gui_gtk_x11.c	/^gui_mch_set_sp_color(guicolor_T color)$/;"	f
gui_mch_set_sp_color	gui_x11.c	/^gui_mch_set_sp_color(color)$/;"	f
gui_mch_set_text_area_pos	gui_athena.c	/^gui_mch_set_text_area_pos(x, y, w, h)$/;"	f
gui_mch_set_text_area_pos	gui_gtk.c	/^gui_mch_set_text_area_pos(int x, int y, int w, int h)$/;"	f
gui_mch_set_text_area_pos	gui_motif.c	/^gui_mch_set_text_area_pos(x, y, w, h)$/;"	f
gui_mch_set_toolbar_pos	gui_athena.c	/^gui_mch_set_toolbar_pos(x, y, w, h)$/;"	f
gui_mch_set_winpos	gui_gtk_x11.c	/^gui_mch_set_winpos(int x, int y)$/;"	f
gui_mch_set_winpos	gui_x11.c	/^gui_mch_set_winpos(x, y)$/;"	f
gui_mch_setmouse	gui_gtk_x11.c	/^gui_mch_setmouse(int x, int y)$/;"	f
gui_mch_setmouse	gui_x11.c	/^gui_mch_setmouse(x, y)$/;"	f
gui_mch_settitle	gui_gtk_x11.c	/^gui_mch_settitle(char_u *title, char_u *icon)$/;"	f
gui_mch_show_popupmenu	gui_athena.c	/^gui_mch_show_popupmenu(menu)$/;"	f
gui_mch_show_popupmenu	gui_gtk.c	/^gui_mch_show_popupmenu(vimmenu_T *menu)$/;"	f
gui_mch_show_popupmenu	gui_motif.c	/^gui_mch_show_popupmenu(menu)$/;"	f
gui_mch_show_tabline	gui_gtk_x11.c	/^gui_mch_show_tabline(int showit)$/;"	f
gui_mch_show_tabline	gui_motif.c	/^gui_mch_show_tabline(int showit)$/;"	f
gui_mch_show_toolbar	gui_athena.c	/^gui_mch_show_toolbar(int showit)$/;"	f
gui_mch_show_toolbar	gui_gtk_x11.c	/^gui_mch_show_toolbar(int showit)$/;"	f
gui_mch_show_toolbar	gui_motif.c	/^gui_mch_show_toolbar(int showit)$/;"	f
gui_mch_showing_tabline	gui_gtk_x11.c	/^gui_mch_showing_tabline(void)$/;"	f
gui_mch_showing_tabline	gui_motif.c	/^gui_mch_showing_tabline(void)$/;"	f
gui_mch_start_blink	gui_gtk_x11.c	/^gui_mch_start_blink(void)$/;"	f
gui_mch_start_blink	gui_x11.c	/^gui_mch_start_blink()$/;"	f
gui_mch_stop_blink	gui_gtk_x11.c	/^gui_mch_stop_blink(void)$/;"	f
gui_mch_stop_blink	gui_x11.c	/^gui_mch_stop_blink()$/;"	f
gui_mch_submenu_change	gui_athena.c	/^gui_mch_submenu_change(menu, colors)$/;"	f	file:
gui_mch_text_area_extra_height	gui_motif.c	/^gui_mch_text_area_extra_height()$/;"	f
gui_mch_toggle_tearoffs	gui_athena.c	/^gui_mch_toggle_tearoffs(enable)$/;"	f
gui_mch_toggle_tearoffs	gui_gtk.c	/^gui_mch_toggle_tearoffs(int enable)$/;"	f
gui_mch_toggle_tearoffs	gui_motif.c	/^gui_mch_toggle_tearoffs(enable)$/;"	f
gui_mch_toggle_tearoffs	menu.c	/^gui_mch_toggle_tearoffs(int enable)$/;"	f
gui_mch_uninit	gui_x11.c	/^gui_mch_uninit()$/;"	f
gui_mch_unpost_balloon	gui_beval.c	/^gui_mch_unpost_balloon(beval)$/;"	f
gui_mch_update	gui_gtk_x11.c	/^gui_mch_update(void)$/;"	f
gui_mch_update	gui_x11.c	/^gui_mch_update()$/;"	f
gui_mch_update_tabline	gui_gtk_x11.c	/^gui_mch_update_tabline(void)$/;"	f
gui_mch_update_tabline	gui_motif.c	/^gui_mch_update_tabline(void)$/;"	f
gui_mch_wait_for_chars	gui_gtk_x11.c	/^gui_mch_wait_for_chars(long wtime)$/;"	f
gui_mch_wait_for_chars	gui_x11.c	/^gui_mch_wait_for_chars(wtime)$/;"	f
gui_menu_cb	gui.c	/^gui_menu_cb(menu)$/;"	f
gui_motif_add_actext	gui_motif.c	/^gui_motif_add_actext(menu)$/;"	f	file:
gui_motif_create_fontlist	gui_motif.c	/^gui_motif_create_fontlist(font)$/;"	f
gui_motif_fontset2fontlist	gui_motif.c	/^gui_motif_fontset2fontlist(fontset)$/;"	f
gui_motif_menu_colors	gui_motif.c	/^gui_motif_menu_colors(id)$/;"	f	file:
gui_motif_menu_fontlist	gui_motif.c	/^gui_motif_menu_fontlist(id)$/;"	f
gui_motif_scroll_colors	gui_motif.c	/^gui_motif_scroll_colors(id)$/;"	f	file:
gui_motif_set_mnemonics	gui_motif.c	/^gui_motif_set_mnemonics(enable)$/;"	f
gui_motif_synch_fonts	gui_motif.c	/^gui_motif_synch_fonts(void)$/;"	f
gui_motif_update_mousemodel	gui_motif.c	/^gui_motif_update_mousemodel(menu)$/;"	f
gui_mouse_correct	gui.c	/^gui_mouse_correct()$/;"	f
gui_mouse_moved	gui.c	/^gui_mouse_moved(x, y)$/;"	f
gui_new_scrollbar_colors	gui.c	/^gui_new_scrollbar_colors()$/;"	f
gui_new_shellsize	gui.c	/^gui_new_shellsize()$/;"	f
gui_outstr	gui.c	/^gui_outstr(s, len)$/;"	f	file:
gui_outstr_nowrap	gui.c	/^gui_outstr_nowrap(s, len, flags, fg, bg, back)$/;"	f
gui_position_components	gui.c	/^gui_position_components(total_width)$/;"	f	file:
gui_position_menu	gui.c	/^gui_position_menu()$/;"	f
gui_prepare	gui.c	/^gui_prepare(argc, argv)$/;"	f
gui_prev_topfill	globals.h	/^EXTERN int	gui_prev_topfill INIT(= 0);$/;"	v
gui_prev_topline	globals.h	/^EXTERN linenr_T gui_prev_topline INIT(= 0);$/;"	v
gui_redraw	gui.c	/^gui_redraw(x, y, w, h)$/;"	f
gui_redraw_block	gui.c	/^gui_redraw_block(row1, col1, row2, col2, flags)$/;"	f
gui_remove_scrollbars	gui.c	/^gui_remove_scrollbars()$/;"	f
gui_reset_scroll_region	gui.c	/^gui_reset_scroll_region()$/;"	f
gui_resize_shell	gui.c	/^gui_resize_shell(pixel_width, pixel_height)$/;"	f
gui_screenchar	gui.c	/^gui_screenchar(off, flags, fg, bg, back)$/;"	f	file:
gui_screenstr	gui.c	/^gui_screenstr(off, len, flags, fg, bg, back)$/;"	f	file:
gui_send_mouse_event	gui.c	/^gui_send_mouse_event(button, x, y, repeated_click, modifiers)$/;"	f
gui_set_bg_color	gui.c	/^gui_set_bg_color(name)$/;"	f	file:
gui_set_cursor	gui.c	/^gui_set_cursor(row, col)$/;"	f
gui_set_fg_color	gui.c	/^gui_set_fg_color(name)$/;"	f	file:
gui_set_shellsize	gui.c	/^gui_set_shellsize(mustset, fit_to_display, direction)$/;"	f
gui_shell_closed	gui.c	/^gui_shell_closed()$/;"	f
gui_show_popupmenu	menu.c	/^gui_show_popupmenu()$/;"	f
gui_start	gui.c	/^gui_start()$/;"	f
gui_start_highlight	gui.c	/^gui_start_highlight(mask)$/;"	f
gui_stop_highlight	gui.c	/^gui_stop_highlight(mask)$/;"	f
gui_undraw_cursor	gui.c	/^gui_undraw_cursor()$/;"	f
gui_update_cursor	gui.c	/^gui_update_cursor(force, clear_selection)$/;"	f
gui_update_cursor_later	gui.c	/^gui_update_cursor_later()$/;"	f
gui_update_horiz_scrollbar	gui.c	/^gui_update_horiz_scrollbar(force)$/;"	f	file:
gui_update_menus	menu.c	/^gui_update_menus(modes)$/;"	f
gui_update_menus_recurse	menu.c	/^gui_update_menus_recurse(menu, mode)$/;"	f	file:
gui_update_screen	gui.c	/^gui_update_screen()$/;"	f
gui_update_scrollbars	gui.c	/^gui_update_scrollbars(force)$/;"	f
gui_update_tabline	gui.c	/^gui_update_tabline()$/;"	f
gui_use_tabline	gui.c	/^gui_use_tabline()$/;"	f
gui_wait_for_chars	gui.c	/^gui_wait_for_chars(wtime)$/;"	f
gui_win_pos_T	gui.h	/^} gui_win_pos_T;$/;"	t	typeref:enum:__anon63
gui_win_x	globals.h	/^EXTERN int	gui_win_x INIT(= -1);$/;"	v
gui_win_y	globals.h	/^EXTERN int	gui_win_y INIT(= -1);$/;"	v
gui_wingoto_xy	gui.c	/^gui_wingoto_xy(x, y)$/;"	f	file:
gui_write	gui.c	/^gui_write(s, len)$/;"	f
gui_x11_blink_cb	gui_x11.c	/^gui_x11_blink_cb(timed_out, interval_id)$/;"	f	file:
gui_x11_callbacks	gui_x11.c	/^gui_x11_callbacks(textArea, vimForm)$/;"	f
gui_x11_check_copy_area	gui_x11.c	/^gui_x11_check_copy_area()$/;"	f	file:
gui_x11_create_blank_mouse	gui_x11.c	/^gui_x11_create_blank_mouse()$/;"	f	file:
gui_x11_create_widgets	gui_athena.c	/^gui_x11_create_widgets()$/;"	f
gui_x11_create_widgets	gui_motif.c	/^gui_x11_create_widgets()$/;"	f
gui_x11_destroy_widgets	gui_athena.c	/^gui_x11_destroy_widgets()$/;"	f
gui_x11_destroy_widgets	gui_motif.c	/^gui_x11_destroy_widgets()$/;"	f
gui_x11_enter_cb	gui_x11.c	/^gui_x11_enter_cb(w, data, event, dum)$/;"	f	file:
gui_x11_expose_cb	gui_x11.c	/^gui_x11_expose_cb(w, dud, event, dum)$/;"	f	file:
gui_x11_focus_change_cb	gui_x11.c	/^gui_x11_focus_change_cb(w, data, event, dum)$/;"	f	file:
gui_x11_get_last_mouse_event	gui_x11.c	/^gui_x11_get_last_mouse_event()$/;"	f
gui_x11_get_wid	gui_athena.c	/^gui_x11_get_wid()$/;"	f
gui_x11_get_wid	gui_motif.c	/^gui_x11_get_wid()$/;"	f
gui_x11_key_hit_cb	gui_x11.c	/^gui_x11_key_hit_cb(w, dud, event, dum)$/;"	f
gui_x11_leave_cb	gui_x11.c	/^gui_x11_leave_cb(w, data, event, dum)$/;"	f	file:
gui_x11_menu_cb	gui_x11.c	/^gui_x11_menu_cb(w, client_data, call_data)$/;"	f
gui_x11_mouse_cb	gui_x11.c	/^gui_x11_mouse_cb(w, dud, event, dum)$/;"	f	file:
gui_x11_resize_window_cb	gui_x11.c	/^gui_x11_resize_window_cb(w, dud, event, dum)$/;"	f	file:
gui_x11_send_event_handler	gui_x11.c	/^gui_x11_send_event_handler(w, client_data, event, dum)$/;"	f	file:
gui_x11_set_back_color	gui_athena.c	/^gui_x11_set_back_color()$/;"	f
gui_x11_set_back_color	gui_motif.c	/^gui_x11_set_back_color()$/;"	f
gui_x11_sniff_request_cb	gui_x11.c	/^gui_x11_sniff_request_cb(closure, source, id)$/;"	f	file:
gui_x11_timer_cb	gui_x11.c	/^gui_x11_timer_cb(timed_out, interval_id)$/;"	f	file:
gui_x11_visibility_cb	gui_x11.c	/^gui_x11_visibility_cb(w, dud, event, dum)$/;"	f	file:
gui_x11_wm_protocol_handler	gui_x11.c	/^gui_x11_wm_protocol_handler(w, client_data, event, dum)$/;"	f	file:
gui_xm_select_font	gui_xmdlg.c	/^gui_xm_select_font(char_u *current)$/;"	f
gui_xy2colrow	gui.c	/^gui_xy2colrow(x, y, colp)$/;"	f
guicolor_T	gui.h	/^typedef long	    guicolor_T;	\/* handle for a GUI color; for X11 this should$/;"	t
guicolor_T	structs.h	/^# define guicolor_T /;"	d
guint	gui_gtk_x11.c	/^# define guint /;"	d	file:
guint8	gui_gtk.c	/^# define guint8 /;"	d	file:
hIconvDLL	mbyte.c	/^static HINSTANCE hIconvDLL = 0;$/;"	v	file:
hMsvcrtDLL	mbyte.c	/^static HINSTANCE hMsvcrtDLL = 0;$/;"	v	file:
hMzGC	if_mzsch.c	/^static HINSTANCE hMzGC = 0;$/;"	v	file:
hMzSch	if_mzsch.c	/^static HINSTANCE hMzSch = 0;$/;"	v	file:
hOrigin	gui_at_fs.c	/^    int		hOrigin;$/;"	m	struct:__anon14	file:
hProc	if_cscope.h	/^    HANDLE	    hProc;	\/* cscope process handle *\/$/;"	m	struct:csi
hTclLib	if_tcl.c	/^static HANDLE hTclLib = NULL;$/;"	v	file:
had_end	fold.c	/^    int		had_end;	\/* level of fold that is forced to end above$/;"	m	struct:__anon12	file:
had_endbrace	regexp.c	/^static char_u	had_endbrace[NSUBEXP];	\/* flags, TRUE if end of () found *\/$/;"	v	file:
had_eol	regexp.c	/^static int	had_eol;	\/* TRUE when EOL found by vim_regcomp() *\/$/;"	v	file:
half_shape	arabic.c	/^half_shape(c)$/;"	f	file:
halfpage	move.c	/^halfpage(flag, Prenum)$/;"	f
han_index	hangulin.c	/^#define han_index(/;"	d	file:
handle_drop	ex_docmd.c	/^handle_drop(filec, filev, split)$/;"	f
handle_key_queue	netbeans.c	/^handle_key_queue(void)$/;"	f	file:
handle_resize	os_unix.c	/^handle_resize()$/;"	f	file:
handle_subscript	eval.c	/^handle_subscript(arg, rettv, evaluate, verbose)$/;"	f	file:
handle_swap_exists	buffer.c	/^handle_swap_exists(old_curbuf)$/;"	f
handle_tabmenu	normal.c	/^handle_tabmenu()$/;"	f
handle_x_keys	misc2.c	/^handle_x_keys(key)$/;"	f
handler_id	gui.h	/^    unsigned long handler_id;   \/* Id of "value_changed" signal handler *\/$/;"	m	struct:GuiScrollbar
hangul_automata2	hangulin.c	/^hangul_automata2(buf, c)$/;"	f	file:
hangul_automata3	hangulin.c	/^hangul_automata3(buf, c)$/;"	f	file:
hangul_input_clear	hangulin.c	/^hangul_input_clear()$/;"	f
hangul_input_process	hangulin.c	/^hangul_input_process(s, len)$/;"	f
hangul_input_state	hangulin.c	/^static int hangul_input_state = 0;$/;"	v	file:
hangul_input_state_get	hangulin.c	/^hangul_input_state_get()$/;"	f
hangul_input_state_set	hangulin.c	/^hangul_input_state_set(state)$/;"	f
hangul_input_state_toggle	hangulin.c	/^hangul_input_state_toggle()$/;"	f
hangul_keyboard_set	hangulin.c	/^hangul_keyboard_set()$/;"	f
hangul_keyboard_type	hangulin.c	/^static int hangul_keyboard_type = HANGUL_DEFAULT_KEYBOARD;$/;"	v	file:
hardcopy_line	hardcopy.c	/^hardcopy_line(psettings, page_line, ppos)$/;"	f	file:
hasAnyFolding	fold.c	/^hasAnyFolding(win)$/;"	f
hasFolding	fold.c	/^hasFolding(lnum, firstp, lastp)$/;"	f
hasFoldingWin	fold.c	/^hasFoldingWin(win, lnum, firstp, lastp, cache, infop)$/;"	f
has_autocmd	fileio.c	/^has_autocmd(event, sfname, buf)$/;"	f
has_charset	hardcopy.c	/^    int		has_charset;$/;"	m	struct:prt_ps_charset_S	file:
has_color	structs.h	/^    int		has_color;$/;"	m	struct:__anon100
has_compl_option	edit.c	/^has_compl_option(dict_opt)$/;"	f	file:
has_cont_list	syntax.c	/^    char	has_cont_list;	\/* TRUE if "cont_list" can be used *\/$/;"	m	struct:__anon58	file:
has_count	ex_docmd.c	/^    int		has_count;  \/* :123verbose  :3tab *\/$/;"	m	struct:cmdmod	file:
has_cursorhold	fileio.c	/^has_cursorhold()$/;"	f
has_cursormoved	fileio.c	/^has_cursormoved()$/;"	f
has_cursormovedI	fileio.c	/^has_cursormovedI()$/;"	f
has_format_option	option.c	/^has_format_option(x)$/;"	f
has_loop_cmd	ex_eval.c	/^has_loop_cmd(p)$/;"	f
has_mbyte	globals.h	/^EXTERN int	has_mbyte INIT(= 0);		\/* any multi-byte encoding *\/$/;"	v
has_mouse_termcode	term.c	/^static int has_mouse_termcode = 0;$/;"	v	file:
has_non_ascii	spell.c	/^has_non_ascii(s)$/;"	f	file:
has_patch	version.c	/^has_patch(n)$/;"	f
has_profiling	ex_cmds2.c	/^has_profiling(file, fname, fp)$/;"	f
has_submenu	gui_athena.c	/^has_submenu(widget)$/;"	f	file:
hash_T	structs.h	/^typedef long_u hash_T;		\/* Type for hi_hash *\/$/;"	t
hash_add	hashtab.c	/^hash_add(ht, key)$/;"	f
hash_add_item	hashtab.c	/^hash_add_item(ht, hi, key, hash)$/;"	f
hash_clear	hashtab.c	/^hash_clear(ht)$/;"	f
hash_clear_all	hashtab.c	/^hash_clear_all(ht, off)$/;"	f
hash_debug_results	hashtab.c	/^hash_debug_results()$/;"	f
hash_find	hashtab.c	/^hash_find(ht, key)$/;"	f
hash_hash	hashtab.c	/^hash_hash(key)$/;"	f
hash_init	hashtab.c	/^hash_init(ht)$/;"	f
hash_lock	hashtab.c	/^hash_lock(ht)$/;"	f
hash_lookup	hashtab.c	/^hash_lookup(ht, key, hash)$/;"	f
hash_may_resize	hashtab.c	/^hash_may_resize(ht, minitems)$/;"	f	file:
hash_remove	hashtab.c	/^hash_remove(ht, hi)$/;"	f
hash_removed	globals.h	/^EXTERN char_u	hash_removed;$/;"	v
hash_unlock	hashtab.c	/^hash_unlock(ht)$/;"	f
hashitem_S	structs.h	/^typedef struct hashitem_S$/;"	s
hashitem_T	structs.h	/^} hashitem_T;$/;"	t	typeref:struct:hashitem_S
hashkey	spell.c	/^	char_u	hashkey[6];	\/* the hash key, only used while compressing *\/$/;"	m	union:wordnode_S::__anon54	file:
hashtab_T	structs.h	/^} hashtab_T;$/;"	t	typeref:struct:hashtable_S
hashtable_S	structs.h	/^typedef struct hashtable_S$/;"	s
hasnum	structs.h	/^    int		hasnum;$/;"	m	struct:__anon98
haveConnection	netbeans.c	/^static int haveConnection = FALSE;	\/* socket is connected and$/;"	v	file:
have_dollars	os_unix.c	/^have_dollars(num, file)$/;"	f	file:
have_wildcard	os_unix.c	/^have_wildcard(num, file)$/;"	f	file:
head	netbeans.c	/^static queue_T head;  \/* dummy node, header for circular queue *\/$/;"	v	file:
head	tag.c	/^    char_u	*head;		\/* start of pattern head *\/$/;"	m	struct:__anon60	file:
header_count	undo.c	/^static int header_count;$/;"	v	file:
headlen	tag.c	/^    int		headlen;	\/* length of head[] *\/$/;"	m	struct:__anon60	file:
height	gui.h	/^    int		height;		\/* Current height of scroll bar in rows *\/$/;"	m	struct:GuiScrollbar
height	gui_gtk_f.h	/^    guint height;$/;"	m	struct:_GtkForm
height	hardcopy.c	/^    float	height;$/;"	m	struct:prt_mediasize_S	file:
height	move.c	/^    int		    height;	\/* height of added line *\/$/;"	m	struct:__anon44	file:
help	if_cscope.h	/^    char *  help;$/;"	m	struct:__anon68
help_compare	ex_cmds.c	/^help_compare(s1, s2)$/;"	f	file:
help_heuristic	ex_cmds.c	/^help_heuristic(matched_string, offset, wrong_case)$/;"	f
helptags_one	ex_cmds.c	/^helptags_one(dir, ext, tagfname, add_help_tags)$/;"	f	file:
hex2nr	charset.c	/^hex2nr(c)$/;"	f
hexhex2nr	charset.c	/^hexhex2nr(p)$/;"	f
hi_hash	structs.h	/^    long_u	hi_hash;	\/* cached hash number of hi_key *\/$/;"	m	struct:hashitem_S
hi_key	structs.h	/^    char_u	*hi_key;$/;"	m	struct:hashitem_S
hidden	structs.h	/^    int		hidden;$/;"	m	struct:VimMenu
hide	structs.h	/^    int		hide;			\/* TRUE when ":hide" was used *\/$/;"	m	struct:__anon83
highest_patch	version.c	/^highest_patch()$/;"	f
highlight_attr	globals.h	/^EXTERN int	highlight_attr[HLF_COUNT];  \/* Highl. attr for each context. *\/$/;"	v
highlight_changed	syntax.c	/^highlight_changed()$/;"	f
highlight_clear	syntax.c	/^highlight_clear(idx)$/;"	f	file:
highlight_color	syntax.c	/^highlight_color(id, what, modec)$/;"	f
highlight_exists	syntax.c	/^highlight_exists(name)$/;"	f
highlight_ga	syntax.c	/^static garray_T highlight_ga;	\/* highlight groups for 'highlight' option *\/$/;"	v	file:
highlight_gui_color_rgb	syntax.c	/^highlight_gui_color_rgb(id, fg)$/;"	f
highlight_gui_started	syntax.c	/^highlight_gui_started()$/;"	f
highlight_has_attr	syntax.c	/^highlight_has_attr(id, flag, modec)$/;"	f
highlight_init_both	syntax.c	/^static char *(highlight_init_both[]) =$/;"	v	file:
highlight_init_dark	syntax.c	/^static char *(highlight_init_dark[]) =$/;"	v	file:
highlight_init_light	syntax.c	/^static char *(highlight_init_light[]) =$/;"	v	file:
highlight_list	syntax.c	/^highlight_list()$/;"	f	file:
highlight_list_arg	syntax.c	/^highlight_list_arg(id, didh, type, iarg, sarg, name)$/;"	f	file:
highlight_list_one	syntax.c	/^highlight_list_one(id)$/;"	f	file:
highlight_list_two	syntax.c	/^highlight_list_two(cnt, attr)$/;"	f	file:
highlight_mask	gui.h	/^    int		highlight_mask;	    \/* Highlight attribute mask *\/$/;"	m	struct:Gui
highlight_match	globals.h	/^EXTERN int	highlight_match INIT(= FALSE);	\/* show search match pos *\/$/;"	v
highlight_pixmap	gui_xmebwp.h	/^    Pixmap highlight_pixmap;$/;"	m	struct:_XmEnhancedButtonPart
highlight_stlnc	globals.h	/^EXTERN int	highlight_stlnc[9];		\/* On top of user *\/$/;"	v
highlight_user	globals.h	/^EXTERN int	highlight_user[9];		\/* User[1-9] attributes *\/$/;"	v
hinstPython	if_python.c	/^static HINSTANCE hinstPython = 0; \/* Instance of python.dll *\/$/;"	v	file:
hinstRuby	if_ruby.c	/^static HINSTANCE hinstRuby = 0; \/* Instance of ruby.dll *\/$/;"	v	file:
hisidx	ex_getln.c	/^static int	hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};  \/* lastused entry *\/$/;"	v	file:
hislen	ex_getln.c	/^static int	hislen = 0;		\/* actual length of history tables *\/$/;"	v	file:
hisnum	ex_getln.c	/^    int		hisnum;		\/* identifying number *\/$/;"	m	struct:hist_entry	file:
hisnum	ex_getln.c	/^static int	hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};$/;"	v	file:
hisstr	ex_getln.c	/^    char_u	*hisstr;	\/* actual entry, separator char after the NUL *\/$/;"	m	struct:hist_entry	file:
hist_char2type	ex_getln.c	/^hist_char2type(c)$/;"	f	file:
hist_entry	ex_getln.c	/^typedef struct hist_entry$/;"	s	file:
hist_type2char	ex_getln.c	/^hist_type2char(type, use_question)$/;"	f	file:
histentry_T	ex_getln.c	/^} histentry_T;$/;"	t	typeref:struct:hist_entry	file:
history	ex_getln.c	/^static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};$/;"	v	file:
history_names	ex_getln.c	/^static char *(history_names[]) =$/;"	v	file:
hit_return_msg	message.c	/^hit_return_msg()$/;"	f	file:
hkmap	edit.c	/^hkmap(c)$/;"	f
hl	structs.h	/^    match_T	hl;	    \/* struct for doing the actual highlighting *\/$/;"	m	struct:matchitem
hl_attr	vim.h	/^#define hl_attr(/;"	d
hl_attr_table	syntax.c	/^static int hl_attr_table[] =$/;"	v	file:
hl_combine_attr	syntax.c	/^hl_combine_attr(char_attr, prim_attr)$/;"	f
hl_do_font	syntax.c	/^hl_do_font(idx, arg, do_normal, do_menu, do_tooltip)$/;"	f	file:
hl_get_font_name	syntax.c	/^hl_get_font_name()$/;"	f
hl_group	syntax.c	/^struct hl_group$/;"	s	file:
hl_has_settings	syntax.c	/^hl_has_settings(idx, check_link)$/;"	f	file:
hl_name_table	syntax.c	/^static char *(hl_name_table[]) =$/;"	v	file:
hl_set_bg_color_name	syntax.c	/^hl_set_bg_color_name(name)$/;"	f
hl_set_fg_color_name	syntax.c	/^hl_set_fg_color_name(name)$/;"	f
hl_set_font_name	syntax.c	/^hl_set_font_name(font_name)$/;"	f
hlf_T	vim.h	/^} hlf_T;$/;"	t	typeref:enum:__anon103
hlg_id	structs.h	/^    int		hlg_id;	    \/* highlight group ID *\/$/;"	m	struct:matchitem
hold_gui_events	globals.h	/^EXTERN int	hold_gui_events INIT(= 0);$/;"	v
home_replace	misc1.c	/^home_replace(buf, src, dst, dstlen, one)$/;"	f
home_replace_save	misc1.c	/^home_replace_save(buf, src)$/;"	f
homedir	misc1.c	/^static char_u	*homedir = NULL;$/;"	v	file:
hpux	pty.c	/^# define hpux$/;"	d	file:
ht_array	structs.h	/^    hashitem_T	*ht_array;	\/* points to the array, allocated when it's$/;"	m	struct:hashtable_S
ht_error	structs.h	/^    int		ht_error;	\/* when set growing failed, can't add more$/;"	m	struct:hashtable_S
ht_filled	structs.h	/^    long_u	ht_filled;	\/* number of items used + removed *\/$/;"	m	struct:hashtable_S
ht_locked	structs.h	/^    int		ht_locked;	\/* counter for hash_lock() *\/$/;"	m	struct:hashtable_S
ht_mask	structs.h	/^    long_u	ht_mask;	\/* mask used for hash value (nr of items in$/;"	m	struct:hashtable_S
ht_smallarray	structs.h	/^    hashitem_T	ht_smallarray[HT_INIT_SIZE];   \/* initial array *\/$/;"	m	struct:hashtable_S
ht_used	structs.h	/^    long_u	ht_used;	\/* number of items used *\/$/;"	m	struct:hashtable_S
iceconn	os_unix.c	/^    IceConn iceconn;	    \/* The ICE connection ID *\/$/;"	m	struct:__anon46	file:
icon_builtin	structs.h	/^    int		icon_builtin;	    \/* icon names is BuiltIn{nr} *\/$/;"	m	struct:VimMenu
icon_size_changed_foreach	gui_gtk_x11.c	/^icon_size_changed_foreach(GtkWidget *widget, gpointer user_data)$/;"	f	file:
iconfile	structs.h	/^    char_u	*iconfile;	    \/* name of file for icon or NULL *\/$/;"	m	struct:VimMenu
iconidx	structs.h	/^    int		iconidx;	    \/* icon index (-1 if not set) *\/$/;"	m	struct:VimMenu
iconv	globals.h	/^EXTERN size_t (*iconv) (iconv_t cd, const char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);$/;"	v
iconv_close	globals.h	/^EXTERN int (*iconv_close) (iconv_t cd);$/;"	v
iconv_enabled	mbyte.c	/^iconv_enabled(verbose)$/;"	f
iconv_end	mbyte.c	/^iconv_end()$/;"	f
iconv_errno	globals.h	/^EXTERN int* (*iconv_errno) (void);$/;"	v
iconv_open	globals.h	/^EXTERN iconv_t (*iconv_open) (const char *tocode, const char *fromcode);$/;"	v
iconv_string	mbyte.c	/^iconv_string(vcp, str, slen, unconvlenp)$/;"	f	file:
iconv_t	structs.h	/^typedef struct _iconv_t *iconv_t;$/;"	t	typeref:struct:_iconv_t
iconv_t	structs.h	/^typedef void *iconv_t;$/;"	t
iconvctl	globals.h	/^EXTERN int (*iconvctl) (iconv_t cd, int request, void *argument);$/;"	v
id	gui.h	/^    ControlHandle id;		\/* A handle to the scrollbar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    GtkWidget *id;		\/* Id of real scroll bar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    HWND	id;		\/* Id of real scroll bar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    PtWidget_t	*id;$/;"	m	struct:GuiScrollbar
id	gui.h	/^    Widget	id;		\/* Id of real scroll bar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    int		id;		\/* Window handle of scrollbar window *\/$/;"	m	struct:GuiScrollbar
id	gui_motif.c	/^    int	    id;$/;"	m	struct:dialog_callback_arg	file:
id	if_xcmdsrv.c	/^    Window  id;$/;"	m	struct:ServerReply	file:
id	structs.h	/^    GtkWidget	*id;		    \/* Manage this to enable item *\/$/;"	m	struct:VimMenu
id	structs.h	/^    PtWidget_t	*id;$/;"	m	struct:VimMenu
id	structs.h	/^    UINT	id;		    \/* Id of menu item *\/$/;"	m	struct:VimMenu
id	structs.h	/^    Widget	id;		    \/* Manage this to enable item *\/$/;"	m	struct:VimMenu
id	structs.h	/^    int		*id;		    \/* Not used, but gui.c needs it *\/$/;"	m	struct:VimMenu
id	structs.h	/^    int		id;		\/* highlight group ID *\/$/;"	m	struct:cursor_entry
id	structs.h	/^    int		id;		\/* unique identifier for each placed sign *\/$/;"	m	struct:signlist
id	structs.h	/^    int		id;	    \/* match ID *\/$/;"	m	struct:matchitem
id	structs.h	/^    short	id;		\/* highlight group ID of item *\/$/;"	m	struct:sp_syn
id_lm	structs.h	/^    int		id_lm;		\/* highlight group ID for :lmap mode *\/$/;"	m	struct:cursor_entry
ident	gui.h	/^    long	ident;		\/* Unique identifier for each scrollbar *\/$/;"	m	struct:GuiScrollbar
idopt_T	option.c	/^} idopt_T;$/;"	t	typeref:enum:__anon45	file:
idx_T	spell.c	/^typedef int idx_T;$/;"	t	file:
idx_T	spell.c	/^typedef long idx_T;$/;"	t	file:
if_level	ex_docmd.c	/^static int	if_level = 0;		\/* depth in :if *\/$/;"	v	file:
ignore_enter	gui_gtk.c	/^    int		ignore_enter;	    \/* no default button, ignore "Enter" *\/$/;"	m	struct:_DialogInfo	file:
ignore_enter	gui_gtk.c	/^    int		ignore_enter;$/;"	m	struct:_CancelData	file:
ignore_script	globals.h	/^EXTERN int	ignore_script INIT(= FALSE);  \/* ignore script input *\/$/;"	v
ignore_tabline_evt	gui_gtk_x11.c	/^static int ignore_tabline_evt = FALSE;$/;"	v	file:
ignorecase	search.c	/^ignorecase(pat)$/;"	f
illegal_char	option.c	/^illegal_char(errbuf, c)$/;"	f	file:
illegal_slash	misc2.c	/^illegal_slash(name)$/;"	f
im_activatekey_keyval	mbyte.c	/^static unsigned int  im_activatekey_keyval = GDK_VoidSymbol;$/;"	v	file:
im_activatekey_state	mbyte.c	/^static unsigned int  im_activatekey_state  = 0;$/;"	v	file:
im_add_to_input	mbyte.c	/^im_add_to_input(char_u *str, int len)$/;"	f	file:
im_commit_cb	mbyte.c	/^im_commit_cb(GtkIMContext *context, const gchar *str, gpointer data)$/;"	f	file:
im_commit_handler_id	mbyte.c	/^static unsigned long im_commit_handler_id  = 0;$/;"	v	file:
im_correct_cursor	mbyte.c	/^im_correct_cursor(int num_move_back)$/;"	f	file:
im_delete_preedit	mbyte.c	/^im_delete_preedit(void)$/;"	f	file:
im_get_feedback_attr	mbyte.c	/^im_get_feedback_attr(int col)$/;"	f
im_get_status	hangulin.c	/^im_get_status()$/;"	f
im_get_status	mbyte.c	/^im_get_status()$/;"	f
im_get_status	mbyte.c	/^im_get_status(void)$/;"	f
im_is_active	mbyte.c	/^static int im_is_active	       = FALSE;	\/* IM is enabled for current mode    *\/$/;"	v	file:
im_is_preediting	mbyte.c	/^im_is_preediting()$/;"	f
im_preedit_changed_cb	mbyte.c	/^im_preedit_changed_cb(GtkIMContext *context, gpointer data)$/;"	f	file:
im_preedit_cursor	mbyte.c	/^static int im_preedit_cursor   = 0;	\/* cursor offset in characters       *\/$/;"	v	file:
im_preedit_end_cb	mbyte.c	/^im_preedit_end_cb(GtkIMContext *context, gpointer data)$/;"	f	file:
im_preedit_start_cb	mbyte.c	/^im_preedit_start_cb(GtkIMContext *context, gpointer data)$/;"	f	file:
im_preedit_trailing	mbyte.c	/^static int im_preedit_trailing = 0;	\/* number of characters after cursor *\/$/;"	v	file:
im_save_status	ui.c	/^im_save_status(psave)$/;"	f
im_set_active	mbyte.c	/^im_set_active(active)$/;"	f
im_set_active	mbyte.c	/^im_set_active(int active)$/;"	f
im_set_position	mbyte.c	/^im_set_position(int row, int col)$/;"	f
im_set_position	mbyte.c	/^im_set_position(row, col)$/;"	f
im_show_info	mbyte.c	/^im_show_info(void)$/;"	f	file:
im_shutdown	mbyte.c	/^im_shutdown(void)$/;"	f
im_string_to_keyval	mbyte.c	/^im_string_to_keyval(const char *str, unsigned int *keyval, unsigned int *state)$/;"	f	file:
im_synthesize_keypress	mbyte.c	/^im_synthesize_keypress(unsigned int keyval, unsigned int state)$/;"	f	file:
im_xim_isvalid_imactivate	mbyte.c	/^im_xim_isvalid_imactivate()$/;"	f
im_xim_isvalid_imactivate	mbyte.c	/^im_xim_isvalid_imactivate(void)$/;"	f
im_xim_send_event_imactivate	mbyte.c	/^im_xim_send_event_imactivate()$/;"	f	file:
im_xim_str2keycode	mbyte.c	/^im_xim_str2keycode(code, state)$/;"	f	file:
image	structs.h	/^    Pixmap	image;		    \/* Toolbar image *\/$/;"	m	struct:VimMenu
imp_PyExc_AttributeError	if_python.c	/^static PyObject *imp_PyExc_AttributeError;$/;"	v	file:
imp_PyExc_IndexError	if_python.c	/^static PyObject *imp_PyExc_IndexError;$/;"	v	file:
imp_PyExc_KeyboardInterrupt	if_python.c	/^static PyObject *imp_PyExc_KeyboardInterrupt;$/;"	v	file:
imp_PyExc_TypeError	if_python.c	/^static PyObject *imp_PyExc_TypeError;$/;"	v	file:
imp_PyExc_ValueError	if_python.c	/^static PyObject *imp_PyExc_ValueError;$/;"	v	file:
inAtomic	netbeans.c	/^static int inAtomic = 0;$/;"	v	file:
in_cinkeys	edit.c	/^in_cinkeys(keytyped, when, line_is_empty)$/;"	f
in_focus	gui.h	/^    int		in_focus;	    \/* Vim has input focus *\/$/;"	m	struct:Gui
in_history	ex_getln.c	/^in_history(type, str, move_to_front)$/;"	f	file:
in_html_tag	search.c	/^in_html_tag(end_tag)$/;"	f	file:
in_id_list	syntax.c	/^in_id_list(cur_si, list, ssp, contained)$/;"	f	file:
in_mch_delay	os_unix.c	/^static int	in_mch_delay = FALSE;	    \/* sleeping in mch_delay() *\/$/;"	v	file:
in_pixels	gui_xmdlg.c	/^    Boolean	in_pixels;	\/* toggle state - size in pixels  *\/$/;"	m	struct:_SharedFontSelData	file:
in_use	gui.h	/^    int		in_use;		    \/* Is the GUI being used? *\/$/;"	m	struct:Gui
in_win_border	charset.c	/^in_win_border(wp, vcol)$/;"	f
inbuf	ui.c	/^static char_u	inbuf[INBUFLEN + MAX_KEY_CODE_LEN];$/;"	v	file:
inbufcount	ui.c	/^static int	inbufcount = 0;	    \/* number of chars in inbuf[] *\/$/;"	v	file:
inc	misc2.c	/^inc(lp)$/;"	f
inc_cursor	misc2.c	/^inc_cursor()$/;"	f
inc_msg_scrolled	message.c	/^inc_msg_scrolled()$/;"	f	file:
inc_tag	structs.h	/^    int		inc_tag;	\/* ":syn include" unique tag *\/$/;"	m	struct:sp_syn
inchar	getchar.c	/^inchar(buf, maxlen, wait_time, tb_change_cnt)$/;"	f
inchar_time	ex_cmds2.c	/^static proftime_T inchar_time;$/;"	v	file:
incl	misc2.c	/^incl(lp)$/;"	f
include_default	syntax.c	/^static int include_default = 0;	\/* when 1 include "default" *\/$/;"	v	file:
include_groups	fileio.c	/^static int include_groups = FALSE;$/;"	v	file:
include_link	syntax.c	/^static int include_link = 0;	\/* when 2 include "link" and "clear" *\/$/;"	v	file:
include_none	syntax.c	/^static int include_none = 0;	\/* when 1 include "None" *\/$/;"	v	file:
included_patches	version.c	/^static int included_patches[] =$/;"	v	file:
inclusive	structs.h	/^    int		inclusive;	\/* TRUE if char motion is inclusive (only$/;"	m	struct:oparg_S
ind_hash_comment	misc1.c	/^static int	ind_hash_comment = 0;   \/* # starts a comment *\/$/;"	v	file:
index	gui_gtk.c	/^    int		index;$/;"	m	struct:_ButtonData	file:
index	spell.c	/^	int	index;		\/* index in written nodes (valid after first$/;"	m	union:wordnode_S::__anon54	file:
indir	option.c	/^    idopt_T	indir;		\/* global option: PV_NONE;$/;"	m	struct:vimoption	file:
info_message	globals.h	/^EXTERN int	info_message INIT(= FALSE); \/* printing informative message *\/$/;"	v
info_pointer	structs.h	/^typedef struct info_pointer$/;"	s
infoptr_T	structs.h	/^} infoptr_T;	\/* block\/index pair *\/$/;"	t	typeref:struct:info_pointer
inindent	misc1.c	/^inindent(extra)$/;"	f
initDone	netbeans.c	/^    unsigned int	 initDone:1;$/;"	m	struct:nbbuf_struct	file:
init_chartab	charset.c	/^init_chartab()$/;"	f
init_class_tab	regexp.c	/^init_class_tab()$/;"	f	file:
init_exn_catching_apply	if_mzsch.c	/^init_exn_catching_apply(void)$/;"	f	file:
init_gui_options	option.c	/^init_gui_options()$/;"	f
init_highlight	syntax.c	/^init_highlight(both, reset)$/;"	f
init_history	ex_getln.c	/^init_history()$/;"	f
init_homedir	misc1.c	/^init_homedir()$/;"	f
init_locale	main.c	/^init_locale()$/;"	f	file:
init_mappings	getchar.c	/^init_mappings()$/;"	f
init_normal_cmds	normal.c	/^init_normal_cmds()$/;"	f
init_preedit_start_col	mbyte.c	/^init_preedit_start_col(void)$/;"	f	file:
init_signal_stack	os_unix.c	/^init_signal_stack()$/;"	f	file:
init_spell_chartab	spell.c	/^init_spell_chartab()$/;"	f
init_spellfile	spell.c	/^init_spellfile()$/;"	f	file:
init_syl_tab	spell.c	/^init_syl_tab(slang)$/;"	f	file:
init_syn_patterns	syntax.c	/^init_syn_patterns()$/;"	f	file:
init_tv	eval.c	/^init_tv(varp)$/;"	f	file:
init_typebuf	getchar.c	/^init_typebuf()$/;"	f	file:
init_var_dict	eval.c	/^init_var_dict(dict, dict_var)$/;"	f
init_window_hints_state	gui_gtk_x11.c	/^static int init_window_hints_state = 0;$/;"	v	file:
init_yank	ops.c	/^init_yank()$/;"	f
initchr	regexp.c	/^initchr(str)$/;"	f	file:
initialFileCmd	workshop.c	/^static char	*initialFileCmd;	\/* save command but defer doing it *\/$/;"	v	file:
initialised	if_python.c	/^static int initialised = 0;$/;"	v	file:
initialized	if_mzsch.c	/^static int initialized = 0;$/;"	v	file:
initmap	getchar.c	/^static struct initmap$/;"	s	file:
initmappings	getchar.c	/^} initmappings[] =$/;"	v	typeref:struct:initmap	file:
initmaster	pty.c	/^initmaster(f)$/;"	f	file:
inmacro	search.c	/^inmacro(opt, s)$/;"	f	file:
inputHandler	integration.c	/^static XtInputId inputHandler;		\/* Cookie for input *\/$/;"	v	file:
inputHandler	netbeans.c	/^static XtInputId inputHandler;		\/* Cookie for input *\/$/;"	v	file:
inputHandler	netbeans.c	/^static gint inputHandler;		\/* Cookie for input *\/$/;"	v	file:
inputHandler	netbeans.c	/^static int  inputHandler = -1;		\/* simply ret.value of WSAAsyncSelect() *\/$/;"	v	file:
input_available	getchar.c	/^input_available()$/;"	f
input_conv	globals.h	/^EXTERN vimconv_T input_conv;			\/* type of input conversion *\/$/;"	v
input_fn	ex_getln.c	/^    int		input_fn;	\/* when TRUE Invoked for input() function *\/$/;"	m	struct:cmdline_info	file:
input_style	mbyte.c	/^static XIMStyle	input_style;$/;"	v	file:
input_timer_cb	gui_gtk_x11.c	/^input_timer_cb(gpointer data)$/;"	f	file:
inputsecret_flag	eval.c	/^static int inputsecret_flag = 0;$/;"	v	file:
ins_at_eol	globals.h	/^EXTERN int	ins_at_eol INIT(= FALSE); \/* put cursor after eol when$/;"	v
ins_bs	edit.c	/^ins_bs(c, mode, inserted_space_p)$/;"	f	file:
ins_bs_one	edit.c	/^ins_bs_one(vcolp)$/;"	f	file:
ins_bytes	misc1.c	/^ins_bytes(p)$/;"	f
ins_bytes_len	misc1.c	/^ins_bytes_len(p, len)$/;"	f
ins_char	misc1.c	/^ins_char(c)$/;"	f
ins_char_bytes	misc1.c	/^ins_char_bytes(buf, charlen)$/;"	f
ins_char_typebuf	getchar.c	/^ins_char_typebuf(c)$/;"	f
ins_compl_accept_char	edit.c	/^ins_compl_accept_char(c)$/;"	f	file:
ins_compl_active	edit.c	/^ins_compl_active()$/;"	f
ins_compl_add	edit.c	/^ins_compl_add(str, len, icase, fname, cptext, cdir, flags, adup)$/;"	f	file:
ins_compl_add_infercase	edit.c	/^ins_compl_add_infercase(str, len, icase, fname, dir, flags)$/;"	f
ins_compl_add_list	edit.c	/^ins_compl_add_list(list)$/;"	f	file:
ins_compl_add_matches	edit.c	/^ins_compl_add_matches(num_matches, matches, icase)$/;"	f	file:
ins_compl_add_tv	edit.c	/^ins_compl_add_tv(tv, dir)$/;"	f
ins_compl_addfrommatch	edit.c	/^ins_compl_addfrommatch()$/;"	f	file:
ins_compl_addleader	edit.c	/^ins_compl_addleader(c)$/;"	f	file:
ins_compl_bs	edit.c	/^ins_compl_bs()$/;"	f	file:
ins_compl_check_keys	edit.c	/^ins_compl_check_keys(frequency)$/;"	f
ins_compl_clear	edit.c	/^ins_compl_clear()$/;"	f	file:
ins_compl_del_pum	edit.c	/^ins_compl_del_pum()$/;"	f	file:
ins_compl_delete	edit.c	/^ins_compl_delete()$/;"	f	file:
ins_compl_dictionaries	edit.c	/^ins_compl_dictionaries(dict_start, pat, flags, thesaurus)$/;"	f	file:
ins_compl_equal	edit.c	/^ins_compl_equal(match, str, len)$/;"	f	file:
ins_compl_files	edit.c	/^ins_compl_files(count, files, thesaurus, flags, regmatch, buf, dir)$/;"	f	file:
ins_compl_free	edit.c	/^ins_compl_free()$/;"	f	file:
ins_compl_get_exp	edit.c	/^ins_compl_get_exp(ini)$/;"	f	file:
ins_compl_insert	edit.c	/^ins_compl_insert()$/;"	f	file:
ins_compl_key2count	edit.c	/^ins_compl_key2count(c)$/;"	f	file:
ins_compl_key2dir	edit.c	/^ins_compl_key2dir(c)$/;"	f	file:
ins_compl_longest_match	edit.c	/^ins_compl_longest_match(match)$/;"	f	file:
ins_compl_make_cyclic	edit.c	/^ins_compl_make_cyclic()$/;"	f	file:
ins_compl_new_leader	edit.c	/^ins_compl_new_leader()$/;"	f	file:
ins_compl_next	edit.c	/^ins_compl_next(allow_get_expansion, count, insert_match)$/;"	f	file:
ins_compl_next_buf	edit.c	/^ins_compl_next_buf(buf, flag)$/;"	f	file:
ins_compl_prep	edit.c	/^ins_compl_prep(c)$/;"	f	file:
ins_compl_pum_key	edit.c	/^ins_compl_pum_key(c)$/;"	f	file:
ins_compl_restart	edit.c	/^ins_compl_restart()$/;"	f	file:
ins_compl_set_original_text	edit.c	/^ins_compl_set_original_text(str)$/;"	f	file:
ins_compl_show_pum	edit.c	/^ins_compl_show_pum()$/;"	f
ins_compl_upd_pum	edit.c	/^ins_compl_upd_pum()$/;"	f	file:
ins_compl_use_match	edit.c	/^ins_compl_use_match(c)$/;"	f	file:
ins_complete	edit.c	/^ins_complete(c)$/;"	f	file:
ins_copychar	edit.c	/^ins_copychar(lnum)$/;"	f	file:
ins_ctrl_	edit.c	/^ins_ctrl_()$/;"	f	file:
ins_ctrl_ey	edit.c	/^ins_ctrl_ey(tc)$/;"	f	file:
ins_ctrl_g	edit.c	/^ins_ctrl_g()$/;"	f	file:
ins_ctrl_hat	edit.c	/^ins_ctrl_hat()$/;"	f	file:
ins_ctrl_o	edit.c	/^ins_ctrl_o()$/;"	f	file:
ins_ctrl_v	edit.c	/^ins_ctrl_v()$/;"	f	file:
ins_ctrl_x	edit.c	/^ins_ctrl_x()$/;"	f	file:
ins_del	edit.c	/^ins_del()$/;"	f	file:
ins_digraph	edit.c	/^ins_digraph()$/;"	f	file:
ins_down	edit.c	/^ins_down(startcol)$/;"	f	file:
ins_drop	edit.c	/^ins_drop()$/;"	f	file:
ins_end	edit.c	/^ins_end(c)$/;"	f	file:
ins_eol	edit.c	/^ins_eol(c)$/;"	f	file:
ins_esc	edit.c	/^ins_esc(count, cmdchar, nomove)$/;"	f	file:
ins_home	edit.c	/^ins_home(c)$/;"	f	file:
ins_horscroll	edit.c	/^ins_horscroll()$/;"	f
ins_insert	edit.c	/^ins_insert(replaceState)$/;"	f	file:
ins_left	edit.c	/^ins_left()$/;"	f	file:
ins_mouse	edit.c	/^ins_mouse(c)$/;"	f	file:
ins_mousescroll	edit.c	/^ins_mousescroll(up)$/;"	f	file:
ins_need_undo	edit.c	/^static int	ins_need_undo;		\/* call u_save() before inserting a$/;"	v	file:
ins_pagedown	edit.c	/^ins_pagedown()$/;"	f	file:
ins_pageup	edit.c	/^ins_pageup()$/;"	f	file:
ins_redraw	edit.c	/^ins_redraw(ready)$/;"	f	file:
ins_reg	edit.c	/^ins_reg()$/;"	f	file:
ins_right	edit.c	/^ins_right()$/;"	f	file:
ins_s_left	edit.c	/^ins_s_left()$/;"	f	file:
ins_s_right	edit.c	/^ins_s_right()$/;"	f	file:
ins_scroll	edit.c	/^ins_scroll()$/;"	f
ins_shift	edit.c	/^ins_shift(c, lastc)$/;"	f	file:
ins_start_select	edit.c	/^ins_start_select(c)$/;"	f	file:
ins_str	misc1.c	/^ins_str(s)$/;"	f
ins_tab	edit.c	/^ins_tab()$/;"	f	file:
ins_tabline	edit.c	/^ins_tabline(c)$/;"	f	file:
ins_try_si	edit.c	/^ins_try_si(c)$/;"	f	file:
ins_typebuf	getchar.c	/^ins_typebuf(str, noremap, offset, nottyped, silent)$/;"	f
ins_up	edit.c	/^ins_up(startcol)$/;"	f	file:
insecure_flag	option.c	/^# define insecure_flag(/;"	d	file:
insecure_flag	option.c	/^insecure_flag(opt_idx, opt_flags)$/;"	f	file:
insensitive_pixmap	gui_xmebwp.h	/^    Pixmap insensitive_pixmap;$/;"	m	struct:_XmEnhancedButtonPart
insertDone	netbeans.c	/^    unsigned int	 insertDone:1;$/;"	m	struct:nbbuf_struct	file:
insert_buffer_line_list	if_mzsch.c	/^insert_buffer_line_list(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
insert_reg	ops.c	/^insert_reg(regname, literally)$/;"	f
insert_sign	buffer.c	/^insert_sign(buf, prev, next, id, lnum, typenr)$/;"	f	file:
insert_special	edit.c	/^insert_special(c, allow_modmask, ctrlv)$/;"	f	file:
insertchar	edit.c	/^insertchar(c, flags, second_indent)$/;"	f
instr	vim.h	/^#  undef instr$/;"	d
int_u	vim.h	/^typedef unsigned int	int_u;$/;"	t
int_wordlist	spell.c	/^static char_u	*int_wordlist = NULL;$/;"	v	file:
int_wordlist_spl	spell.c	/^int_wordlist_spl(fname)$/;"	f	file:
intable	mbyte.c	/^intable(table, size, c)$/;"	f	file:
internal_format	edit.c	/^internal_format(textwidth, second_indent, flags, format_only)$/;"	f	file:
interp	if_tcl.c	/^    Tcl_Interp	*interp;$/;"	m	struct:ref	file:
interp	if_tcl.c	/^    Tcl_Interp *interp;$/;"	m	struct:__anon37	file:
interval	mbyte.c	/^struct interval$/;"	s	file:
intr_char	globals.h	/^EXTERN int	intr_char INIT(= 0);	    \/* extra interrupt character *\/$/;"	v
intro_message	version.c	/^intro_message(colon)$/;"	f
invalid_bot	fold.c	/^static linenr_T invalid_bot = (linenr_T)0;$/;"	v	file:
invalid_range	ex_docmd.c	/^invalid_range(eap)$/;"	f	file:
invalid_top	fold.c	/^static linenr_T invalid_top = (linenr_T)0;$/;"	v	file:
invalidate_botline	move.c	/^invalidate_botline()$/;"	f
invalidate_botline_win	move.c	/^invalidate_botline_win(wp)$/;"	f
invalidate_current_state	syntax.c	/^invalidate_current_state()$/;"	f	file:
invert_gc	gui.h	/^    GC		invert_gc;$/;"	m	struct:Gui
invoke_edit	normal.c	/^invoke_edit(cap, repl, cmd, startln)$/;"	f	file:
ip_bnum	structs.h	/^    blocknr_T	ip_bnum;	\/* block number *\/$/;"	m	struct:info_pointer
ip_high	structs.h	/^    linenr_T	ip_high;	\/* highest lnum in this block *\/$/;"	m	struct:info_pointer
ip_index	structs.h	/^    int		ip_index;	\/* index for block with current lnum *\/$/;"	m	struct:info_pointer
ip_low	structs.h	/^    linenr_T	ip_low;		\/* lowest lnum in this block *\/$/;"	m	struct:info_pointer
ireg_ic	regexp.c	/^static int	ireg_ic;$/;"	v	file:
ireg_icombine	regexp.c	/^static int	ireg_icombine;$/;"	v	file:
ireg_maxcol	regexp.c	/^static colnr_T	ireg_maxcol;$/;"	v	file:
isMapped	integration.c	/^isMapped(Widget widget)$/;"	f	file:
isNetbeansBuffer	netbeans.c	/^isNetbeansBuffer(buf_T *bufp)$/;"	f
isNetbeansModified	netbeans.c	/^isNetbeansModified(buf_T *bufp)$/;"	f
isShowing	workshop.c	/^isShowing($/;"	f	file:
isWindowMapped	integration.c	/^isWindowMapped(Display *display, Window win)$/;"	f	file:
is_MAX	ops.c	/^    int		is_MAX;		\/* TRUE if curswant==MAXCOL when starting *\/$/;"	m	struct:block_def	file:
is_Magic	regexp.c	/^#define is_Magic(/;"	d	file:
is_VIsual	structs.h	/^    int		is_VIsual;	\/* operator on Visual area *\/$/;"	m	struct:oparg_S
is_cjk_font	gui_gtk_x11.c	/^is_cjk_font(PangoFontDescription *font_desc)$/;"	f	file:
is_click	misc2.c	/^    int	    is_click;		\/* Is it a mouse button click event? *\/$/;"	m	struct:mousetable	file:
is_dev_fd_file	fileio.c	/^is_dev_fd_file(fname)$/;"	f	file:
is_drag	misc2.c	/^    int	    is_drag;		\/* Is it a mouse drag event? *\/$/;"	m	struct:mousetable	file:
is_etag	tag.c	/^    int		is_etag;	\/* TRUE for emacs tag *\/$/;"	m	struct:tag_pointers	file:
is_oneChar	ops.c	/^    int		is_oneChar;	\/* TRUE if block within one character *\/$/;"	m	struct:block_def	file:
is_qf_win	quickfix.c	/^is_qf_win(win, qi)$/;"	f	file:
is_short	ops.c	/^    int		is_short;	\/* TRUE if line is too short to fit in block *\/$/;"	m	struct:block_def	file:
istermoption	option.c	/^istermoption(p)$/;"	f	file:
ital_font	gui.h	/^    GuiFont	ital_font;	    \/* Italic font *\/$/;"	m	struct:Gui
italic	structs.h	/^    int		italic;$/;"	m	struct:__anon99
item_compare	eval.c	/^item_compare(s1, s2)$/;"	f	file:
item_compare2	eval.c	/^item_compare2(s1, s2)$/;"	f	file:
item_compare_func	eval.c	/^static char_u	*item_compare_func;$/;"	v	file:
item_compare_func_err	eval.c	/^static int	item_compare_func_err;$/;"	v	file:
item_compare_ic	eval.c	/^static int	item_compare_ic;$/;"	v	file:
item_copy	eval.c	/^item_copy(from, to, deep, copyID)$/;"	f	file:
item_lock	eval.c	/^item_lock(tv, deep, lock)$/;"	f	file:
j_charsets	hardcopy.c	/^static struct prt_ps_charset_S j_charsets[] =$/;"	v	typeref:struct:prt_ps_charset_S	file:
j_encodings	hardcopy.c	/^static struct prt_ps_encoding_S j_encodings[] =$/;"	v	typeref:struct:prt_ps_encoding_S	file:
jobname	structs.h	/^    char_u	*jobname;$/;"	m	struct:__anon100
johab_fcon_to_wan	hangulin.c	/^static const char_u johab_fcon_to_wan[] =$/;"	v	file:
johab_lcon_to_wan	hangulin.c	/^static const char_u johab_lcon_to_wan[] =$/;"	v	file:
johab_vow_to_wan	hangulin.c	/^static const char_u johab_vow_to_wan[] =$/;"	v	file:
jumpProc	gui_at_sb.h	/^    XtCallbackList jumpProc;	\/* same as thumbProc but pass data by ref *\/$/;"	m	struct:__anon64
jump_to_mouse	ui.c	/^jump_to_mouse(flags, inclusive, which_button)$/;"	f
jumpto_tag	tag.c	/^jumpto_tag(lbuf, forceit, keep_help)$/;"	f	file:
k_charsets	hardcopy.c	/^static struct prt_ps_charset_S k_charsets[] =$/;"	v	typeref:struct:prt_ps_charset_S	file:
k_encodings	hardcopy.c	/^static struct prt_ps_encoding_S k_encodings[] =$/;"	v	typeref:struct:prt_ps_encoding_S	file:
k_syn	structs.h	/^    struct sp_syn k_syn;	\/* struct passed to in_id_list() *\/$/;"	m	struct:keyentry	typeref:struct:keyentry::sp_syn
ke_next	structs.h	/^    keyentry_T	*ke_next;	\/* next entry with identical "keyword[]" *\/$/;"	m	struct:keyentry
keep_filetype	globals.h	/^EXTERN int	keep_filetype INIT(= FALSE);	\/* value for did_filetype when$/;"	v
keep_help_flag	globals.h	/^EXTERN int	keep_help_flag INIT(= FALSE); \/* doing :ta from help file *\/$/;"	v
keep_msg	globals.h	/^EXTERN char_u	*keep_msg INIT(= NULL);	    \/* msg to be shown after redraw *\/$/;"	v
keep_msg_attr	globals.h	/^EXTERN int	keep_msg_attr INIT(= 0);    \/* highlight attr for keep_msg *\/$/;"	v
keep_msg_more	globals.h	/^EXTERN int	keep_msg_more INIT(= FALSE); \/* keep_msg was set by msgmore() *\/$/;"	v
keepalt	structs.h	/^    int		keepalt;		\/* TRUE when ":keepalt" was used *\/$/;"	m	struct:__anon83
keepend_level	syntax.c	/^static int keepend_level = -1;$/;"	v	file:
keepjumps	structs.h	/^    int		keepjumps;		\/* TRUE when ":keepjumps" was used *\/$/;"	m	struct:__anon83
keepmarks	structs.h	/^    int		keepmarks;		\/* TRUE when ":keepmarks" was used *\/$/;"	m	struct:__anon83
key	misc2.c	/^    int	    key;	\/* Special key code or ascii value *\/$/;"	m	struct:key_name_entry	file:
key	netbeans.c	/^    int		     key;$/;"	m	struct:keyqueue	file:
keyHead	netbeans.c	/^static keyQ_T keyHead; \/* dummy node, header for circular queue *\/$/;"	v	file:
keyQ_T	netbeans.c	/^typedef struct keyqueue keyQ_T;$/;"	t	typeref:struct:keyqueue	file:
key_event	gui_beval.c	/^key_event(BalloonEval *beval, unsigned keyval, int is_keypress)$/;"	f	file:
key_extra	keymap.h	/^enum key_extra$/;"	g
key_name_entry	misc2.c	/^static struct key_name_entry$/;"	s	file:
key_names	term.c	/^static char *(key_names[]) =$/;"	v	file:
key_names_table	misc2.c	/^} key_names_table[] =$/;"	v	typeref:struct:key_name_entry	file:
key_press_event	gui_gtk_x11.c	/^key_press_event(GtkWidget *widget, GdkEventKey *event, gpointer data)$/;"	f	file:
key_press_event_queue	mbyte.c	/^static GSList *key_press_event_queue = NULL;$/;"	v	file:
key_release_event	gui_gtk_x11.c	/^key_release_event(GtkWidget *widget, GdkEventKey *event, gpointer data)$/;"	f	file:
key_sym	gui_gtk_x11.c	/^    guint key_sym;$/;"	m	struct:special_key	file:
key_sym	gui_x11.c	/^    KeySym  key_sym;$/;"	m	struct:specialkey	file:
keyentry	structs.h	/^struct keyentry$/;"	s
keyentry_T	structs.h	/^typedef struct keyentry keyentry_T;$/;"	t	typeref:struct:keyentry
keyhit_callback	gui_athena.c	/^keyhit_callback(w, client_data, event, cont)$/;"	f	file:
keyhit_callback	gui_motif.c	/^keyhit_callback(w, client_data, event, cont)$/;"	f	file:
keymap_init	digraph.c	/^keymap_init()$/;"	f
keymap_unload	digraph.c	/^keymap_unload()$/;"	f	file:
keyqueue	netbeans.c	/^struct keyqueue$/;"	s	file:
keys	misc2.c	/^static ulg keys[3]; \/* keys defining the pseudo-random sequence *\/$/;"	v	file:
keyval_to_string	gui_gtk_x11.c	/^keyval_to_string(unsigned int keyval, unsigned int state, char_u *string)$/;"	f	file:
keyword	structs.h	/^    char_u	keyword[1];	\/* actually longer *\/$/;"	m	struct:keyentry
keyword	syntax.c	/^    int		keyword;	\/* TRUE for ":syn keyword" *\/$/;"	m	struct:__anon58	file:
kind_table_for_2	hangulin.c	/^kind_table_for_2(c)$/;"	f	file:
kind_table_for_3	hangulin.c	/^static short_u kind_table_for_3[] =$/;"	v	file:
km_startsel	globals.h	/^EXTERN int	km_startsel INIT(= FALSE);$/;"	v
km_stopsel	globals.h	/^EXTERN int	km_stopsel INIT(= FALSE);$/;"	v
kmap_T	digraph.c	/^} kmap_T;$/;"	t	typeref:struct:__anon1	file:
ks_table1	hangulin.c	/^static const char_u ks_table1[][3] =$/;"	v	file:
ks_table2	hangulin.c	/^static const unsigned short ks_table2[][4] =$/;"	v	file:
ksmd_str	term.c	/^static char ksmd_str[20];$/;"	v	file:
ksme_str	term.c	/^static char ksme_str[20];$/;"	v	file:
ksmr_str	term.c	/^static char ksmr_str[20];$/;"	v	file:
l	hangulin.c	/^static int f=F_NULL, m=M_NULL, l=L_NULL;$/;"	v	file:
l_avars	eval.c	/^    dict_T	l_avars;	\/* a: argument variables *\/$/;"	m	struct:funccall_S	file:
l_avars_var	eval.c	/^    dictitem_T	l_avars_var;	\/* variable for a: scope *\/$/;"	m	struct:funccall_S	file:
l_listitems	eval.c	/^    listitem_T	l_listitems[MAX_FUNC_ARGS];	\/* listitems for a:000 *\/$/;"	m	struct:funccall_S	file:
l_varlist	eval.c	/^    list_T	l_varlist;	\/* list for a:000 *\/$/;"	m	struct:funccall_S	file:
l_vars	eval.c	/^    dict_T	l_vars;		\/* l: local function variables *\/$/;"	m	struct:funccall_S	file:
l_vars_var	eval.c	/^    dictitem_T	l_vars_var;	\/* variable for l: scope *\/$/;"	m	struct:funccall_S	file:
label	gui_xmebwp.h	/^    XmLabelPart label;$/;"	m	struct:_XmEnhancedButtonRec
label	structs.h	/^    GtkWidget   *label;		    \/* Used by "set wak=" code. *\/$/;"	m	struct:VimMenu
label_class	gui_xmebwp.h	/^    XmLabelClassPart label_class;$/;"	m	struct:__anon67
label_expose	gui_motif.c	/^label_expose(_w, _event, _region)$/;"	f	file:
label_location	gui_xmebwp.h	/^    int label_location;$/;"	m	struct:_XmEnhancedButtonPart
lalloc	misc2.c	/^lalloc(size, message)$/;"	f
lalloc_clear	misc2.c	/^lalloc_clear(size, message)$/;"	f
langmap_init	option.c	/^langmap_init()$/;"	f	file:
langmap_mapchar	globals.h	/^EXTERN char_u	langmap_mapchar[256];	\/* mapping for language keys *\/$/;"	v
langmap_set	option.c	/^langmap_set()$/;"	f	file:
langp_S	spell.c	/^typedef struct langp_S$/;"	s	file:
langp_T	spell.c	/^} langp_T;$/;"	t	typeref:struct:langp_S	file:
last	fileio.c	/^    char	    last;		\/* last command in list *\/$/;"	m	struct:AutoCmd	file:
last	fileio.c	/^    char	    last;		\/* last pattern for apply_autocmds() *\/$/;"	m	struct:AutoPat	file:
last	mbyte.c	/^    unsigned short last;$/;"	m	struct:interval	file:
last_breakp	ex_cmds2.c	/^static int last_breakp = 0;	\/* nr of last defined breakpoint *\/$/;"	v	file:
last_cmdline	globals.h	/^EXTERN char_u	*last_cmdline INIT(= NULL); \/* last command line (for ":) *\/$/;"	v
last_cursormoved	globals.h	/^EXTERN pos_T	last_cursormoved	    \/* for CursorMoved event *\/$/;"	v
last_event	fileio.c	/^static event_T	last_event;$/;"	v	file:
last_group	fileio.c	/^static int	last_group;$/;"	v	file:
last_idx	search.c	/^static int last_idx = 0;	\/* index in spats[] for RE_LAST *\/$/;"	v	file:
last_insert	edit.c	/^static char_u	*last_insert = NULL;	\/* the text of the previous insert,$/;"	v	file:
last_insert_skip	edit.c	/^static int	last_insert_skip; \/* nr of chars in front of previous insert *\/$/;"	v	file:
last_l	hangulin.c	/^static int last_l = -1, last_ll = -1;$/;"	v	file:
last_ll	hangulin.c	/^static int last_l = -1, last_ll = -1;$/;"	v	file:
last_maptick	ex_getln.c	/^static int	last_maptick = -1;	\/* last seen maptick *\/$/;"	v	file:
last_matchgroup	syntax.c	/^static int  last_matchgroup;$/;"	v	file:
last_mouse_event	gui_x11.c	/^static XButtonPressedEvent last_mouse_event;$/;"	v	file:
last_msg_hist	message.c	/^static struct msg_hist *last_msg_hist = NULL;$/;"	v	typeref:struct:msg_hist	file:
last_msgchunk	message.c	/^static msgchunk_T *last_msgchunk = NULL; \/* last displayed text *\/$/;"	v	file:
last_pat_prog	search.c	/^last_pat_prog(regmatch)$/;"	f
last_recorded_len	getchar.c	/^static int	last_recorded_len = 0;	\/* number of last recorded chars *\/$/;"	v	file:
last_search_pat	search.c	/^last_search_pat()$/;"	f
last_set_msg	eval.c	/^last_set_msg(scriptID)$/;"	f
last_shape	gui_gtk_x11.c	/^static int last_shape = 0;$/;"	v	file:
last_shape	gui_x11.c	/^static int last_shape = 0;$/;"	v	file:
last_sign_typenr	ex_cmds.c	/^static int	last_sign_typenr = MAX_TYPENR;	\/* is decremented *\/$/;"	v	file:
last_sourcing_lnum	message.c	/^static int	last_sourcing_lnum = 0;$/;"	v	file:
last_sourcing_name	message.c	/^static char_u   *last_sourcing_name = NULL;$/;"	v	file:
last_status	window.c	/^last_status(morewin)$/;"	f
last_status_rec	window.c	/^last_status_rec(fr, statusline)$/;"	f	file:
last_window	window.c	/^last_window()$/;"	f	file:
lastbuf	globals.h	/^EXTERN buf_T	*lastbuf INIT(= NULL);	\/* last buffer *\/$/;"	v
lasticon	buffer.c	/^static char_u *lasticon = NULL;$/;"	v	file:
lastmark	undo.c	/^static int lastmark = 0;$/;"	v	file:
lasttitle	buffer.c	/^static char_u *lasttitle = NULL;$/;"	v	file:
lastwin	globals.h	/^# define lastwin /;"	d
lastwin	globals.h	/^EXTERN win_T	*lastwin;		\/* last window *\/$/;"	v
latin1flags	charset.c	/^static char_u latin1flags[257] = "                                                                 UUUUUUUUUUUUUUUUUUUUUUUUUU      llllllllllllllllllllllllll                                                                     UUUUUUUUUUUUUUUUUUUUUUU UUUUUUUllllllllllllllllllllllll llllllll";$/;"	v	file:
latin1lower	charset.c	/^static char_u latin1lower[257] = "                                 !\\"#$%&'()*+,-.\/0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";$/;"	v	file:
latin1upper	charset.c	/^static char_u latin1upper[257] = "                                 !\\"#$%&'()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~";$/;"	v	file:
latin_char2bytes	mbyte.c	/^latin_char2bytes(c, buf)$/;"	f
latin_char2cells	mbyte.c	/^latin_char2cells(c)$/;"	f
latin_char2len	mbyte.c	/^latin_char2len(c)$/;"	f
latin_head_off	mbyte.c	/^latin_head_off(base, p)$/;"	f
latin_off2cells	mbyte.c	/^latin_off2cells(off, max_off)$/;"	f
latin_ptr2cells	mbyte.c	/^latin_ptr2cells(p)$/;"	f
latin_ptr2char	mbyte.c	/^latin_ptr2char(p)$/;"	f
latin_ptr2len	mbyte.c	/^latin_ptr2len(p)$/;"	f
lbase	if_tcl.c	/^    int lbase;$/;"	m	struct:__anon37	file:
lbr_chartabsize	charset.c	/^lbr_chartabsize(s, col)$/;"	f
lbr_chartabsize_adv	charset.c	/^lbr_chartabsize_adv(s, col)$/;"	f
lc_active	globals.h	/^EXTERN int lc_active INIT(= FALSE); \/* TRUE when lc_jump_env is valid. *\/$/;"	v
lc_jump_env	globals.h	/^EXTERN JMP_BUF lc_jump_env;	\/* argument to SETJMP() *\/$/;"	v
lc_signal	globals.h	/^EXTERN int lc_signal;		\/* catched signal number, 0 when no was signal$/;"	v
lcon	hangulin.c	/^lcon(c)$/;"	f	file:
lcs_eol	globals.h	/^EXTERN int	lcs_eol INIT(= '$');$/;"	v
lcs_ext	globals.h	/^EXTERN int	lcs_ext INIT(= NUL);$/;"	v
lcs_nbsp	globals.h	/^EXTERN int	lcs_nbsp INIT(= NUL);$/;"	v
lcs_prec	globals.h	/^EXTERN int	lcs_prec INIT(= NUL);$/;"	v
lcs_tab1	globals.h	/^EXTERN int	lcs_tab1 INIT(= NUL);$/;"	v
lcs_tab2	globals.h	/^EXTERN int	lcs_tab2 INIT(= NUL);$/;"	v
lcs_trail	globals.h	/^EXTERN int	lcs_trail INIT(= NUL);$/;"	v
lead_spaces	hardcopy.c	/^    int		lead_spaces;	    \/* remaining spaces for a TAB *\/$/;"	m	struct:__anon20	file:
leave_cleanup	ex_eval.c	/^leave_cleanup(csp)$/;"	f
leave_notify_event	gui_gtk_x11.c	/^leave_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)$/;"	f	file:
leave_tabpage	window.c	/^leave_tabpage(new_curbuf)$/;"	f	file:
left_sbar_x	gui.h	/^    int		left_sbar_x;	    \/* Calculated x coord for left scrollbar *\/$/;"	m	struct:Gui
leftcol_changed	misc2.c	/^leftcol_changed()$/;"	f
len	hardcopy.c	/^    int		len;$/;"	m	struct:prt_dsc_comment_S	file:
len	hardcopy.c	/^    int		len;$/;"	m	struct:prt_dsc_line_S	file:
len	hardcopy.c	/^    int     len;$/;"	m	struct:prt_resfile_buffer_S	file:
len	tag.c	/^    int		len;		\/* length of pat[] *\/$/;"	m	struct:__anon60	file:
len	term.c	/^    int	    len;	    \/* STRLEN(code) *\/$/;"	m	struct:termcode	file:
length	gui_at_sb.h	/^    Dimension	  length;	\/* either height or width *\/$/;"	m	struct:__anon64
level	eval.c	/^    int		level;		\/* top nesting level of executed function *\/$/;"	m	struct:funccall_S	file:
level	ex_cmds2.c	/^    int		level;		\/* top nesting level of sourced file *\/$/;"	m	struct:source_cookie	file:
li_next	structs.h	/^    listitem_T	*li_next;	\/* next item in list *\/$/;"	m	struct:listitem_S
li_prev	structs.h	/^    listitem_T	*li_prev;	\/* previous item in list *\/$/;"	m	struct:listitem_S
li_tv	structs.h	/^    typval_T	li_tv;		\/* type and value of the variable *\/$/;"	m	struct:listitem_S
libcall_common	eval.c	/^libcall_common(argvars, rettv, type)$/;"	f	file:
limit_pos	syntax.c	/^limit_pos(pos, limit)$/;"	f	file:
limit_pos_zero	syntax.c	/^limit_pos_zero(pos, limit)$/;"	f	file:
limit_thumb	gui_at_sb.h	/^    Bool	limit_thumb;	\/* limit thumb to inside scrollbar *\/$/;"	m	struct:__anon64
limitscore_T	spell.c	/^} limitscore_T;$/;"	t	typeref:struct:__anon57	file:
line	ex_docmd.c	/^    char_u	*line;		\/* command line *\/$/;"	m	struct:__anon9	file:
line	search.c	/^    int		line;		\/* search has line offset *\/$/;"	m	struct:soffset	file:
line1	ex_cmds.h	/^    linenr_T	line1;		\/* the first line number *\/$/;"	m	struct:exarg
line1	spell.c	/^static char line1[PRINTLINESIZE];$/;"	v	file:
line2	ex_cmds.h	/^    linenr_T	line2;		\/* the second line number or count *\/$/;"	m	struct:exarg
line2	spell.c	/^static char line2[PRINTLINESIZE];$/;"	v	file:
line3	spell.c	/^static char line3[PRINTLINESIZE];$/;"	v	file:
lineFolded	fold.c	/^lineFolded(win, lnum)$/;"	f
line_breakcheck	misc1.c	/^line_breakcheck()$/;"	f
line_count	structs.h	/^    long	line_count;	\/* number of lines from op_start to op_end$/;"	m	struct:oparg_S
line_count_info	ops.c	/^line_count_info(line, wc, cc, limit, eol_size)$/;"	f	file:
line_end	hardcopy.c	/^    int     line_end;$/;"	m	struct:prt_resfile_buffer_S	file:
line_in_range	if_mzsch.c	/^line_in_range(linenr_T lnum, buf_T *buf)$/;"	f	file:
line_s_current	if_ruby.c	/^static VALUE line_s_current()$/;"	f	file:
line_start	hardcopy.c	/^    int     line_start;$/;"	m	struct:prt_resfile_buffer_S	file:
lineclear	screen.c	/^lineclear(off, width)$/;"	f	file:
linecopy	screen.c	/^linecopy(to, from, wp)$/;"	f	file:
lineempty	macros.h	/^#define lineempty(/;"	d
lineinvalid	screen.c	/^lineinvalid(off, width)$/;"	f	file:
linelen	ex_cmds.c	/^linelen(has_tab)$/;"	f	file:
linenr	eval.c	/^    int		linenr;		\/* next line to be executed *\/$/;"	m	struct:funccall_S	file:
linenr_T	structs.h	/^typedef long		linenr_T;$/;"	t
linenr_T	vim.h	/^typedef long	    linenr_T;		\/* line number type *\/$/;"	t
lineoff_T	move.c	/^} lineoff_T;$/;"	t	typeref:struct:__anon44	file:
lines_gap	ex_docmd.c	/^    garray_T	*lines_gap;		\/* growarray with line info *\/$/;"	m	struct:loop_cookie	file:
lines_left	globals.h	/^EXTERN int	lines_left INIT(= -1);	    \/* lines left for listing *\/$/;"	v
lines_per_page	structs.h	/^    int		lines_per_page;$/;"	m	struct:__anon100
linetabsize	charset.c	/^linetabsize(s)$/;"	f
linewhite	search.c	/^linewhite(lnum)$/;"	f
lisp_match	misc1.c	/^lisp_match(p)$/;"	f	file:
list	gui_xmdlg.c	/^    Widget	list[NONE];$/;"	m	struct:_SharedFontSelData	file:
list2fpos	eval.c	/^list2fpos(arg, posp, fnump)$/;"	f	file:
list2proftime	eval.c	/^list2proftime(arg, tm)$/;"	f	file:
list2string	eval.c	/^list2string(tv, copyID)$/;"	f	file:
list_T	structs.h	/^typedef struct listvar_S list_T;$/;"	t	typeref:struct:listvar_S
list_add_watch	eval.c	/^list_add_watch(l, lw)$/;"	f	file:
list_alloc	eval.c	/^list_alloc()$/;"	f
list_append	eval.c	/^list_append(l, item)$/;"	f	file:
list_append_dict	eval.c	/^list_append_dict(list, dict)$/;"	f
list_append_number	eval.c	/^list_append_number(l, n)$/;"	f	file:
list_append_string	eval.c	/^list_append_string(l, str, len)$/;"	f	file:
list_append_tv	eval.c	/^list_append_tv(l, tv)$/;"	f	file:
list_arg_vars	eval.c	/^list_arg_vars(eap, arg, first)$/;"	f	file:
list_buf_vars	eval.c	/^list_buf_vars(first)$/;"	f	file:
list_concat	eval.c	/^list_concat(l1, l2, tv)$/;"	f	file:
list_copy	eval.c	/^list_copy(orig, deep, copyID)$/;"	f	file:
list_equal	eval.c	/^list_equal(l1, l2, ic)$/;"	f	file:
list_extend	eval.c	/^list_extend(l1, l2, bef)$/;"	f	file:
list_find	eval.c	/^list_find(l, n)$/;"	f	file:
list_find_nr	eval.c	/^list_find_nr(l, idx, errorp)$/;"	f	file:
list_fix_watch	eval.c	/^list_fix_watch(l, item)$/;"	f	file:
list_free	eval.c	/^list_free(l, recurse)$/;"	f
list_func_head	eval.c	/^list_func_head(fp, indent)$/;"	f	file:
list_func_vars	eval.c	/^list_func_vars(first)$/;"	f	file:
list_glob_vars	eval.c	/^list_glob_vars(first)$/;"	f	file:
list_hashtable_vars	eval.c	/^list_hashtable_vars(ht, prefix, empty, first)$/;"	f	file:
list_idx_of_item	eval.c	/^list_idx_of_item(l, item)$/;"	f	file:
list_insert_tv	eval.c	/^list_insert_tv(l, tv, item)$/;"	f	file:
list_join	eval.c	/^list_join(gap, l, sep, echo, copyID)$/;"	f	file:
list_len	eval.c	/^list_len(l)$/;"	f	file:
list_one_var	eval.c	/^list_one_var(v, prefix, first)$/;"	f	file:
list_one_var_a	eval.c	/^list_one_var_a(prefix, name, type, string, first)$/;"	f	file:
list_rem_watch	eval.c	/^list_rem_watch(l, lwrem)$/;"	f	file:
list_remove	eval.c	/^list_remove(l, item, item2)$/;"	f	file:
list_script_vars	eval.c	/^list_script_vars(first)$/;"	f	file:
list_tab_vars	eval.c	/^list_tab_vars(first)$/;"	f	file:
list_unref	eval.c	/^list_unref(l)$/;"	f
list_version	version.c	/^list_version()$/;"	f
list_vim_vars	eval.c	/^list_vim_vars(first)$/;"	f	file:
list_win_vars	eval.c	/^list_win_vars(first)$/;"	f	file:
listcmd_busy	globals.h	/^EXTERN int	listcmd_busy INIT(= FALSE); \/* set when :argdo, :windo or$/;"	v
listdigraphs	digraph.c	/^listdigraphs()$/;"	f
listitem_S	structs.h	/^struct listitem_S$/;"	s
listitem_T	structs.h	/^typedef struct listitem_S listitem_T;$/;"	t	typeref:struct:listitem_S
listitem_alloc	eval.c	/^listitem_alloc()$/;"	f	file:
listitem_free	eval.c	/^listitem_free(item)$/;"	f	file:
listitem_remove	eval.c	/^listitem_remove(l, item)$/;"	f	file:
listvar_S	structs.h	/^struct listvar_S$/;"	s
listwatch_S	structs.h	/^struct listwatch_S$/;"	s
listwatch_T	structs.h	/^typedef struct listwatch_S listwatch_T;$/;"	t	typeref:struct:listwatch_S
literal	main.c	/^    int		literal;		\/* don't expand file names *\/$/;"	m	struct:__anon39	file:
ll_di	eval.c	/^    dictitem_T	*ll_di;		\/* The dictitem or NULL *\/$/;"	m	struct:lval_S	file:
ll_dict	eval.c	/^    dict_T	*ll_dict;	\/* The Dictionary or NULL *\/$/;"	m	struct:lval_S	file:
ll_empty2	eval.c	/^    int		ll_empty2;	\/* Second index is empty: [i:] *\/$/;"	m	struct:lval_S	file:
ll_exp_name	eval.c	/^    char_u	*ll_exp_name;	\/* NULL or expanded name in allocated memory. *\/$/;"	m	struct:lval_S	file:
ll_free_all	quickfix.c	/^ll_free_all(pqi)$/;"	f	file:
ll_get_or_alloc_list	quickfix.c	/^ll_get_or_alloc_list(wp)$/;"	f	file:
ll_li	eval.c	/^    listitem_T	*ll_li;		\/* The list item or NULL. *\/$/;"	m	struct:lval_S	file:
ll_list	eval.c	/^    list_T	*ll_list;	\/* The list or NULL. *\/$/;"	m	struct:lval_S	file:
ll_n1	eval.c	/^    long	ll_n1;		\/* First index for list *\/$/;"	m	struct:lval_S	file:
ll_n2	eval.c	/^    long	ll_n2;		\/* Second index for list range *\/$/;"	m	struct:lval_S	file:
ll_name	eval.c	/^    char_u	*ll_name;	\/* start of variable name (can be NULL) *\/$/;"	m	struct:lval_S	file:
ll_new_list	quickfix.c	/^ll_new_list()$/;"	f	file:
ll_newkey	eval.c	/^    char_u	*ll_newkey;	\/* New key for Dict in alloc. mem or NULL. *\/$/;"	m	struct:lval_S	file:
ll_range	eval.c	/^    int		ll_range;	\/* TRUE when a [i:j] range was used *\/$/;"	m	struct:lval_S	file:
ll_tv	eval.c	/^    typval_T	*ll_tv;		\/* Typeval of item being used.  If "newkey"$/;"	m	struct:lval_S	file:
lnum	ex_cmds.c	/^    linenr_T	lnum;			\/* line number *\/$/;"	m	struct:__anon8	file:
lnum	ex_docmd.c	/^    linenr_T	lnum;		\/* sourcing_lnum of the line *\/$/;"	m	struct:__anon9	file:
lnum	fold.c	/^    linenr_T	lnum;		\/* current line number *\/$/;"	m	struct:__anon12	file:
lnum	move.c	/^    linenr_T	    lnum;	\/* line number *\/$/;"	m	struct:__anon44	file:
lnum	search.c	/^    linenr_T	lnum;		\/* Line we were up to in file *\/$/;"	m	struct:SearchedFile	file:
lnum	structs.h	/^    linenr_T	lnum;		\/* line number which has this sign *\/$/;"	m	struct:signlist
lnum	structs.h	/^    linenr_T	lnum;	\/* line number *\/$/;"	m	struct:__anon79
lnum	structs.h	/^    linenr_T	lnum;	\/* line number *\/$/;"	m	struct:__anon80
lnum	structs.h	/^    linenr_T	lnum;	\/* the line to search for a match *\/$/;"	m	struct:__anon96
lnum_save	fold.c	/^    linenr_T	lnum_save;	\/* line nr used by foldUpdateIEMSRecurse() *\/$/;"	m	struct:__anon12	file:
load_buffer_by_name	workshop.c	/^load_buffer_by_name($/;"	f	file:
load_colors	syntax.c	/^load_colors(name)$/;"	f
load_current_state	syntax.c	/^load_current_state(from)$/;"	f	file:
load_dummy_buffer	quickfix.c	/^load_dummy_buffer(fname)$/;"	f	file:
load_menu_iconfile	gui_gtk.c	/^load_menu_iconfile(char_u *name, GtkIconSize icon_size)$/;"	f	file:
load_window	workshop.c	/^load_window($/;"	f	file:
local_xsmp_handle_requests	gui_gtk_x11.c	/^local_xsmp_handle_requests(source, condition, data)$/;"	f	file:
local_xsmp_handle_requests	gui_x11.c	/^local_xsmp_handle_requests(c, s, i)$/;"	f	file:
lockmarks	structs.h	/^    int		lockmarks;		\/* TRUE when ":lockmarks" was used *\/$/;"	m	struct:__anon83
longVersion	version.c	/^char	*longVersion = VIM_VERSION_LONG;$/;"	v
longVersion	version.c	/^char	*longVersion = VIM_VERSION_LONG_DATE __DATE__ " " __TIME__ ")";$/;"	v
longVersion	version.c	/^char	longVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)$/;"	v
long_i	vim.h	/^typedef		 __int64        long_i;$/;"	t
long_i	vim.h	/^typedef		 long __w64     long_i;$/;"	t
long_to_char	memline.c	/^long_to_char(n, s)$/;"	f	file:
long_u	vim.h	/^typedef unsigned __int64        long_u;$/;"	t
long_u	vim.h	/^typedef unsigned long __w64	long_u;$/;"	t
longest_lnum	gui.c	/^static linenr_T longest_lnum = 0;$/;"	v	file:
lookup	nbdebug.c	/^lookup($/;"	f	file:
lookup	wsdebug.c	/^lookup($/;"	f	file:
lookupVerb	workshop.c	/^lookupVerb($/;"	f	file:
lookup_menu_iconfile	gui_gtk.c	/^lookup_menu_iconfile(char_u *iconfile, char_u *dest)$/;"	f	file:
loop_cookie	ex_docmd.c	/^struct loop_cookie$/;"	s	file:
lowest_marked	memline.c	/^static linenr_T	lowest_marked = 0;$/;"	v	file:
lp_region	spell.c	/^    int		lp_region;	\/* bitmask for region or REGION_ALL *\/$/;"	m	struct:langp_S	file:
lp_replang	spell.c	/^    slang_T	*lp_replang;	\/* language used for REP items or NULL *\/$/;"	m	struct:langp_S	file:
lp_sallang	spell.c	/^    slang_T	*lp_sallang;	\/* language used for sound folding or NULL *\/$/;"	m	struct:langp_S	file:
lp_slang	spell.c	/^    slang_T	*lp_slang;	\/* info for this language *\/$/;"	m	struct:langp_S	file:
lpos_T	structs.h	/^} lpos_T;$/;"	t	typeref:struct:__anon80
lrF_sub	farsi.c	/^lrF_sub(ibuf)$/;"	f
lrFswap	farsi.c	/^lrFswap(cmdbuf, len)$/;"	f
lrswap	farsi.c	/^lrswap(ibuf)$/;"	f
lrswapbuf	farsi.c	/^lrswapbuf(buf, len)$/;"	f	file:
lt	macros.h	/^# define lt(/;"	d
ltoreq	macros.h	/^#define ltoreq(/;"	d
ltp	macros.h	/^# define ltp(/;"	d
lv_copyID	structs.h	/^    int		lv_copyID;	\/* ID used by deepcopy() *\/$/;"	m	struct:listvar_S
lv_copylist	structs.h	/^    list_T	*lv_copylist;	\/* copied list used by deepcopy() *\/$/;"	m	struct:listvar_S
lv_first	structs.h	/^    listitem_T	*lv_first;	\/* first item, NULL if none *\/$/;"	m	struct:listvar_S
lv_idx	structs.h	/^    int		lv_idx;		\/* cached index of an item *\/$/;"	m	struct:listvar_S
lv_idx_item	structs.h	/^    listitem_T	*lv_idx_item;	\/* when not NULL item at index "lv_idx" *\/$/;"	m	struct:listvar_S
lv_last	structs.h	/^    listitem_T	*lv_last;	\/* last item, NULL if none *\/$/;"	m	struct:listvar_S
lv_len	structs.h	/^    int		lv_len;		\/* number of items *\/$/;"	m	struct:listvar_S
lv_lock	structs.h	/^    char	lv_lock;	\/* zero, VAR_LOCKED, VAR_FIXED *\/$/;"	m	struct:listvar_S
lv_refcount	structs.h	/^    int		lv_refcount;	\/* reference count *\/$/;"	m	struct:listvar_S
lv_used_next	structs.h	/^    list_T	*lv_used_next;	\/* next list in used lists list *\/$/;"	m	struct:listvar_S
lv_used_prev	structs.h	/^    list_T	*lv_used_prev;	\/* previous list in used lists list *\/$/;"	m	struct:listvar_S
lv_watch	structs.h	/^    listwatch_T	*lv_watch;	\/* first watcher, NULL if none *\/$/;"	m	struct:listvar_S
lval_S	eval.c	/^typedef struct lval_S$/;"	s	file:
lval_T	eval.c	/^} lval_T;$/;"	t	typeref:struct:lval_S	file:
lvl	fold.c	/^    int		lvl;		\/* current level (-1 for undefined) *\/$/;"	m	struct:__anon12	file:
lvl_next	fold.c	/^    int		lvl_next;	\/* level used for next line *\/$/;"	m	struct:__anon12	file:
lw_item	structs.h	/^    listitem_T		*lw_item;	\/* item being watched *\/$/;"	m	struct:listwatch_S
lw_next	structs.h	/^    listwatch_T		*lw_next;	\/* next watcher *\/$/;"	m	struct:listwatch_S
m	hangulin.c	/^static int f=F_NULL, m=M_NULL, l=L_NULL;$/;"	v	file:
mVIM	if_ruby.c	/^static VALUE mVIM;$/;"	v	file:
m_block	structs.h	/^struct m_block$/;"	s
m_expr	structs.h	/^    char	m_expr;		\/* <expr> used, m_str is an expression *\/$/;"	m	struct:mapblock
m_info	structs.h	/^struct m_info$/;"	s
m_keylen	structs.h	/^    int		m_keylen;	\/* strlen(m_keys) *\/$/;"	m	struct:mapblock
m_keys	structs.h	/^    char_u	*m_keys;	\/* mapped from *\/$/;"	m	struct:mapblock
m_mode	structs.h	/^    int		m_mode;		\/* valid mode *\/$/;"	m	struct:mapblock
m_next	structs.h	/^    mapblock_T	*m_next;	\/* next mapblock in list *\/$/;"	m	struct:mapblock
m_next	structs.h	/^    minfo_T	*m_next;	\/* pointer to next free chunk in the list *\/$/;"	m	struct:m_info
m_noremap	structs.h	/^    int		m_noremap;	\/* if non-zero no re-mapping for m_str *\/$/;"	m	struct:mapblock
m_onlyone	window.c	/^static char *m_onlyone = N_("Already only one window");$/;"	v	file:
m_script_ID	structs.h	/^    scid_T	m_script_ID;	\/* ID of script where map was defined *\/$/;"	m	struct:mapblock
m_silent	structs.h	/^    char	m_silent;	\/* <silent> used, don't echo commands *\/$/;"	m	struct:mapblock
m_size	structs.h	/^    long_u	m_size;		\/* size of the chunk (including m_info) *\/$/;"	m	struct:m_info
m_str	structs.h	/^    char_u	*m_str;		\/* mapped to *\/$/;"	m	struct:mapblock
magic	search.c	/^    int		    magic;	\/* magicness of the pattern *\/$/;"	m	struct:spat	file:
magick	gui_gtk_x11.c	/^# undef magick$/;"	d	file:
magick	gui_gtk_x11.c	/^#define magick /;"	d	file:
magick	gui_gtk_x11.c	/^#undef magick$/;"	d	file:
main	if_python.c	/^#undef main /;"	d	file:
main_errors	main.c	/^static char *(main_errors[]) =$/;"	v	file:
main_loop	main.c	/^main_loop(cmdwin, noexmode)$/;"	f
main_msg	main.c	/^main_msg(s)$/;"	f	file:
main_start_gui	main.c	/^main_start_gui()$/;"	f	file:
mainerr	main.c	/^mainerr(n, str)$/;"	f	file:
mainerr_arg_missing	main.c	/^mainerr_arg_missing(str)$/;"	f
mainwin	gui.h	/^    GtkWidget	*mainwin;	    \/* top level GTK window *\/$/;"	m	struct:Gui
mainwin_destroy_cb	gui_gtk_x11.c	/^mainwin_destroy_cb(GtkObject *object, gpointer data)$/;"	f	file:
mainwin_event_cb	gui_beval.c	/^mainwin_event_cb(GtkWidget *widget, GdkEvent *event, gpointer data)$/;"	f	file:
mainwin_realize	gui_gtk_x11.c	/^mainwin_realize(GtkWidget *widget, gpointer data)$/;"	f	file:
mainwin_screen_changed_cb	gui_gtk_x11.c	/^mainwin_screen_changed_cb(GtkWidget  *widget,$/;"	f	file:
make_bom	fileio.c	/^make_bom(buf, name)$/;"	f	file:
make_case_word	spell.c	/^make_case_word(fword, cword, flags)$/;"	f	file:
make_connection	eval.c	/^make_connection()$/;"	f	file:
make_crc_tab	misc2.c	/^make_crc_tab()$/;"	f	file:
make_expanded_name	eval.c	/^make_expanded_name(in_start, expr_start, expr_end, in_end)$/;"	f	file:
make_extmatch	regexp.c	/^make_extmatch()$/;"	f	file:
make_filter_cmd	ex_cmds.c	/^make_filter_cmd(cmd, itmp, otmp)$/;"	f
make_modules	if_mzsch.c	/^make_modules(Scheme_Env *env)$/;"	f	file:
make_percent_swname	memline.c	/^make_percent_swname(dir, name)$/;"	f	file:
make_pull_name	gui_athena.c	/^make_pull_name(name)$/;"	f	file:
make_snapshot	window.c	/^make_snapshot()$/;"	f	file:
make_snapshot_rec	window.c	/^make_snapshot_rec(fr, frp)$/;"	f	file:
make_tabpages	window.c	/^make_tabpages(maxcount)$/;"	f
make_version	version.c	/^make_version()$/;"	f
make_windows	window.c	/^make_windows(count, vertical)$/;"	f
makefoldset	option.c	/^makefoldset(fd)$/;"	f
makemap	getchar.c	/^makemap(fd, buf)$/;"	f
makeopens	ex_docmd.c	/^makeopens(fd, dirnow)$/;"	f	file:
makeset	option.c	/^makeset(fd, opt_flags, local_only)$/;"	f
makeswapname	memline.c	/^makeswapname(fname, ffname, buf, dir_name)$/;"	f
maketitle	buffer.c	/^maketitle()$/;"	f
manage_centered	gui_motif.c	/^manage_centered(dialog_child)$/;"	f
map_clear	getchar.c	/^map_clear(cmdp, arg, forceit, abbr)$/;"	f
map_clear_int	getchar.c	/^map_clear_int(buf, mode, local, abbr)$/;"	f
map_free	getchar.c	/^map_free(mpp)$/;"	f	file:
map_to_exists	getchar.c	/^map_to_exists(str, modechars, abbr)$/;"	f
map_to_exists_mode	getchar.c	/^map_to_exists_mode(rhs, mode, abbr)$/;"	f
mapblock	structs.h	/^struct mapblock$/;"	s
mapblock_T	structs.h	/^typedef struct mapblock mapblock_T;$/;"	t	typeref:struct:mapblock
maphash	getchar.c	/^static mapblock_T	*(maphash[256]);$/;"	v	file:
maphash_valid	getchar.c	/^static int		maphash_valid = FALSE;$/;"	v	file:
mapped	gui_gtk_f.c	/^    gint mapped;$/;"	m	struct:_GtkFormChild	file:
mapped_ctrl_c	globals.h	/^EXTERN int	mapped_ctrl_c INIT(= FALSE); \/* CTRL-C is mapped *\/$/;"	v
mapsigntype	netbeans.c	/^mapsigntype(nbbuf_T *buf, int localsigntype)$/;"	f	file:
maptick	globals.h	/^EXTERN int	maptick INIT(= 0);	\/* tick for each non-mapped char *\/$/;"	v
mark	structs.h	/^    pos_T	mark;		\/* cursor position *\/$/;"	m	struct:filemark
mark_adjust	mark.c	/^mark_adjust(line1, line2, amount, amount_after)$/;"	f
mark_col_adjust	mark.c	/^mark_col_adjust(lnum, mincol, lnum_amount, col_amount)$/;"	f
mark_line	mark.c	/^mark_line(mp, lead_len)$/;"	f	file:
mask	gui_gtk_x11.c	/^    GdkBitmap *mask;$/;"	m	struct:__anon19	file:
match	gui_xmdlg.c	/^match(SharedFontSelData *data, enum ListSpecifier l, int i)$/;"	f	file:
match	structs.h	/^    regmmatch_T	match;	    \/* regexp program for pattern *\/$/;"	m	struct:matchitem
match_T	structs.h	/^} match_T;$/;"	t	typeref:struct:__anon96
match_add	window.c	/^match_add(wp, grp, pat, prio, id)$/;"	f
match_delete	window.c	/^match_delete(wp, id, perr)$/;"	f
match_file_list	fileio.c	/^match_file_list(list, sfname, ffname)$/;"	f
match_file_pat	fileio.c	/^match_file_pat(pattern, prog, fname, sfname, tail, allow_dirs)$/;"	f
match_suffix	misc1.c	/^match_suffix(fname)$/;"	f
matched	search.c	/^    int		matched;	\/* Found a match in this file *\/$/;"	m	struct:SearchedFile	file:
matches	regexp.h	/^    char_u		*matches[NSUBEXP];$/;"	m	struct:__anon78
matchinf_S	spell.c	/^typedef struct matchinf_S$/;"	s	file:
matchinf_T	spell.c	/^} matchinf_T;$/;"	t	typeref:struct:matchinf_S	file:
matchitem	structs.h	/^struct matchitem$/;"	s
matchitem_T	structs.h	/^typedef struct matchitem matchitem_T;$/;"	t	typeref:struct:matchitem
max	gui.h	/^    long	max;		\/* Number of lines in buffer *\/$/;"	m	struct:GuiScrollbar
max	gui_at_sb.h	/^    float	  max;		\/* Maximum value for top *\/$/;"	m	struct:__anon64
max_min	eval.c	/^max_min(argvars, rettv, domax)$/;"	f	file:
max_topfill	move.c	/^max_topfill()$/;"	f	file:
maxa	if_mzsch.c	/^    int		maxa;$/;"	m	struct:__anon23	file:
maxval	regexp.c	/^    long	maxval;$/;"	m	struct:regstar_S	file:
may_clear_sb_text	message.c	/^may_clear_sb_text()$/;"	f
may_core_dump	os_unix.c	/^may_core_dump()$/;"	f	file:
may_garbage_collect	globals.h	/^EXTERN int	may_garbage_collect INIT(= FALSE);$/;"	v
may_get_selection	ops.c	/^may_get_selection(regname)$/;"	f
may_open_tabpage	window.c	/^may_open_tabpage()$/;"	f
may_req_termresponse	term.c	/^may_req_termresponse()$/;"	f
may_set_selection	ops.c	/^may_set_selection()$/;"	f	file:
may_start_select	normal.c	/^may_start_select(c)$/;"	f
may_sync_undo	getchar.c	/^may_sync_undo()$/;"	f	file:
mb_adjust_cursor	mbyte.c	/^mb_adjust_cursor()$/;"	f
mb_adjust_opend	ops.c	/^mb_adjust_opend(oap)$/;"	f	file:
mb_adjustpos	mbyte.c	/^mb_adjustpos(lp)$/;"	f
mb_bytelen_tab	globals.h	/^EXTERN char	mb_bytelen_tab[256];$/;"	v
mb_charlen	mbyte.c	/^mb_charlen(str)$/;"	f
mb_charlen_len	mbyte.c	/^mb_charlen_len(str, len)$/;"	f
mb_copy_char	mbyte.c	/^mb_copy_char(fp, tp)$/;"	f
mb_cptr2char_adv	mbyte.c	/^mb_cptr2char_adv(pp)$/;"	f
mb_cptr2len	macros.h	/^# define mb_cptr2len(/;"	d
mb_cptr_adv	macros.h	/^# define mb_cptr_adv(/;"	d
mb_decompose	regexp.c	/^mb_decompose(c, c1, c2, c3)$/;"	f	file:
mb_fix_col	mbyte.c	/^mb_fix_col(col, row)$/;"	f
mb_get_class	mbyte.c	/^mb_get_class(p)$/;"	f
mb_info	structs.h	/^    minfo_T	mb_info;	\/* head of free chunk list for this block *\/$/;"	m	struct:m_block
mb_init	mbyte.c	/^mb_init()$/;"	f
mb_lefthalve	mbyte.c	/^mb_lefthalve(row, col)$/;"	f
mb_maxsize	structs.h	/^    size_t	mb_maxsize;	\/* size of largest fee chunk *\/$/;"	m	struct:m_block
mb_next	structs.h	/^    mblock_T	*mb_next;	\/* pointer to next allocated block *\/$/;"	m	struct:m_block
mb_off_next	mbyte.c	/^mb_off_next(base, p)$/;"	f
mb_prevptr	mbyte.c	/^mb_prevptr(line, p)$/;"	f
mb_ptr2char_adv	mbyte.c	/^mb_ptr2char_adv(pp)$/;"	f
mb_ptr_adv	macros.h	/^# define mb_ptr_adv(/;"	d
mb_ptr_back	macros.h	/^# define mb_ptr_back(/;"	d
mb_replace_pop_ins	edit.c	/^mb_replace_pop_ins(cc)$/;"	f	file:
mb_size	structs.h	/^    size_t	mb_size;	\/* total size of all chunks in this block *\/$/;"	m	struct:m_block
mb_str2wide	spell.c	/^mb_str2wide(s)$/;"	f	file:
mb_strnicmp	mbyte.c	/^mb_strnicmp(s1, s2, nn)$/;"	f
mb_tail_off	mbyte.c	/^mb_tail_off(base, p)$/;"	f
mb_unescape	mbyte.c	/^mb_unescape(pp)$/;"	f
mbfont_opts	hardcopy.c	/^static option_table_T mbfont_opts[OPT_MBFONT_NUM_OPTIONS] =$/;"	v	file:
mblock_T	structs.h	/^typedef struct m_block mblock_T;$/;"	t	typeref:struct:m_block
mcase	gui_gtk.c	/^    GtkWidget *mcase;	\/* 'Match case' check button *\/$/;"	m	struct:_SharedFindReplace	file:
mcase	gui_motif.c	/^    Widget mcase;	\/* 'match case' check button *\/$/;"	m	struct:_SharedFindReplace	file:
mch_FullName	os_unix.c	/^mch_FullName(fname, buf, len, force)$/;"	f
mch_access	macros.h	/^#   define mch_access(/;"	d
mch_access	macros.h	/^# define mch_access(/;"	d
mch_breakcheck	os_unix.c	/^mch_breakcheck()$/;"	f
mch_call_shell	os_unix.c	/^mch_call_shell(cmd, options)$/;"	f
mch_can_exe	os_unix.c	/^mch_can_exe(name)$/;"	f
mch_can_restore_icon	os_unix.c	/^mch_can_restore_icon()$/;"	f
mch_can_restore_title	os_unix.c	/^mch_can_restore_title()$/;"	f
mch_char_avail	os_unix.c	/^mch_char_avail()$/;"	f
mch_chdir	os_unix.h	/^#  define mch_chdir(/;"	d
mch_check_win	os_unix.c	/^mch_check_win(argc, argv)$/;"	f
mch_copy_sec	os_unix.c	/^mch_copy_sec(from_file, to_file)$/;"	f
mch_delay	os_unix.c	/^mch_delay(msec, ignoreinput)$/;"	f
mch_didjmp	os_unix.c	/^mch_didjmp()$/;"	f
mch_dirname	os_unix.c	/^mch_dirname(buf, len)$/;"	f
mch_early_init	os_unix.c	/^mch_early_init()$/;"	f
mch_endjmp	os_unix.c	/^mch_endjmp()$/;"	f
mch_errmsg	message.c	/^# undef mch_errmsg$/;"	d	file:
mch_errmsg	message.c	/^mch_errmsg(str)$/;"	f
mch_errmsg	vim.h	/^# define mch_errmsg(/;"	d
mch_exit	os_unix.c	/^mch_exit(r)$/;"	f
mch_expand_wildcards	os_unix.c	/^mch_expand_wildcards(num_pat, pat, num_file, file, flags)$/;"	f
mch_expandpath	misc1.c	/^mch_expandpath($/;"	f
mch_expandpath	os_unix.c	/^mch_expandpath(gap, path, flags)$/;"	f
mch_fopen	macros.h	/^#  define mch_fopen(/;"	d
mch_fopen	macros.h	/^# define mch_fopen(/;"	d
mch_free_acl	os_unix.c	/^mch_free_acl(aclent)$/;"	f
mch_free_mem	os_unix.c	/^mch_free_mem()$/;"	f
mch_fstat	macros.h	/^# define mch_fstat(/;"	d
mch_get_acl	os_unix.c	/^mch_get_acl(fname)$/;"	f
mch_get_host_name	os_unix.c	/^mch_get_host_name(s, len)$/;"	f
mch_get_pid	os_unix.c	/^mch_get_pid()$/;"	f
mch_get_shellsize	os_unix.c	/^mch_get_shellsize()$/;"	f
mch_get_uname	os_unix.c	/^mch_get_uname(uid, s, len)$/;"	f
mch_get_user_name	os_unix.c	/^mch_get_user_name(s, len)$/;"	f
mch_getenv	os_unix.h	/^#   define mch_getenv(/;"	d
mch_getperm	os_unix.c	/^mch_getperm(name)$/;"	f
mch_gpm_process	os_unix.c	/^mch_gpm_process()$/;"	f	file:
mch_has_exp_wildcard	os_unix.c	/^mch_has_exp_wildcard(p)$/;"	f
mch_has_wildcard	os_unix.c	/^mch_has_wildcard(p)$/;"	f
mch_hide	os_unix.c	/^mch_hide(name)$/;"	f
mch_inchar	os_unix.c	/^mch_inchar(buf, maxlen, wtime, tb_change_cnt)$/;"	f
mch_init	os_unix.c	/^mch_init()$/;"	f
mch_input_isatty	os_unix.c	/^mch_input_isatty()$/;"	f
mch_isFullName	os_unix.c	/^mch_isFullName(fname)$/;"	f
mch_isdir	os_unix.c	/^mch_isdir(name)$/;"	f
mch_libcall	os_unix.c	/^mch_libcall(libname, funcname, argstring, argint, string_result, number_result)$/;"	f
mch_lstat	macros.h	/^# define mch_lstat(/;"	d
mch_memmove	misc2.c	/^mch_memmove(dst_arg, src_arg, len)$/;"	f
mch_memmove	os_unix.h	/^#   define mch_memmove(/;"	d
mch_memmove	os_unix.h	/^#  define mch_memmove(/;"	d
mch_memmove	os_unix.h	/^# define mch_memmove(/;"	d
mch_memmove	vim.h	/^#  define mch_memmove(/;"	d
mch_msg	message.c	/^# undef mch_msg$/;"	d	file:
mch_msg	message.c	/^mch_msg(str)$/;"	f
mch_msg	vim.h	/^# define mch_msg(/;"	d
mch_new_shellsize	os_unix.c	/^mch_new_shellsize()$/;"	f
mch_nodetype	os_unix.c	/^mch_nodetype(name)$/;"	f
mch_open	macros.h	/^#   define mch_open(/;"	d
mch_open	macros.h	/^#  define mch_open(/;"	d
mch_open	macros.h	/^# define mch_open(/;"	d
mch_open_rw	macros.h	/^#  define mch_open_rw(/;"	d
mch_open_rw	macros.h	/^# define mch_open_rw(/;"	d
mch_print_begin	hardcopy.c	/^mch_print_begin(psettings)$/;"	f
mch_print_begin_page	hardcopy.c	/^mch_print_begin_page(str)$/;"	f
mch_print_blank_page	hardcopy.c	/^mch_print_blank_page()$/;"	f
mch_print_cleanup	hardcopy.c	/^mch_print_cleanup()$/;"	f
mch_print_end	hardcopy.c	/^mch_print_end(psettings)$/;"	f
mch_print_end_page	hardcopy.c	/^mch_print_end_page()$/;"	f
mch_print_init	hardcopy.c	/^mch_print_init(psettings, jobname, forceit)$/;"	f
mch_print_set_bg	hardcopy.c	/^mch_print_set_bg(bgcol)$/;"	f
mch_print_set_fg	hardcopy.c	/^mch_print_set_fg(fgcol)$/;"	f
mch_print_set_font	hardcopy.c	/^mch_print_set_font(iBold, iItalic, iUnderline)$/;"	f
mch_print_start_line	hardcopy.c	/^mch_print_start_line(margin, page_line)$/;"	f
mch_print_text_out	hardcopy.c	/^mch_print_text_out(p, len)$/;"	f
mch_remove	os_unix.h	/^#  define mch_remove(/;"	d
mch_rename	os_unix.c	/^mch_rename(src, dest)$/;"	f
mch_rename	os_unix.h	/^#  define mch_rename(/;"	d
mch_restore_title	os_unix.c	/^mch_restore_title(which)$/;"	f
mch_rmdir	os_unix.h	/^#   define mch_rmdir(/;"	d
mch_rmdir	os_unix.h	/^#  define mch_rmdir(/;"	d
mch_screenmode	os_unix.c	/^mch_screenmode(arg)$/;"	f
mch_set_acl	os_unix.c	/^mch_set_acl(fname, aclent)$/;"	f
mch_set_mouse_shape	gui_gtk_x11.c	/^mch_set_mouse_shape(int shape)$/;"	f
mch_set_mouse_shape	gui_x11.c	/^mch_set_mouse_shape(shape)$/;"	f
mch_set_shellsize	os_unix.c	/^mch_set_shellsize()$/;"	f
mch_setenv	os_unix.h	/^#  define mch_setenv(/;"	d
mch_setmouse	os_unix.c	/^mch_setmouse(on)$/;"	f
mch_setperm	os_unix.c	/^mch_setperm(name, perm)$/;"	f
mch_settitle	os_unix.c	/^mch_settitle(title, icon)$/;"	f
mch_settmode	os_unix.c	/^mch_settmode(tmode)$/;"	f
mch_stackcheck	os_unix.c	/^mch_stackcheck(p)$/;"	f
mch_startjmp	os_unix.c	/^mch_startjmp()$/;"	f
mch_stat	macros.h	/^#   define mch_stat(/;"	d
mch_stat	macros.h	/^#  define mch_stat(/;"	d
mch_stat	macros.h	/^# define mch_stat(/;"	d
mch_suspend	os_unix.c	/^mch_suspend()$/;"	f
mch_total_mem	os_unix.c	/^mch_total_mem(special)$/;"	f
mch_write	os_unix.c	/^mch_write(s, len)$/;"	f
mcmd_e	if_cscope.h	/^} mcmd_e;$/;"	t	typeref:enum:__anon70
mediumVersion	version.c	/^static char	*mediumVersion = VIM_VERSION_MEDIUM;$/;"	v	file:
mem_allocated	misc2.c	/^static long_u mem_allocated;$/;"	v	file:
mem_allocs	misc2.c	/^static long_u mem_allocs[MEM_SIZES];$/;"	v	file:
mem_freed	misc2.c	/^static long_u mem_freed;$/;"	v	file:
mem_frees	misc2.c	/^static long_u mem_frees[MEM_SIZES];$/;"	v	file:
mem_peak	misc2.c	/^static long_u mem_peak;$/;"	v	file:
mem_post_alloc	misc2.c	/^mem_post_alloc(pp, size)$/;"	f	file:
mem_pre_alloc_l	misc2.c	/^mem_pre_alloc_l(sizep)$/;"	f	file:
mem_pre_alloc_s	misc2.c	/^mem_pre_alloc_s(sizep)$/;"	f	file:
mem_pre_free	misc2.c	/^mem_pre_free(pp)$/;"	f	file:
mem_realloc	misc2.c	/^mem_realloc(ptr, size)$/;"	f
memfile	structs.h	/^struct memfile$/;"	s
memfile_T	structs.h	/^typedef struct memfile	    memfile_T;$/;"	t	typeref:struct:memfile
memline	structs.h	/^typedef struct memline$/;"	s
memline_T	structs.h	/^} memline_T;$/;"	t	typeref:struct:memline
menuBar	gui_athena.c	/^static Widget menuBar = (Widget)0;$/;"	v	file:
menuBar	gui_motif.c	/^static Widget menuBar;$/;"	v	file:
menuMap	workshop.c	/^static MenuMap	*menuMap;		\/* list of verb\/menu mappings *\/$/;"	v	file:
menuMapMax	workshop.c	/^static int	 menuMapMax;		\/* allocated size of menuMap *\/$/;"	v	file:
menuMapSize	workshop.c	/^static int	 menuMapSize;		\/* current size of menuMap *\/$/;"	v	file:
menuTrans	gui_athena.c	/^static XtTranslations	popupTrans, parentTrans, menuTrans, supermenuTrans;$/;"	v	file:
menu_bg_pixel	gui.h	/^    guicolor_T	menu_bg_pixel;		\/* Same in Pixel format *\/$/;"	m	struct:Gui
menu_def_bg_pixel	gui.h	/^    guicolor_T	menu_def_bg_pixel;  \/* Default menu background *\/$/;"	m	struct:Gui
menu_def_fg_pixel	gui.h	/^    guicolor_T	menu_def_fg_pixel;  \/* Default menu foreground *\/$/;"	m	struct:Gui
menu_enabled	gui_motif.c	/^static int menu_enabled = TRUE;$/;"	v	file:
menu_fg_pixel	gui.h	/^    guicolor_T	menu_fg_pixel;		\/* Same in Pixel format *\/$/;"	m	struct:Gui
menu_font	gui.h	/^    GuiFont	menu_font;	    \/* menu item font *\/$/;"	m	struct:Gui
menu_fontset	gui.h	/^    GuiFontset	menu_fontset;	    \/* set of fonts for multi-byte chars *\/$/;"	m	struct:Gui
menu_handle	structs.h	/^    MenuHandle	menu_handle;$/;"	m	struct:VimMenu
menu_height	gui.h	/^    int		menu_height;	    \/* Height of the menu bar *\/$/;"	m	struct:Gui
menu_height_fixed	gui.h	/^    char	menu_height_fixed;  \/* TRUE if menu height fixed *\/$/;"	m	struct:Gui
menu_id	structs.h	/^    short	menu_id;	    \/* the menu id to which this item belong *\/$/;"	m	struct:VimMenu
menu_is_active	gui.h	/^    char	menu_is_active;	    \/* TRUE if menu is present *\/$/;"	m	struct:Gui
menu_is_child_of_popup	menu.c	/^menu_is_child_of_popup(menu)$/;"	f
menu_is_hidden	menu.c	/^menu_is_hidden(name)$/;"	f	file:
menu_is_menubar	menu.c	/^menu_is_menubar(name)$/;"	f
menu_is_popup	menu.c	/^menu_is_popup(name)$/;"	f
menu_is_separator	menu.c	/^menu_is_separator(name)$/;"	f
menu_is_tearoff	menu.c	/^menu_is_tearoff(name)$/;"	f	file:
menu_is_toolbar	menu.c	/^menu_is_toolbar(name)$/;"	f
menu_item_activate	gui_gtk.c	/^menu_item_activate(GtkWidget *widget, gpointer data)$/;"	f	file:
menu_item_new	gui_gtk.c	/^menu_item_new(vimmenu_T *menu, GtkWidget *parent_widget)$/;"	f	file:
menu_mode_chars	menu.c	/^static char_u	menu_mode_chars[] = {'n', 'v', 's', 'o', 'i', 'c', 't'};$/;"	v	file:
menu_nable_recurse	menu.c	/^menu_nable_recurse(menu, name, modes, enable)$/;"	f	file:
menu_name_equal	menu.c	/^menu_name_equal(name, menu)$/;"	f	file:
menu_name_skip	menu.c	/^menu_name_skip(name)$/;"	f
menu_namecmp	menu.c	/^menu_namecmp(name, mname)$/;"	f	file:
menu_skip_part	menu.c	/^menu_skip_part(p)$/;"	f	file:
menu_stock_ids	gui_gtk.c	/^static const char * const menu_stock_ids[] =$/;"	v	file:
menu_text	menu.c	/^menu_text(str, mnemonic, actext)$/;"	f	file:
menu_width	gui.h	/^    int		menu_width;	    \/* Width of the menu bar *\/$/;"	m	struct:Gui
menubar	gui.h	/^    GtkWidget	*menubar;	    \/* menubar *\/$/;"	m	struct:Gui
menubar_h	gui.h	/^    GtkWidget	*menubar_h;	    \/* menubar handle *\/$/;"	m	struct:Gui
menutrans_T	menu.c	/^} menutrans_T;$/;"	t	typeref:struct:__anon43	file:
menutrans_ga	menu.c	/^static garray_T menutrans_ga = {0, 0, 0, 0, NULL};$/;"	v	file:
menutrans_lookup	menu.c	/^menutrans_lookup(name, len)$/;"	f	file:
messageFromEserve	integration.c	/^messageFromEserve(XtPointer clientData, int *NOTUSED1, XtInputId *NOTUSED2)$/;"	f
messageFromNetbeansW32	netbeans.c	/^messageFromNetbeansW32()$/;"	f
messages	structs.h	/^    struct msglist	*messages;	\/* message(s) causing error exception *\/$/;"	m	struct:vim_exception	typeref:struct:vim_exception::msglist
messaging	screen.c	/^messaging()$/;"	f
mf_alloc_bhdr	memfile.c	/^mf_alloc_bhdr(mfp, page_count)$/;"	f	file:
mf_blocknr_max	structs.h	/^    blocknr_T	mf_blocknr_max;		\/* highest positive block number + 1*\/$/;"	m	struct:memfile
mf_blocknr_min	structs.h	/^    blocknr_T	mf_blocknr_min;		\/* lowest negative block number - 1 *\/$/;"	m	struct:memfile
mf_close	memfile.c	/^mf_close(mfp, del_file)$/;"	f
mf_close_file	memfile.c	/^mf_close_file(buf, getlines)$/;"	f
mf_dirty	structs.h	/^    int		mf_dirty;		\/* TRUE if there are dirty blocks *\/$/;"	m	struct:memfile
mf_do_open	memfile.c	/^mf_do_open(mfp, fname, flags)$/;"	f	file:
mf_dont_release	globals.h	/^EXTERN int	mf_dont_release INIT(= FALSE);	\/* don't release blocks *\/$/;"	v
mf_fd	structs.h	/^    int		mf_fd;			\/* file descriptor *\/$/;"	m	struct:memfile
mf_ffname	structs.h	/^    char_u	*mf_ffname;		\/* idem, full path *\/$/;"	m	struct:memfile
mf_find_hash	memfile.c	/^mf_find_hash(mfp, nr)$/;"	f	file:
mf_fname	structs.h	/^    char_u	*mf_fname;		\/* name of the file *\/$/;"	m	struct:memfile
mf_free	memfile.c	/^mf_free(mfp, hp)$/;"	f
mf_free_bhdr	memfile.c	/^mf_free_bhdr(hp)$/;"	f	file:
mf_free_first	structs.h	/^    bhdr_T	*mf_free_first;		\/* first block_hdr in free list *\/$/;"	m	struct:memfile
mf_fullname	memfile.c	/^mf_fullname(mfp)$/;"	f
mf_get	memfile.c	/^mf_get(mfp, nr, page_count)$/;"	f
mf_hash	structs.h	/^    bhdr_T	*mf_hash[MEMHASHSIZE];	\/* array of hash lists *\/$/;"	m	struct:memfile
mf_infile_count	structs.h	/^    blocknr_T	mf_infile_count;	\/* number of pages in the file *\/$/;"	m	struct:memfile
mf_ins_free	memfile.c	/^mf_ins_free(mfp, hp)$/;"	f	file:
mf_ins_hash	memfile.c	/^mf_ins_hash(mfp, hp)$/;"	f	file:
mf_ins_used	memfile.c	/^mf_ins_used(mfp, hp)$/;"	f	file:
mf_need_trans	memfile.c	/^mf_need_trans(mfp)$/;"	f
mf_neg_count	structs.h	/^    blocknr_T	mf_neg_count;		\/* number of negative blocks numbers *\/$/;"	m	struct:memfile
mf_new	memfile.c	/^mf_new(mfp, negative, page_count)$/;"	f
mf_new_page_size	memfile.c	/^mf_new_page_size(mfp, new_size)$/;"	f
mf_open	memfile.c	/^mf_open(fname, flags)$/;"	f
mf_open_file	memfile.c	/^mf_open_file(mfp, fname)$/;"	f
mf_page_size	structs.h	/^    unsigned	mf_page_size;		\/* number of bytes in a page *\/$/;"	m	struct:memfile
mf_put	memfile.c	/^mf_put(mfp, hp, dirty, infile)$/;"	f
mf_read	memfile.c	/^mf_read(mfp, hp)$/;"	f	file:
mf_release	memfile.c	/^mf_release(mfp, page_count)$/;"	f	file:
mf_release_all	memfile.c	/^mf_release_all()$/;"	f
mf_rem_free	memfile.c	/^mf_rem_free(mfp)$/;"	f	file:
mf_rem_hash	memfile.c	/^mf_rem_hash(mfp, hp)$/;"	f	file:
mf_rem_used	memfile.c	/^mf_rem_used(mfp, hp)$/;"	f	file:
mf_set_dirty	memfile.c	/^mf_set_dirty(mfp)$/;"	f
mf_set_ffname	memfile.c	/^mf_set_ffname(mfp)$/;"	f
mf_sync	memfile.c	/^mf_sync(mfp, flags)$/;"	f
mf_trans	structs.h	/^    NR_TRANS	*mf_trans[MEMHASHSIZE];	\/* array of trans lists *\/$/;"	m	struct:memfile
mf_trans_add	memfile.c	/^mf_trans_add(mfp, hp)$/;"	f	file:
mf_trans_del	memfile.c	/^mf_trans_del(mfp, old_nr)$/;"	f
mf_used_count	structs.h	/^    unsigned	mf_used_count;		\/* number of pages in used list *\/$/;"	m	struct:memfile
mf_used_count_max	structs.h	/^    unsigned	mf_used_count_max;	\/* maximum number of pages in memory *\/$/;"	m	struct:memfile
mf_used_first	structs.h	/^    bhdr_T	*mf_used_first;		\/* mru block_hdr in used list *\/$/;"	m	struct:memfile
mf_used_last	structs.h	/^    bhdr_T	*mf_used_last;		\/* lru block_hdr in used list *\/$/;"	m	struct:memfile
mf_write	memfile.c	/^mf_write(mfp, hp)$/;"	f	file:
mi_buf	spell.c	/^    buf_T	*mi_buf;		\/* buffer being checked *\/$/;"	m	struct:matchinf_S	file:
mi_capflags	spell.c	/^    int		mi_capflags;		\/* WF_ONECAP WF_ALLCAP WF_KEEPCAP *\/$/;"	m	struct:matchinf_S	file:
mi_cend	spell.c	/^    char_u	*mi_cend;		\/* char after what was used for$/;"	m	struct:matchinf_S	file:
mi_compextra	spell.c	/^    int		mi_compextra;		\/* nr of COMPOUNDROOT words *\/$/;"	m	struct:matchinf_S	file:
mi_compflags	spell.c	/^    char_u	mi_compflags[MAXWLEN];	\/* flags for compound words used *\/$/;"	m	struct:matchinf_S	file:
mi_complen	spell.c	/^    int		mi_complen;		\/* nr of compound words used *\/$/;"	m	struct:matchinf_S	file:
mi_compoff	spell.c	/^    int		mi_compoff;		\/* start of following word offset *\/$/;"	m	struct:matchinf_S	file:
mi_cprefixlen	spell.c	/^    int		mi_cprefixlen;		\/* byte length of prefix in original$/;"	m	struct:matchinf_S	file:
mi_cprefixlen	spell.c	/^# define mi_cprefixlen /;"	d	file:
mi_end	spell.c	/^    char_u	*mi_end;		\/* end of matching word so far *\/$/;"	m	struct:matchinf_S	file:
mi_end2	spell.c	/^    char_u	*mi_end2;		\/* "mi_end" without following word *\/$/;"	m	struct:matchinf_S	file:
mi_fend	spell.c	/^    char_u	*mi_fend;		\/* next char to be added to mi_fword *\/$/;"	m	struct:matchinf_S	file:
mi_fword	spell.c	/^    char_u	mi_fword[MAXWLEN + 1];	\/* mi_word case-folded *\/$/;"	m	struct:matchinf_S	file:
mi_fwordlen	spell.c	/^    int		mi_fwordlen;		\/* nr of valid bytes in mi_fword *\/$/;"	m	struct:matchinf_S	file:
mi_lp	spell.c	/^    langp_T	*mi_lp;			\/* info for language and region *\/$/;"	m	struct:matchinf_S	file:
mi_prefarridx	spell.c	/^    int		mi_prefarridx;		\/* index in sl_pidxs with list of$/;"	m	struct:matchinf_S	file:
mi_prefcnt	spell.c	/^    int		mi_prefcnt;		\/* number of entries at mi_prefarridx *\/$/;"	m	struct:matchinf_S	file:
mi_prefixlen	spell.c	/^    int		mi_prefixlen;		\/* byte length of prefix *\/$/;"	m	struct:matchinf_S	file:
mi_result	spell.c	/^    int		mi_result;		\/* result so far: SP_BAD, SP_OK, etc. *\/$/;"	m	struct:matchinf_S	file:
mi_result2	spell.c	/^    int		mi_result2;		\/* "mi_resul" without following word *\/$/;"	m	struct:matchinf_S	file:
mi_word	spell.c	/^    char_u	*mi_word;		\/* start of word being checked *\/$/;"	m	struct:matchinf_S	file:
min_rows	window.c	/^min_rows()$/;"	f
min_thumb	gui_at_sb.h	/^    Dimension	  min_thumb;	\/* minimum size for the thumb. *\/$/;"	m	struct:__anon64
mina	if_mzsch.c	/^    int		mina;	\/* arity information *\/$/;"	m	struct:__anon23	file:
minfo_T	structs.h	/^typedef struct m_info minfo_T;$/;"	t	typeref:struct:m_info
minlen	ex_docmd.c	/^    int		minlen;$/;"	m	struct:cmdmod	file:
minval	regexp.c	/^    long	minval;$/;"	m	struct:regstar_S	file:
mkdir_recurse	eval.c	/^mkdir_recurse(dir, prot)$/;"	f	file:
mksession_nl	ex_docmd.c	/^static int mksession_nl = FALSE;    \/* use NL only in put_eol() *\/$/;"	v	file:
mkspell	spell.c	/^mkspell(fcount, fnames, ascii, overwrite, added_word)$/;"	f	file:
ml_add_stack	memline.c	/^ml_add_stack(buf)$/;"	f	file:
ml_append	memline.c	/^ml_append(lnum, line, len, newfile)$/;"	f
ml_append_buf	memline.c	/^ml_append_buf(buf, lnum, line, len, newfile)$/;"	f
ml_append_int	memline.c	/^ml_append_int(buf, lnum, line, len, newfile, mark)$/;"	f	file:
ml_chunksize	structs.h	/^    chunksize_T *ml_chunksize;$/;"	m	struct:memline
ml_chunksize	structs.h	/^typedef struct ml_chunksize$/;"	s
ml_clearmarked	memline.c	/^ml_clearmarked()$/;"	f
ml_close	memline.c	/^ml_close(buf, del_file)$/;"	f
ml_close_all	memline.c	/^ml_close_all(del_file)$/;"	f
ml_close_notmod	memline.c	/^ml_close_notmod()$/;"	f
ml_delete	memline.c	/^ml_delete(lnum, message)$/;"	f
ml_delete_int	memline.c	/^ml_delete_int(buf, lnum, message)$/;"	f	file:
ml_find_line	memline.c	/^ml_find_line(buf, lnum, action)$/;"	f	file:
ml_find_line_or_offset	memline.c	/^ml_find_line_or_offset(buf, lnum, offp)$/;"	f
ml_firstmarked	memline.c	/^ml_firstmarked()$/;"	f
ml_flags	structs.h	/^    int		ml_flags;$/;"	m	struct:memline
ml_flush_line	memline.c	/^ml_flush_line(buf)$/;"	f	file:
ml_get	memline.c	/^ml_get(lnum)$/;"	f
ml_get_buf	memline.c	/^ml_get_buf(buf, lnum, will_change)$/;"	f
ml_get_curline	memline.c	/^ml_get_curline()$/;"	f
ml_get_cursor	memline.c	/^ml_get_cursor()$/;"	f
ml_get_pos	memline.c	/^ml_get_pos(pos)$/;"	f
ml_line_alloced	memline.c	/^ml_line_alloced()$/;"	f
ml_line_count	structs.h	/^    linenr_T	ml_line_count;	\/* number of lines in the buffer *\/$/;"	m	struct:memline
ml_line_lnum	structs.h	/^    linenr_T	ml_line_lnum;	\/* line number of cached line, 0 if not valid *\/$/;"	m	struct:memline
ml_line_ptr	structs.h	/^    char_u	*ml_line_ptr;	\/* pointer to cached line *\/$/;"	m	struct:memline
ml_lineadd	memline.c	/^ml_lineadd(buf, count)$/;"	f	file:
ml_locked	structs.h	/^    bhdr_T	*ml_locked;	\/* block used by last ml_get *\/$/;"	m	struct:memline
ml_locked_high	structs.h	/^    linenr_T	ml_locked_high;	\/* last line in ml_locked *\/$/;"	m	struct:memline
ml_locked_lineadd	structs.h	/^    int		ml_locked_lineadd;  \/* number of lines inserted in ml_locked *\/$/;"	m	struct:memline
ml_locked_low	structs.h	/^    linenr_T	ml_locked_low;	\/* first line in ml_locked *\/$/;"	m	struct:memline
ml_mfp	structs.h	/^    memfile_T	*ml_mfp;	\/* pointer to associated memfile *\/$/;"	m	struct:memline
ml_new_data	memline.c	/^ml_new_data(mfp, negative, page_count)$/;"	f	file:
ml_new_ptr	memline.c	/^ml_new_ptr(mfp)$/;"	f	file:
ml_numchunks	structs.h	/^    int		ml_numchunks;$/;"	m	struct:memline
ml_open	memline.c	/^ml_open(buf)$/;"	f
ml_open_file	memline.c	/^ml_open_file(buf)$/;"	f
ml_open_files	memline.c	/^ml_open_files()$/;"	f
ml_preserve	memline.c	/^ml_preserve(buf, message)$/;"	f
ml_recover	memline.c	/^ml_recover()$/;"	f
ml_replace	memline.c	/^ml_replace(lnum, line, copy)$/;"	f
ml_setflags	memline.c	/^ml_setflags(buf)$/;"	f
ml_setmarked	memline.c	/^ml_setmarked(lnum)$/;"	f
ml_setname	memline.c	/^ml_setname(buf)$/;"	f
ml_stack	structs.h	/^    infoptr_T	*ml_stack;	\/* stack of pointer blocks (array of IPTRs) *\/$/;"	m	struct:memline
ml_stack_size	structs.h	/^    int		ml_stack_size;	\/* total number of entries in ml_stack *\/$/;"	m	struct:memline
ml_stack_top	structs.h	/^    int		ml_stack_top;	\/* current top if ml_stack *\/$/;"	m	struct:memline
ml_sync_all	memline.c	/^ml_sync_all(check_file, check_char)$/;"	f
ml_timestamp	memline.c	/^ml_timestamp(buf)$/;"	f
ml_upd_block0	memline.c	/^ml_upd_block0(buf, set_fname)$/;"	f	file:
ml_updatechunk	memline.c	/^ml_updatechunk(buf, line, len, updtype)$/;"	f	file:
ml_usedchunks	structs.h	/^    int		ml_usedchunks;$/;"	m	struct:memline
mlcs_numlines	structs.h	/^    int		mlcs_numlines;$/;"	m	struct:ml_chunksize
mlcs_totalsize	structs.h	/^    long	mlcs_totalsize;$/;"	m	struct:ml_chunksize
mnemonic	structs.h	/^    int		mnemonic;	    \/* mnemonic key (after '&') *\/$/;"	m	struct:VimMenu
mnemonic_event	gui_motif.c	/^mnemonic_event(Widget w, XtPointer call_data, XKeyEvent *event)$/;"	f	file:
mod_flag	misc2.c	/^    short	mod_flag;	\/* Bit(s) for particular key modifier *\/$/;"	m	struct:modmasktable	file:
mod_mask	globals.h	/^EXTERN int	mod_mask INIT(= 0x0);		\/* current key modifiers *\/$/;"	v
mod_mask	misc2.c	/^    short	mod_mask;	\/* Bit-mask for particular key modifier *\/$/;"	m	struct:modmasktable	file:
mod_mask_table	misc2.c	/^} mod_mask_table[] =$/;"	v	typeref:struct:modmasktable	file:
mode	getchar.c	/^    int		mode;$/;"	m	struct:initmap	file:
mode	vim.h	/^    short_u	mode;		\/* Select by char, word, or line. *\/$/;"	m	struct:VimClipboard
mode_displayed	globals.h	/^EXTERN int	mode_displayed INIT(= FALSE);	\/* mode is being displayed *\/$/;"	v
modec	structs.h	/^    int		modec;$/;"	m	struct:__anon100
modes	structs.h	/^    int		modes;		    \/* Which modes is this menu visible for? *\/$/;"	m	struct:VimMenu
modified	netbeans.c	/^    unsigned int	 modified:1;$/;"	m	struct:nbbuf_struct	file:
modified_was_set	globals.h	/^EXTERN int	modified_was_set;		\/* did ":set modified" *\/$/;"	v
modifier_keys_table	misc2.c	/^static char_u modifier_keys_table[] =$/;"	v	file:
modifier_len	ex_docmd.c	/^modifier_len(cmd)$/;"	f
modifiers_gdk2mouse	gui_gtk_x11.c	/^modifiers_gdk2mouse(guint state)$/;"	f	file:
modifiers_gdk2vim	gui_gtk_x11.c	/^modifiers_gdk2vim(guint state)$/;"	f	file:
modify_fname	eval.c	/^modify_fname(src, usedlen, fnamep, bufp, fnamelen)$/;"	f
modlen	term.c	/^    int	    modlen;	    \/* length of part before ";*~". *\/$/;"	m	struct:termcode	file:
modmasktable	misc2.c	/^static struct modmasktable$/;"	s	file:
modname	fileio.c	/^modname(fname, ext, prepend_dot)$/;"	f
moreenv	misc2.c	/^moreenv()$/;"	f	file:
motif_get_toolbar_colors	gui_motif.c	/^motif_get_toolbar_colors(bgp, fgp, bsp, tsp, hsp)$/;"	f
motif_tabline_timer_cb	gui_motif.c	/^motif_tabline_timer_cb (timed_out, interval_id)$/;"	f	file:
motion_force	structs.h	/^    int		motion_force;	\/* force motion type: 'v', 'V' or CTRL-V *\/$/;"	m	struct:oparg_S
motion_notify_event	gui_gtk_x11.c	/^motion_notify_event(GtkWidget *widget, GdkEventMotion *event, gpointer data)$/;"	f	file:
motion_repeat_offset	gui_gtk_x11.c	/^static int   motion_repeat_offset = FALSE;$/;"	v	file:
motion_repeat_timer	gui_gtk_x11.c	/^static guint motion_repeat_timer  = 0;$/;"	v	file:
motion_repeat_timer_cb	gui_gtk_x11.c	/^motion_repeat_timer_cb(gpointer data)$/;"	f	file:
motion_type	structs.h	/^    int		motion_type;	\/* type of the current cursor motion *\/$/;"	m	struct:oparg_S
mouse_click_timer	gui_gtk_x11.c	/^static guint mouse_click_timer = 0;$/;"	v	file:
mouse_click_timer_cb	gui_gtk_x11.c	/^mouse_click_timer_cb(gpointer data)$/;"	f	file:
mouse_col	globals.h	/^EXTERN int	mouse_col;$/;"	v
mouse_comp_pos	ui.c	/^mouse_comp_pos(win, rowp, colp, lnump)$/;"	f
mouse_dragging	globals.h	/^EXTERN int	mouse_dragging INIT(= 0);	\/* extending Visual area with$/;"	v
mouse_find_win	ui.c	/^mouse_find_win(rowp, colp)$/;"	f
mouse_has	term.c	/^mouse_has(c)$/;"	f
mouse_model_popup	term.c	/^mouse_model_popup()$/;"	f
mouse_past_bottom	globals.h	/^EXTERN int	mouse_past_bottom INIT(= FALSE);\/* mouse below last line *\/$/;"	v
mouse_past_eol	globals.h	/^EXTERN int	mouse_past_eol INIT(= FALSE);	\/* mouse right of line *\/$/;"	v
mouse_row	globals.h	/^EXTERN int	mouse_row;$/;"	v
mouse_table	misc2.c	/^} mouse_table[] =$/;"	v	typeref:struct:mousetable	file:
mouse_timed_out	gui_gtk_x11.c	/^static int mouse_timed_out = TRUE;$/;"	v	file:
mousetable	misc2.c	/^static struct mousetable$/;"	s	file:
move_lines	fileio.c	/^move_lines(frombuf, tobuf)$/;"	f	file:
movechangelist	mark.c	/^movechangelist(count)$/;"	f
movemark	mark.c	/^movemark(count)$/;"	f
mparm_T	main.c	/^} mparm_T;$/;"	t	typeref:struct:__anon39	file:
mr_pattern	search.c	/^static char_u	    *mr_pattern = NULL;	\/* pattern used by search_regcomp() *\/$/;"	v	file:
mr_pattern_alloced	search.c	/^static int	    mr_pattern_alloced = FALSE; \/* mr_pattern was allocated *\/$/;"	v	file:
msg	gui_beval.h	/^    char_u		*msg;$/;"	m	struct:BalloonEvalStruct
msg	message.c	/^    char_u		*msg;$/;"	m	struct:msg_hist	file:
msg	message.c	/^msg(s)$/;"	f
msg	structs.h	/^    char_u		*msg;		\/* original message *\/$/;"	m	struct:msglist
msgCB	gui_beval.h	/^    void		(*msgCB)__ARGS((struct BalloonEvalStruct *, int));$/;"	m	struct:BalloonEvalStruct
msg_add_eol	fileio.c	/^msg_add_eol()$/;"	f	file:
msg_add_fileformat	fileio.c	/^msg_add_fileformat(eol_type)$/;"	f	file:
msg_add_fname	fileio.c	/^msg_add_fname(buf, fname)$/;"	f
msg_add_lines	fileio.c	/^msg_add_lines(insert_space, lnum, nchars)$/;"	f
msg_advance	message.c	/^msg_advance(col)$/;"	f
msg_attr	message.c	/^msg_attr(s, attr)$/;"	f
msg_attr_keep	message.c	/^msg_attr_keep(s, attr, keep)$/;"	f
msg_buf	globals.h	/^EXTERN char_u	msg_buf[MSG_BUF_LEN];	\/* small buffer for messages *\/$/;"	v
msg_check	message.c	/^msg_check()$/;"	f
msg_check_screen	message.c	/^msg_check_screen()$/;"	f	file:
msg_clr_cmdline	message.c	/^msg_clr_cmdline()$/;"	f
msg_clr_eos	message.c	/^msg_clr_eos()$/;"	f
msg_clr_eos_force	message.c	/^msg_clr_eos_force()$/;"	f
msg_col	globals.h	/^EXTERN int	msg_col;$/;"	v
msg_compressing	spell.c	/^static char *msg_compressing = N_("Compressing word tree...");$/;"	v	file:
msg_didany	globals.h	/^EXTERN int	msg_didany INIT(= FALSE);   \/* msg_outstr() was used at all *\/$/;"	v
msg_didout	globals.h	/^EXTERN int	msg_didout INIT(= FALSE);   \/* msg_outstr() was used in line *\/$/;"	v
msg_end	message.c	/^msg_end()$/;"	f
msg_end_prompt	message.c	/^msg_end_prompt()$/;"	f
msg_hist	message.c	/^struct msg_hist$/;"	s	file:
msg_hist_len	message.c	/^static int msg_hist_len = 0;$/;"	v	file:
msg_hist_off	globals.h	/^EXTERN int      msg_hist_off INIT(= FALSE); \/* don't add messages to history *\/$/;"	v
msg_home_replace	message.c	/^msg_home_replace(fname)$/;"	f
msg_home_replace_attr	message.c	/^msg_home_replace_attr(fname, attr)$/;"	f	file:
msg_home_replace_hl	message.c	/^msg_home_replace_hl(fname)$/;"	f
msg_list	globals.h	/^EXTERN struct msglist **msg_list INIT(= NULL);$/;"	v	typeref:struct:
msg_make	message.c	/^msg_make(arg)$/;"	f
msg_may_trunc	message.c	/^msg_may_trunc(force, s)$/;"	f
msg_moremsg	message.c	/^msg_moremsg(full)$/;"	f
msg_no_more	globals.h	/^EXTERN int	msg_no_more INIT(= FALSE);  \/* don't use more prompt, truncate$/;"	v
msg_nowait	globals.h	/^EXTERN int	msg_nowait INIT(= FALSE);   \/* don't wait for this msg *\/$/;"	v
msg_outnum	message.c	/^msg_outnum(n)$/;"	f
msg_outtrans	message.c	/^msg_outtrans(str)$/;"	f
msg_outtrans_attr	message.c	/^msg_outtrans_attr(str, attr)$/;"	f
msg_outtrans_len	message.c	/^msg_outtrans_len(str, len)$/;"	f
msg_outtrans_len_attr	message.c	/^msg_outtrans_len_attr(msgstr, len, attr)$/;"	f
msg_outtrans_one	message.c	/^msg_outtrans_one(p, attr)$/;"	f
msg_outtrans_special	message.c	/^msg_outtrans_special(strstart, from)$/;"	f
msg_pos_mode	screen.c	/^msg_pos_mode()$/;"	f	file:
msg_prt_line	message.c	/^msg_prt_line(s, list)$/;"	f
msg_putchar	message.c	/^msg_putchar(c)$/;"	f
msg_putchar_attr	message.c	/^msg_putchar_attr(c, attr)$/;"	f
msg_puts	message.c	/^msg_puts(s)$/;"	f
msg_puts_attr	message.c	/^msg_puts_attr(s, attr)$/;"	f
msg_puts_attr_len	message.c	/^msg_puts_attr_len(str, maxlen, attr)$/;"	f	file:
msg_puts_display	message.c	/^msg_puts_display(str, maxlen, attr, recurse)$/;"	f	file:
msg_puts_long_attr	message.c	/^msg_puts_long_attr(longstr, attr)$/;"	f
msg_puts_long_len_attr	message.c	/^msg_puts_long_len_attr(longstr, len, attr)$/;"	f
msg_puts_printf	message.c	/^msg_puts_printf(str, maxlen)$/;"	f	file:
msg_puts_title	message.c	/^msg_puts_title(s)$/;"	f
msg_row	globals.h	/^EXTERN int	msg_row;$/;"	v
msg_sb_start	message.c	/^msg_sb_start(mps)$/;"	f	file:
msg_screen_putchar	message.c	/^msg_screen_putchar(c, attr)$/;"	f	file:
msg_scroll	globals.h	/^EXTERN int	msg_scroll INIT(= FALSE);   \/* msg_start() will scroll *\/$/;"	v
msg_scroll_up	message.c	/^msg_scroll_up()$/;"	f	file:
msg_scrolled	globals.h	/^EXTERN int	msg_scrolled;	\/* Number of screen lines that windows have$/;"	v
msg_scrolled_ign	globals.h	/^EXTERN int	msg_scrolled_ign INIT(= FALSE);$/;"	v
msg_show_console_dialog	message.c	/^msg_show_console_dialog(message, buttons, dfltbutton)$/;"	f	file:
msg_silent	globals.h	/^EXTERN int	msg_silent INIT(= 0);	\/* don't print messages *\/$/;"	v
msg_source	message.c	/^msg_source(attr)$/;"	f
msg_start	message.c	/^msg_start()$/;"	f
msg_starthere	message.c	/^msg_starthere()$/;"	f
msg_strtrunc	message.c	/^msg_strtrunc(s, force)$/;"	f
msg_trunc_attr	message.c	/^msg_trunc_attr(s, force, attr)$/;"	f
msg_use_printf	message.c	/^msg_use_printf()$/;"	f
msgchunk_S	message.c	/^struct msgchunk_S$/;"	s	file:
msgchunk_T	message.c	/^typedef struct msgchunk_S msgchunk_T;$/;"	t	typeref:struct:msgchunk_S	file:
msglist	structs.h	/^struct msglist$/;"	s
msgmore	misc1.c	/^msgmore(n)$/;"	f
mshape	structs.h	/^    int		mshape;		\/* one of the MSHAPE defines *\/$/;"	m	struct:cursor_entry
mshape_ids	gui_gtk_x11.c	/^static const int mshape_ids[] =$/;"	v	file:
mshape_ids	gui_x11.c	/^static int mshape_ids[] =$/;"	v	file:
mshape_names	misc2.c	/^static char * mshape_names[] =$/;"	v	file:
mt_names	tag.c	/^static char	*mt_names[MT_COUNT\/2] =$/;"	v	file:
mtime	gui_at_fs.c	/^    time_t	mtime;$/;"	m	struct:__anon14	file:
must_redraw	globals.h	/^EXTERN int	must_redraw INIT(= 0);	    \/* type of redraw necessary *\/$/;"	v
my_iconv_open	mbyte.c	/^my_iconv_open(to, from)$/;"	f
mz_buffer_type	if_mzsch.c	/^static Scheme_Type mz_buffer_type;$/;"	v	file:
mz_fix_cursor	if_mzsch.c	/^mz_fix_cursor(int lo, int hi, int extra)$/;"	f	file:
mz_threads_allow	if_mzsch.c	/^static int mz_threads_allow = 0;$/;"	v	file:
mz_window_type	if_mzsch.c	/^static Scheme_Type mz_window_type;$/;"	v	file:
mzgc_imports	if_mzsch.c	/^static Thunk_Info mzgc_imports[] = {$/;"	v	file:
mzsch_imports	if_mzsch.c	/^static Thunk_Info mzsch_imports[] = {$/;"	v	file:
mzscheme_beep	if_mzsch.c	/^mzscheme_beep(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
mzscheme_buffer_free	if_mzsch.c	/^mzscheme_buffer_free(buf_T *buf)$/;"	f
mzscheme_enabled	if_mzsch.c	/^mzscheme_enabled(int verbose)$/;"	f
mzscheme_end	if_mzsch.c	/^mzscheme_end(void)$/;"	f
mzscheme_init	if_mzsch.c	/^mzscheme_init(void)$/;"	f	file:
mzscheme_interface_init	if_mzsch.c	/^mzscheme_interface_init(vim_mz_buffer *mzbuff)$/;"	f	file:
mzscheme_io_init	if_mzsch.c	/^mzscheme_io_init(void)$/;"	f	file:
mzscheme_open_buffer	if_mzsch.c	/^mzscheme_open_buffer(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
mzscheme_runtime_link_init	if_mzsch.c	/^mzscheme_runtime_link_init(char *sch_dll, char *gc_dll, int verbose)$/;"	f	file:
mzscheme_window_free	if_mzsch.c	/^mzscheme_window_free(win_T *win)$/;"	f
mzthreads_allowed	if_mzsch.c	/^mzthreads_allowed(void)$/;"	f
mzvim_apply	if_mzsch.c	/^mzvim_apply(Scheme_Object *proc, int argc, Scheme_Object **argv)$/;"	f
mzvim_check_threads	if_mzsch.c	/^mzvim_check_threads(void)$/;"	f
mzvim_eval_string	if_mzsch.c	/^mzvim_eval_string(char_u *str)$/;"	f
mzvim_reset_timer	if_mzsch.c	/^mzvim_reset_timer(void)$/;"	f
nChars	gui_at_fs.c	/^    int		nChars;$/;"	m	struct:__anon14	file:
nEntries	gui_at_fs.c	/^    int		nEntries;$/;"	m	struct:__anon14	file:
nIndexHigh	if_cscope.h	/^    DWORD	    nIndexHigh;	\/* st_ino has no meaning in the Windows *\/$/;"	m	struct:csi
nIndexLow	if_cscope.h	/^    DWORD	    nIndexLow;$/;"	m	struct:csi
nVolume	if_cscope.h	/^    DWORD	    nVolume;	\/* Volume serial number, instead of st_dev *\/$/;"	m	struct:csi
n_collated_copies	structs.h	/^    int		n_collated_copies;$/;"	m	struct:__anon100
n_commands	main.c	/^    int		n_commands;		     \/* no. of commands from + or -c *\/$/;"	m	struct:__anon39	file:
n_opencmd	normal.c	/^n_opencmd(cap)$/;"	f	file:
n_pre_commands	main.c	/^    int		n_pre_commands;		     \/* no. of commands from --cmd *\/$/;"	m	struct:__anon39	file:
n_start_visual_mode	normal.c	/^n_start_visual_mode(c)$/;"	f	file:
n_swapchar	normal.c	/^n_swapchar(cap)$/;"	f	file:
n_uncollated_copies	structs.h	/^    int		n_uncollated_copies;$/;"	m	struct:__anon100
name	ex_docmd.c	/^    char	*name;$/;"	m	struct:cmdmod	file:
name	ex_docmd.c	/^    char    *name;$/;"	m	struct:__anon10	file:
name	fileio.c	/^    char	*name;	\/* event name *\/$/;"	m	struct:event_name	file:
name	gui_at_fs.c	/^    char	*name;$/;"	m	struct:__anon15	file:
name	gui_gtk_x11.c	/^    const char	    *name;$/;"	m	struct:__anon18	file:
name	gui_xmdlg.c	/^    Widget	name;$/;"	m	struct:_SharedFontSelData	file:
name	hardcopy.c	/^    char	*name;$/;"	m	struct:prt_mediasize_S	file:
name	hardcopy.c	/^    char_u  name[64];$/;"	m	struct:prt_ps_resource_S	file:
name	if_cscope.h	/^    char *  name;$/;"	m	struct:__anon68
name	if_mzsch.c	/^    char	    *name;$/;"	m	struct:__anon24	file:
name	if_mzsch.c	/^    char	*name;$/;"	m	struct:__anon23	file:
name	if_mzsch.c	/^    char    *name;$/;"	m	struct:__anon27	file:
name	if_python.c	/^    char *name;$/;"	m	struct:__anon28	file:
name	if_ruby.c	/^    char *name;$/;"	m	struct:__anon36	file:
name	if_tcl.c	/^    char* name;$/;"	m	struct:__anon38	file:
name	mbyte.c	/^{   char *name;		int canon;}$/;"	m	struct:__anon41	file:
name	mbyte.c	/^{   char *name;		int prop;		int codepage;}$/;"	m	struct:__anon40	file:
name	misc2.c	/^    char_u	name;		\/* Single letter name of modifier *\/$/;"	m	struct:modmasktable	file:
name	misc2.c	/^    char_u  *name;	\/* Name of key *\/$/;"	m	struct:key_name_entry	file:
name	os_unix.c	/^    char    *name;	\/* Signal name (not char_u!). *\/$/;"	m	struct:signalinfo	file:
name	search.c	/^    char_u	*name;		\/* Full name of file *\/$/;"	m	struct:SearchedFile	file:
name	structs.h	/^    char	*name;		\/* mode name (fixed) *\/$/;"	m	struct:cursor_entry
name	structs.h	/^    char_u	*name;		    \/* Name of menu *\/$/;"	m	struct:VimMenu
name	structs.h	/^    const char	*name;$/;"	m	struct:__anon98
name	syntax.c	/^    char	*name;$/;"	m	struct:name_list	file:
name	syntax.c	/^    char    *name;				\/* subcommand name *\/$/;"	m	struct:subcommand	file:
name	term.c	/^    char_u  name[2];	    \/* termcap name of entry *\/$/;"	m	struct:termcode	file:
name	workshop.c	/^    char	*name;			\/* name of the menu *\/$/;"	m	struct:__anon62	file:
nameStrip	workshop.c	/^nameStrip($/;"	f	file:
name_callback	gui_xmdlg.c	/^name_callback(Widget w,$/;"	f	file:
name_list	syntax.c	/^struct name_list$/;"	s	file:
name_part	gui_xmdlg.c	/^name_part(char *font, char *buf)$/;"	f	file:
name_to_mod_mask	misc2.c	/^name_to_mod_mask(c)$/;"	f
namedfm	mark.c	/^static xfmark_T namedfm[NMARKS + EXTRA_MARKS];		\/* marks with file nr *\/$/;"	v	file:
namelowcpy	misc1.c	/^namelowcpy($/;"	f	file:
names	gui_xmdlg.c	/^    char	**names;	\/* font name array of arrays *\/$/;"	m	struct:_SharedFontSelData	file:
nb_bufp2nbbuf_fire	netbeans.c	/^nb_bufp2nbbuf_fire(buf_T *bufp, int *bufnop)$/;"	f	file:
nb_debug	nbdebug.c	/^FILE		*nb_debug = NULL;$/;"	v
nb_dlevel	nbdebug.c	/^u_int		 nb_dlevel = 0;		\/* nb_debug verbosity level *\/$/;"	v
nb_do_cmd	netbeans.c	/^nb_do_cmd($/;"	f	file:
nb_get_buf	netbeans.c	/^nb_get_buf(int bufno)$/;"	f	file:
nb_getbufno	netbeans.c	/^nb_getbufno(buf_T *bufp)$/;"	f	file:
nb_init_graphics	netbeans.c	/^nb_init_graphics(void)$/;"	f	file:
nb_joinlines	netbeans.c	/^nb_joinlines(linenr_T first, linenr_T other)$/;"	f	file:
nb_parse_cmd	netbeans.c	/^nb_parse_cmd(char_u *cmd)$/;"	f	file:
nb_partialremove	netbeans.c	/^nb_partialremove(linenr_T lnum, colnr_T first, colnr_T last)$/;"	f	file:
nb_quote	netbeans.c	/^nb_quote(char_u *txt)$/;"	f	file:
nb_reply_nil	netbeans.c	/^nb_reply_nil(int cmdno)$/;"	f	file:
nb_reply_nr	netbeans.c	/^nb_reply_nr(int cmdno, long result)$/;"	f	file:
nb_reply_text	netbeans.c	/^nb_reply_text(int cmdno, char_u *result)$/;"	f	file:
nb_send	netbeans.c	/^nb_send(char *buf, char *fun)$/;"	f	file:
nb_set_curbuf	netbeans.c	/^nb_set_curbuf(buf_T *buf)$/;"	f	file:
nb_unquote	netbeans.c	/^nb_unquote(char_u *p, char_u **endp)$/;"	f	file:
nbbuf_T	netbeans.c	/^typedef struct nbbuf_struct nbbuf_T;$/;"	t	typeref:struct:nbbuf_struct	file:
nbbuf_number	netbeans.c	/^    int			 nbbuf_number;$/;"	m	struct:nbbuf_struct	file:
nbbuf_struct	netbeans.c	/^struct nbbuf_struct$/;"	s	file:
nbdbg	nbdebug.c	/^nbdbg($/;"	f
nbdbg	nbdebug.h	/^nbdbg($/;"	f
nbdebug	nbdebug.h	/^#define nbdebug(/;"	d
nbdebug	vim.h	/^# define nbdebug(/;"	d
nbdebug_log_init	nbdebug.c	/^nbdebug_log_init($/;"	f
nbdebug_wait	nbdebug.c	/^void nbdebug_wait($/;"	f
nbprt	nbdebug.c	/^nbprt($/;"	f
nbprt	nbdebug.h	/^nbprt($/;"	f
nbtrace	nbdebug.c	/^nbtrace($/;"	f
nbtrace	nbdebug.h	/^nbtrace($/;"	f
nchar	structs.h	/^    int		nchar;		\/* next command character (optional) *\/$/;"	m	struct:cmdarg_S
ncharC1	structs.h	/^    int		ncharC1;	\/* first composing character (optional) *\/$/;"	m	struct:cmdarg_S
ncharC2	structs.h	/^    int		ncharC2;	\/* second composing character (optional) *\/$/;"	m	struct:cmdarg_S
need_check_timestamps	globals.h	/^EXTERN int	need_check_timestamps INIT(= FALSE); \/* need to check file$/;"	v
need_clear_subexpr	regexp.c	/^static int	need_clear_subexpr;	\/* subexpressions still need to be$/;"	v	file:
need_clear_zsubexpr	regexp.c	/^static int	need_clear_zsubexpr = FALSE;	\/* extmatch subexpressions$/;"	v	file:
need_clr_eos	globals.h	/^EXTERN int	need_clr_eos INIT(= FALSE); \/* need to clear text before$/;"	v
need_fileinfo	globals.h	/^EXTERN int	need_fileinfo INIT(= FALSE);\/* do fileinfo() after redraw *\/$/;"	v
need_gather	term.c	/^static int	need_gather = FALSE;	    \/* need to fill termleader[] *\/$/;"	v	file:
need_highlight_changed	globals.h	/^EXTERN int	need_highlight_changed INIT(= TRUE);$/;"	v
need_maketitle	globals.h	/^EXTERN int	need_maketitle INIT(= TRUE); \/* call maketitle() soon *\/$/;"	v
need_mouse_correct	globals.h	/^EXTERN int	need_mouse_correct INIT(= FALSE);$/;"	v
need_rethrow	ex_docmd.c	/^    int		need_rethrow;$/;"	m	struct:dbg_stuff	file:
need_rethrow	globals.h	/^EXTERN int need_rethrow INIT(= FALSE);$/;"	v
need_start_insertmode	globals.h	/^EXTERN int	need_start_insertmode INIT(= FALSE);$/;"	v
need_wait_return	globals.h	/^EXTERN int	need_wait_return INIT(= 0); \/* need to wait for return later *\/$/;"	v
needs_charset	hardcopy.c	/^    int		needs_charset;$/;"	m	struct:prt_ps_encoding_S	file:
needupdate	netbeans.c	/^static int needupdate = 0;$/;"	v	file:
nested	fileio.c	/^    char	    nested;		\/* If autocommands nest here *\/$/;"	m	struct:AutoCmd	file:
netbeansArg	globals.h	/^EXTERN char *netbeansArg INIT(= NULL);	\/* the -nb[:host:port:passwd] arg *\/$/;"	v
netbeansCloseFile	globals.h	/^EXTERN int netbeansCloseFile INIT(= 0);	\/* send killed if != 0 *\/$/;"	v
netbeansFireChanges	globals.h	/^EXTERN int netbeansFireChanges INIT(= 1); \/* send buffer changes if != 0 *\/$/;"	v
netbeansForcedQuit	globals.h	/^EXTERN int netbeansForcedQuit INIT(= 0);\/* don't write modified files *\/$/;"	v
netbeansReadFile	globals.h	/^EXTERN int netbeansReadFile INIT(= 1);	\/* OK to read from disk if != 0 *\/$/;"	v
netbeansSuppressNoLines	globals.h	/^EXTERN int netbeansSuppressNoLines INIT(= 0); \/* skip "No lines in buffer" *\/$/;"	v
netbeans_Xt_connect	netbeans.c	/^netbeans_Xt_connect(void *context)$/;"	f	file:
netbeans_beval_cb	netbeans.c	/^netbeans_beval_cb($/;"	f
netbeans_button_release	netbeans.c	/^netbeans_button_release(int button)$/;"	f
netbeans_connect	netbeans.c	/^netbeans_connect(void)$/;"	f	file:
netbeans_deleted_all_lines	netbeans.c	/^netbeans_deleted_all_lines(buf_T *bufp)$/;"	f
netbeans_disconnect	netbeans.c	/^netbeans_disconnect(void)$/;"	f	file:
netbeans_draw_multisign_indicator	netbeans.c	/^netbeans_draw_multisign_indicator(int row)$/;"	f
netbeans_end	netbeans.c	/^netbeans_end(void)$/;"	f
netbeans_file_activated	netbeans.c	/^netbeans_file_activated(buf_T *bufp)$/;"	f
netbeans_file_closed	netbeans.c	/^netbeans_file_closed(buf_T *bufp)$/;"	f
netbeans_file_opened	netbeans.c	/^netbeans_file_opened(buf_T *bufp)$/;"	f
netbeans_frame_moved	netbeans.c	/^netbeans_frame_moved(int new_x, int new_y)$/;"	f
netbeans_gtk_connect	netbeans.c	/^netbeans_gtk_connect(void)$/;"	f	file:
netbeans_gutter_click	netbeans.c	/^netbeans_gutter_click(linenr_T lnum)$/;"	f
netbeans_inserted	netbeans.c	/^netbeans_inserted($/;"	f
netbeans_is_guarded	netbeans.c	/^netbeans_is_guarded(linenr_T top, linenr_T bot)$/;"	f
netbeans_keycommand	netbeans.c	/^netbeans_keycommand(int key)$/;"	f
netbeans_keyname	netbeans.c	/^netbeans_keyname(int key, char *buf)$/;"	f	file:
netbeans_keystring	netbeans.c	/^netbeans_keystring(int key, char *keyName)$/;"	f	file:
netbeans_parse_messages	netbeans.c	/^netbeans_parse_messages(void)$/;"	f
netbeans_removed	netbeans.c	/^netbeans_removed($/;"	f
netbeans_save_buffer	netbeans.c	/^netbeans_save_buffer(buf_T *bufp)$/;"	f
netbeans_send_disconnect	netbeans.c	/^netbeans_send_disconnect()$/;"	f
netbeans_startup_done	netbeans.c	/^netbeans_startup_done(void)$/;"	f
netbeans_unmodified	netbeans.c	/^netbeans_unmodified(buf_T *bufp)$/;"	f
netbeans_w32_connect	netbeans.c	/^netbeans_w32_connect(void)$/;"	f	file:
newFoldLevel	fold.c	/^newFoldLevel()$/;"	f
newFoldLevelWin	fold.c	/^newFoldLevelWin(wp)$/;"	f	file:
new_cmdpos	ex_getln.c	/^static int	new_cmdpos;	\/* position set by set_cmdline_pos() *\/$/;"	v	file:
new_curbuf	structs.h	/^    buf_T	*new_curbuf;	\/* buffer to be used *\/$/;"	m	struct:__anon97
new_curwin	structs.h	/^    win_T	*new_curwin;	\/* new curwin if save_curwin != NULL *\/$/;"	m	struct:__anon97
new_insert_skip	edit.c	/^static int	new_insert_skip;  \/* nr of chars in front of current insert *\/$/;"	v	file:
new_last_cmdline	globals.h	/^EXTERN char_u	*new_last_cmdline INIT(= NULL);	\/* new value for last_cmdline *\/$/;"	v
new_pixel_height	globals.h	/^EXTERN int	new_pixel_height INIT(= 0);$/;"	v
new_pixel_width	globals.h	/^EXTERN int	new_pixel_width INIT(= 0);$/;"	v
new_script_vars	eval.c	/^new_script_vars(id)$/;"	f
newenv	misc2.c	/^newenv()$/;"	f	file:
newline_on_exit	globals.h	/^EXTERN int	newline_on_exit INIT(= FALSE);	\/* did msg in altern. screen *\/$/;"	v
next	fileio.c	/^    struct AutoCmd  *next;		\/* Next AutoCmd in list *\/$/;"	m	struct:AutoCmd	typeref:struct:AutoCmd::AutoCmd	file:
next	fileio.c	/^    struct AutoPat  *next;		\/* next AutoPat in AutoPat list *\/$/;"	m	struct:AutoPat	typeref:struct:AutoPat::AutoPat	file:
next	fileio.c	/^    struct AutoPatCmd   *next;	\/* chain of active apc-s for auto-invalidation*\/$/;"	m	struct:AutoPatCmd	typeref:struct:AutoPatCmd::AutoPatCmd	file:
next	if_tcl.c	/^    struct ref	*next;$/;"	m	struct:ref	typeref:struct:ref::ref	file:
next	message.c	/^    struct msg_hist	*next;$/;"	m	struct:msg_hist	typeref:struct:msg_hist::msg_hist	file:
next	netbeans.c	/^    struct cmdqueue *next;$/;"	m	struct:cmdqueue	typeref:struct:cmdqueue::cmdqueue	file:
next	netbeans.c	/^    struct keyqueue *next;$/;"	m	struct:keyqueue	typeref:struct:keyqueue::keyqueue	file:
next	quickfix.c	/^    efm_T	    *next;	\/* pointer to next (NULL if last) *\/$/;"	m	struct:efm_S	file:
next	quickfix.c	/^    struct dir_stack_T	*next;$/;"	m	struct:dir_stack_T	typeref:struct:dir_stack_T::dir_stack_T	file:
next	spell.c	/^	wordnode_T *next;	\/* next node with same hash key *\/$/;"	m	union:wordnode_S::__anon55	file:
next	structs.h	/^    eslist_T	*next;			\/* next element on the list *\/$/;"	m	struct:eslist_elem
next	structs.h	/^    matchitem_T	*next;$/;"	m	struct:matchitem
next	structs.h	/^    signlist_T	*next;		\/* next signlist entry *\/$/;"	m	struct:signlist
next	structs.h	/^    struct msglist	*next;		\/* next of several messages in a row *\/$/;"	m	struct:msglist	typeref:struct:msglist::msglist
next	structs.h	/^    vimmenu_T	*next;		    \/* Next item in menu *\/$/;"	m	struct:VimMenu
nextPtr	if_xcmdsrv.c	/^    struct PendingCommand *nextPtr;$/;"	m	struct:PendingCommand	typeref:struct:PendingCommand::PendingCommand	file:
next_fenc	fileio.c	/^next_fenc(pp)$/;"	f	file:
next_for_item	eval.c	/^next_for_item(fi_void, arg)$/;"	f
next_list	structs.h	/^    short	*next_list;	\/* ID list for next match (if non-zero) *\/$/;"	m	struct:keyentry
next_list	syntax.c	/^    short	*next_list;	\/* group IDs for "nextgroup" argument *\/$/;"	m	struct:__anon58	file:
next_match_col	syntax.c	/^static int next_match_col;		\/* column for start of next match *\/$/;"	v	file:
next_match_end_idx	syntax.c	/^static int next_match_end_idx;		\/* ID of group for end pattn or zero *\/$/;"	v	file:
next_match_eoe_pos	syntax.c	/^static lpos_T next_match_eoe_pos;	\/* pos. for end of end pattern *\/$/;"	v	file:
next_match_eos_pos	syntax.c	/^static lpos_T next_match_eos_pos;	\/* end of start pattn (start region) *\/$/;"	v	file:
next_match_extmatch	syntax.c	/^static reg_extmatch_T *next_match_extmatch = NULL;$/;"	v	file:
next_match_flags	syntax.c	/^static long next_match_flags;		\/* flags for next match *\/$/;"	v	file:
next_match_h_endpos	syntax.c	/^static lpos_T next_match_h_endpos;	\/* pos. for highl. end of next match *\/$/;"	v	file:
next_match_h_startpos	syntax.c	/^static lpos_T next_match_h_startpos;  \/* pos. for highl. start of next match *\/$/;"	v	file:
next_match_idx	syntax.c	/^static int next_match_idx;		\/* index of matched item *\/$/;"	v	file:
next_match_m_endpos	syntax.c	/^static lpos_T next_match_m_endpos;	\/* position for end of next match *\/$/;"	v	file:
next_search_hl	screen.c	/^next_search_hl(win, shl, lnum, mincol)$/;"	f	file:
nextb	regexp.c	/^    int		nextb;		\/* next byte *\/$/;"	m	struct:regstar_S	file:
nextb_ic	regexp.c	/^    int		nextb_ic;	\/* next byte reverse case *\/$/;"	m	struct:regstar_S	file:
nextchr	regexp.c	/^static int	nextchr;    \/* used for ungetchr() *\/$/;"	v	file:
nextcmd	ex_cmds.h	/^    char_u	*nextcmd;	\/* next command (NULL if none) *\/$/;"	m	struct:exarg
nextcmd	fileio.c	/^    AutoCmd	*nextcmd;	\/* next AutoCmd to execute *\/$/;"	m	struct:AutoPatCmd	file:
nextent	termlib.c	/^nextent(tbuf, termcap, buflen)		\/* Read 1 entry from TERMCAP file *\/$/;"	f	file:
nextline	ex_cmds2.c	/^    char_u      *nextline;      \/* if not NULL: line that was read ahead *\/$/;"	m	struct:source_cookie	file:
nextwild	ex_getln.c	/^nextwild(xp, type, options)$/;"	f	file:
no_Magic	regexp.c	/^no_Magic(x)$/;"	f	file:
no_abbr	globals.h	/^EXTERN int	no_abbr INIT(= TRUE);	\/* TRUE when no abbreviations loaded *\/$/;"	v
no_check_timestamps	globals.h	/^EXTERN int	no_check_timestamps INIT(= 0);	\/* Don't check timestamps *\/$/;"	v
no_console_input	gui.c	/^no_console_input()$/;"	f
no_hlsearch	globals.h	/^EXTERN int	no_hlsearch INIT(= FALSE);$/;"	v
no_lines_msg	globals.h	/^EXTERN char_u no_lines_msg[]	INIT(= N_("--No lines in buffer--"));$/;"	v
no_mapping	globals.h	/^EXTERN int no_mapping INIT(= FALSE);	\/* currently no mapping allowed *\/$/;"	v
no_scs	search.c	/^    int		    no_scs;	\/* no smarcase for this pattern *\/$/;"	m	struct:spat	file:
no_smartcase	globals.h	/^EXTERN int	no_smartcase INIT(= FALSE);	\/* don't use 'smartcase' once *\/$/;"	v
no_spell_checking	spell.c	/^no_spell_checking(wp)$/;"	f	file:
no_swap_file	main.c	/^    int		no_swap_file;		\/* "-n" argument used *\/$/;"	m	struct:__anon39	file:
no_u_sync	globals.h	/^EXTERN int no_u_sync INIT(= 0);		\/* Don't call u_sync() *\/$/;"	v
no_viminfo	ex_cmds.c	/^no_viminfo()$/;"	f	file:
no_wait_return	globals.h	/^EXTERN int	no_wait_return INIT(= 0);   \/* don't wait for return for now *\/$/;"	v
no_zero_mapping	globals.h	/^EXTERN int no_zero_mapping INIT(= 0);	\/* mapping zero not allowed *\/$/;"	v
noalt	gui_gtk.c	/^    int		noalt;		    \/* accept accelerators without Alt *\/$/;"	m	struct:_DialogInfo	file:
node_compress	spell.c	/^node_compress(spin, node, ht, tot)$/;"	f	file:
node_equal	spell.c	/^node_equal(n1, n2)$/;"	f	file:
nofile_fname	tag.c	/^static char_u	*nofile_fname = NULL;	\/* fname for NOTAGFILE error *\/$/;"	v	file:
nofold_len	spell.c	/^nofold_len(fword, flen, word)$/;"	f	file:
non_zero_arg	eval.c	/^non_zero_arg(argvars)$/;"	f	file:
noremap	structs.h	/^    int		noremap[MENU_MODES]; \/* A REMAP_ flag for each mode *\/$/;"	m	struct:VimMenu
noremapbuf_init	getchar.c	/^static char_u	noremapbuf_init[TYPELEN_INIT];	\/* initial typebuf.tb_noremap *\/$/;"	v	file:
norm_font	gui.h	/^    GuiFont	norm_font;	    \/* Normal font *\/$/;"	m	struct:Gui
norm_pixel	gui.h	/^    guicolor_T	norm_pixel;	    \/* Color of normal text *\/$/;"	m	struct:Gui
normal_cmd	normal.c	/^normal_cmd(oap, toplevel)$/;"	f
normal_pixmap	gui_xmebwp.h	/^    Pixmap normal_pixmap;$/;"	m	struct:_XmEnhancedButtonPart
normal_search	normal.c	/^normal_search(cap, dir, pat, opt)$/;"	f	file:
not_exiting	ex_docmd.c	/^not_exiting()$/;"	f
not_writing	ex_cmds.c	/^not_writing()$/;"	f
notify_multithread	if_mzsch.c	/^notify_multithread(int on)$/;"	f	file:
nr2hex	charset.c	/^nr2hex(c)$/;"	f	file:
nr_trans	structs.h	/^struct nr_trans$/;"	s
nt_new_bnum	structs.h	/^    blocknr_T	nt_new_bnum;		\/* new, positive, number *\/$/;"	m	struct:nr_trans
nt_next	structs.h	/^    NR_TRANS	*nt_next;		\/* next nr_trans in hash list *\/$/;"	m	struct:nr_trans
nt_old_bnum	structs.h	/^    blocknr_T	nt_old_bnum;		\/* old, negative, number *\/$/;"	m	struct:nr_trans
nt_prev	structs.h	/^    NR_TRANS	*nt_prev;		\/* previous nr_trans in hash list *\/$/;"	m	struct:nr_trans
num	gui_xmdlg.c	/^    int		num;		\/* number of font names *\/$/;"	m	struct:_SharedFontSelData	file:
num_alloc	misc2.c	/^static long_u num_alloc;$/;"	v	file:
num_charsets	hardcopy.c	/^    int				num_charsets;$/;"	m	struct:prt_ps_mbfont_S	file:
num_cols	gui.h	/^    int		num_cols;	    \/* Number of columns *\/$/;"	m	struct:Gui
num_complex_braces	regexp.c	/^static int	num_complex_braces; \/* Complex \\{...} count *\/$/;"	v	file:
num_encodings	hardcopy.c	/^    int				num_encodings;$/;"	m	struct:prt_ps_mbfont_S	file:
num_freed	misc2.c	/^static long_u num_freed;$/;"	v	file:
num_rows	gui.h	/^    int		num_rows;	    \/* Number of rows *\/$/;"	m	struct:Gui
number	structs.h	/^    long	number;$/;"	m	struct:__anon98
number	structs.h	/^    prt_text_attr_T number;$/;"	m	struct:__anon100
number_width	screen.c	/^number_width(wp)$/;"	f
number_width	vim.h	/^# define number_width(/;"	d
nv_Replace	normal.c	/^nv_Replace(cap)$/;"	f	file:
nv_Undo	normal.c	/^nv_Undo(cap)$/;"	f	file:
nv_Zet	normal.c	/^nv_Zet(cap)$/;"	f	file:
nv_abbrev	normal.c	/^nv_abbrev(cap)$/;"	f	file:
nv_addsub	normal.c	/^nv_addsub(cap)$/;"	f	file:
nv_at	normal.c	/^nv_at(cap)$/;"	f	file:
nv_bck_word	normal.c	/^nv_bck_word(cap)$/;"	f	file:
nv_beginline	normal.c	/^nv_beginline(cap)$/;"	f	file:
nv_brace	normal.c	/^nv_brace(cap)$/;"	f	file:
nv_brackets	normal.c	/^nv_brackets(cap)$/;"	f	file:
nv_clear	normal.c	/^nv_clear(cap)$/;"	f	file:
nv_cmd	normal.c	/^static const struct nv_cmd$/;"	s	file:
nv_cmd_idx	normal.c	/^static short nv_cmd_idx[NV_CMDS_SIZE];$/;"	v	file:
nv_cmds	normal.c	/^} nv_cmds[] =$/;"	v	typeref:struct:nv_cmd	file:
nv_colon	normal.c	/^nv_colon(cap)$/;"	f	file:
nv_compare	normal.c	/^nv_compare(s1, s2)$/;"	f	file:
nv_csearch	normal.c	/^nv_csearch(cap)$/;"	f	file:
nv_ctrlg	normal.c	/^nv_ctrlg(cap)$/;"	f	file:
nv_ctrlh	normal.c	/^nv_ctrlh(cap)$/;"	f	file:
nv_ctrlo	normal.c	/^nv_ctrlo(cap)$/;"	f	file:
nv_cursorhold	normal.c	/^nv_cursorhold(cap)$/;"	f	file:
nv_cursormark	normal.c	/^nv_cursormark(cap, flag, pos)$/;"	f	file:
nv_diffgetput	diff.c	/^nv_diffgetput(put)$/;"	f
nv_dollar	normal.c	/^nv_dollar(cap)$/;"	f	file:
nv_dot	normal.c	/^nv_dot(cap)$/;"	f	file:
nv_down	normal.c	/^nv_down(cap)$/;"	f	file:
nv_drop	normal.c	/^nv_drop(cap)$/;"	f	file:
nv_edit	normal.c	/^nv_edit(cap)$/;"	f	file:
nv_end	normal.c	/^nv_end(cap)$/;"	f	file:
nv_error	normal.c	/^nv_error(cap)$/;"	f	file:
nv_esc	normal.c	/^nv_esc(cap)$/;"	f	file:
nv_exmode	normal.c	/^nv_exmode(cap)$/;"	f	file:
nv_findpar	normal.c	/^nv_findpar(cap)$/;"	f	file:
nv_func_T	normal.c	/^typedef void (*nv_func_T) __ARGS((cmdarg_T *cap));$/;"	t	file:
nv_g_cmd	normal.c	/^nv_g_cmd(cap)$/;"	f	file:
nv_gd	normal.c	/^nv_gd(oap, nchar, thisblock)$/;"	f	file:
nv_gomark	normal.c	/^nv_gomark(cap)$/;"	f	file:
nv_goto	normal.c	/^nv_goto(cap)$/;"	f	file:
nv_gotofile	normal.c	/^nv_gotofile(cap)$/;"	f	file:
nv_halfpage	normal.c	/^nv_halfpage(cap)$/;"	f	file:
nv_hat	normal.c	/^nv_hat(cap)$/;"	f	file:
nv_help	normal.c	/^nv_help(cap)$/;"	f	file:
nv_home	normal.c	/^nv_home(cap)$/;"	f	file:
nv_hor_scrollbar	normal.c	/^nv_hor_scrollbar(cap)$/;"	f	file:
nv_ident	normal.c	/^nv_ident(cap)$/;"	f	file:
nv_ignore	normal.c	/^nv_ignore(cap)$/;"	f	file:
nv_join	normal.c	/^nv_join(cap)$/;"	f	file:
nv_kundo	normal.c	/^nv_kundo(cap)$/;"	f	file:
nv_left	normal.c	/^nv_left(cap)$/;"	f	file:
nv_lineop	normal.c	/^nv_lineop(cap)$/;"	f	file:
nv_mark	normal.c	/^nv_mark(cap)$/;"	f	file:
nv_max_linear	normal.c	/^static int nv_max_linear;$/;"	v	file:
nv_mouse	normal.c	/^nv_mouse(cap)$/;"	f	file:
nv_mousescroll	normal.c	/^nv_mousescroll(cap)$/;"	f	file:
nv_nbcmd	normal.c	/^nv_nbcmd(cap)$/;"	f	file:
nv_next	normal.c	/^nv_next(cap)$/;"	f	file:
nv_nop	normal.c	/^nv_nop(cap)$/;"	f	file:
nv_normal	normal.c	/^nv_normal(cap)$/;"	f	file:
nv_object	normal.c	/^nv_object(cap)$/;"	f	file:
nv_open	normal.c	/^nv_open(cap)$/;"	f	file:
nv_operator	normal.c	/^nv_operator(cap)$/;"	f	file:
nv_optrans	normal.c	/^nv_optrans(cap)$/;"	f	file:
nv_page	normal.c	/^nv_page(cap)$/;"	f	file:
nv_pcmark	normal.c	/^nv_pcmark(cap)$/;"	f	file:
nv_percent	normal.c	/^nv_percent(cap)$/;"	f	file:
nv_pipe	normal.c	/^nv_pipe(cap)$/;"	f	file:
nv_put	normal.c	/^nv_put(cap)$/;"	f	file:
nv_record	normal.c	/^nv_record(cap)$/;"	f	file:
nv_redo	normal.c	/^nv_redo(cap)$/;"	f	file:
nv_regname	normal.c	/^nv_regname(cap)$/;"	f	file:
nv_replace	normal.c	/^nv_replace(cap)$/;"	f	file:
nv_right	normal.c	/^nv_right(cap)$/;"	f	file:
nv_screengo	normal.c	/^nv_screengo(oap, dir, dist)$/;"	f	file:
nv_scroll	normal.c	/^nv_scroll(cap)$/;"	f	file:
nv_scroll_line	normal.c	/^nv_scroll_line(cap)$/;"	f	file:
nv_search	normal.c	/^nv_search(cap)$/;"	f	file:
nv_select	normal.c	/^nv_select(cap)$/;"	f	file:
nv_sniff	normal.c	/^nv_sniff(cap)$/;"	f	file:
nv_subst	normal.c	/^nv_subst(cap)$/;"	f	file:
nv_suspend	normal.c	/^nv_suspend(cap)$/;"	f	file:
nv_tabline	normal.c	/^nv_tabline(cap)$/;"	f	file:
nv_tabmenu	normal.c	/^nv_tabmenu(cap)$/;"	f	file:
nv_tagpop	normal.c	/^nv_tagpop(cap)$/;"	f	file:
nv_tilde	normal.c	/^nv_tilde(cap)$/;"	f	file:
nv_undo	normal.c	/^nv_undo(cap)$/;"	f	file:
nv_up	normal.c	/^nv_up(cap)$/;"	f	file:
nv_ver_scrollbar	normal.c	/^nv_ver_scrollbar(cap)$/;"	f	file:
nv_visual	normal.c	/^nv_visual(cap)$/;"	f	file:
nv_vreplace	normal.c	/^nv_vreplace(cap)$/;"	f	file:
nv_window	normal.c	/^nv_window(cap)$/;"	f	file:
nv_wordcmd	normal.c	/^nv_wordcmd(cap)$/;"	f	file:
nv_zet	normal.c	/^nv_zet(cap)$/;"	f	file:
oap	structs.h	/^    oparg_T	*oap;		\/* Operator arguments *\/$/;"	m	struct:cmdarg_S
objtbl	if_ruby.c	/^static VALUE objtbl;$/;"	v	file:
off	fold.c	/^    linenr_T	off;		\/* offset between lnum and real line number *\/$/;"	m	struct:__anon12	file:
off	search.c	/^    long	off;		\/* line or char offset *\/$/;"	m	struct:soffset	file:
off	search.c	/^    struct soffset  off;$/;"	m	struct:spat	typeref:struct:spat::soffset	file:
off2pos	netbeans.c	/^off2pos(buf_T *buf, long offset)$/;"	f	file:
offset	mbyte.c	/^    int offset;$/;"	m	struct:__anon42	file:
offset2bytes	spell.c	/^offset2bytes(nr, buf)$/;"	f	file:
ok	gui_xmdlg.c	/^    Widget	ok;$/;"	m	struct:_SharedFontSelData	file:
ok_callback	gui_xmdlg.c	/^ok_callback(Widget w,$/;"	f	file:
old	gui_xmdlg.c	/^    XFontStruct	*old;		\/* font data structure for sample display *\/$/;"	m	struct:_SharedFontSelData	file:
oldEvent	gui_at_sb.c	/^    XEvent *oldEvent;$/;"	m	struct:EventData	file:
old_char	getchar.c	/^static int old_char = -1;	\/* character put back by vungetc() *\/$/;"	v	file:
old_fn	if_python.c	/^static writefn old_fn = NULL;$/;"	v	file:
old_indent	edit.c	/^static int	old_indent = 0;		\/* for ^^D command in insert mode *\/$/;"	v	file:
old_label_expose	gui_motif.c	/^static XtExposeProc old_label_expose = NULL;$/;"	v	file:
old_list	gui_xmdlg.c	/^    XmFontList	old_list;	\/* font data structure for sample display *\/$/;"	m	struct:_SharedFontSelData	file:
old_mod_mask	getchar.c	/^static int old_mod_mask;	\/* mod_mask for ungotten character *\/$/;"	v	file:
old_mouse_shape	misc2.c	/^static int old_mouse_shape = 0;$/;"	v	file:
old_redobuff	getchar.c	/^static struct buffheader old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
old_showcmd_buf	normal.c	/^static char_u	old_showcmd_buf[SHOWCMD_BUFLEN];  \/* For push_showcmd() *\/$/;"	v	file:
old_sub	ex_cmds.c	/^static char_u	*old_sub = NULL;	\/* previous substitute pattern *\/$/;"	v	file:
old_termresponse	fileio.c	/^static char_u	*old_termresponse = NULL;$/;"	v	file:
oldicon	os_unix.c	/^static char_u	*oldicon = NULL;$/;"	v	file:
oldtitle	os_unix.c	/^static char_u	*oldtitle = NULL;$/;"	v	file:
on_select_tab	gui_gtk_x11.c	/^on_select_tab($/;"	f	file:
on_tabline_menu	gui_gtk_x11.c	/^on_tabline_menu(GtkWidget *widget, GdkEvent *event)$/;"	f	file:
oneLineTextEditTranslations	gui_at_fs.c	/^static char *oneLineTextEditTranslations = "\\$/;"	v	file:
one_adjust	mark.c	/^#define one_adjust(/;"	d	file:
one_adjust_nodel	mark.c	/^#define one_adjust_nodel(/;"	d	file:
one_exactly	regexp.c	/^static int	one_exactly = FALSE;	\/* only do one char for EXACTLY *\/$/;"	v	file:
onecap_copy	spell.c	/^onecap_copy(word, wcopy, upper)$/;"	f	file:
oneleft	edit.c	/^oneleft()$/;"	f
onepage	move.c	/^onepage(dir, count)$/;"	f
oneright	edit.c	/^oneright()$/;"	f
only_one_window	window.c	/^only_one_window()$/;"	f
opFoldRange	fold.c	/^opFoldRange(first, last, opening, recurse, had_visual)$/;"	f
op_change	ops.c	/^op_change(oap)$/;"	f
op_colon	normal.c	/^op_colon(oap)$/;"	f	file:
op_delete	ops.c	/^op_delete(oap)$/;"	f
op_format	ops.c	/^op_format(oap, keep_cursor)$/;"	f
op_formatexpr	ops.c	/^op_formatexpr(oap)$/;"	f
op_function	normal.c	/^op_function(oap)$/;"	f	file:
op_insert	ops.c	/^op_insert(oap, count1)$/;"	f
op_on_lines	ops.c	/^op_on_lines(op)$/;"	f
op_reindent	ops.c	/^op_reindent(oap, how)$/;"	f
op_replace	ops.c	/^op_replace(oap, c)$/;"	f
op_shift	ops.c	/^op_shift(oap, curs_top, amount)$/;"	f
op_tilde	ops.c	/^op_tilde(oap)$/;"	f
op_type	structs.h	/^    int		op_type;	\/* current pending operator type *\/$/;"	m	struct:oparg_S
op_yank	ops.c	/^op_yank(oap, deleting, mess)$/;"	f
oparg_S	structs.h	/^typedef struct oparg_S$/;"	s
oparg_T	structs.h	/^} oparg_T;$/;"	t	typeref:struct:oparg_S
opchars	ops.c	/^static char opchars[][3] =$/;"	v	file:
opcount	globals.h	/^EXTERN int	opcount INIT(= 0);	\/* count for pending operator *\/$/;"	v
opcount	structs.h	/^    long	opcount;	\/* count before an operator *\/$/;"	m	struct:cmdarg_S
openFold	fold.c	/^openFold(lnum, count)$/;"	f
openFoldRecurse	fold.c	/^openFoldRecurse(lnum)$/;"	f
open_app_context	ui.c	/^open_app_context()$/;"	f
open_buffer	buffer.c	/^open_buffer(read_stdin, eap)$/;"	f
open_exfile	ex_docmd.c	/^open_exfile(fname, forceit, mode)$/;"	f
open_line	misc1.c	/^open_line(dir, flags, old_indent)$/;"	f
open_spellbuf	spell.c	/^open_spellbuf()$/;"	f	file:
openscript	getchar.c	/^openscript(name, directly)$/;"	f
opt_strings_flags	option.c	/^opt_strings_flags(val, values, flagp, list)$/;"	f	file:
option_expand	option.c	/^option_expand(opt_idx, val)$/;"	f	file:
option_table_T	structs.h	/^} option_table_T;$/;"	t	typeref:struct:__anon98
option_value2string	option.c	/^option_value2string(opp, opt_flags)$/;"	f	file:
option_was_set	option.c	/^option_was_set(name)$/;"	f
optioncmd	if_tcl.c	/^optioncmd(dummy, interp, objc, objv)$/;"	f	file:
options	option.c	/^	options[] =$/;"	v	typeref:struct:_far	file:
optval_default	option.c	/^optval_default(p, varp)$/;"	f	file:
orientation	gui_at_sb.h	/^    XtOrientation orientation;	\/* horizontal or vertical *\/$/;"	m	struct:__anon64
orig_line_count	globals.h	/^EXTERN int	orig_line_count INIT(= 0);  \/* Line count when "gR" started *\/$/;"	v
orig_topfill	term.c	/^static int orig_topfill = 0;$/;"	v	file:
orig_topline	term.c	/^static linenr_T orig_topline = 0;$/;"	v	file:
origin_end_col	vim.h	/^    short_u	origin_end_col;$/;"	m	struct:VimClipboard
origin_row	vim.h	/^    short_u	origin_row;$/;"	m	struct:VimClipboard
origin_start_col	vim.h	/^    short_u	origin_start_col;$/;"	m	struct:VimClipboard
ospeed	term.c	/^short ospeed;$/;"	v
ospeed	termlib.c	/^short	ospeed;		      \/* Baud rate (1-16, 1=300, 16=19200), as in stty *\/$/;"	v
other_sourcing_name	message.c	/^other_sourcing_name()$/;"	f	file:
otherfile	buffer.c	/^otherfile(ffname)$/;"	f
otherfile_buf	buffer.c	/^otherfile_buf(buf, ffname$/;"	f	file:
out_buf	term.c	/^static char_u		out_buf[OUT_SIZE + 1];$/;"	v	file:
out_char	term.c	/^out_char(c)$/;"	f
out_char_nf	term.c	/^out_char_nf(c)$/;"	f	file:
out_flush	term.c	/^out_flush()$/;"	f
out_flush_check	term.c	/^out_flush_check()$/;"	f
out_pos	term.c	/^static int		out_pos = 0;	\/* number of chars in out_buf *\/$/;"	v	file:
out_str	term.c	/^out_str(s)$/;"	f
out_str_nf	term.c	/^out_str_nf(s)$/;"	f
out_trash	term.c	/^out_trash()$/;"	f
outfile	structs.h	/^    char_u	*outfile;$/;"	m	struct:__anon100
output_conv	globals.h	/^EXTERN vimconv_T output_conv;			\/* type of output conversion *\/$/;"	v
overstrike	ex_getln.c	/^    int		overstrike;	\/* Typing mode on the command line.  Shared by$/;"	m	struct:cmdline_info	file:
owned	vim.h	/^    int		owned;		\/* Flag: do we own the selection? *\/$/;"	m	struct:VimClipboard
p_acd	option.h	/^EXTERN int	p_acd;		\/* 'autochdir' *\/$/;"	v
p_ai	option.c	/^static int	p_ai;$/;"	v	file:
p_ai_nopaste	option.c	/^static int	p_ai_nopaste;$/;"	v	file:
p_aleph	option.h	/^EXTERN long	p_aleph;	\/* 'aleph' *\/$/;"	v
p_altkeymap	option.h	/^EXTERN int	p_altkeymap;	\/* 'altkeymap' *\/$/;"	v
p_ambw	option.h	/^EXTERN char_u	*p_ambw;	\/* 'ambiwidth' *\/$/;"	v
p_ambw_values	option.c	/^static char *(p_ambw_values[]) = {"single", "double", NULL};$/;"	v	file:
p_antialias	option.h	/^EXTERN int	*p_antialias;	\/* 'antialias' *\/$/;"	v
p_ar	option.h	/^EXTERN int	p_ar;		\/* 'autoread' *\/$/;"	v
p_ari	option.h	/^EXTERN int	p_ari;		\/* 'allowrevins' *\/$/;"	v
p_arshape	option.h	/^EXTERN int	p_arshape;	\/* 'arabicshape' *\/$/;"	v
p_aw	option.h	/^EXTERN int	p_aw;		\/* 'autowrite' *\/$/;"	v
p_awa	option.h	/^EXTERN int	p_awa;		\/* 'autowriteall' *\/$/;"	v
p_bdir	option.h	/^EXTERN char_u	*p_bdir;	\/* 'backupdir' *\/$/;"	v
p_bdlay	option.h	/^EXTERN long	p_bdlay;	\/* 'balloondelay' *\/$/;"	v
p_beval	option.h	/^EXTERN int	p_beval;	\/* 'ballooneval' *\/$/;"	v
p_bex	option.h	/^EXTERN char_u	*p_bex;		\/* 'backupext' *\/$/;"	v
p_bexpr	option.h	/^EXTERN char_u	*p_bexpr;$/;"	v
p_bg	option.h	/^EXTERN char_u	*p_bg;		\/* 'background' *\/$/;"	v
p_bg_values	option.c	/^static char *(p_bg_values[]) = {"light", "dark", NULL};$/;"	v	file:
p_bh	option.c	/^static char_u	*p_bh;$/;"	v	file:
p_bin	option.c	/^static int	p_bin;$/;"	v	file:
p_biosk	option.h	/^EXTERN int	p_biosk;	\/* 'bioskey' *\/$/;"	v
p_bk	option.h	/^EXTERN int	p_bk;		\/* 'backup' *\/$/;"	v
p_bkc	option.h	/^EXTERN char_u	*p_bkc;		\/* 'backupcopy' *\/$/;"	v
p_bkc_values	option.h	/^static char *(p_bkc_values[]) = {"yes", "auto", "no", "breaksymlink", "breakhardlink", NULL};$/;"	v
p_bl	option.c	/^static int	p_bl;$/;"	v	file:
p_bomb	option.c	/^static int	p_bomb;$/;"	v	file:
p_breakat	option.h	/^EXTERN char_u	*p_breakat;	\/* 'breakat' *\/$/;"	v
p_bs	option.h	/^EXTERN char_u	*p_bs;		\/* 'backspace' *\/$/;"	v
p_bs_values	option.c	/^static char *(p_bs_values[]) = {"indent", "eol", "start", NULL};$/;"	v	file:
p_bsdir	option.h	/^EXTERN char_u	*p_bsdir;	\/* 'browsedir' *\/$/;"	v
p_bsdir_values	option.c	/^static char *(p_bsdir_values[]) = {"current", "last", "buffer", NULL};$/;"	v	file:
p_bsk	option.h	/^EXTERN char_u	*p_bsk;		\/* 'backupskip' *\/$/;"	v
p_bt	option.c	/^static char_u	*p_bt;$/;"	v	file:
p_bufhidden_values	option.c	/^static char *(p_bufhidden_values[]) = {"hide", "unload", "delete", "wipe", NULL};$/;"	v	file:
p_buftype_values	option.c	/^static char *(p_buftype_values[]) = {"nofile", "nowrite", "quickfix", "help", "acwrite", NULL};$/;"	v	file:
p_buftype_values	option.c	/^static char *(p_buftype_values[]) = {"nofile", "nowrite", "quickfix", "help", NULL};$/;"	v	file:
p_cb	option.h	/^EXTERN char_u	*p_cb;		\/* 'clipboard' *\/$/;"	v
p_ccv	option.h	/^EXTERN char_u	*p_ccv;		\/* 'charconvert' *\/$/;"	v
p_cdpath	option.h	/^EXTERN char_u	*p_cdpath;	\/* 'cdpath' *\/$/;"	v
p_cedit	option.h	/^EXTERN char_u	*p_cedit;	\/* 'cedit' *\/$/;"	v
p_cfu	option.c	/^static char_u	*p_cfu;$/;"	v	file:
p_ch	option.h	/^EXTERN long	p_ch;		\/* 'cmdheight' *\/$/;"	v
p_ci	option.c	/^static int	p_ci;$/;"	v	file:
p_cin	option.c	/^static int	p_cin;$/;"	v	file:
p_cink	option.c	/^static char_u	*p_cink;$/;"	v	file:
p_cino	option.c	/^static char_u	*p_cino;$/;"	v	file:
p_cinw	option.c	/^static char_u	*p_cinw;$/;"	v	file:
p_cmp	option.h	/^EXTERN char_u	*p_cmp;		\/* 'casemap' *\/$/;"	v
p_cmp_values	option.h	/^static char *(p_cmp_values[]) = {"internal", "keepascii", NULL};$/;"	v
p_cms	option.c	/^static char_u	*p_cms;$/;"	v	file:
p_com	option.c	/^static char_u	*p_com;$/;"	v	file:
p_confirm	option.h	/^EXTERN int	p_confirm;	\/* 'confirm' *\/$/;"	v
p_consk	option.h	/^EXTERN int	p_consk;	\/* 'conskey' *\/$/;"	v
p_cot	option.h	/^EXTERN char_u	*p_cot;		\/* 'completeopt' *\/$/;"	v
p_cot_values	option.c	/^static char *(p_cot_values[]) = {"menu", "menuone", "longest", "preview", NULL};$/;"	v	file:
p_cp	option.h	/^EXTERN int	p_cp;		\/* 'compatible' *\/$/;"	v
p_cpo	option.h	/^EXTERN char_u	*p_cpo;		\/* 'cpoptions' *\/$/;"	v
p_cpt	option.c	/^static char_u	*p_cpt;$/;"	v	file:
p_cspc	option.h	/^EXTERN long	p_cspc;		\/* 'cscopepathcomp' *\/$/;"	v
p_csprg	option.h	/^EXTERN char_u	*p_csprg;	\/* 'cscopeprg' *\/$/;"	v
p_csqf	option.h	/^EXTERN char_u	*p_csqf;	\/* 'cscopequickfix' *\/$/;"	v
p_cst	option.h	/^EXTERN int	p_cst;		\/* 'cscopetag' *\/$/;"	v
p_csto	option.h	/^EXTERN long	p_csto;		\/* 'cscopetagorder' *\/$/;"	v
p_csverbose	option.h	/^EXTERN int	p_csverbose;	\/* 'cscopeverbose' *\/$/;"	v
p_cwh	option.h	/^EXTERN long	p_cwh;		\/* 'cmdwinheight' *\/$/;"	v
p_debug	option.h	/^EXTERN char_u	*p_debug;	\/* 'debug' *\/$/;"	v
p_debug_values	option.c	/^static char *(p_debug_values[]) = {"msg", "throw", "beep", NULL};$/;"	v	file:
p_deco	option.h	/^EXTERN int	p_deco;		\/* 'delcombine' *\/$/;"	v
p_def	option.h	/^EXTERN char_u	*p_def;		\/* 'define' *\/$/;"	v
p_dex	option.h	/^EXTERN char_u	*p_dex;		\/* 'diffexpr' *\/$/;"	v
p_dg	option.h	/^EXTERN int	p_dg;		\/* 'digraph' *\/$/;"	v
p_dict	option.h	/^EXTERN char_u	*p_dict;	\/* 'dictionary' *\/$/;"	v
p_dip	option.h	/^EXTERN char_u	*p_dip;		\/* 'diffopt' *\/$/;"	v
p_dir	option.h	/^EXTERN char_u	*p_dir;		\/* 'directory' *\/$/;"	v
p_dy	option.h	/^EXTERN char_u	*p_dy;		\/* 'display' *\/$/;"	v
p_dy_values	option.h	/^static char *(p_dy_values[]) = {"lastline", "uhex", NULL};$/;"	v
p_ea	option.h	/^EXTERN int	p_ea;		\/* 'equalalways' *\/$/;"	v
p_ead	option.h	/^EXTERN char_u	*p_ead;		\/* 'eadirection' *\/$/;"	v
p_ead_values	option.c	/^static char *(p_ead_values[]) = {"both", "ver", "hor", NULL};$/;"	v	file:
p_eb	option.h	/^EXTERN int	p_eb;		\/* 'errorbells' *\/$/;"	v
p_ed	option.h	/^EXTERN int	p_ed;		\/* 'edcompatible' *\/$/;"	v
p_ef	option.h	/^EXTERN char_u	*p_ef;		\/* 'errorfile' *\/$/;"	v
p_efm	option.h	/^EXTERN char_u	*p_efm;		\/* 'errorformat' *\/$/;"	v
p_ei	option.h	/^EXTERN char_u	*p_ei;		\/* 'eventignore' *\/$/;"	v
p_ek	option.h	/^EXTERN int	p_ek;		\/* 'esckeys' *\/$/;"	v
p_enc	option.h	/^EXTERN char_u	*p_enc;		\/* 'encoding' *\/$/;"	v
p_eol	option.c	/^static int	p_eol;$/;"	v	file:
p_ep	option.h	/^EXTERN char_u	*p_ep;		\/* 'equalprg' *\/$/;"	v
p_et	option.c	/^static int	p_et;$/;"	v	file:
p_et_nobin	option.c	/^static int	p_et_nobin;$/;"	v	file:
p_exrc	option.h	/^EXTERN int	p_exrc;		\/* 'exrc' *\/$/;"	v
p_fcl	option.h	/^EXTERN char_u	*p_fcl;		\/* 'foldclose' *\/$/;"	v
p_fcl_values	option.c	/^static char *(p_fcl_values[]) = {"all", NULL};$/;"	v	file:
p_fcs	option.h	/^EXTERN char_u	*p_fcs;		\/* 'fillchar' *\/$/;"	v
p_fdls	option.h	/^EXTERN long	p_fdls;		\/* 'foldlevelstart' *\/$/;"	v
p_fdm_values	option.c	/^static char *(p_fdm_values[]) = {"manual", "expr", "marker", "indent", "syntax",$/;"	v	file:
p_fdo	option.h	/^EXTERN char_u	*p_fdo;		\/* 'foldopen' *\/$/;"	v
p_fdo_values	option.h	/^static char *(p_fdo_values[]) = {"all", "block", "hor", "mark", "percent",$/;"	v
p_fenc	option.c	/^static char_u	*p_fenc;$/;"	v	file:
p_fencs	option.h	/^EXTERN char_u	*p_fencs;	\/* 'fileencodings' *\/$/;"	v
p_fex	option.c	/^static char_u	*p_fex;$/;"	v	file:
p_ff	option.c	/^static char_u	*p_ff;$/;"	v	file:
p_ff_values	option.c	/^static char *(p_ff_values[]) = {FF_UNIX, FF_DOS, FF_MAC, NULL};$/;"	v	file:
p_ffs	option.h	/^EXTERN char_u	*p_ffs;		\/* 'fileformats' *\/$/;"	v
p_fkmap	option.h	/^EXTERN int	p_fkmap;	\/* 'fkmap' *\/$/;"	v
p_flp	option.c	/^static char_u	*p_flp;$/;"	v	file:
p_fo	option.c	/^static char_u	*p_fo;$/;"	v	file:
p_fp	option.h	/^EXTERN char_u	*p_fp;		\/* 'formatprg' *\/$/;"	v
p_fs	option.h	/^EXTERN int	p_fs;		\/* 'fsync' *\/$/;"	v
p_ft	option.c	/^static char_u	*p_ft;$/;"	v	file:
p_gd	option.h	/^EXTERN int	p_gd;		\/* 'gdefault' *\/$/;"	v
p_gefm	option.h	/^EXTERN char_u	*p_gefm;	\/* 'grepformat' *\/$/;"	v
p_ghr	option.h	/^EXTERN long	p_ghr;		\/* 'guiheadroom' *\/$/;"	v
p_go	option.h	/^EXTERN char_u	*p_go;		\/* 'guioptions' *\/$/;"	v
p_gp	option.h	/^EXTERN char_u	*p_gp;		\/* 'grepprg' *\/$/;"	v
p_gtl	option.h	/^EXTERN char_u	*p_gtl;		\/* 'guitablabel' *\/$/;"	v
p_gtt	option.h	/^EXTERN char_u	*p_gtt;		\/* 'guitabtooltip' *\/$/;"	v
p_guicursor	option.h	/^EXTERN char_u	*p_guicursor;	\/* 'guicursor' *\/$/;"	v
p_guifont	option.h	/^EXTERN char_u	*p_guifont;	\/* 'guifont' *\/$/;"	v
p_guifontset	option.h	/^EXTERN char_u	*p_guifontset;	\/* 'guifontset' *\/$/;"	v
p_guifontwide	option.h	/^EXTERN char_u	*p_guifontwide;	\/* 'guifontwide' *\/$/;"	v
p_guipty	option.h	/^EXTERN int	p_guipty;	\/* 'guipty' *\/$/;"	v
p_header	option.h	/^EXTERN char_u	*p_header;	\/* 'printheader' *\/$/;"	v
p_hf	option.h	/^EXTERN char_u	*p_hf;		\/* 'helpfile' *\/$/;"	v
p_hh	option.h	/^EXTERN long	p_hh;		\/* 'helpheight' *\/$/;"	v
p_hi	option.h	/^EXTERN long	p_hi;		\/* 'history' *\/$/;"	v
p_hid	option.h	/^EXTERN int	p_hid;		\/* 'hidden' *\/$/;"	v
p_hkmap	option.h	/^EXTERN int	p_hkmap;	\/* 'hkmap' *\/$/;"	v
p_hkmapp	option.h	/^EXTERN int	p_hkmapp;	\/* 'hkmapp' *\/$/;"	v
p_hl	option.h	/^EXTERN char_u	*p_hl;		\/* 'highlight' *\/$/;"	v
p_hlg	option.h	/^EXTERN char_u	*p_hlg;		\/* 'helplang' *\/$/;"	v
p_hls	option.h	/^EXTERN int	p_hls;		\/* 'hlsearch' *\/$/;"	v
p_ic	option.h	/^EXTERN int	p_ic;		\/* 'ignorecase' *\/$/;"	v
p_icon	option.h	/^EXTERN int	p_icon;		\/* 'icon' *\/$/;"	v
p_iconstring	option.h	/^EXTERN char_u	*p_iconstring;	\/* 'iconstring' *\/$/;"	v
p_im	option.h	/^EXTERN int	p_im;		\/* 'insertmode' *\/$/;"	v
p_imak	option.h	/^EXTERN char_u	*p_imak;	\/* 'imactivatekey' *\/$/;"	v
p_imcmdline	option.h	/^EXTERN int	p_imcmdline;	\/* 'imcmdline' *\/$/;"	v
p_imdisable	option.h	/^EXTERN int	p_imdisable;	\/* 'imdisable' *\/$/;"	v
p_iminsert	option.c	/^static long	p_iminsert;$/;"	v	file:
p_imsearch	option.c	/^static long	p_imsearch;$/;"	v	file:
p_inc	option.h	/^EXTERN char_u	*p_inc;$/;"	v
p_inde	option.c	/^static char_u	*p_inde;$/;"	v	file:
p_indk	option.c	/^static char_u	*p_indk;$/;"	v	file:
p_inex	option.c	/^static char_u	*p_inex;$/;"	v	file:
p_inf	option.c	/^static int	p_inf;$/;"	v	file:
p_is	option.h	/^EXTERN int	p_is;		\/* 'incsearch' *\/$/;"	v
p_isf	option.h	/^EXTERN char_u	*p_isf;		\/* 'isfname' *\/$/;"	v
p_isi	option.h	/^EXTERN char_u	*p_isi;		\/* 'isident' *\/$/;"	v
p_isk	option.c	/^static char_u	*p_isk;$/;"	v	file:
p_isp	option.h	/^EXTERN char_u	*p_isp;		\/* 'isprint' *\/$/;"	v
p_js	option.h	/^EXTERN int	p_js;		\/* 'joinspaces' *\/$/;"	v
p_key	option.c	/^static char_u	*p_key;$/;"	v	file:
p_keymap	option.c	/^static char_u	*p_keymap;$/;"	v	file:
p_km	option.h	/^EXTERN char_u	*p_km;		\/* 'keymodel' *\/$/;"	v
p_km_values	option.c	/^static char *(p_km_values[]) = {"startsel", "stopsel", NULL};$/;"	v	file:
p_kp	option.h	/^EXTERN char_u	*p_kp;		\/* 'keywordprg' *\/$/;"	v
p_langmap	option.h	/^EXTERN char_u	*p_langmap;	\/* 'langmap'*\/$/;"	v
p_lcs	option.h	/^EXTERN char_u	*p_lcs;		\/* 'listchars' *\/$/;"	v
p_linespace	option.h	/^EXTERN long	p_linespace;	\/* 'linespace' *\/$/;"	v
p_lisp	option.c	/^static int	p_lisp;$/;"	v	file:
p_lispwords	option.h	/^EXTERN char_u	*p_lispwords;	\/* 'lispwords' *\/$/;"	v
p_lm	option.h	/^EXTERN char_u	*p_lm;		\/* 'langmenu' *\/$/;"	v
p_lpl	option.h	/^EXTERN int	p_lpl;		\/* 'loadplugins' *\/$/;"	v
p_ls	option.h	/^EXTERN long	p_ls;		\/* 'laststatus' *\/$/;"	v
p_lz	option.h	/^EXTERN int	p_lz;		\/* 'lazyredraw' *\/$/;"	v
p_ma	option.c	/^static int	p_ma;$/;"	v	file:
p_macatsui	option.h	/^EXTERN int	p_macatsui;	\/* 'macatsui' *\/$/;"	v
p_magic	option.h	/^EXTERN int	p_magic;	\/* 'magic' *\/$/;"	v
p_mat	option.h	/^EXTERN long	p_mat;		\/* 'matchtime' *\/$/;"	v
p_mco	option.h	/^EXTERN long	p_mco;		\/* 'maxcombine' *\/$/;"	v
p_mef	option.h	/^EXTERN char_u	*p_mef;		\/* 'makeef' *\/$/;"	v
p_mfd	option.h	/^EXTERN long	p_mfd;		\/* 'maxfuncdepth' *\/$/;"	v
p_mh	option.h	/^EXTERN int	p_mh;		\/* 'mousehide' *\/$/;"	v
p_mis	option.h	/^EXTERN long	p_mis;		\/* 'menuitems' *\/$/;"	v
p_ml	option.c	/^static int	p_ml;$/;"	v	file:
p_ml_nobin	option.c	/^static int	p_ml_nobin;$/;"	v	file:
p_mls	option.h	/^EXTERN long	p_mls;		\/* 'modelines' *\/$/;"	v
p_mm	option.h	/^EXTERN long	p_mm;		\/* 'maxmem' *\/$/;"	v
p_mmd	option.h	/^EXTERN long	p_mmd;		\/* 'maxmapdepth' *\/$/;"	v
p_mmp	option.h	/^EXTERN long	p_mmp;		\/* 'maxmempattern' *\/$/;"	v
p_mmt	option.h	/^EXTERN long	p_mmt;		\/* 'maxmemtot' *\/$/;"	v
p_mod	option.c	/^static int	p_mod;$/;"	v	file:
p_more	option.h	/^EXTERN int	p_more;		\/* 'more' *\/$/;"	v
p_mouse	option.h	/^EXTERN char_u	*p_mouse;	\/* 'mouse' *\/$/;"	v
p_mousef	option.h	/^EXTERN int	p_mousef;	\/* 'mousefocus' *\/$/;"	v
p_mousem	option.h	/^EXTERN char_u	*p_mousem;	\/* 'mousemodel' *\/$/;"	v
p_mousem_values	option.c	/^static char *(p_mousem_values[]) = {"extend", "popup", "popup_setpos", "mac", NULL};$/;"	v	file:
p_mouseshape	option.h	/^EXTERN char_u	*p_mouseshape;	\/* 'mouseshape' *\/$/;"	v
p_mouset	option.h	/^EXTERN long	p_mouset;	\/* 'mousetime' *\/$/;"	v
p_mp	option.h	/^EXTERN char_u	*p_mp;		\/* 'makeprg' *\/$/;"	v
p_mps	option.c	/^static char_u	*p_mps;$/;"	v	file:
p_msm	option.h	/^EXTERN char_u	*p_msm;		\/* 'mkspellmem' *\/$/;"	v
p_mzq	option.h	/^EXTERN long	p_mzq;		\/* 'mzquantum *\/$/;"	v
p_nf	option.c	/^static char_u	*p_nf;$/;"	v	file:
p_nf_values	option.c	/^static char *(p_nf_values[]) = {"octal", "hex", "alpha", NULL};$/;"	v	file:
p_odev	option.h	/^EXTERN int	p_odev;		\/* 'opendevice' *\/$/;"	v
p_oft	option.c	/^static char_u	*p_oft;$/;"	v	file:
p_ofu	option.c	/^static char_u	*p_ofu;$/;"	v	file:
p_opfunc	option.h	/^EXTERN char_u	*p_opfunc;	\/* 'operatorfunc' *\/$/;"	v
p_para	option.h	/^EXTERN char_u	*p_para;	\/* 'paragraphs' *\/$/;"	v
p_paste	option.h	/^EXTERN int	p_paste;	\/* 'paste' *\/$/;"	v
p_path	option.h	/^EXTERN char_u	*p_path;	\/* 'path' *\/$/;"	v
p_pdev	option.h	/^EXTERN char_u	*p_pdev;	\/* 'printdevice' *\/$/;"	v
p_penc	option.h	/^EXTERN char_u	*p_penc;	\/* 'printencoding' *\/$/;"	v
p_pex	option.h	/^EXTERN char_u	*p_pex;		\/* 'patchexpr' *\/$/;"	v
p_pexpr	option.h	/^EXTERN char_u	*p_pexpr;	\/* 'printexpr' *\/$/;"	v
p_pfn	option.h	/^EXTERN char_u	*p_pfn;		\/* 'printfont' *\/$/;"	v
p_ph	option.h	/^EXTERN long	p_ph;		\/* 'pumheight' *\/$/;"	v
p_pi	option.c	/^static int	p_pi;$/;"	v	file:
p_pm	option.h	/^EXTERN char_u	*p_pm;		\/* 'patchmode' *\/$/;"	v
p_pmcs	option.h	/^EXTERN char_u	*p_pmcs;	\/* 'printmbcharset' *\/$/;"	v
p_pmfn	option.h	/^EXTERN char_u	*p_pmfn;	\/* 'printmbfont' *\/$/;"	v
p_popt	option.h	/^EXTERN char_u	*p_popt;	\/* 'printoptions' *\/$/;"	v
p_prompt	option.h	/^EXTERN int	p_prompt;	\/* 'prompt' *\/$/;"	v
p_pt	option.h	/^EXTERN char_u	*p_pt;		\/* 'pastetoggle' *\/$/;"	v
p_pvh	option.h	/^EXTERN long	p_pvh;		\/* 'previewheight' *\/$/;"	v
p_qe	option.c	/^static char_u	*p_qe;$/;"	v	file:
p_rdt	option.h	/^EXTERN long	p_rdt;		\/* 'redrawtime' *\/$/;"	v
p_remap	option.h	/^EXTERN int	p_remap;	\/* 'remap' *\/$/;"	v
p_report	option.h	/^EXTERN long	p_report;	\/* 'report' *\/$/;"	v
p_ri	option.h	/^EXTERN int	p_ri;		\/* 'revins' *\/$/;"	v
p_ro	option.c	/^static int	p_ro;$/;"	v	file:
p_rs	option.h	/^EXTERN int	p_rs;		\/* 'restorescreen' *\/$/;"	v
p_rtp	option.h	/^EXTERN char_u	*p_rtp;		\/* 'runtimepath' *\/$/;"	v
p_ru	option.h	/^EXTERN int	p_ru;		\/* 'ruler' *\/$/;"	v
p_ruf	option.h	/^EXTERN char_u	*p_ruf;		\/* 'rulerformat' *\/$/;"	v
p_sb	option.h	/^EXTERN int	p_sb;		\/* 'splitbelow' *\/$/;"	v
p_sbo	option.h	/^EXTERN char_u	*p_sbo;		\/* 'scrollopt' *\/$/;"	v
p_sbr	option.h	/^EXTERN char_u	*p_sbr;		\/* 'showbreak' *\/$/;"	v
p_sc	option.h	/^EXTERN int	p_sc;		\/* 'showcmd' *\/$/;"	v
p_scbopt_values	option.c	/^static char *(p_scbopt_values[]) = {"ver", "hor", "jump", NULL};$/;"	v	file:
p_scs	option.h	/^EXTERN int	p_scs;		\/* 'smartcase' *\/$/;"	v
p_sections	option.h	/^EXTERN char_u	*p_sections;	\/* 'sections' *\/$/;"	v
p_secure	option.h	/^EXTERN int	p_secure;	\/* 'secure' *\/$/;"	v
p_sel	option.h	/^EXTERN char_u	*p_sel;		\/* 'selection' *\/$/;"	v
p_sel_values	option.c	/^static char *(p_sel_values[]) = {"inclusive", "exclusive", "old", NULL};$/;"	v	file:
p_sft	option.h	/^EXTERN int	p_sft;		\/* 'showfulltag' *\/$/;"	v
p_sh	option.h	/^EXTERN char_u	*p_sh;		\/* 'shell' *\/$/;"	v
p_shcf	option.h	/^EXTERN char_u	*p_shcf;	\/* 'shellcmdflag' *\/$/;"	v
p_shm	option.h	/^EXTERN char_u	*p_shm;		\/* 'shortmess' *\/$/;"	v
p_shq	option.h	/^EXTERN char_u	*p_shq;		\/* 'shellquote' *\/$/;"	v
p_si	option.c	/^static int	p_si;$/;"	v	file:
p_siso	option.h	/^EXTERN long	p_siso;		\/* 'sidescrolloff' *\/$/;"	v
p_sj	option.h	/^EXTERN long	p_sj;		\/* 'scrolljump' *\/$/;"	v
p_slm	option.h	/^EXTERN char_u	*p_slm;		\/* 'selectmode' *\/$/;"	v
p_slm_values	option.c	/^static char *(p_slm_values[]) = {"mouse", "key", "cmd", NULL};$/;"	v	file:
p_sm	option.h	/^EXTERN int	p_sm;		\/* 'showmatch' *\/$/;"	v
p_smc	option.c	/^static long	p_smc;$/;"	v	file:
p_smd	option.h	/^EXTERN int	p_smd;		\/* 'showmode' *\/$/;"	v
p_sn	option.c	/^static int	p_sn;$/;"	v	file:
p_so	option.h	/^EXTERN long	p_so;		\/* 'scrolloff' *\/$/;"	v
p_sol	option.h	/^EXTERN int	p_sol;		\/* 'startofline' *\/$/;"	v
p_sp	option.h	/^EXTERN char_u	*p_sp;		\/* 'shellpipe' *\/$/;"	v
p_spc	option.c	/^static char_u	*p_spc;$/;"	v	file:
p_spf	option.c	/^static char_u	*p_spf;$/;"	v	file:
p_spl	option.c	/^static char_u	*p_spl;$/;"	v	file:
p_spr	option.h	/^EXTERN int	p_spr;		\/* 'splitright' *\/$/;"	v
p_sps	option.h	/^EXTERN char_u	*p_sps;		\/* 'spellsuggest' *\/$/;"	v
p_sr	option.h	/^EXTERN int	p_sr;		\/* 'shiftround' *\/$/;"	v
p_srr	option.h	/^EXTERN char_u	*p_srr;		\/* 'shellredir' *\/$/;"	v
p_ss	option.h	/^EXTERN long	p_ss;		\/* 'sidescroll' *\/$/;"	v
p_ssl	option.h	/^EXTERN int	p_ssl;		\/* 'shellslash' *\/$/;"	v
p_ssop	option.h	/^EXTERN char_u	*p_ssop;	\/* 'sessionoptions' *\/$/;"	v
p_ssop_values	option.h	/^static char *(p_ssop_values[]) = {"buffers", "winpos", "resize", "winsize",$/;"	v
p_st	option.h	/^EXTERN long	p_st;		\/* 'shelltype' *\/$/;"	v
p_sta	option.h	/^EXTERN int	p_sta;		\/* 'smarttab' *\/$/;"	v
p_stal	option.h	/^EXTERN long	p_stal;		\/* 'showtabline' *\/$/;"	v
p_stl	option.h	/^EXTERN char_u	*p_stl;		\/* 'statusline' *\/$/;"	v
p_stmp	option.h	/^EXTERN int	p_stmp;		\/* 'shelltemp' *\/$/;"	v
p_sts	option.c	/^static long	p_sts;$/;"	v	file:
p_sts_nopaste	option.c	/^static long	p_sts_nopaste;$/;"	v	file:
p_su	option.h	/^EXTERN char_u	*p_su;		\/* 'suffixes' *\/$/;"	v
p_sua	option.c	/^static char_u	*p_sua;$/;"	v	file:
p_sw	option.c	/^static long	p_sw;$/;"	v	file:
p_swb	option.h	/^EXTERN char_u	*p_swb;		\/* 'switchbuf' *\/$/;"	v
p_swb_values	option.h	/^static char *(p_swb_values[]) = {"useopen", "usetab", "split", "newtab", NULL};$/;"	v
p_swf	option.c	/^static int	p_swf;$/;"	v	file:
p_sws	option.h	/^EXTERN char_u	*p_sws;		\/* 'swapsync' *\/$/;"	v
p_sxq	option.h	/^EXTERN char_u	*p_sxq;		\/* 'shellxquote' *\/$/;"	v
p_syn	option.c	/^static char_u	*p_syn;$/;"	v	file:
p_ta	option.h	/^EXTERN int	p_ta;		\/* 'textauto' *\/$/;"	v
p_tags	option.h	/^EXTERN char_u	*p_tags;	\/* 'tags' *\/$/;"	v
p_tal	option.h	/^EXTERN char_u	*p_tal;		\/* 'tabline' *\/$/;"	v
p_tbi	option.h	/^EXTERN int	p_tbi;		\/* 'ttybuiltin' *\/$/;"	v
p_tbidi	option.h	/^EXTERN int	p_tbidi;	\/* 'termbidi' *\/$/;"	v
p_tbis	option.h	/^EXTERN char_u	*p_tbis;	\/* 'toolbariconsize' *\/$/;"	v
p_tbis_values	option.h	/^static char *(p_tbis_values[]) = {"tiny", "small", "medium", "large", NULL};$/;"	v
p_tbs	option.h	/^EXTERN int	p_tbs;		\/* 'tagbsearch' *\/$/;"	v
p_tenc	option.h	/^EXTERN char_u	*p_tenc;	\/* 'termencoding' *\/$/;"	v
p_term	option.c	/^#define p_term(/;"	d	file:
p_terse	option.h	/^EXTERN int	p_terse;	\/* 'terse' *\/$/;"	v
p_tf	option.h	/^EXTERN int	p_tf;		\/* 'ttyfast' *\/$/;"	v
p_tgst	option.h	/^EXTERN int	p_tgst;		\/* 'tagstack' *\/$/;"	v
p_timeout	option.h	/^EXTERN int	p_timeout;	\/* 'timeout' *\/$/;"	v
p_title	option.h	/^EXTERN int	p_title;	\/* 'title' *\/$/;"	v
p_titlelen	option.h	/^EXTERN long	p_titlelen;	\/* 'titlelen' *\/$/;"	v
p_titleold	option.h	/^EXTERN char_u	*p_titleold;	\/* 'titleold' *\/$/;"	v
p_titlestring	option.h	/^EXTERN char_u	*p_titlestring;	\/* 'titlestring' *\/$/;"	v
p_tl	option.h	/^EXTERN long	p_tl;		\/* 'taglength' *\/$/;"	v
p_tm	option.h	/^EXTERN long	p_tm;		\/* 'timeoutlen' *\/$/;"	v
p_to	option.h	/^EXTERN int	p_to;		\/* 'tildeop' *\/$/;"	v
p_toolbar	option.h	/^EXTERN char_u	*p_toolbar;	\/* 'toolbar' *\/$/;"	v
p_toolbar_values	option.h	/^static char *(p_toolbar_values[]) = {"text", "icons", "tooltips", "horiz", NULL};$/;"	v
p_tpm	option.h	/^EXTERN long	p_tpm;		\/* 'tabpagemax' *\/$/;"	v
p_tr	option.h	/^EXTERN int	p_tr;		\/* 'tagrelative' *\/$/;"	v
p_ts	option.c	/^static long	p_ts;$/;"	v	file:
p_tsr	option.h	/^EXTERN char_u	*p_tsr;		\/* 'thesaurus' *\/$/;"	v
p_ttimeout	option.h	/^EXTERN int	p_ttimeout;	\/* 'ttimeout' *\/$/;"	v
p_ttm	option.h	/^EXTERN long	p_ttm;		\/* 'ttimeoutlen' *\/$/;"	v
p_ttym	option.h	/^EXTERN char_u	*p_ttym;	\/* 'ttymouse' *\/$/;"	v
p_ttym_values	option.h	/^static char *(p_ttym_values[]) = {"xterm", "xterm2", "dec", "netterm", "jsbterm", "pterm", NULL};$/;"	v
p_ttyscroll	option.h	/^EXTERN long	p_ttyscroll;	\/* 'ttyscroll' *\/$/;"	v
p_tw	option.c	/^static long	p_tw;$/;"	v	file:
p_tw_nobin	option.c	/^static long	p_tw_nobin;$/;"	v	file:
p_tw_nopaste	option.c	/^static long	p_tw_nopaste;$/;"	v	file:
p_tx	option.c	/^static int	p_tx;$/;"	v	file:
p_uc	option.h	/^EXTERN long	p_uc;		\/* 'updatecount' *\/$/;"	v
p_ul	option.h	/^EXTERN long	p_ul;		\/* 'undolevels' *\/$/;"	v
p_ut	option.h	/^EXTERN long	p_ut;		\/* 'updatetime' *\/$/;"	v
p_vb	option.h	/^EXTERN int	p_vb;		\/* 'visualbell' *\/$/;"	v
p_vdir	option.h	/^EXTERN char_u	*p_vdir;	\/* 'viewdir' *\/$/;"	v
p_ve	option.h	/^EXTERN char_u	*p_ve;		\/* 'virtualedit' *\/$/;"	v
p_ve_values	option.h	/^static char *(p_ve_values[]) = {"block", "insert", "all", "onemore", NULL};$/;"	v
p_verbose	option.h	/^EXTERN long	p_verbose;	\/* 'verbose' *\/$/;"	v
p_vfile	option.h	/^EXTERN char_u	*p_vfile;	\/* 'verbosefile' *\/$/;"	v
p_viminfo	option.h	/^EXTERN char_u	*p_viminfo;	\/* 'viminfo' *\/$/;"	v
p_vop	option.h	/^EXTERN char_u	*p_vop;		\/* 'viewoptions' *\/$/;"	v
p_wa	option.h	/^EXTERN int	p_wa;		\/* 'writeany' *\/$/;"	v
p_wak	option.h	/^EXTERN char_u	*p_wak;		\/* 'winaltkeys' *\/$/;"	v
p_wak_values	option.c	/^static char *(p_wak_values[]) = {"yes", "menu", "no", NULL};$/;"	v	file:
p_warn	option.h	/^EXTERN int	p_warn;		\/* 'warn' *\/$/;"	v
p_wb	option.h	/^EXTERN int	p_wb;		\/* 'writebackup' *\/$/;"	v
p_wc	option.h	/^EXTERN long	p_wc;		\/* 'wildchar' *\/$/;"	v
p_wcm	option.h	/^EXTERN long	p_wcm;		\/* 'wildcharm' *\/$/;"	v
p_wd	option.h	/^EXTERN long	p_wd;		\/* 'writedelay' *\/$/;"	v
p_wh	option.h	/^EXTERN long	p_wh;		\/* 'winheight' *\/$/;"	v
p_wig	option.h	/^EXTERN char_u	*p_wig;		\/* 'wildignore' *\/$/;"	v
p_wim	option.h	/^EXTERN char_u	*p_wim;		\/* 'wildmode' *\/$/;"	v
p_window	option.h	/^EXTERN long	p_window;	\/* 'window' *\/$/;"	v
p_wiv	option.h	/^EXTERN int	p_wiv;		\/* 'weirdinvert' *\/$/;"	v
p_wiw	option.h	/^EXTERN long	p_wiw;		\/* 'winwidth' *\/$/;"	v
p_wm	option.c	/^static long	p_wm;$/;"	v	file:
p_wm_nobin	option.c	/^static long	p_wm_nobin;$/;"	v	file:
p_wm_nopaste	option.c	/^static long	p_wm_nopaste;$/;"	v	file:
p_wmh	option.h	/^EXTERN long	p_wmh;		\/* 'winminheight' *\/$/;"	v
p_wmnu	option.h	/^EXTERN int	p_wmnu;		\/* 'wildmenu' *\/$/;"	v
p_wmw	option.h	/^EXTERN long	p_wmw;		\/* 'winminwidth' *\/$/;"	v
p_wop	option.h	/^EXTERN char_u	*p_wop;		\/* 'wildoptions' *\/$/;"	v
p_wop_values	option.c	/^static char *(p_wop_values[]) = {"tagfile", NULL};$/;"	v	file:
p_write	option.h	/^EXTERN int	p_write;	\/* 'write' *\/$/;"	v
p_ws	option.h	/^EXTERN int	p_ws;		\/* 'wrapscan' *\/$/;"	v
p_ww	option.h	/^EXTERN char_u	*p_ww;		\/* 'whichwrap' *\/$/;"	v
page_count	hardcopy.c	/^static int	page_count;$/;"	v	file:
paragraph_start	ops.c	/^paragraph_start(lnum)$/;"	f
parent	structs.h	/^    vimmenu_T	*parent;	    \/* Parent of menu *\/$/;"	m	struct:VimMenu
parentTrans	gui_athena.c	/^static XtTranslations	popupTrans, parentTrans, menuTrans, supermenuTrans;$/;"	v	file:
parent_class	gui_gtk_f.c	/^static GtkWidgetClass *parent_class = NULL;$/;"	v	file:
parent_class	gui_gtk_f.h	/^    GtkContainerClass parent_class;$/;"	m	struct:_GtkFormClass
parseMarker	fold.c	/^parseMarker(wp)$/;"	f	file:
parse_builtin_tcap	term.c	/^parse_builtin_tcap(term)$/;"	f	file:
parse_command_name	main.c	/^parse_command_name(parmp)$/;"	f	file:
parse_compl_arg	ex_docmd.c	/^parse_compl_arg(value, vallen, complp, argt, compl_arg)$/;"	f
parse_list_options	hardcopy.c	/^parse_list_options(option_str, table, table_size)$/;"	f	file:
parse_match	tag.c	/^parse_match(lbuf, tagp)$/;"	f	file:
parse_printmbfont	hardcopy.c	/^parse_printmbfont()$/;"	f
parse_printoptions	hardcopy.c	/^parse_printoptions()$/;"	f
parse_shape_opt	misc2.c	/^parse_shape_opt(what)$/;"	f
parse_tag_line	tag.c	/^parse_tag_line(lbuf,$/;"	f	file:
parse_uri_list	gui_gtk_x11.c	/^parse_uri_list(int *count, char_u *data, int len)$/;"	f	file:
paste_option_changed	option.c	/^paste_option_changed()$/;"	f	file:
pat	fileio.c	/^    char_u	    *pat;		\/* pattern as typed (NULL when pattern$/;"	m	struct:AutoPat	file:
pat	search.c	/^    char_u	    *pat;	\/* the pattern (in allocated memory) or NULL *\/$/;"	m	struct:spat	file:
pat	tag.c	/^    char_u	*pat;		\/* the pattern *\/$/;"	m	struct:__anon60	file:
pat_T	tag.c	/^} pat_T;$/;"	t	typeref:struct:__anon60	file:
path	gui_at_fs.c	/^    char	*path;$/;"	m	struct:__anon14	file:
path_is_url	window.c	/^path_is_url(p)$/;"	f	file:
path_with_url	window.c	/^path_with_url(fname)$/;"	f
pathcmp	misc2.c	/^pathcmp(p, q, maxlen)$/;"	f
patlen	fileio.c	/^    int		    patlen;		\/* strlen() of pat *\/$/;"	m	struct:AutoPat	file:
pattern	structs.h	/^    char_u	*pattern;   \/* pattern to highlight *\/$/;"	m	struct:matchitem
pause_time	ex_cmds2.c	/^static proftime_T pause_time;$/;"	v	file:
pb_count	memline.c	/^    short_u	pb_count;	\/* number of pointer in this block *\/$/;"	m	struct:pointer_block	file:
pb_count_max	memline.c	/^    short_u	pb_count_max;	\/* maximum value for pb_count *\/$/;"	m	struct:pointer_block	file:
pb_id	memline.c	/^    short_u	pb_id;		\/* ID for pointer block: PTR_ID *\/$/;"	m	struct:pointer_block	file:
pb_pointer	memline.c	/^    PTR_EN	pb_pointer[1];	\/* list of pointers to blocks (actually longer)$/;"	m	struct:pointer_block	file:
pc_attr	edit.c	/^static int  pc_attr;$/;"	v	file:
pc_bytes	edit.c	/^static char_u pc_bytes[2];		\/* saved bytes *\/$/;"	v	file:
pc_bytes	edit.c	/^static char_u pc_bytes[MB_MAXBYTES + 1]; \/* saved bytes *\/$/;"	v	file:
pc_col	edit.c	/^static int  pc_col;$/;"	v	file:
pc_row	edit.c	/^static int  pc_row;$/;"	v	file:
pc_status	edit.c	/^static int  pc_status;$/;"	v	file:
pchar	macros.h	/^#define pchar(/;"	d
pchar_cursor	misc1.c	/^pchar_cursor(c)$/;"	f
pe_bnum	memline.c	/^    blocknr_T	pe_bnum;	\/* block number *\/$/;"	m	struct:pointer_entry	file:
pe_line_count	memline.c	/^    linenr_T	pe_line_count;	\/* number of lines in this branch *\/$/;"	m	struct:pointer_entry	file:
pe_old_lnum	memline.c	/^    linenr_T	pe_old_lnum;	\/* lnum for this block (for recovery) *\/$/;"	m	struct:pointer_entry	file:
pe_page_count	memline.c	/^    int		pe_page_count;	\/* number of pages in block pe_bnum *\/$/;"	m	struct:pointer_entry	file:
peekchr	regexp.c	/^peekchr()$/;"	f	file:
pending	structs.h	/^    int pending;		\/* error\/interrupt\/exception state *\/$/;"	m	struct:cleanup_stuff
pendingCommands	if_xcmdsrv.c	/^static PendingCommand *pendingCommands = NULL;$/;"	v	file:
percentage	structs.h	/^    int		percentage;	\/* percentage of cell for bar *\/$/;"	m	struct:cursor_entry
pid	if_cscope.h	/^    DWORD	    pid;	\/* PID of the connected cscope process. *\/$/;"	m	struct:csi
pid	if_cscope.h	/^    pid_t	    pid;	\/* PID of the connected cscope process. *\/$/;"	m	struct:csi
pixmap	gui_gtk_x11.c	/^    GdkPixmap *pixmap;$/;"	m	struct:__anon19	file:
pixmap_create_by_dir	gui_gtk.c	/^pixmap_create_by_dir(char_u *name, GdkPixmap **pixmap, GdkBitmap **mask)$/;"	f	file:
pixmap_create_by_num	gui_gtk.c	/^pixmap_create_by_num(int pixmap_num, GdkPixmap **pixmap, GdkBitmap **mask)$/;"	f	file:
pixmap_create_from_file	gui_gtk.c	/^pixmap_create_from_file(char_u *fname, GdkPixmap **pixmap, GdkBitmap **mask)$/;"	f	file:
pixmap_create_from_xpm	gui_gtk.c	/^pixmap_create_from_xpm(char **xpm, GdkPixmap **pixmap, GdkBitmap **mask)$/;"	f	file:
pixmap_data	gui_xmebwp.h	/^    String pixmap_data;$/;"	m	struct:_XmEnhancedButtonPart
pixmap_depth	gui_xmebwp.h	/^    int pixmap_depth;$/;"	m	struct:_XmEnhancedButtonPart
pixmap_file	gui_xmebwp.h	/^    String pixmap_file;$/;"	m	struct:_XmEnhancedButtonPart
pixmap_height	gui_xmebwp.h	/^    Dimension pixmap_height;$/;"	m	struct:_XmEnhancedButtonPart
pixmap_width	gui_xmebwp.h	/^    Dimension pixmap_width;$/;"	m	struct:_XmEnhancedButtonPart
pixval	gui.h	/^    int		pixval;		\/* pixel count of value *\/$/;"	m	struct:GuiScrollbar
plain_vgetc	getchar.c	/^plain_vgetc()$/;"	f
pldebug	integration.c	/^pldebug($/;"	f
plines	misc1.c	/^plines(lnum)$/;"	f
plines_m_win	misc1.c	/^plines_m_win(wp, first, last)$/;"	f
plines_nofill	misc1.c	/^plines_nofill(lnum)$/;"	f
plines_win	misc1.c	/^plines_win(wp, lnum, winheight)$/;"	f
plines_win_col	misc1.c	/^plines_win_col(wp, lnum, column)$/;"	f
plines_win_nofill	misc1.c	/^plines_win_nofill(wp, lnum, winheight)$/;"	f
plines_win_nofold	misc1.c	/^plines_win_nofold(wp, lnum)$/;"	f
pointerEvent	gui_beval.c	/^pointerEvent(beval, event)$/;"	f	file:
pointerEventEH	gui_beval.c	/^pointerEventEH(w, client_data, event, unused)$/;"	f	file:
pointer_block	memline.c	/^struct pointer_block$/;"	s	file:
pointer_entry	memline.c	/^struct pointer_entry$/;"	s	file:
pointer_event	gui_beval.c	/^pointer_event(BalloonEval *beval, int x, int y, unsigned state)$/;"	f	file:
pointer_hidden	gui.h	/^    int		pointer_hidden;	    \/* Is the mouse pointer hidden? *\/$/;"	m	struct:Gui
pop	hangulin.c	/^#define pop(/;"	d	file:
pop_current_state	syntax.c	/^pop_current_state()$/;"	f	file:
pop_showcmd	normal.c	/^pop_showcmd()$/;"	f
popupTrans	gui_athena.c	/^static XtTranslations	popupTrans, parentTrans, menuTrans, supermenuTrans;$/;"	v	file:
popup_menu_position_func	gui_gtk.c	/^popup_menu_position_func(GtkMenu *menu,$/;"	f	file:
popup_mode_name	menu.c	/^popup_mode_name(name, idx)$/;"	f	file:
popup_mouse_pos	gui_gtk.c	/^static int popup_mouse_pos;$/;"	v	file:
port	if_mzsch.c	/^    Scheme_Object   *port;$/;"	m	struct:__anon24	file:
pos	regexp.c	/^	lpos_T	pos;	\/* reginput pos, for multi-line regexp *\/$/;"	m	union:__anon47::__anon48	file:
pos	regexp.c	/^	lpos_T	pos;$/;"	m	union:__anon49::__anon50	file:
pos2off	netbeans.c	/^pos2off(buf_T *buf, pos_T *pos)$/;"	f	file:
pos_T	structs.h	/^} pos_T;$/;"	t	typeref:struct:__anon79
postpone_keycommand	netbeans.c	/^postpone_keycommand(int key)$/;"	f	file:
postponed_mouseshape	globals.h	/^EXTERN int	postponed_mouseshape INIT(= FALSE); \/* postponed updating the$/;"	v
postponed_split	globals.h	/^EXTERN int	postponed_split INIT(= 0);  \/* for CTRL-W CTRL-] command *\/$/;"	v
postponed_split_flags	globals.h	/^EXTERN int	postponed_split_flags INIT(= 0);  \/* args for win_split() *\/$/;"	v
postponed_split_tab	globals.h	/^EXTERN int	postponed_split_tab INIT(= 0);  \/* cmdmod.tab *\/$/;"	v
ppath	if_cscope.h	/^    char *	    ppath;	\/* path to prepend (the -P option) *\/$/;"	m	struct:csi
pre_commands	main.c	/^    char_u	*pre_commands[MAX_ARG_CMDS]; \/* commands from --cmd argument *\/$/;"	m	struct:__anon39	file:
pre_whitesp	ops.c	/^    int		pre_whitesp;	\/* screen cols of ws before block *\/$/;"	m	struct:block_def	file:
pre_whitesp_c	ops.c	/^    int		pre_whitesp_c;	\/* chars of ws before block *\/$/;"	m	struct:block_def	file:
prechar	structs.h	/^    int		prechar;	\/* prefix character (optional, always 'g') *\/$/;"	m	struct:cmdarg_S
preedit_buf_len	mbyte.c	/^static int	preedit_buf_len = 0;$/;"	v	file:
preedit_callback_setup	mbyte.c	/^preedit_callback_setup(GdkIC *ic)$/;"	f	file:
preedit_caret_cbproc	mbyte.c	/^preedit_caret_cbproc(XIC xic, XPointer client_data, XPointer call_data)$/;"	f	file:
preedit_done_cbproc	mbyte.c	/^preedit_done_cbproc(XIC xic, XPointer client_data, XPointer call_data)$/;"	f	file:
preedit_draw_cbproc	mbyte.c	/^preedit_draw_cbproc(XIC xic, XPointer client_data, XPointer call_data)$/;"	f	file:
preedit_end_col	globals.h	/^EXTERN colnr_T		preedit_end_col INIT(= MAXCOL);$/;"	v
preedit_get_status	mbyte.c	/^preedit_get_status(void)$/;"	f
preedit_is_active	mbyte.c	/^static int preedit_is_active   = FALSE;$/;"	v	file:
preedit_start_cbproc	mbyte.c	/^preedit_start_cbproc(XIC xic, XPointer client_data, XPointer call_data)$/;"	f	file:
preedit_start_col	globals.h	/^EXTERN colnr_T		preedit_start_col INIT(= MAXCOL);$/;"	v
prefix	quickfix.c	/^    char_u	    prefix;	\/* prefix of this format line: *\/$/;"	m	struct:efm_S	file:
prep_exarg	fileio.c	/^prep_exarg(eap, buf)$/;"	f
prep_redo	normal.c	/^prep_redo(regname, num, cmd1, cmd2, cmd3, cmd4, cmd5)$/;"	f	file:
prep_redo_cmd	normal.c	/^prep_redo_cmd(cap)$/;"	f	file:
prepare_pats	tag.c	/^prepare_pats(pats, has_re)$/;"	f	file:
prepare_search_hl	screen.c	/^prepare_search_hl(wp, lnum)$/;"	f	file:
prepare_server	main.c	/^prepare_server(parmp)$/;"	f	file:
prepare_tagpreview	ex_cmds.c	/^prepare_tagpreview(undo_sync)$/;"	f
prepare_to_exit	misc1.c	/^prepare_to_exit()$/;"	f
prepare_viminfo_history	ex_getln.c	/^prepare_viminfo_history(asklen)$/;"	f
prepare_vimvar	eval.c	/^prepare_vimvar(idx, save_tv)$/;"	f	file:
preprocs_left	ops.c	/^preprocs_left()$/;"	f
present	structs.h	/^    int		present;$/;"	m	struct:__anon98
preserve_exit	misc1.c	/^preserve_exit()$/;"	f
prev	netbeans.c	/^    struct cmdqueue *prev;$/;"	m	struct:cmdqueue	typeref:struct:cmdqueue::cmdqueue	file:
prev	netbeans.c	/^    struct keyqueue *prev;$/;"	m	struct:keyqueue	typeref:struct:keyqueue::keyqueue	file:
prev	structs.h	/^    signlist_T  *prev;		\/* previous entry -- for easy reordering *\/$/;"	m	struct:signlist
prev	vim.h	/^    pos_T	prev;		\/* Previous position *\/$/;"	m	struct:VimClipboard
prev_at_start	regexp.c	/^static int	prev_at_start;  \/* True when on the second character *\/$/;"	v	file:
prev_bg_color	gui_x11.c	/^static guicolor_T	prev_bg_color = INVALCOLOR;$/;"	v	file:
prev_ccline	ex_getln.c	/^static struct cmdline_info  prev_ccline;$/;"	v	typeref:struct:cmdline_info	file:
prev_ccline_used	ex_getln.c	/^static int		    prev_ccline_used = FALSE;$/;"	v	file:
prev_count0	structs.h	/^    long	prev_count0;	\/* ca.count0 saved for K_CURSORHOLD *\/$/;"	m	struct:oparg_S
prev_dir	ex_docmd.c	/^static char_u	*prev_dir = NULL;$/;"	v	file:
prev_fg_color	gui_x11.c	/^static guicolor_T	prev_fg_color = INVALCOLOR;$/;"	v	file:
prev_lnum	fold.c	/^static linenr_T prev_lnum = 0;$/;"	v	file:
prev_lnum_lvl	fold.c	/^static int prev_lnum_lvl = -1;$/;"	v	file:
prev_opcount	structs.h	/^    long	prev_opcount;	\/* ca.opcount saved for K_CURSORHOLD *\/$/;"	m	struct:oparg_S
prev_sp_color	gui_x11.c	/^static guicolor_T	prev_sp_color = INVALCOLOR;$/;"	v	file:
prev_timeval	main.c	/^static struct timeval	prev_timeval;$/;"	v	typeref:struct:timeval	file:
prev_which_scrollbars	gui.c	/^static int	prev_which_scrollbars[3];$/;"	v	file:
prev_wrap	gui.h	/^    int		prev_wrap;	    \/* For updating the horizontal scrollbar *\/$/;"	m	struct:Gui
prevchr	regexp.c	/^static int	prevchr;$/;"	v	file:
prevchr_len	regexp.c	/^static int	prevchr_len;	\/* byte length of previous char *\/$/;"	v	file:
prevcmd	ex_cmds.c	/^static char_u	*prevcmd = NULL;	\/* the previous command *\/$/;"	v	file:
prevprevchr	regexp.c	/^static int	prevprevchr;$/;"	v	file:
prevwin	globals.h	/^EXTERN win_T	*prevwin INIT(= NULL);	\/* previous window *\/$/;"	v
prim	if_mzsch.c	/^    Scheme_Closed_Prim	*prim;$/;"	m	struct:__anon23	file:
primitive	gui_xmebwp.h	/^    XmPrimitivePart primitive;$/;"	m	struct:_XmEnhancedButtonRec
primitive_class	gui_xmebwp.h	/^    XmPrimitiveClassPart primitive_class;$/;"	m	struct:__anon67
prims	if_mzsch.c	/^static Vim_Prim prims[]=$/;"	v	file:
print_line	ex_cmds.c	/^print_line(lnum, use_number, list)$/;"	f
print_line_no_prefix	ex_cmds.c	/^print_line_no_prefix(lnum, use_number, list)$/;"	f
print_pos	hardcopy.c	/^    int		print_pos;	    \/* virtual column for computing TABs *\/$/;"	m	struct:__anon20	file:
print_read_msg	netbeans.c	/^print_read_msg(buf)$/;"	f	file:
print_save_msg	netbeans.c	/^print_save_msg(buf, nchars)$/;"	f	file:
printdigraph	digraph.c	/^printdigraph(dp)$/;"	f	file:
printer_opts	globals.h	/^EXTERN option_table_T printer_opts[OPT_PRINT_NUM_OPTIONS]$/;"	v
printer_page_num	globals.h	/^EXTERN linenr_T printer_page_num;$/;"	v
priority	structs.h	/^    int		priority;	    \/* Menu order priority *\/$/;"	m	struct:VimMenu
priority	structs.h	/^    int		priority;   \/* match priority *\/$/;"	m	struct:matchitem
proc	if_mzsch.c	/^    Scheme_Object   *proc;$/;"	m	struct:__anon26	file:
process_compflags	spell.c	/^process_compflags(spin, aff, compflags)$/;"	f	file:
process_env	main.c	/^process_env(env, is_viminit)$/;"	f
process_menuItem	integration.c	/^process_menuItem($/;"	f	file:
process_motion_notify	gui_gtk_x11.c	/^process_motion_notify(int x, int y, GdkModifierType state)$/;"	f	file:
process_still_running	memline.c	/^static int process_still_running;$/;"	v	file:
process_toolbarButton	integration.c	/^process_toolbarButton($/;"	f	file:
processing_queued_event	mbyte.c	/^static gboolean processing_queued_event = FALSE;$/;"	v	file:
prof_child	eval.c	/^    proftime_T	prof_child;	\/* time spent in a child *\/$/;"	m	struct:funccall_S	file:
prof_child_enter	eval.c	/^prof_child_enter(tm)$/;"	f
prof_child_exit	eval.c	/^prof_child_exit(tm)$/;"	f
prof_def_func	ex_cmds2.c	/^prof_def_func()$/;"	f
prof_func_line	eval.c	/^prof_func_line(fd, count, total, self, prefer_self)$/;"	f	file:
prof_ga	ex_cmds2.c	/^static garray_T prof_ga = {0, 0, sizeof(struct debuggy), 4, NULL};$/;"	v	file:
prof_inchar_enter	ex_cmds2.c	/^prof_inchar_enter()$/;"	f
prof_inchar_exit	ex_cmds2.c	/^prof_inchar_exit()$/;"	f
prof_self_cmp	eval.c	/^prof_self_cmp(s1, s2)$/;"	f	file:
prof_sort_list	eval.c	/^prof_sort_list(fd, sorttab, st_len, title, prefer_self)$/;"	f	file:
prof_total_cmp	eval.c	/^prof_total_cmp(s1, s2)$/;"	f	file:
prof_wait_time	ex_cmds2.c	/^static proftime_T prof_wait_time;$/;"	v	file:
profile_add	ex_cmds2.c	/^profile_add(tm, tm2)$/;"	f
profile_cmp	ex_cmds2.c	/^profile_cmp(tm1, tm2)$/;"	f
profile_dump	ex_cmds2.c	/^profile_dump()$/;"	f
profile_end	ex_cmds2.c	/^profile_end(tm)$/;"	f
profile_equal	ex_cmds2.c	/^profile_equal(tm1, tm2)$/;"	f
profile_fname	ex_cmds2.c	/^static char_u	*profile_fname = NULL;$/;"	v	file:
profile_get_wait	ex_cmds2.c	/^profile_get_wait(tm)$/;"	f
profile_msg	ex_cmds2.c	/^profile_msg(tm)$/;"	f
profile_passed_limit	ex_cmds2.c	/^profile_passed_limit(tm)$/;"	f
profile_self	ex_cmds2.c	/^profile_self(self, total, children)$/;"	f
profile_setlimit	ex_cmds2.c	/^profile_setlimit(msec, tm)$/;"	f
profile_start	ex_cmds2.c	/^profile_start(tm)$/;"	f
profile_sub	ex_cmds2.c	/^profile_sub(tm, tm2)$/;"	f
profile_sub_wait	ex_cmds2.c	/^profile_sub_wait(tm, tma)$/;"	f
profile_zero	ex_cmds2.c	/^profile_zero(tm)$/;"	f
proftime_T	vim.h	/^typedef LARGE_INTEGER proftime_T;$/;"	t
proftime_T	vim.h	/^typedef int proftime_T;	    \/* dummy for function prototypes *\/$/;"	t
proftime_T	vim.h	/^typedef struct timeval proftime_T;$/;"	t	typeref:struct:timeval
prog	quickfix.c	/^    regprog_T	    *prog;	\/* pre-formatted part of 'errorformat' *\/$/;"	m	struct:efm_S	file:
prog_magic_wrong	regexp.c	/^prog_magic_wrong()$/;"	f	file:
program	regexp.h	/^    char_u		program[1];		\/* actually longer.. *\/$/;"	m	struct:__anon75
prompt_for_number	misc1.c	/^prompt_for_number(mouse_used)$/;"	f
prop	mbyte.c	/^{   char *name;		int prop;		int codepage;}$/;"	m	struct:__anon40	file:
property_event	gui_gtk_x11.c	/^property_event(GtkWidget *widget, GdkEventProperty *event, gpointer data)$/;"	f	file:
proportional	gui_xmdlg.c	/^proportional(char *font)$/;"	f	file:
prt_add_resource	hardcopy.c	/^prt_add_resource(resource)$/;"	f	file:
prt_ascii_encoding	hardcopy.c	/^static char *prt_ascii_encoding;$/;"	v	file:
prt_attribute_change	hardcopy.c	/^static int prt_attribute_change;$/;"	v	file:
prt_bgcol	hardcopy.c	/^static int prt_bgcol;$/;"	v	file:
prt_bgcol_offset	hardcopy.c	/^static float prt_bgcol_offset;$/;"	v	file:
prt_bottom_margin	hardcopy.c	/^static float prt_bottom_margin;$/;"	v	file:
prt_bufsiz	hardcopy.c	/^static int prt_bufsiz;$/;"	v	file:
prt_build_cid_fontname	hardcopy.c	/^prt_build_cid_fontname(font, name, name_len)$/;"	f	file:
prt_char_width	hardcopy.c	/^static float prt_char_width;$/;"	v	file:
prt_check_resource	hardcopy.c	/^prt_check_resource(resource, version)$/;"	f	file:
prt_cmap	hardcopy.c	/^static char prt_cmap[80];$/;"	v	file:
prt_collate	hardcopy.c	/^static int prt_collate;$/;"	v	file:
prt_conv	hardcopy.c	/^static vimconv_T prt_conv;$/;"	v	file:
prt_custom_cmap	hardcopy.c	/^static int prt_custom_cmap;$/;"	v	file:
prt_def_cidfont	hardcopy.c	/^prt_def_cidfont(new_name, height, cidfont)$/;"	f	file:
prt_def_font	hardcopy.c	/^prt_def_font(new_name, encoding, height, font)$/;"	f	file:
prt_def_var	hardcopy.c	/^prt_def_var(name, value, prec)$/;"	f	file:
prt_do_bgcol	hardcopy.c	/^static int prt_do_bgcol;$/;"	v	file:
prt_do_conv	hardcopy.c	/^static int prt_do_conv;$/;"	v	file:
prt_do_moveto	hardcopy.c	/^static int prt_do_moveto;$/;"	v	file:
prt_do_underline	hardcopy.c	/^static int prt_do_underline;$/;"	v	file:
prt_dsc_atend	hardcopy.c	/^#define prt_dsc_atend(/;"	d	file:
prt_dsc_comment_S	hardcopy.c	/^struct prt_dsc_comment_S$/;"	s	file:
prt_dsc_docmedia	hardcopy.c	/^prt_dsc_docmedia(paper_name, width, height, weight, colour, type)$/;"	f	file:
prt_dsc_font_resource	hardcopy.c	/^prt_dsc_font_resource(resource, ps_font)$/;"	f	file:
prt_dsc_ints	hardcopy.c	/^prt_dsc_ints(comment, count, ints)$/;"	f	file:
prt_dsc_line_S	hardcopy.c	/^struct prt_dsc_line_S$/;"	s	file:
prt_dsc_noarg	hardcopy.c	/^prt_dsc_noarg(comment)$/;"	f	file:
prt_dsc_requirements	hardcopy.c	/^prt_dsc_requirements(duplex, tumble, collate, color, num_copies)$/;"	f	file:
prt_dsc_resources	hardcopy.c	/^prt_dsc_resources(comment, type, string)$/;"	f	file:
prt_dsc_start	hardcopy.c	/^prt_dsc_start()$/;"	f	file:
prt_dsc_table	hardcopy.c	/^static struct prt_dsc_comment_S prt_dsc_table[] =$/;"	v	typeref:struct:prt_dsc_comment_S	file:
prt_dsc_text	hardcopy.c	/^prt_dsc_text(comment, text)$/;"	f	file:
prt_dsc_textline	hardcopy.c	/^prt_dsc_textline(comment, text)$/;"	f	file:
prt_dup_cidfont	hardcopy.c	/^prt_dup_cidfont(original_name, new_name)$/;"	f	file:
prt_duplex	hardcopy.c	/^static int prt_duplex;$/;"	v	file:
prt_fgcol	hardcopy.c	/^static int prt_fgcol;$/;"	v	file:
prt_file_error	hardcopy.c	/^static int prt_file_error;$/;"	v	file:
prt_find_resource	hardcopy.c	/^prt_find_resource(name, resource)$/;"	f	file:
prt_first_line_height	hardcopy.c	/^static float prt_first_line_height;$/;"	v	file:
prt_flush_buffer	hardcopy.c	/^prt_flush_buffer()$/;"	f	file:
prt_font	hardcopy.c	/^static int prt_font;$/;"	v	file:
prt_font_metrics	hardcopy.c	/^prt_font_metrics(font_scale)$/;"	f	file:
prt_get_attr	hardcopy.c	/^prt_get_attr(hl_id, pattr, modec)$/;"	f	file:
prt_get_cpl	hardcopy.c	/^prt_get_cpl()$/;"	f	file:
prt_get_lpp	hardcopy.c	/^prt_get_lpp()$/;"	f	file:
prt_get_term_color	hardcopy.c	/^prt_get_term_color(colorindex)$/;"	f	file:
prt_get_unit	hardcopy.c	/^prt_get_unit(idx)$/;"	f
prt_half_width	hardcopy.c	/^static int prt_half_width;$/;"	v	file:
prt_header	hardcopy.c	/^prt_header(psettings, pagenum, lnum)$/;"	f	file:
prt_header_height	hardcopy.c	/^prt_header_height()$/;"	f
prt_hexchar	hardcopy.c	/^static char_u prt_hexchar[] = "0123456789abcdef";$/;"	v	file:
prt_in_ascii	hardcopy.c	/^static int prt_in_ascii;$/;"	v	file:
prt_left_margin	hardcopy.c	/^static float prt_left_margin;$/;"	v	file:
prt_line_buffer	hardcopy.c	/^static char_u prt_line_buffer[257];$/;"	v	file:
prt_line_height	hardcopy.c	/^static float prt_line_height;$/;"	v	file:
prt_line_number	hardcopy.c	/^prt_line_number(psettings, page_line, lnum)$/;"	f	file:
prt_match_charset	hardcopy.c	/^prt_match_charset(p_charset, p_cmap, pp_mbchar)$/;"	f	file:
prt_match_encoding	hardcopy.c	/^prt_match_encoding(p_encoding, p_cmap, pp_mbenc)$/;"	f	file:
prt_media	hardcopy.c	/^static int prt_media;$/;"	v	file:
prt_mediasize	hardcopy.c	/^static struct prt_mediasize_S prt_mediasize[] =$/;"	v	typeref:struct:prt_mediasize_S	file:
prt_mediasize_S	hardcopy.c	/^struct prt_mediasize_S$/;"	s	file:
prt_message	hardcopy.c	/^prt_message(s)$/;"	f	file:
prt_need_bgcol	hardcopy.c	/^static int prt_need_bgcol;$/;"	v	file:
prt_need_fgcol	hardcopy.c	/^static int prt_need_fgcol;$/;"	v	file:
prt_need_font	hardcopy.c	/^static int prt_need_font;$/;"	v	file:
prt_need_moveto	hardcopy.c	/^static int prt_need_moveto;$/;"	v	file:
prt_need_underline	hardcopy.c	/^static int prt_need_underline;$/;"	v	file:
prt_new_bgcol	hardcopy.c	/^static int prt_new_bgcol;$/;"	v	file:
prt_next_dsc	hardcopy.c	/^prt_next_dsc(p_dsc_line)$/;"	f	file:
prt_num_copies	hardcopy.c	/^static int prt_num_copies;$/;"	v	file:
prt_number_width	hardcopy.c	/^static float prt_number_width;$/;"	v	file:
prt_open_resource	hardcopy.c	/^prt_open_resource(resource)$/;"	f	file:
prt_out_mbyte	hardcopy.c	/^static int prt_out_mbyte;$/;"	v	file:
prt_page_height	hardcopy.c	/^static float prt_page_height;$/;"	v	file:
prt_page_margins	hardcopy.c	/^prt_page_margins(width, height, left, right, top, bottom)$/;"	f	file:
prt_page_num	hardcopy.c	/^static int prt_page_num;$/;"	v	file:
prt_page_width	hardcopy.c	/^static float prt_page_width;$/;"	v	file:
prt_portrait	hardcopy.c	/^static int prt_portrait;$/;"	v	file:
prt_pos_T	hardcopy.c	/^} prt_pos_T;$/;"	t	typeref:struct:__anon20	file:
prt_pos_x	hardcopy.c	/^static float prt_pos_x = 0;$/;"	v	file:
prt_pos_x_moveto	hardcopy.c	/^static float prt_pos_x_moveto = 0.0;$/;"	v	file:
prt_pos_y	hardcopy.c	/^static float prt_pos_y = 0;$/;"	v	file:
prt_pos_y_moveto	hardcopy.c	/^static float prt_pos_y_moveto = 0.0;$/;"	v	file:
prt_ps_buffer	hardcopy.c	/^static garray_T prt_ps_buffer;$/;"	v	file:
prt_ps_charset_S	hardcopy.c	/^struct prt_ps_charset_S$/;"	s	file:
prt_ps_courier_font	hardcopy.c	/^static struct prt_ps_font_S prt_ps_courier_font =$/;"	v	typeref:struct:prt_ps_font_S	file:
prt_ps_encoding_S	hardcopy.c	/^struct prt_ps_encoding_S$/;"	s	file:
prt_ps_fd	hardcopy.c	/^static FILE *prt_ps_fd;$/;"	v	file:
prt_ps_file_name	hardcopy.c	/^static char_u *prt_ps_file_name = NULL;$/;"	v	file:
prt_ps_font	hardcopy.c	/^static struct prt_ps_font_S* prt_ps_font;$/;"	v	typeref:struct:prt_ps_font_S	file:
prt_ps_font_S	hardcopy.c	/^struct prt_ps_font_S$/;"	s	file:
prt_ps_mb_font	hardcopy.c	/^static struct prt_ps_font_S prt_ps_mb_font =$/;"	v	typeref:struct:prt_ps_font_S	file:
prt_ps_mbfont_S	hardcopy.c	/^struct prt_ps_mbfont_S$/;"	s	file:
prt_ps_mbfonts	hardcopy.c	/^static struct prt_ps_mbfont_S prt_ps_mbfonts[] =$/;"	v	typeref:struct:prt_ps_mbfont_S	file:
prt_ps_resource_S	hardcopy.c	/^struct prt_ps_resource_S$/;"	s	file:
prt_real_bits	hardcopy.c	/^prt_real_bits(real, precision, pinteger, pfraction)$/;"	f	file:
prt_resfile	hardcopy.c	/^static struct prt_resfile_buffer_S prt_resfile;$/;"	v	typeref:struct:prt_resfile_buffer_S	file:
prt_resfile_buffer_S	hardcopy.c	/^struct prt_resfile_buffer_S$/;"	s	file:
prt_resfile_next_line	hardcopy.c	/^prt_resfile_next_line()$/;"	f	file:
prt_resfile_skip_nonws	hardcopy.c	/^prt_resfile_skip_nonws(offset)$/;"	f	file:
prt_resfile_skip_ws	hardcopy.c	/^prt_resfile_skip_ws(offset)$/;"	f	file:
prt_resfile_strncmp	hardcopy.c	/^prt_resfile_strncmp(offset, string, len)$/;"	f	file:
prt_resource_name	hardcopy.c	/^prt_resource_name(filename, cookie)$/;"	f	file:
prt_resource_types	hardcopy.c	/^static char *prt_resource_types[] =$/;"	v	file:
prt_right_margin	hardcopy.c	/^static float prt_right_margin;$/;"	v	file:
prt_set_bg	hardcopy.c	/^prt_set_bg(bg)$/;"	f	file:
prt_set_fg	hardcopy.c	/^prt_set_fg(fg)$/;"	f	file:
prt_set_font	hardcopy.c	/^prt_set_font(bold, italic, underline)$/;"	f	file:
prt_settings_T	structs.h	/^} prt_settings_T;$/;"	t	typeref:struct:__anon100
prt_text_attr_T	structs.h	/^} prt_text_attr_T;$/;"	t	typeref:struct:__anon99
prt_text_run	hardcopy.c	/^static float prt_text_run;$/;"	v	file:
prt_top_margin	hardcopy.c	/^static float prt_top_margin;$/;"	v	file:
prt_tumble	hardcopy.c	/^static int prt_tumble;$/;"	v	file:
prt_underline	hardcopy.c	/^static int prt_underline;$/;"	v	file:
prt_use_courier	hardcopy.c	/^static int prt_use_courier;$/;"	v	file:
prt_use_number	hardcopy.c	/^prt_use_number()$/;"	f
prt_write_boolean	hardcopy.c	/^prt_write_boolean(b)$/;"	f	file:
prt_write_file	hardcopy.c	/^prt_write_file(buffer)$/;"	f	file:
prt_write_file_len	hardcopy.c	/^prt_write_file_len(buffer, bytes)$/;"	f	file:
prt_write_file_raw_len	hardcopy.c	/^prt_write_file_raw_len(buffer, bytes)$/;"	f	file:
prt_write_int	hardcopy.c	/^prt_write_int(i)$/;"	f	file:
prt_write_real	hardcopy.c	/^prt_write_real(val, prec)$/;"	f	file:
prt_write_string	hardcopy.c	/^prt_write_string(s)$/;"	f	file:
ps_fontname	hardcopy.c	/^    char	*(ps_fontname[4]);$/;"	m	struct:prt_ps_font_S	file:
psepc	globals.h	/^EXTERN char	psepc INIT(= '\\\\');	\/* normal path separator character *\/$/;"	v
psepcN	globals.h	/^EXTERN char	psepcN INIT(= '\/');	\/* abnormal path separator character *\/$/;"	v
pseps	globals.h	/^EXTERN char	pseps[2]		\/* normal path separator string *\/$/;"	v
pseudo_code	misc2.c	/^    int	    pseudo_code;	\/* Code for pseudo mouse event *\/$/;"	m	struct:mousetable	file:
pstrcmp	misc1.c	/^pstrcmp(a, b)$/;"	f	file:
pstrcmp	misc1.c	/^pstrcmp(const void *a, const void *b)$/;"	f	file:
ptag_entry	tag.c	/^static taggy_T ptag_entry = {NULL};$/;"	v	file:
ptr	if_mzsch.c	/^    void    **ptr;$/;"	m	struct:__anon27	file:
ptr	if_python.c	/^    PYTHON_PROC *ptr;$/;"	m	struct:__anon28	file:
ptr	if_ruby.c	/^    RUBY_PROC *ptr;$/;"	m	struct:__anon36	file:
ptr	if_tcl.c	/^    TCL_PROC* ptr;$/;"	m	struct:__anon38	file:
ptr	regexp.c	/^	char_u	*ptr;	\/* reginput pointer, for single-line regexp *\/$/;"	m	union:__anon47::__anon48	file:
ptr	regexp.c	/^	char_u	*ptr;$/;"	m	union:__anon49::__anon50	file:
ptr2cells	charset.c	/^ptr2cells(p)$/;"	f
pullAction	gui_athena.c	/^static XtActionsRec	pullAction[2] = {$/;"	v	file:
pullerBitmap	gui_athena.c	/^static Pixmap		pullerBitmap = None;$/;"	v	file:
puller_width	gui_athena.c	/^static int		puller_width = 0;$/;"	v	file:
pum_array	popupmnu.c	/^static pumitem_T *pum_array = NULL;	\/* items of displayed pum *\/$/;"	v	file:
pum_base_width	popupmnu.c	/^static int pum_base_width;		\/* width of pum items base *\/$/;"	v	file:
pum_clear	popupmnu.c	/^pum_clear()$/;"	f
pum_col	popupmnu.c	/^static int pum_col;			\/* left column of pum *\/$/;"	v	file:
pum_display	popupmnu.c	/^pum_display(array, size, selected)$/;"	f
pum_do_redraw	popupmnu.c	/^static int pum_do_redraw = FALSE;	\/* do redraw anyway *\/$/;"	v	file:
pum_enough_matches	edit.c	/^pum_enough_matches()$/;"	f	file:
pum_extra	structs.h	/^    char_u	*pum_extra;	\/* extra menu text (may be truncated) *\/$/;"	m	struct:__anon101
pum_first	popupmnu.c	/^static int pum_first = 0;		\/* index of top item *\/$/;"	v	file:
pum_get_height	popupmnu.c	/^pum_get_height()$/;"	f
pum_height	popupmnu.c	/^static int pum_height;			\/* nr of displayed pum items *\/$/;"	v	file:
pum_info	structs.h	/^    char_u	*pum_info;	\/* extra info *\/$/;"	m	struct:__anon101
pum_kind	structs.h	/^    char_u	*pum_kind;	\/* extra kind text (may be truncated) *\/$/;"	m	struct:__anon101
pum_kind_width	popupmnu.c	/^static int pum_kind_width;		\/* width of pum items kind column *\/$/;"	v	file:
pum_redraw	popupmnu.c	/^pum_redraw()$/;"	f
pum_row	popupmnu.c	/^static int pum_row;			\/* top row of pum *\/$/;"	v	file:
pum_scrollbar	popupmnu.c	/^static int pum_scrollbar;		\/* TRUE when scrollbar present *\/$/;"	v	file:
pum_selected	popupmnu.c	/^static int pum_selected;		\/* index of selected item or -1 *\/$/;"	v	file:
pum_set_selected	popupmnu.c	/^pum_set_selected(n, repeat)$/;"	f	file:
pum_size	popupmnu.c	/^static int pum_size;			\/* nr of items in "pum_array" *\/$/;"	v	file:
pum_text	structs.h	/^    char_u	*pum_text;	\/* main menu text *\/$/;"	m	struct:__anon101
pum_undisplay	popupmnu.c	/^pum_undisplay()$/;"	f
pum_visible	popupmnu.c	/^pum_visible()$/;"	f
pum_wanted	edit.c	/^pum_wanted()$/;"	f	file:
pum_width	popupmnu.c	/^static int pum_width;			\/* width of displayed pum items *\/$/;"	v	file:
pumitem_T	structs.h	/^} pumitem_T;$/;"	t	typeref:struct:__anon101
push	hangulin.c	/^#define push(/;"	d	file:
push_current_state	syntax.c	/^push_current_state(idx)$/;"	f	file:
push_next_match	syntax.c	/^push_next_match(cur_si)$/;"	f	file:
push_raw_key	ui.c	/^push_raw_key (s, len)$/;"	f
push_showcmd	normal.c	/^push_showcmd()$/;"	f
pushbutton	gui_xmebwp.h	/^    XmPushButtonPart pushbutton;$/;"	m	struct:_XmEnhancedButtonRec
pushbutton_class	gui_xmebwp.h	/^    XmPushButtonClassPart pushbutton_class;$/;"	m	struct:__anon67
put_and_redo	farsi.c	/^put_and_redo(c)$/;"	f	file:
put_bytes	spell.c	/^put_bytes(fd, nr, len)$/;"	f
put_curr_and_l_to_X	farsi.c	/^put_curr_and_l_to_X(c)$/;"	f	file:
put_eol	ex_docmd.c	/^put_eol(fd)$/;"	f
put_escstr	getchar.c	/^put_escstr(fd, strstart, what)$/;"	f
put_foldopen_recurse	fold.c	/^put_foldopen_recurse(fd, gap, off)$/;"	f	file:
put_folds	fold.c	/^put_folds(fd, wp)$/;"	f
put_folds_recurse	fold.c	/^put_folds_recurse(fd, gap, off)$/;"	f	file:
put_id_list	syntax.c	/^put_id_list(name, list, attr)$/;"	f	file:
put_in_typebuf	ops.c	/^put_in_typebuf(s, esc, colon, silent)$/;"	f	file:
put_line	ex_docmd.c	/^put_line(fd, s)$/;"	f
put_node	spell.c	/^put_node(fd, node, idx, regionmask, prefixtree)$/;"	f	file:
put_on_cmdline	ex_getln.c	/^put_on_cmdline(str, len, redraw)$/;"	f
put_pattern	syntax.c	/^put_pattern(s, c, spp, attr)$/;"	f	file:
put_reedit_in_typebuf	ops.c	/^put_reedit_in_typebuf(silent)$/;"	f	file:
put_register	ops.c	/^put_register(name, reg)$/;"	f
put_setbool	option.c	/^put_setbool(fd, cmd, name, value)$/;"	f	file:
put_setnum	option.c	/^put_setnum(fd, cmd, name, valuep)$/;"	f	file:
put_setstring	option.c	/^put_setstring(fd, cmd, name, valuep, expand)$/;"	f	file:
put_sugtime	spell.c	/^put_sugtime(spin, fd)$/;"	f	file:
put_view	ex_docmd.c	/^put_view(fd, wp, add_edit, flagp, current_arg_idx)$/;"	f	file:
putcmdline	ex_getln.c	/^putcmdline(c, shift)$/;"	f
putdigraph	digraph.c	/^putdigraph(str)$/;"	f
putenv	misc2.c	/^putenv(string)$/;"	f
py_fix_cursor	if_python.c	/^py_fix_cursor(linenr_T lo, linenr_T hi, linenr_T extra)$/;"	f	file:
pygilstate	if_python.c	/^static PyGILState_STATE pygilstate = PyGILState_UNLOCKED;$/;"	v	file:
python_buffer_free	if_python.c	/^python_buffer_free(buf_T *buf)$/;"	f
python_enabled	if_python.c	/^python_enabled(int verbose)$/;"	f
python_end	if_python.c	/^python_end()$/;"	f
python_funcname_table	if_python.c	/^} python_funcname_table[] =$/;"	v	typeref:struct:__anon28	file:
python_runtime_link_init	if_python.c	/^python_runtime_link_init(char *libname, int verbose)$/;"	f	file:
python_window_free	if_python.c	/^python_window_free(win_T *win)$/;"	f
qf_add_entry	quickfix.c	/^qf_add_entry(qi, prevp, dir, fname, bufnum, mesg, lnum, col, vis_col, pattern,$/;"	f	file:
qf_age	ex_docmd.c	/^# define qf_age	/;"	d	file:
qf_age	quickfix.c	/^qf_age(eap)$/;"	f
qf_clean_dir_stack	quickfix.c	/^qf_clean_dir_stack(stackptr)$/;"	f	file:
qf_cleared	quickfix.c	/^    char_u	qf_cleared;	\/* set to TRUE if line has been deleted *\/$/;"	m	struct:qfline_S	file:
qf_col	quickfix.c	/^    int		qf_col;		\/* column where the error occurred *\/$/;"	m	struct:qfline_S	file:
qf_count	quickfix.c	/^    int		qf_count;	\/* number of errors (0 means no error list) *\/$/;"	m	struct:qf_list_S	file:
qf_curlist	quickfix.c	/^    int		qf_curlist;	    \/* current error list *\/$/;"	m	struct:qf_info_S	file:
qf_current_entry	quickfix.c	/^qf_current_entry(wp)$/;"	f
qf_fill_buffer	quickfix.c	/^qf_fill_buffer(qi)$/;"	f	file:
qf_find_buf	quickfix.c	/^qf_find_buf(qi)$/;"	f	file:
qf_find_win	quickfix.c	/^qf_find_win(qi)$/;"	f	file:
qf_fmt_text	quickfix.c	/^qf_fmt_text(text, buf, bufsize)$/;"	f	file:
qf_fnum	quickfix.c	/^    int		qf_fnum;	\/* file number for the line *\/$/;"	m	struct:qfline_S	file:
qf_free	quickfix.c	/^qf_free(qi, idx)$/;"	f	file:
qf_free_all	quickfix.c	/^qf_free_all(wp)$/;"	f
qf_get_fnum	quickfix.c	/^qf_get_fnum(directory, fname)$/;"	f	file:
qf_guess_filepath	quickfix.c	/^qf_guess_filepath(filename)$/;"	f	file:
qf_index	quickfix.c	/^    int		qf_index;	\/* current index in the error list *\/$/;"	m	struct:qf_list_S	file:
qf_info_S	quickfix.c	/^struct qf_info_S$/;"	s	file:
qf_info_T	structs.h	/^typedef struct qf_info_S qf_info_T;$/;"	t	typeref:struct:qf_info_S
qf_init	quickfix.c	/^qf_init(wp, efile, errorformat, newlist)$/;"	f
qf_init_ext	quickfix.c	/^qf_init_ext(qi, efile, buf, tv, errorformat, newlist, lnumfirst, lnumlast)$/;"	f	file:
qf_jump	quickfix.c	/^qf_jump(qi, dir, errornr, forceit)$/;"	f
qf_list	ex_docmd.c	/^# define qf_list	/;"	d	file:
qf_list	quickfix.c	/^qf_list(eap)$/;"	f
qf_list_S	quickfix.c	/^typedef struct qf_list_S$/;"	s	file:
qf_list_T	quickfix.c	/^} qf_list_T;$/;"	t	typeref:struct:qf_list_S	file:
qf_listcount	quickfix.c	/^    int		qf_listcount;	    \/* current number of lists *\/$/;"	m	struct:qf_info_S	file:
qf_lists	quickfix.c	/^    qf_list_T	qf_lists[LISTCOUNT];$/;"	m	struct:qf_info_S	file:
qf_lnum	quickfix.c	/^    linenr_T	qf_lnum;	\/* line number where the error occurred *\/$/;"	m	struct:qfline_S	file:
qf_mark_adjust	quickfix.c	/^qf_mark_adjust(wp, line1, line2, amount, amount_after)$/;"	f
qf_msg	quickfix.c	/^qf_msg(qi)$/;"	f	file:
qf_new_list	quickfix.c	/^qf_new_list(qi)$/;"	f	file:
qf_next	quickfix.c	/^    qfline_T	*qf_next;	\/* pointer to next error in the list *\/$/;"	m	struct:qfline_S	file:
qf_nonevalid	quickfix.c	/^    int		qf_nonevalid;	\/* TRUE if not a single valid entry found *\/$/;"	m	struct:qf_list_S	file:
qf_nr	quickfix.c	/^    int		qf_nr;		\/* error number *\/$/;"	m	struct:qfline_S	file:
qf_pattern	quickfix.c	/^    char_u	*qf_pattern;	\/* search pattern for the error *\/$/;"	m	struct:qfline_S	file:
qf_pop_dir	quickfix.c	/^qf_pop_dir(stackptr)$/;"	f	file:
qf_prev	quickfix.c	/^    qfline_T	*qf_prev;	\/* pointer to previous error in the list *\/$/;"	m	struct:qfline_S	file:
qf_ptr	quickfix.c	/^    qfline_T	*qf_ptr;	\/* pointer to the current error *\/$/;"	m	struct:qf_list_S	file:
qf_push_dir	quickfix.c	/^qf_push_dir(dirbuf, stackptr)$/;"	f	file:
qf_refcount	quickfix.c	/^    int		qf_refcount;$/;"	m	struct:qf_info_S	file:
qf_start	quickfix.c	/^    qfline_T	*qf_start;	\/* pointer to the first error *\/$/;"	m	struct:qf_list_S	file:
qf_text	quickfix.c	/^    char_u	*qf_text;	\/* description of the error *\/$/;"	m	struct:qfline_S	file:
qf_type	quickfix.c	/^    char_u	qf_type;	\/* type of the error (mostly 'E'); 1 for$/;"	m	struct:qfline_S	file:
qf_types	quickfix.c	/^qf_types(c, nr)$/;"	f	file:
qf_update_buffer	quickfix.c	/^qf_update_buffer(qi)$/;"	f	file:
qf_valid	quickfix.c	/^    char_u	qf_valid;	\/* valid error message detected *\/$/;"	m	struct:qfline_S	file:
qf_viscol	quickfix.c	/^    char_u	qf_viscol;	\/* set to TRUE if qf_col is screen column *\/$/;"	m	struct:qfline_S	file:
qf_win_pos_update	quickfix.c	/^qf_win_pos_update(qi, old_qf_index)$/;"	f	file:
qfline_S	quickfix.c	/^struct qfline_S$/;"	s	file:
qfline_T	quickfix.c	/^typedef struct qfline_S qfline_T;$/;"	t	typeref:struct:qfline_S	file:
ql_info	quickfix.c	/^static qf_info_T ql_info;	\/* global quickfix list *\/$/;"	v	file:
qsort	misc2.c	/^qsort(base, elm_count, elm_size, cmp)$/;"	f
query	hangulin.c	/^#define query(/;"	d	file:
queue_T	netbeans.c	/^typedef struct cmdqueue queue_T;$/;"	t	typeref:struct:cmdqueue	file:
quit_more	globals.h	/^EXTERN int	quit_more INIT(= FALSE);    \/* 'q' hit at "--more--" msg *\/$/;"	v
quitmore	ex_docmd.c	/^static int	quitmore = 0;$/;"	v	file:
quote_meta	edit.c	/^quote_meta(dest, src, len)$/;"	f	file:
r_cmdno	netbeans.c	/^static int r_cmdno;			\/* current command number for reply *\/$/;"	v	file:
raise_if_error	if_mzsch.c	/^raise_if_error(void)$/;"	f
raise_vim_exn	if_mzsch.c	/^raise_vim_exn(const char *add_info)$/;"	f
rangeEnd	mbyte.c	/^    int rangeEnd;$/;"	m	struct:__anon42	file:
rangeStart	mbyte.c	/^    int rangeStart;$/;"	m	struct:__anon42	file:
range_end	if_mzsch.c	/^static long range_end;$/;"	v	file:
range_end	if_tcl.c	/^    int range_start, range_end;$/;"	m	struct:__anon37	file:
range_start	if_mzsch.c	/^static long range_start;$/;"	v	file:
range_start	if_tcl.c	/^    int range_start, range_end;$/;"	m	struct:__anon37	file:
rb_assoc_new	if_ruby.c	/^#define rb_assoc_new	/;"	d	file:
rb_cFalseClass	if_ruby.c	/^# define rb_cFalseClass	/;"	d	file:
rb_cFixnum	if_ruby.c	/^# define rb_cFixnum	/;"	d	file:
rb_cNilClass	if_ruby.c	/^# define rb_cNilClass	/;"	d	file:
rb_cObject	if_ruby.c	/^#define rb_cObject	/;"	d	file:
rb_cSymbol	if_ruby.c	/^# define rb_cSymbol	/;"	d	file:
rb_cTrueClass	if_ruby.c	/^# define rb_cTrueClass	/;"	d	file:
rb_check_type	if_ruby.c	/^#define rb_check_type	/;"	d	file:
rb_class_path	if_ruby.c	/^#define rb_class_path	/;"	d	file:
rb_data_object_alloc	if_ruby.c	/^#define rb_data_object_alloc	/;"	d	file:
rb_define_class_under	if_ruby.c	/^#define rb_define_class_under	/;"	d	file:
rb_define_const	if_ruby.c	/^#define rb_define_const	/;"	d	file:
rb_define_global_function	if_ruby.c	/^#define rb_define_global_function	/;"	d	file:
rb_define_method	if_ruby.c	/^#define rb_define_method	/;"	d	file:
rb_define_module	if_ruby.c	/^#define rb_define_module	/;"	d	file:
rb_define_module_function	if_ruby.c	/^#define rb_define_module_function	/;"	d	file:
rb_define_singleton_method	if_ruby.c	/^#define rb_define_singleton_method	/;"	d	file:
rb_define_virtual_variable	if_ruby.c	/^#define rb_define_virtual_variable	/;"	d	file:
rb_eArgError	if_ruby.c	/^#define rb_eArgError	/;"	d	file:
rb_eIndexError	if_ruby.c	/^#define rb_eIndexError	/;"	d	file:
rb_eRuntimeError	if_ruby.c	/^#define rb_eRuntimeError	/;"	d	file:
rb_eStandardError	if_ruby.c	/^#define rb_eStandardError	/;"	d	file:
rb_eval_string_protect	if_ruby.c	/^#define rb_eval_string_protect	/;"	d	file:
rb_global_variable	if_ruby.c	/^#define rb_global_variable	/;"	d	file:
rb_hash_aset	if_ruby.c	/^#define rb_hash_aset	/;"	d	file:
rb_hash_new	if_ruby.c	/^#define rb_hash_new	/;"	d	file:
rb_inspect	if_ruby.c	/^#define rb_inspect	/;"	d	file:
rb_int2inum	if_ruby.c	/^#define rb_int2inum	/;"	d	file:
rb_lastline_get	if_ruby.c	/^#define rb_lastline_get	/;"	d	file:
rb_lastline_set	if_ruby.c	/^#define rb_lastline_set	/;"	d	file:
rb_load_protect	if_ruby.c	/^#define rb_load_protect	/;"	d	file:
rb_num2long	if_ruby.c	/^#define rb_num2long	/;"	d	file:
rb_num2ulong	if_ruby.c	/^#define rb_num2ulong	/;"	d	file:
rb_obj_alloc	if_ruby.c	/^#define rb_obj_alloc	/;"	d	file:
rb_obj_as_string	if_ruby.c	/^#define rb_obj_as_string	/;"	d	file:
rb_obj_id	if_ruby.c	/^#define rb_obj_id	/;"	d	file:
rb_raise	if_ruby.c	/^#define rb_raise	/;"	d	file:
rb_stdout	if_ruby.c	/^#define rb_stdout	/;"	d	file:
rb_str2cstr	if_ruby.c	/^#define rb_str2cstr	/;"	d	file:
rb_str_cat	if_ruby.c	/^#define rb_str_cat	/;"	d	file:
rb_str_concat	if_ruby.c	/^#define rb_str_concat	/;"	d	file:
rb_str_new	if_ruby.c	/^#define rb_str_new	/;"	d	file:
rb_str_new2	if_ruby.c	/^#define rb_str_new2	/;"	d	file:
rb_w32_snprintf	if_ruby.c	/^# define rb_w32_snprintf	/;"	d	file:
rc_did_emsg	globals.h	/^EXTERN int	rc_did_emsg INIT(= FALSE);  \/* vim_regcomp() called emsg() *\/$/;"	v
re_extmatch_in	globals.h	/^EXTERN reg_extmatch_T *re_extmatch_in INIT(= NULL); \/* Used by vim_regexec():$/;"	v
re_extmatch_out	globals.h	/^EXTERN reg_extmatch_T *re_extmatch_out INIT(= NULL); \/* Set by vim_regexec()$/;"	v
re_has_z	regexp.c	/^static int	re_has_z;	\/* \\z item detected *\/$/;"	v	file:
re_lookbehind	regexp.c	/^re_lookbehind(prog)$/;"	f
re_multi_type	regexp.c	/^re_multi_type(c)$/;"	f	file:
re_multiline	regexp.c	/^re_multiline(prog)$/;"	f
re_num_cmp	regexp.c	/^re_num_cmp(val, scan)$/;"	f	file:
re_put_long	regexp.c	/^re_put_long(p, val)$/;"	f	file:
read_charflags_section	spell.c	/^read_charflags_section(fd)$/;"	f	file:
read_cmd_fd	globals.h	/^EXTERN int	read_cmd_fd INIT(= 0);	    \/* fd to read commands from *\/$/;"	v
read_cnt_string	spell.c	/^read_cnt_string(fd, cnt_bytes, cntp)$/;"	f	file:
read_compound	spell.c	/^read_compound(fd, slang, len)$/;"	f	file:
read_edit	ex_cmds.h	/^    int		read_edit;	\/* ++edit argument *\/$/;"	m	struct:exarg
read_error_exit	ui.c	/^read_error_exit()$/;"	f
read_from_input_buf	ui.c	/^read_from_input_buf(buf, maxlen)$/;"	f
read_limits	regexp.c	/^read_limits(minval, maxval)$/;"	f	file:
read_prefcond_section	spell.c	/^read_prefcond_section(fd, lp)$/;"	f	file:
read_redo	getchar.c	/^read_redo(init, old_redo)$/;"	f	file:
read_region_section	spell.c	/^read_region_section(fd, lp, len)$/;"	f	file:
read_rep_section	spell.c	/^read_rep_section(fd, gap, first)$/;"	f	file:
read_sal_section	spell.c	/^read_sal_section(fd, slang)$/;"	f	file:
read_sofo_section	spell.c	/^read_sofo_section(fd, slang)$/;"	f	file:
read_stdin	main.c	/^read_stdin()$/;"	f	file:
read_string	spell.c	/^read_string(fd, cnt)$/;"	f	file:
read_stuff	getchar.c	/^read_stuff(advance)$/;"	f	file:
read_tree_node	spell.c	/^read_tree_node(fd, byts, idxs, maxidx, startidx, prefixtree, maxprefcondnr)$/;"	f	file:
read_viminfo	ex_cmds.c	/^read_viminfo(file, want_info, want_marks, forceit)$/;"	f
read_viminfo_bufferlist	buffer.c	/^read_viminfo_bufferlist(virp, writing)$/;"	f
read_viminfo_filemark	mark.c	/^read_viminfo_filemark(virp, force)$/;"	f
read_viminfo_history	ex_getln.c	/^read_viminfo_history(virp)$/;"	f
read_viminfo_register	ops.c	/^read_viminfo_register(virp, force)$/;"	f
read_viminfo_search_pattern	search.c	/^read_viminfo_search_pattern(virp, force)$/;"	f
read_viminfo_sub_string	ex_cmds.c	/^read_viminfo_sub_string(virp, force)$/;"	f
read_viminfo_up_to_marks	ex_cmds.c	/^read_viminfo_up_to_marks(virp, forceit, writing)$/;"	f	file:
read_viminfo_varlist	eval.c	/^read_viminfo_varlist(virp, writing)$/;"	f
read_words_section	spell.c	/^read_words_section(fd, lp, len)$/;"	f	file:
readfile	fileio.c	/^readfile(fname, sfname, from, lines_to_skip, lines_to_read, eap, flags)$/;"	f
readfile_charconvert	fileio.c	/^readfile_charconvert(fname, fenc, fdp)$/;"	f	file:
readfile_linenr	fileio.c	/^readfile_linenr(linecnt, p, endp)$/;"	f	file:
readonlymode	globals.h	/^EXTERN int	readonlymode INIT(= FALSE); \/* Set to TRUE for "view" *\/$/;"	v
real	gui_at_fs.c	/^    char	*real;$/;"	m	struct:__anon13	file:
realloc_cmdbuff	ex_getln.c	/^realloc_cmdbuff(len)$/;"	f	file:
really_exiting	globals.h	/^EXTERN int	really_exiting INIT(= FALSE);$/;"	v
received_selection	gui_gtk_x11.c	/^static int received_selection = RS_NONE;$/;"	v	file:
recordbuff	getchar.c	/^static struct buffheader recordbuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
recov_file_names	memline.c	/^recov_file_names(names, path, prepend_dot)$/;"	f	file:
recover_names	memline.c	/^recover_names(fname, list, nr)$/;"	f
recoverymode	globals.h	/^EXTERN int	recoverymode INIT(= FALSE); \/* Set to TRUE for "-r" option *\/$/;"	v
recurse_tearoffs	gui_gtk.c	/^recurse_tearoffs(vimmenu_T *menu, int val)$/;"	f	file:
redir_endp	eval.c	/^static char_u	*redir_endp = NULL;$/;"	v	file:
redir_fd	globals.h	/^EXTERN FILE *redir_fd INIT(= NULL);	\/* message redirection file *\/$/;"	v
redir_ga	eval.c	/^static garray_T redir_ga;	\/* only valid when redir_lval is not NULL *\/$/;"	v	file:
redir_lval	eval.c	/^static lval_T	*redir_lval = NULL;$/;"	v	file:
redir_off	globals.h	/^EXTERN int  redir_off INIT(= FALSE);	\/* no redirection for a moment *\/$/;"	v
redir_reg	globals.h	/^EXTERN int  redir_reg INIT(= 0);	\/* message redirection register *\/$/;"	v
redir_varname	eval.c	/^static char_u	*redir_varname = NULL;$/;"	v	file:
redir_vname	globals.h	/^EXTERN int  redir_vname INIT(= 0);	\/* message redirection variable *\/$/;"	v
redir_write	message.c	/^redir_write(str, maxlen)$/;"	f	file:
redo_VIsual_busy	globals.h	/^EXTERN int	redo_VIsual_busy INIT(= FALSE);$/;"	v
redo_literal	edit.c	/^redo_literal(c)$/;"	f	file:
redobuff	getchar.c	/^static struct buffheader redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
redrawWinline	screen.c	/^redrawWinline(lnum, invalid)$/;"	f
redraw_all_later	screen.c	/^redraw_all_later(type)$/;"	f
redraw_block	screen.c	/^redraw_block(row, end, wp)$/;"	f	file:
redraw_buf_later	screen.c	/^redraw_buf_later(buf, type)$/;"	f
redraw_cmdline	globals.h	/^EXTERN int	redraw_cmdline INIT(= FALSE);	\/* cmdline must be redrawn *\/$/;"	v
redraw_curbuf_later	screen.c	/^redraw_curbuf_later(type)$/;"	f
redraw_custum_statusline	screen.c	/^redraw_custum_statusline(wp)$/;"	f	file:
redraw_later	screen.c	/^redraw_later(type)$/;"	f
redraw_later_clear	screen.c	/^redraw_later_clear()$/;"	f
redraw_statuslines	screen.c	/^redraw_statuslines()$/;"	f
redraw_tabline	globals.h	/^EXTERN int	    redraw_tabline INIT(= FALSE);  \/* need to redraw tabline *\/$/;"	v
redraw_win_later	screen.c	/^redraw_win_later(wp, type)$/;"	f
redrawcmd	ex_getln.c	/^redrawcmd()$/;"	f
redrawcmd_preedit	ex_getln.c	/^redrawcmd_preedit()$/;"	f	file:
redrawcmdline	ex_getln.c	/^redrawcmdline()$/;"	f
redrawcmdprompt	ex_getln.c	/^redrawcmdprompt()$/;"	f	file:
redrawing	screen.c	/^redrawing()$/;"	f
ref	if_tcl.c	/^struct ref$/;"	s	file:
ref_extmatch	regexp.c	/^ref_extmatch(em)$/;"	f
refcnt	regexp.h	/^    short		refcnt;$/;"	m	struct:__anon78
refsdeleted	if_tcl.c	/^static struct ref refsdeleted;	\/* dummy object for deleted ref list *\/$/;"	v	typeref:struct:ref	file:
reg	regexp.c	/^reg(paren, flagp)$/;"	f	file:
reg_buf	regexp.c	/^static buf_T		*reg_buf;$/;"	v	file:
reg_do_extmatch	globals.h	/^EXTERN int	reg_do_extmatch INIT(= 0);  \/* Used when compiling regexp:$/;"	v
reg_endp	regexp.c	/^static char_u		**reg_endp = NULL;$/;"	v	file:
reg_endpos	regexp.c	/^static lpos_T		*reg_endpos = NULL;$/;"	v	file:
reg_endzp	regexp.c	/^static char_u	*reg_endzp[NSUBEXP];	\/*   and end of \\z(...\\) matches *\/$/;"	v	file:
reg_endzpos	regexp.c	/^static lpos_T	reg_endzpos[NSUBEXP];	\/* idem, end pos *\/$/;"	v	file:
reg_equi_class	regexp.c	/^reg_equi_class(c)$/;"	f	file:
reg_extmatch_T	regexp.h	/^} reg_extmatch_T;$/;"	t	typeref:struct:__anon78
reg_firstlnum	regexp.c	/^static linenr_T		reg_firstlnum;$/;"	v	file:
reg_getline	regexp.c	/^reg_getline(lnum)$/;"	f	file:
reg_line_lbr	regexp.c	/^static int		reg_line_lbr;	    \/* "\\n" in string is line break *\/$/;"	v	file:
reg_magic	regexp.c	/^static int	reg_magic;	\/* magicness of the pattern: *\/$/;"	v	file:
reg_match	regexp.c	/^static regmatch_T	*reg_match;$/;"	v	file:
reg_maxline	regexp.c	/^static linenr_T		reg_maxline;$/;"	v	file:
reg_mmatch	regexp.c	/^static regmmatch_T	*reg_mmatch;$/;"	v	file:
reg_nextline	regexp.c	/^reg_nextline()$/;"	f	file:
reg_prev_class	regexp.c	/^reg_prev_class()$/;"	f	file:
reg_prev_sub	regexp.c	/^static char_u		*reg_prev_sub = NULL;$/;"	v	file:
reg_prog	fileio.c	/^    regprog_T	    *reg_prog;		\/* compiled regprog for pattern *\/$/;"	m	struct:AutoPat	file:
reg_restore	regexp.c	/^reg_restore(save, gap)$/;"	f	file:
reg_save	regexp.c	/^reg_save(save, gap)$/;"	f	file:
reg_save_equal	regexp.c	/^reg_save_equal(save)$/;"	f	file:
reg_startp	regexp.c	/^static char_u		**reg_startp = NULL;$/;"	v	file:
reg_startpos	regexp.c	/^static lpos_T		*reg_startpos = NULL;$/;"	v	file:
reg_startzp	regexp.c	/^static char_u	*reg_startzp[NSUBEXP];	\/* Workspace to mark beginning *\/$/;"	v	file:
reg_startzpos	regexp.c	/^static lpos_T	reg_startzpos[NSUBEXP];	\/* idem, beginning pos *\/$/;"	v	file:
reg_strict	regexp.c	/^static int	reg_strict;	\/* "[abc" is illegal *\/$/;"	v	file:
reg_string	regexp.c	/^static int	reg_string;	\/* matching with a string instead of a buffer$/;"	v	file:
reg_submatch	regexp.c	/^reg_submatch(no)$/;"	f
reg_tofree	regexp.c	/^static char_u	*reg_tofree = NULL;$/;"	v	file:
reg_tofreelen	regexp.c	/^static unsigned	reg_tofreelen;$/;"	v	file:
reg_win	regexp.c	/^static win_T		*reg_win;$/;"	v	file:
reganch	regexp.h	/^    char_u		reganch;$/;"	m	struct:__anon75
regatom	regexp.c	/^regatom(flagp)$/;"	f	file:
regbehind_S	regexp.c	/^typedef struct regbehind_S$/;"	s	file:
regbehind_T	regexp.c	/^} regbehind_T;$/;"	t	typeref:struct:regbehind_S	file:
regbranch	regexp.c	/^regbranch(flagp)$/;"	f	file:
regc	regexp.c	/^regc(b)$/;"	f	file:
regcode	regexp.c	/^static char_u	*regcode;	\/* Code-emit pointer, or JUST_CALC_SIZE *\/$/;"	v	file:
regcomp_start	regexp.c	/^regcomp_start(expr, re_flags)$/;"	f	file:
regconcat	regexp.c	/^regconcat(flagp)$/;"	f	file:
regdump	regexp.c	/^regdump(pattern, r)$/;"	f	file:
regflags	regexp.c	/^static unsigned	regflags;	\/* RF_ flags for prog *\/$/;"	v	file:
regflags	regexp.h	/^    unsigned		regflags;$/;"	m	struct:__anon75
reghasz	regexp.h	/^    char_u		reghasz;$/;"	m	struct:__anon75
reginput	regexp.c	/^static char_u	*reginput;	\/* current input, points into "regline" *\/$/;"	v	file:
reginsert	regexp.c	/^reginsert(op, opnd)$/;"	f	file:
reginsert_limits	regexp.c	/^reginsert_limits(op, minval, maxval, opnd)$/;"	f	file:
register_vim_exn	if_mzsch.c	/^register_vim_exn(Scheme_Env *env)$/;"	f	file:
registryProperty	if_xcmdsrv.c	/^static Atom	registryProperty = None;$/;"	v	file:
regitem_S	regexp.c	/^typedef struct regitem_S$/;"	s	file:
regitem_T	regexp.c	/^} regitem_T;$/;"	t	typeref:struct:regitem_S	file:
regline	regexp.c	/^static char_u	*regline;	\/* start of current line *\/$/;"	v	file:
reglnum	regexp.c	/^static linenr_T	reglnum;	\/* line number, relative to first line *\/$/;"	v	file:
regmatch	regexp.c	/^regmatch(scan)$/;"	f	file:
regmatch	tag.c	/^    regmatch_T	regmatch;	\/* regexp program, may be NULL *\/$/;"	m	struct:__anon60	file:
regmatch_T	regexp.h	/^} regmatch_T;$/;"	t	typeref:struct:__anon76
regmbc	regexp.c	/^# define regmbc(/;"	d	file:
regmbc	regexp.c	/^regmbc(c)$/;"	f	file:
regmlen	regexp.h	/^    int			regmlen;$/;"	m	struct:__anon75
regmmatch_T	regexp.h	/^} regmmatch_T;$/;"	t	typeref:struct:__anon77
regmust	regexp.h	/^    char_u		*regmust;$/;"	m	struct:__anon75
regname	ex_cmds.h	/^    int		regname;	\/* register name (NUL if none) *\/$/;"	m	struct:exarg
regname	structs.h	/^    int		regname;	\/* register to use for the operator *\/$/;"	m	struct:oparg_S
regnarrate	regexp.c	/^int		regnarrate = 0;$/;"	v
regnext	regexp.c	/^regnext(p)$/;"	f	file:
regnode	regexp.c	/^regnode(op)$/;"	f	file:
regnpar	regexp.c	/^static int	regnpar;	\/* () count. *\/$/;"	v	file:
regnzpar	regexp.c	/^static int	regnzpar;	\/* \\z() count. *\/$/;"	v	file:
regoptail	regexp.c	/^regoptail(p, val)$/;"	f	file:
regparse	regexp.c	/^static char_u	*regparse;	\/* Input-scan pointer. *\/$/;"	v	file:
regpiece	regexp.c	/^regpiece(flagp)$/;"	f	file:
regprog	regexp.h	/^    regprog_T		*regprog;$/;"	m	struct:__anon76
regprog	regexp.h	/^    regprog_T		*regprog;$/;"	m	struct:__anon77
regprog_T	regexp.h	/^} regprog_T;$/;"	t	typeref:struct:__anon75
regprop	regexp.c	/^regprop(op)$/;"	f	file:
regrepeat	regexp.c	/^regrepeat(p, maxcount)$/;"	f	file:
regsave	regexp.c	/^	regsave_T  regsave;$/;"	m	union:regitem_S::__anon51	file:
regsave_T	regexp.c	/^} regsave_T;$/;"	t	typeref:struct:__anon47	file:
regsize	regexp.c	/^static long	regsize;	\/* Code size. *\/$/;"	v	file:
regstack	regexp.c	/^static garray_T	regstack = {0, 0, 0, 0, NULL};$/;"	v	file:
regstack_pop	regexp.c	/^regstack_pop(scan)$/;"	f	file:
regstack_push	regexp.c	/^regstack_push(state, scan)$/;"	f	file:
regstar_S	regexp.c	/^typedef struct regstar_S$/;"	s	file:
regstar_T	regexp.c	/^} regstar_T;$/;"	t	typeref:struct:regstar_S	file:
regstart	regexp.h	/^    int			regstart;$/;"	m	struct:__anon75
regstate_E	regexp.c	/^typedef enum regstate_E$/;"	g	file:
regstate_T	regexp.c	/^} regstate_T;$/;"	t	typeref:enum:regstate_E	file:
regtail	regexp.c	/^regtail(p, val)$/;"	f	file:
regtilde	regexp.c	/^regtilde(source, magic)$/;"	f
regtry	regexp.c	/^regtry(prog, col)$/;"	f	file:
rem_backslash	charset.c	/^rem_backslash(str)$/;"	f
remote_common	eval.c	/^remote_common(argvars, rettv, expr)$/;"	f	file:
removable	mark.c	/^removable(name)$/;"	f
removeEventHandler	gui_beval.c	/^removeEventHandler(BalloonEval *beval)$/;"	f	file:
removeEventHandler	gui_beval.c	/^removeEventHandler(beval)$/;"	f	file:
remove_key_from_history	ex_getln.c	/^remove_key_from_history()$/;"	f
remove_menu	menu.c	/^remove_menu(menup, name, modes, silent)$/;"	f	file:
remove_tail	misc1.c	/^remove_tail(p, pend, name)$/;"	f	file:
remove_timer	if_mzsch.c	/^remove_timer(void)$/;"	f	file:
rep_compare	spell.c	/^rep_compare(s1, s2)$/;"	f	file:
repeat_cmdline	globals.h	/^EXTERN char_u	*repeat_cmdline INIT(= NULL); \/* command line for "." *\/$/;"	v
repeat_message	message.c	/^repeat_message()$/;"	f
repeating	ex_docmd.c	/^    int		repeating;		\/* TRUE when looping a second time *\/$/;"	m	struct:loop_cookie	file:
repl_cmdline	ex_docmd.c	/^repl_cmdline(eap, src, srclen, repl, cmdlinep)$/;"	f	file:
repl_from	spell.c	/^static char_u	*repl_from = NULL;$/;"	v	file:
repl_to	spell.c	/^static char_u	*repl_to = NULL;$/;"	v	file:
repl_widgets	gui_gtk.c	/^static SharedFindReplace repl_widgets = { NULL, };$/;"	v	file:
repl_widgets	gui_motif.c	/^static SharedFindReplace repl_widgets = { NULL };$/;"	v	file:
replace	gui_gtk.c	/^    GtkWidget *replace;	\/* 'Replace With' action button *\/$/;"	m	struct:_SharedFindReplace	file:
replace	gui_motif.c	/^    Widget replace;	\/* 'Replace With' action button *\/$/;"	m	struct:_SharedFindReplace	file:
replace_do_bs	edit.c	/^replace_do_bs()$/;"	f	file:
replace_flush	edit.c	/^replace_flush()$/;"	f	file:
replace_join	edit.c	/^replace_join(off)$/;"	f	file:
replace_makeprg	ex_docmd.c	/^replace_makeprg(eap, p, cmdlinep)$/;"	f	file:
replace_offset	globals.h	/^EXTERN int	replace_offset INIT(= 0);   \/* offset for replace_push() *\/$/;"	v
replace_pop	edit.c	/^replace_pop()$/;"	f	file:
replace_pop_ins	edit.c	/^replace_pop_ins()$/;"	f	file:
replace_push	edit.c	/^replace_push(c)$/;"	f
replace_push_mb	edit.c	/^replace_push_mb(p)$/;"	f
replace_stack	edit.c	/^static char_u	*replace_stack = NULL;$/;"	v	file:
replace_stack_len	edit.c	/^static long	replace_stack_len = 0;	    \/* max. number of entries *\/$/;"	v	file:
replace_stack_nr	edit.c	/^static long	replace_stack_nr = 0;	    \/* next entry in replace stack *\/$/;"	v	file:
replace_termcodes	term.c	/^replace_termcodes(from, bufp, from_part, do_lt, special)$/;"	f
report_discard_pending	ex_eval.c	/^report_discard_pending(pending, value)$/;"	f
report_make_pending	ex_eval.c	/^report_make_pending(pending, value)$/;"	f
report_pending	ex_eval.c	/^report_pending(action, pending, value)$/;"	f	file:
report_resume_pending	ex_eval.c	/^report_resume_pending(pending, value)$/;"	f
req_codes_from_term	term.c	/^req_codes_from_term()$/;"	f	file:
req_more_codes_from_term	term.c	/^req_more_codes_from_term()$/;"	f	file:
requestBalloon	gui_beval.c	/^requestBalloon(beval)$/;"	f	file:
rescore_one	spell.c	/^rescore_one(su, stp)$/;"	f	file:
rescore_suggestions	spell.c	/^rescore_suggestions(su)$/;"	f	file:
resel_VIsual_col	normal.c	/^static colnr_T	resel_VIsual_col;		\/* nr of cols or end col *\/$/;"	v	file:
resel_VIsual_line_count	normal.c	/^static linenr_T	resel_VIsual_line_count;	\/* number of lines *\/$/;"	v	file:
resel_VIsual_mode	normal.c	/^static int	resel_VIsual_mode = NUL;	\/* 'v', 'V', or Ctrl-V *\/$/;"	v	file:
reset_VIsual	normal.c	/^reset_VIsual()$/;"	f
reset_VIsual_and_resel	normal.c	/^reset_VIsual_and_resel()$/;"	f
reset_cterm_colors	screen.c	/^reset_cterm_colors()$/;"	f
reset_expand_highlight	syntax.c	/^reset_expand_highlight()$/;"	f
reset_focus	gui_motif.c	/^reset_focus()$/;"	f	file:
reset_last_sourcing	message.c	/^reset_last_sourcing()$/;"	f
reset_modifiable	option.c	/^reset_modifiable()$/;"	f
reset_search_dir	search.c	/^reset_search_dir()$/;"	f
reset_signals	os_unix.c	/^reset_signals()$/;"	f
reset_state_setup	mbyte.c	/^reset_state_setup(GdkIC *ic)$/;"	f	file:
resettitle	buffer.c	/^resettitle()$/;"	f
resolve_symlink	memline.c	/^resolve_symlink(fname, buf)$/;"	f	file:
resources	gui_at_sb.c	/^static XtResource resources[] =$/;"	v	file:
resources	gui_xmebw.c	/^static XtResource resources[] =$/;"	v	file:
restart_VIsual_select	normal.c	/^static int	restart_VIsual_select = 0;$/;"	v	file:
restart_command	gui_gtk_x11.c	/^static const char *restart_command = NULL;$/;"	v	file:
restart_edit	globals.h	/^EXTERN int restart_edit INIT(= 0);	\/* call edit when next cmd finished *\/$/;"	v
restoreRedobuff	getchar.c	/^restoreRedobuff()$/;"	f
restore_cmdline	ex_getln.c	/^restore_cmdline(ccp)$/;"	f	file:
restore_cmdline_alloc	ex_getln.c	/^restore_cmdline_alloc(p)$/;"	f
restore_cterm_colors	syntax.c	/^restore_cterm_colors()$/;"	f
restore_dbg_stuff	ex_docmd.c	/^restore_dbg_stuff(dsp)$/;"	f	file:
restore_funccal	eval.c	/^restore_funccal(vfc)$/;"	f
restore_se	regexp.c	/^#define restore_se(/;"	d	file:
restore_search_patterns	search.c	/^restore_search_patterns()$/;"	f
restore_snapshot	window.c	/^restore_snapshot(close_curwin)$/;"	f	file:
restore_snapshot_rec	window.c	/^restore_snapshot_rec(sn, fr)$/;"	f	file:
restore_subexpr	regexp.c	/^restore_subexpr(bp)$/;"	f	file:
restore_typeahead	getchar.c	/^restore_typeahead(tp)$/;"	f
restore_vimvar	eval.c	/^restore_vimvar(idx, save_tv)$/;"	f	file:
restricted	globals.h	/^EXTERN int	restricted INIT(= FALSE);$/;"	v
result	digraph.c	/^    result_T	result;$/;"	m	struct:digraph	file:
result	if_xcmdsrv.c	/^    char_u  *result;	\/* String result for command (malloc'ed).$/;"	m	struct:PendingCommand	file:
result_T	digraph.c	/^typedef char_u result_T;$/;"	t	file:
result_T	digraph.c	/^typedef int result_T;$/;"	t	file:
rettv	eval.c	/^    typval_T	*rettv;		\/* return value *\/$/;"	m	struct:funccall_S	file:
rettv_list_alloc	eval.c	/^rettv_list_alloc(rettv)$/;"	f	file:
returned	eval.c	/^    int		returned;	\/* ":return" used *\/$/;"	m	struct:funccall_S	file:
retval	structs.h	/^    int		retval;		\/* return: CA_* values *\/$/;"	m	struct:cmdarg_S
reverse_line	ops.c	/^reverse_line(s)$/;"	f	file:
reverse_text	search.c	/^reverse_text(s)$/;"	f
revins_chars	edit.c	/^static int	revins_chars;		\/* how much to skip after edit *\/$/;"	v	file:
revins_legal	edit.c	/^static int	revins_legal;		\/* was the last char 'legal'? *\/$/;"	v	file:
revins_on	edit.c	/^static int	revins_on;		\/* reverse insert mode on *\/$/;"	v	file:
revins_scol	edit.c	/^static int	revins_scol;		\/* start column of revins session *\/$/;"	v	file:
rewind_conditionals	ex_eval.c	/^rewind_conditionals(cstack, idx, cond_type, cond_level)$/;"	f
ri_alpha	regexp.c	/^# define ri_alpha(/;"	d	file:
ri_digit	regexp.c	/^# define ri_digit(/;"	d	file:
ri_head	regexp.c	/^# define ri_head(/;"	d	file:
ri_hex	regexp.c	/^# define ri_hex(/;"	d	file:
ri_lower	regexp.c	/^# define ri_lower(/;"	d	file:
ri_octal	regexp.c	/^# define ri_octal(/;"	d	file:
ri_upper	regexp.c	/^# define ri_upper(/;"	d	file:
ri_white	regexp.c	/^# define ri_white(/;"	d	file:
ri_word	regexp.c	/^# define ri_word(/;"	d	file:
right_sbar_x	gui.h	/^    int		right_sbar_x;	    \/* Calculated x coord for right scrollbar *\/$/;"	m	struct:Gui
rl_mirror	screen.c	/^rl_mirror(str)$/;"	f
rm	structs.h	/^    regmmatch_T	rm;	\/* points to the regexp program; contains last found$/;"	m	struct:__anon96
rm_ic	regexp.h	/^    int			rm_ic;$/;"	m	struct:__anon76
rmm_ic	regexp.h	/^    int			rmm_ic;$/;"	m	struct:__anon77
rmm_maxcol	regexp.h	/^    colnr_T		rmm_maxcol;	\/* when not zero: maximum column *\/$/;"	m	struct:__anon77
role_argument	gui_gtk_x11.c	/^static const char *role_argument = NULL;$/;"	v	file:
room	eval.c	/^	char_u	room[VAR_SHORT_LEN];	\/* room for the name *\/$/;"	m	struct:funccall_S::__anon3	file:
root_menu	globals.h	/^EXTERN vimmenu_T	*root_menu INIT(= NULL);$/;"	v
row	gui.h	/^    int		row;		    \/* Current cursor row in GUI display *\/$/;"	m	struct:Gui
row2tcl	if_tcl.c	/^#define row2tcl(/;"	d	file:
row2vim	if_tcl.c	/^#define row2vim(/;"	d	file:
rs_len	regexp.c	/^    int		rs_len;$/;"	m	struct:__anon47	file:
rs_no	regexp.c	/^    short	rs_no;		\/* submatch nr or BEHIND\/NOBEHIND *\/$/;"	m	struct:regitem_S	file:
rs_scan	regexp.c	/^    char_u	*rs_scan;	\/* current node in program *\/$/;"	m	struct:regitem_S	file:
rs_state	regexp.c	/^    regstate_T	rs_state;	\/* what we are doing, one of RS_ above *\/$/;"	m	struct:regitem_S	file:
rs_u	regexp.c	/^    } rs_u;$/;"	m	struct:__anon47	typeref:union:__anon47::__anon48	file:
rs_un	regexp.c	/^    } rs_un;			\/* room for saving reginput *\/$/;"	m	struct:regitem_S	typeref:union:regitem_S::__anon51	file:
rsrc_bold_font_name	gui.h	/^    char_u	*rsrc_bold_font_name; \/* Resource bold font name *\/$/;"	m	struct:Gui
rsrc_boldital_font_name	gui.h	/^    char_u	*rsrc_boldital_font_name;  \/* Resource bold-italic font name *\/$/;"	m	struct:Gui
rsrc_font_name	gui.h	/^    char_u	*rsrc_font_name;    \/* Resource font name, used if 'guifont'$/;"	m	struct:Gui
rsrc_input_method	gui.h	/^    char	*rsrc_input_method;$/;"	m	struct:Gui
rsrc_ital_font_name	gui.h	/^    char_u	*rsrc_ital_font_name; \/* Resource italic font name *\/$/;"	m	struct:Gui
rsrc_menu_bg_name	gui.h	/^    char	*rsrc_menu_bg_name;	\/* Color of menu & dialog background *\/$/;"	m	struct:Gui
rsrc_menu_fg_name	gui.h	/^    char	*rsrc_menu_fg_name;	\/* Color of menu & dialog foreground *\/$/;"	m	struct:Gui
rsrc_menu_font_name	gui.h	/^    char_u	*rsrc_menu_font_name;    \/* Resource menu Font name *\/$/;"	m	struct:Gui
rsrc_preedit_type_name	gui.h	/^    char	*rsrc_preedit_type_name;$/;"	m	struct:Gui
rsrc_rev_video	gui.h	/^    Bool	rsrc_rev_video;	    \/* Use reverse video? *\/$/;"	m	struct:Gui
rsrc_scroll_bg_name	gui.h	/^    char	*rsrc_scroll_bg_name;	\/* Color of scrollbar background *\/$/;"	m	struct:Gui
rsrc_scroll_fg_name	gui.h	/^    char	*rsrc_scroll_fg_name;	\/* Color of scrollbar foreground *\/$/;"	m	struct:Gui
rsrc_tooltip_bg_name	gui.h	/^    char	*rsrc_tooltip_bg_name;	\/* tooltip background color name *\/$/;"	m	struct:Gui
rsrc_tooltip_fg_name	gui.h	/^    char	*rsrc_tooltip_fg_name;	\/* tooltip foreground color name *\/$/;"	m	struct:Gui
rsrc_tooltip_font_name	gui.h	/^    char_u	*rsrc_tooltip_font_name; \/* tooltip font name *\/$/;"	m	struct:Gui
ru_col	globals.h	/^EXTERN int	ru_col;		\/* column for ruler *\/$/;"	v
ru_wid	globals.h	/^EXTERN int	ru_wid;		\/* 'rulerfmt' width of ruler when non-zero *\/$/;"	v
ruby_buffer_free	if_ruby.c	/^void ruby_buffer_free(buf_T *buf)$/;"	f
ruby_enabled	if_ruby.c	/^ruby_enabled(verbose)$/;"	f
ruby_end	if_ruby.c	/^ruby_end()$/;"	f
ruby_errinfo	if_ruby.c	/^#define ruby_errinfo	/;"	d	file:
ruby_funcname_table	if_ruby.c	/^} ruby_funcname_table[] =$/;"	v	typeref:struct:__anon36	file:
ruby_init	if_ruby.c	/^#define ruby_init	/;"	d	file:
ruby_init_loadpath	if_ruby.c	/^#define ruby_init_loadpath	/;"	d	file:
ruby_initialized	if_ruby.c	/^static int ruby_initialized = 0;$/;"	v	file:
ruby_io_init	if_ruby.c	/^static void ruby_io_init(void)$/;"	f	file:
ruby_runtime_link_init	if_ruby.c	/^ruby_runtime_link_init(char *libname, int verbose)$/;"	f	file:
ruby_vim_init	if_ruby.c	/^static void ruby_vim_init(void)$/;"	f	file:
ruby_window_free	if_ruby.c	/^void ruby_window_free(win_T *win)$/;"	f
running_syn_inc_tag	syntax.c	/^static int running_syn_inc_tag = 0;$/;"	v	file:
s_tearoffs	menu.c	/^static int s_tearoffs = FALSE;$/;"	v	file:
safe_vgetc	getchar.c	/^safe_vgetc()$/;"	f
sal_to_bool	spell.c	/^sal_to_bool(s)$/;"	f	file:
salfirst_T	spell.c	/^typedef int salfirst_T;$/;"	t	file:
salfirst_T	spell.c	/^typedef short salfirst_T;$/;"	t	file:
salitem_S	spell.c	/^typedef struct salitem_S$/;"	s	file:
salitem_T	spell.c	/^} salitem_T;$/;"	t	typeref:struct:salitem_S	file:
same_directory	misc2.c	/^same_directory(f1, f2)$/;"	f
same_encoding	fileio.c	/^same_encoding(a, b)$/;"	f	file:
same_leader	ops.c	/^same_leader(lnum, leader1_len, leader1_flags, leader2_len, leader2_flags)$/;"	f	file:
sample	gui_xmdlg.c	/^    Widget	sample;$/;"	m	struct:_SharedFontSelData	file:
sandbox	globals.h	/^EXTERN int	sandbox INIT(= 0);$/;"	v
sandbox_check	if_mzsch.c	/^sandbox_check(void)$/;"	f	file:
sandbox_file_guard	if_mzsch.c	/^sandbox_file_guard(int argc, Scheme_Object **argv)$/;"	f	file:
sandbox_network_guard	if_mzsch.c	/^sandbox_network_guard(int argc, Scheme_Object **argv)$/;"	f	file:
sattr_T	vim.h	/^typedef unsigned char sattr_T;$/;"	t
sattr_T	vim.h	/^typedef unsigned short sattr_T;$/;"	t
save	netbeans.c	/^save(char_u *buf, int len)$/;"	f	file:
saveRedobuff	getchar.c	/^saveRedobuff()$/;"	f
save_after	regexp.c	/^    regsave_T	save_after;$/;"	m	struct:regbehind_S	file:
save_behind	regexp.c	/^    regsave_T	save_behind;$/;"	m	struct:regbehind_S	file:
save_buf	structs.h	/^    buf_T	*save_buf;	\/* saved curbuf *\/$/;"	m	struct:__anon97
save_cmdline	ex_getln.c	/^save_cmdline(ccp)$/;"	f	file:
save_cmdline_alloc	ex_getln.c	/^save_cmdline_alloc()$/;"	f
save_cursor	structs.h	/^    pos_T	save_cursor;	\/* saved cursor pos of save_curwin *\/$/;"	m	struct:__anon97
save_curwin	structs.h	/^    win_T	*save_curwin;	\/* saved curwin, NULL if it didn't change *\/$/;"	m	struct:__anon97
save_dbg_stuff	ex_docmd.c	/^save_dbg_stuff(dsp)$/;"	f	file:
save_ei	structs.h	/^    char_u	*save_ei;		\/* saved value of 'eventignore' *\/$/;"	m	struct:__anon83
save_end	regexp.c	/^    save_se_T   save_end[NSUBEXP];$/;"	m	struct:regbehind_S	file:
save_file_ff	option.c	/^save_file_ff(buf)$/;"	f
save_files	integration.c	/^Boolean save_files = True;		\/* When true, save all files before build actions *\/$/;"	v
save_funccal	eval.c	/^save_funccal()$/;"	f
save_inputbuf	structs.h	/^    char_u		*save_inputbuf;$/;"	m	struct:__anon91
save_level	getchar.c	/^static int save_level = 0;$/;"	v	file:
save_level	search.c	/^static int save_level = 0;$/;"	v	file:
save_need_clear_subexpr	regexp.c	/^    int		save_need_clear_subexpr;$/;"	m	struct:regbehind_S	file:
save_old_redobuff	getchar.c	/^static struct buffheader save_old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
save_p_ls	globals.h	/^EXTERN int  save_p_ls INIT(= -1);	\/* Save 'laststatus' setting *\/$/;"	v
save_p_wmh	globals.h	/^EXTERN int  save_p_wmh INIT(= -1);	\/* Save 'winminheight' setting *\/$/;"	v
save_patterns	os_unix.c	/^save_patterns(num_pat, pat, num_file, file)$/;"	f	file:
save_re_pat	search.c	/^save_re_pat(idx, pat, magic)$/;"	f	file:
save_redobuff	getchar.c	/^static struct buffheader save_redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
save_se	regexp.c	/^#define save_se(/;"	d	file:
save_se_T	regexp.c	/^} save_se_T;$/;"	t	typeref:struct:__anon49	file:
save_se_multi	regexp.c	/^save_se_multi(savep, posp)$/;"	f	file:
save_se_one	regexp.c	/^save_se_one(savep, pp)$/;"	f	file:
save_search_patterns	search.c	/^save_search_patterns()$/;"	f
save_start	regexp.c	/^    save_se_T   save_start[NSUBEXP];$/;"	m	struct:regbehind_S	file:
save_stuffbuff	structs.h	/^    struct buffheader	save_stuffbuff;$/;"	m	struct:__anon91	typeref:struct:__anon91::buffheader
save_subexpr	regexp.c	/^save_subexpr(bp)$/;"	f	file:
save_topfill	structs.h	/^    int		save_topfill;	\/* saved topfill of save_curwin *\/$/;"	m	struct:__anon97
save_topline	structs.h	/^    linenr_T	save_topline;	\/* saved topline of save_curwin *\/$/;"	m	struct:__anon97
save_typeahead	getchar.c	/^save_typeahead(tp)$/;"	f
save_typebuf	getchar.c	/^save_typebuf()$/;"	f
save_typebuf	structs.h	/^    typebuf_T		save_typebuf;$/;"	m	struct:__anon91
save_yourself	os_unix.c	/^    Bool save_yourself;     \/* If we're in the middle of a save_yourself *\/$/;"	m	struct:__anon46	file:
save_yourself_atom	gui_gtk_x11.c	/^static GdkAtom save_yourself_atom = GDK_NONE;$/;"	v	file:
saved_cursor	globals.h	/^EXTERN pos_T	saved_cursor		\/* w_cursor before formatting text. *\/$/;"	v
saved_emsg_silent	structs.h	/^    int		saved_emsg_silent;	\/* saved value of "emsg_silent" *\/$/;"	m	struct:eslist_elem
saved_last_idx	search.c	/^static int	    saved_last_idx = 0;$/;"	v	file:
saved_no_hlsearch	search.c	/^static int	    saved_no_hlsearch = 0;$/;"	v	file:
saved_python_thread	if_python.c	/^static PyThreadState *saved_python_thread = NULL;$/;"	v	file:
saved_spats	search.c	/^static struct spat  saved_spats[2];$/;"	v	typeref:struct:spat	file:
saved_typebuf	getchar.c	/^static typebuf_T saved_typebuf[NSCRIPT];$/;"	v	file:
sb_attr	message.c	/^    int		sb_attr;	\/* text attributes *\/$/;"	m	struct:msgchunk_S	file:
sb_data	spell.c	/^    char_u	sb_data[1];	\/* data, actually longer *\/$/;"	m	struct:sblock_S	file:
sb_eol	message.c	/^    char	sb_eol;		\/* TRUE when line ends after this text *\/$/;"	m	struct:msgchunk_S	file:
sb_msg_col	message.c	/^    int		sb_msg_col;	\/* column in which text starts *\/$/;"	m	struct:msgchunk_S	file:
sb_next	message.c	/^    msgchunk_T	*sb_next;$/;"	m	struct:msgchunk_S	file:
sb_next	spell.c	/^    sblock_T	*sb_next;	\/* next block in list *\/$/;"	m	struct:sblock_S	file:
sb_prev	message.c	/^    msgchunk_T	*sb_prev;$/;"	m	struct:msgchunk_S	file:
sb_text	message.c	/^    char_u	sb_text[1];	\/* text to be displayed, actually longer *\/$/;"	m	struct:msgchunk_S	file:
sb_used	spell.c	/^    int		sb_used;	\/* nr of bytes already in use *\/$/;"	m	struct:sblock_S	file:
sblock_S	spell.c	/^struct sblock_S$/;"	s	file:
sblock_T	spell.c	/^typedef struct sblock_S sblock_T;$/;"	t	typeref:struct:sblock_S	file:
sc_charsets	hardcopy.c	/^static struct prt_ps_charset_S sc_charsets[] =$/;"	v	typeref:struct:prt_ps_charset_S	file:
sc_col	globals.h	/^EXTERN int	sc_col;		\/* column for shown command *\/$/;"	v
sc_encodings	hardcopy.c	/^static struct prt_ps_encoding_S sc_encodings[] =$/;"	v	typeref:struct:prt_ps_encoding_S	file:
schar_T	vim.h	/^typedef char_u schar_T;$/;"	t
scheme_add_global	if_mzsch.c	/^# define scheme_add_global /;"	d	file:
scheme_add_global_symbol	if_mzsch.c	/^# define scheme_add_global_symbol /;"	d	file:
scheme_apply	if_mzsch.c	/^# define scheme_apply /;"	d	file:
scheme_basic_env	if_mzsch.c	/^# define scheme_basic_env /;"	d	file:
scheme_builtin_value	if_mzsch.c	/^# define scheme_builtin_value /;"	d	file:
scheme_byte_string_to_char_string	if_mzsch.c	/^#  define scheme_byte_string_to_char_string /;"	d	file:
scheme_byte_string_to_char_string	if_mzsch.h	/^# define scheme_byte_string_to_char_string(/;"	d
scheme_char_string_to_byte_string	if_mzsch.c	/^#  define scheme_char_string_to_byte_string /;"	d	file:
scheme_char_string_to_path	if_mzsch.c	/^#  define scheme_char_string_to_path /;"	d	file:
scheme_check_threads	if_mzsch.c	/^# define scheme_check_threads /;"	d	file:
scheme_close_input_port	if_mzsch.c	/^# define scheme_close_input_port /;"	d	file:
scheme_config	if_mzsch.h	/^# define scheme_config /;"	d
scheme_console_output	if_mzsch.c	/^# define scheme_console_output /;"	d	file:
scheme_console_printf	if_mzsch.c	/^# define scheme_console_printf /;"	d	file:
scheme_count_lines	if_mzsch.c	/^# define scheme_count_lines /;"	d	file:
scheme_current_config	if_mzsch.c	/^#  define scheme_current_config /;"	d	file:
scheme_current_continuation_marks	if_mzsch.c	/^# define scheme_current_continuation_marks /;"	d	file:
scheme_current_thread	if_mzsch.c	/^# define scheme_current_thread /;"	d	file:
scheme_display	if_mzsch.c	/^# define scheme_display /;"	d	file:
scheme_display_to_string	if_mzsch.c	/^# define scheme_display_to_string /;"	d	file:
scheme_do_eval	if_mzsch.c	/^# define scheme_do_eval /;"	d	file:
scheme_dont_gc_ptr	if_mzsch.c	/^# define scheme_dont_gc_ptr /;"	d	file:
scheme_eof	if_mzsch.c	/^# define scheme_eof /;"	d	file:
scheme_eq	if_mzsch.c	/^# define scheme_eq /;"	d	file:
scheme_eval	if_mzsch.c	/^# define scheme_eval /;"	d	file:
scheme_eval_string	if_mzsch.c	/^# define scheme_eval_string /;"	d	file:
scheme_eval_string_all	if_mzsch.c	/^# define scheme_eval_string_all /;"	d	file:
scheme_false	if_mzsch.c	/^# define scheme_false /;"	d	file:
scheme_finish_primitive_module	if_mzsch.c	/^# define scheme_finish_primitive_module /;"	d	file:
scheme_format	if_mzsch.c	/^#  define scheme_format /;"	d	file:
scheme_format	if_mzsch.h	/^#  undef scheme_format$/;"	d
scheme_format	if_mzsch.h	/^# define scheme_format /;"	d
scheme_format_utf8	if_mzsch.c	/^#  define scheme_format_utf8 /;"	d	file:
scheme_gc_ptr_ok	if_mzsch.c	/^# define scheme_gc_ptr_ok /;"	d	file:
scheme_get_param	if_mzsch.c	/^# define scheme_get_param /;"	d	file:
scheme_get_sized_byte_string_output	if_mzsch.c	/^#  define scheme_get_sized_byte_string_output /;"	d	file:
scheme_get_sized_string_output	if_mzsch.c	/^#  define scheme_get_sized_string_output /;"	d	file:
scheme_get_sized_string_output	if_mzsch.h	/^# define scheme_get_sized_string_output /;"	d
scheme_intern_symbol	if_mzsch.c	/^# define scheme_intern_symbol /;"	d	file:
scheme_lookup_global	if_mzsch.c	/^# define scheme_lookup_global /;"	d	file:
scheme_make_byte_string	if_mzsch.c	/^#  define scheme_make_byte_string /;"	d	file:
scheme_make_byte_string_output_port	if_mzsch.c	/^#  define scheme_make_byte_string_output_port /;"	d	file:
scheme_make_closed_prim_w_arity	if_mzsch.c	/^# define scheme_make_closed_prim_w_arity /;"	d	file:
scheme_make_integer_value	if_mzsch.c	/^# define scheme_make_integer_value /;"	d	file:
scheme_make_namespace	if_mzsch.c	/^# define scheme_make_namespace /;"	d	file:
scheme_make_pair	if_mzsch.c	/^# define scheme_make_pair /;"	d	file:
scheme_make_prim_w_arity	if_mzsch.c	/^# define scheme_make_prim_w_arity /;"	d	file:
scheme_make_sized_string	if_mzsch.h	/^# define scheme_make_sized_string /;"	d
scheme_make_string	if_mzsch.c	/^#  define scheme_make_string /;"	d	file:
scheme_make_string	if_mzsch.h	/^# define scheme_make_string /;"	d
scheme_make_string_output_port	if_mzsch.c	/^#  define scheme_make_string_output_port /;"	d	file:
scheme_make_string_output_port	if_mzsch.h	/^# define scheme_make_string_output_port /;"	d
scheme_make_struct_instance	if_mzsch.c	/^# define scheme_make_struct_instance /;"	d	file:
scheme_make_struct_names	if_mzsch.c	/^# define scheme_make_struct_names /;"	d	file:
scheme_make_struct_type	if_mzsch.c	/^# define scheme_make_struct_type /;"	d	file:
scheme_make_struct_values	if_mzsch.c	/^# define scheme_make_struct_values /;"	d	file:
scheme_make_type	if_mzsch.c	/^# define scheme_make_type /;"	d	file:
scheme_make_vector	if_mzsch.c	/^# define scheme_make_vector /;"	d	file:
scheme_malloc_fail_ok	if_mzsch.c	/^# define scheme_malloc_fail_ok /;"	d	file:
scheme_notify_multithread	if_mzsch.c	/^# define scheme_notify_multithread /;"	d	file:
scheme_null	if_mzsch.c	/^# define scheme_null /;"	d	file:
scheme_open_input_file	if_mzsch.c	/^# define scheme_open_input_file /;"	d	file:
scheme_primitive_module	if_mzsch.c	/^# define scheme_primitive_module /;"	d	file:
scheme_proper_list_length	if_mzsch.c	/^# define scheme_proper_list_length /;"	d	file:
scheme_raise	if_mzsch.c	/^# define scheme_raise /;"	d	file:
scheme_read	if_mzsch.c	/^# define scheme_read /;"	d	file:
scheme_register_static	if_mzsch.c	/^# define scheme_register_static /;"	d	file:
scheme_set_param	if_mzsch.c	/^#  define scheme_set_param /;"	d	file:
scheme_set_stack_base	if_mzsch.c	/^# define scheme_set_stack_base /;"	d	file:
scheme_signal_error	if_mzsch.c	/^# define scheme_signal_error /;"	d	file:
scheme_true	if_mzsch.c	/^# define scheme_true /;"	d	file:
scheme_void	if_mzsch.c	/^# define scheme_void /;"	d	file:
scheme_write_string	if_mzsch.h	/^# define scheme_write_string /;"	d
scheme_wrong_type	if_mzsch.c	/^# define scheme_wrong_type /;"	d	file:
scid_T	structs.h	/^typedef int			scid_T;		\/* script ID *\/$/;"	t
scl_list	syntax.c	/^    short	    *scl_list;	    \/* IDs in this syntax cluster *\/$/;"	m	struct:syn_cluster_S	file:
scl_name	syntax.c	/^    char_u	    *scl_name;	    \/* syntax cluster name *\/$/;"	m	struct:syn_cluster_S	file:
scl_name_u	syntax.c	/^    char_u	    *scl_name_u;    \/* uppercase of scl_name *\/$/;"	m	struct:syn_cluster_S	file:
score	spell.c	/^    int		score;$/;"	m	struct:__anon57	file:
score_combine	spell.c	/^score_combine(su)$/;"	f	file:
score_comp_sal	spell.c	/^score_comp_sal(su)$/;"	f	file:
score_wordcount_adj	spell.c	/^score_wordcount_adj(slang, score, word, split)$/;"	f	file:
screen_Columns	globals.h	/^EXTERN int	screen_Columns INIT(= 0);   \/* actual size of ScreenLines[] *\/$/;"	v
screen_Rows	globals.h	/^EXTERN int	screen_Rows INIT(= 0);	    \/* actual size of ScreenLines[] *\/$/;"	v
screen_attr	screen.c	/^static int	screen_attr = 0;$/;"	v	file:
screen_char	screen.c	/^screen_char(off, row, col)$/;"	f	file:
screen_char_2	screen.c	/^screen_char_2(off, row, col)$/;"	f	file:
screen_char_attr	screen.c	/^static int screen_char_attr = 0;$/;"	v	file:
screen_cleared	globals.h	/^EXTERN int	screen_cleared INIT(= FALSE);	\/* screen has been cleared *\/$/;"	v
screen_comp_differs	screen.c	/^screen_comp_differs(off, u8cc)$/;"	f	file:
screen_cur_col	screen.c	/^static int	screen_cur_row, screen_cur_col;	\/* last known cursor position *\/$/;"	v	file:
screen_cur_row	screen.c	/^static int	screen_cur_row, screen_cur_col;	\/* last known cursor position *\/$/;"	v	file:
screen_del_lines	screen.c	/^screen_del_lines(off, row, line_count, end, force, wp)$/;"	f
screen_draw_rectangle	screen.c	/^screen_draw_rectangle(row, col, height, width, invert)$/;"	f
screen_fill	screen.c	/^screen_fill(start_row, end_row, start_col, end_col, c1, c2, attr)$/;"	f
screen_getbytes	screen.c	/^screen_getbytes(row, col, bytes, attrp)$/;"	f
screen_height	gui_beval.h	/^    Dimension		screen_height;	\/* screen height in pixels *\/$/;"	m	struct:BalloonEvalStruct
screen_ins_lines	screen.c	/^screen_ins_lines(off, row, line_count, end, wp)$/;"	f
screen_line	screen.c	/^screen_line(row, coloff, endcol, clear_width$/;"	f	file:
screen_putchar	screen.c	/^screen_putchar(c, row, col, attr)$/;"	f
screen_puts	screen.c	/^screen_puts(text, row, col, attr)$/;"	f
screen_puts_len	screen.c	/^screen_puts_len(text, len, row, col, attr)$/;"	f
screen_puts_mbyte	message.c	/^screen_puts_mbyte(s, l, attr)$/;"	f	file:
screen_start	screen.c	/^screen_start()$/;"	f
screen_start_highlight	screen.c	/^screen_start_highlight(attr)$/;"	f	file:
screen_stop_highlight	screen.c	/^screen_stop_highlight()$/;"	f
screen_valid	screen.c	/^screen_valid(clear)$/;"	f
screen_width	gui_beval.h	/^    Dimension		screen_width;	\/* screen width in pixels *\/$/;"	m	struct:BalloonEvalStruct
screenalloc	screen.c	/^screenalloc(clear)$/;"	f
screenclear	screen.c	/^screenclear()$/;"	f
screenclear2	screen.c	/^screenclear2()$/;"	f	file:
scriptID	fileio.c	/^    scid_T	    scriptID;		\/* script ID where defined *\/$/;"	m	struct:AutoCmd	file:
scriptID	option.c	/^    scid_T	scriptID;	\/* script in which the option was last set *\/$/;"	m	struct:vimoption	file:
script_autoload	eval.c	/^script_autoload(name, reload)$/;"	f	file:
script_do_profile	ex_cmds2.c	/^script_do_profile(si)$/;"	f	file:
script_dump_profile	ex_cmds2.c	/^script_dump_profile(fd)$/;"	f	file:
script_get	ex_getln.c	/^script_get(eap, cmd)$/;"	f
script_items	ex_cmds2.c	/^static garray_T script_items = {0, 0, sizeof(scriptitem_T), 4, NULL};$/;"	v	file:
script_line_end	ex_cmds2.c	/^script_line_end()$/;"	f
script_line_exec	ex_cmds2.c	/^script_line_exec()$/;"	f
script_line_start	ex_cmds2.c	/^script_line_start()$/;"	f
script_prof_restore	ex_cmds2.c	/^script_prof_restore(tm)$/;"	f
script_prof_save	ex_cmds2.c	/^script_prof_save(tm)$/;"	f
scriptin	globals.h	/^EXTERN FILE	*scriptin[NSCRIPT];	    \/* streams to read script from *\/$/;"	v
scriptitem_S	ex_cmds2.c	/^typedef struct scriptitem_S$/;"	s	file:
scriptitem_T	ex_cmds2.c	/^} scriptitem_T;$/;"	t	typeref:struct:scriptitem_S	file:
scriptnames_slash_adjust	ex_cmds2.c	/^scriptnames_slash_adjust()$/;"	f
scriptout	globals.h	/^EXTERN FILE	*scriptout  INIT(= NULL);   \/* stream to write script to *\/$/;"	v
scriptvar_T	eval.c	/^} scriptvar_T;$/;"	t	typeref:struct:__anon2	file:
scrollProc	gui_at_sb.h	/^    XtCallbackList scrollProc;	\/* proportional scroll *\/$/;"	m	struct:__anon64
scroll_bg_pixel	gui.h	/^    guicolor_T	scroll_bg_pixel;	\/* Same in Pixel format *\/$/;"	m	struct:Gui
scroll_cb	gui_motif.c	/^scroll_cb(w, client_data, call_data)$/;"	f	file:
scroll_cursor_bot	move.c	/^scroll_cursor_bot(min_scroll, set_topbot)$/;"	f
scroll_cursor_halfway	move.c	/^scroll_cursor_halfway(atend)$/;"	f
scroll_cursor_top	move.c	/^scroll_cursor_top(min_scroll, always)$/;"	f
scroll_def_bg_pixel	gui.h	/^    guicolor_T	scroll_def_bg_pixel;  \/* Default scrollbar background *\/$/;"	m	struct:Gui
scroll_def_fg_pixel	gui.h	/^    guicolor_T	scroll_def_fg_pixel;  \/* Default scrollbar foreground *\/$/;"	m	struct:Gui
scroll_event	gui_gtk_x11.c	/^scroll_event(GtkWidget *widget, GdkEventScroll *event, gpointer data)$/;"	f	file:
scroll_fg_pixel	gui.h	/^    guicolor_T	scroll_fg_pixel;	\/* Same in Pixel format *\/$/;"	m	struct:Gui
scroll_line_len	gui.c	/^scroll_line_len(lnum)$/;"	f	file:
scroll_mode	gui_at_sb.h	/^    char	  scroll_mode;	\/* see below *\/$/;"	m	struct:__anon64
scroll_off	gui_at_sb.h	/^    float	  scroll_off;	\/* offset from event to top of thumb *\/$/;"	m	struct:__anon64
scroll_redraw	normal.c	/^scroll_redraw(up, count)$/;"	f
scroll_region	globals.h	/^EXTERN int	scroll_region INIT(= FALSE); \/* term supports scroll region *\/$/;"	v
scroll_region_bot	gui.h	/^    int		scroll_region_bot;  \/* Bottom (last) line of scroll region *\/$/;"	m	struct:Gui
scroll_region_left	gui.h	/^    int		scroll_region_left;  \/* Left (first) column of scroll region *\/$/;"	m	struct:Gui
scroll_region_reset	term.c	/^scroll_region_reset()$/;"	f
scroll_region_right	gui.h	/^    int		scroll_region_right;  \/* Right (last) col. of scroll region *\/$/;"	m	struct:Gui
scroll_region_set	term.c	/^scroll_region_set(wp, off)$/;"	f
scroll_region_top	gui.h	/^    int		scroll_region_top;  \/* Top (first) line of scroll region *\/$/;"	m	struct:Gui
scroll_shift	gui.h	/^    int		scroll_shift;	\/* The scrollbar stuff can handle only up to$/;"	m	struct:GuiScrollbar
scroll_start	term.c	/^scroll_start()$/;"	f
scrollbar	gui_at_sb.h	/^    ScrollbarPart	scrollbar;$/;"	m	struct:_ScrollbarRec
scrollbar_T	gui.h	/^} scrollbar_T;$/;"	t	typeref:struct:GuiScrollbar
scrollbar_class	gui_at_sb.h	/^    ScrollbarClassPart		scrollbar_class;$/;"	m	struct:_ScrollbarClassRec
scrollbar_height	gui.h	/^    int		scrollbar_height;   \/* Height of horizontal scrollbar *\/$/;"	m	struct:Gui
scrollbar_value	globals.h	/^EXTERN long_u	scrollbar_value;$/;"	v
scrollbar_width	gui.h	/^    int		scrollbar_width;    \/* Width of vertical scrollbars *\/$/;"	m	struct:Gui
scrolldown	move.c	/^scrolldown(line_count, byfold)$/;"	f
scrolldown_clamp	move.c	/^scrolldown_clamp()$/;"	f
scrolljump_value	move.c	/^scrolljump_value()$/;"	f	file:
scrollup	move.c	/^scrollup(line_count, byfold)$/;"	f
scrollup_clamp	move.c	/^scrollup_clamp()$/;"	f
sd	integration.c	/^static int sd = -1;$/;"	v	file:
sd	netbeans.c	/^static NBSOCK sd = -1;			\/* socket fd for Netbeans connection *\/$/;"	v	file:
se_u	regexp.c	/^    } se_u;$/;"	m	struct:__anon49	typeref:union:__anon49::__anon50	file:
search_cmn	eval.c	/^search_cmn(argvars, match_pos, flagsp)$/;"	f	file:
search_for_exact_line	search.c	/^search_for_exact_line(buf, pos, dir, pat)$/;"	f
search_hl	screen.c	/^static match_T search_hl;	\/* used for 'hlsearch' highlight matching *\/$/;"	v	file:
search_match_endcol	globals.h	/^EXTERN colnr_T	search_match_endcol;		\/* col nr of match end *\/$/;"	v
search_match_lines	globals.h	/^EXTERN linenr_T	search_match_lines;		\/* lines of of matched string *\/$/;"	v
search_regcomp	search.c	/^search_regcomp(pat, pat_save, pat_use, options, regmatch)$/;"	f
searchbuf	structs.h	/^    char_u	*searchbuf;	\/* return: pointer to search pattern or NULL *\/$/;"	m	struct:cmdarg_S
searchc	search.c	/^searchc(cap, t_cmd)$/;"	f
searchcmdlen	globals.h	/^EXTERN int	searchcmdlen;		    \/* length of previous search cmd *\/$/;"	v
searchit	search.c	/^searchit(win, buf, pos, dir, pat, count, options, pat_use, stop_lnum, tm)$/;"	f
searchpair_cmn	eval.c	/^searchpair_cmn(argvars, match_pos)$/;"	f	file:
secure	globals.h	/^EXTERN int	secure INIT(= FALSE);$/;"	v
seen_b_u_curhead	undo.c	/^static int seen_b_u_curhead;$/;"	v	file:
seen_b_u_newhead	undo.c	/^static int seen_b_u_newhead;$/;"	v	file:
sel	gui_xmdlg.c	/^    String	sel[NONE];	\/* selection category *\/$/;"	m	struct:_SharedFontSelData	file:
selFile	gui_at_fs.c	/^static Widget	selFile,$/;"	v	file:
selFileCancel	gui_at_fs.c	/^		selFileCancel,$/;"	v	file:
selFileField	gui_at_fs.c	/^		selFileField,$/;"	v	file:
selFileForm	gui_at_fs.c	/^		selFileForm,$/;"	v	file:
selFileHScroll	gui_at_fs.c	/^		selFileHScroll,$/;"	v	file:
selFileHScrolls	gui_at_fs.c	/^		selFileHScrolls[3],$/;"	v	file:
selFileLists	gui_at_fs.c	/^		selFileLists[3],$/;"	v	file:
selFileOK	gui_at_fs.c	/^		selFileOK,$/;"	v	file:
selFilePrompt	gui_at_fs.c	/^		selFilePrompt,$/;"	v	file:
selFileVScrolls	gui_at_fs.c	/^		selFileVScrolls[3];$/;"	v	file:
sel_atom	vim.h	/^    Atom	sel_atom;	\/* PRIMARY\/CLIPBOARD selection ID *\/$/;"	m	struct:VimClipboard
select	os_unix.c	/^#  define select	/;"	d	file:
select	os_unix.c	/^# define select /;"	d	file:
select	os_unix.c	/^# undef select$/;"	d	file:
selection_clear_event	gui_gtk_x11.c	/^selection_clear_event(GtkWidget		*widget,$/;"	f	file:
selection_get_cb	gui_gtk_x11.c	/^selection_get_cb(GtkWidget	    *widget,$/;"	f	file:
selection_received_cb	gui_gtk_x11.c	/^selection_received_cb(GtkWidget		*widget,$/;"	f	file:
selection_targets	gui_gtk_x11.c	/^static const GtkTargetEntry selection_targets[] =$/;"	v	file:
selinux_enabled	os_unix.c	/^static int selinux_enabled = -1;$/;"	v	file:
send_tabline_event	gui.c	/^send_tabline_event(nr)$/;"	f
send_tabline_menu_event	gui.c	/^send_tabline_menu_event(tabidx, event)$/;"	f
sense	integration.h	/^	Boolean		sense;$/;"	m	struct:__anon71
sensitive	structs.h	/^    int		sensitive;	    \/* turn button on\/off *\/$/;"	m	struct:VimMenu
separate_nextcmd	ex_docmd.c	/^separate_nextcmd(eap)$/;"	f
serial	if_xcmdsrv.c	/^    int	    serial;	\/* Serial number expected in result. *\/$/;"	m	struct:PendingCommand	file:
serverArg	main.c	/^    int		serverArg;		\/* TRUE when argument for a server *\/$/;"	m	struct:__anon39	file:
serverChangeRegisteredWindow	if_xcmdsrv.c	/^serverChangeRegisteredWindow(dpy, newwin)$/;"	f
serverConvert	main.c	/^serverConvert(client_enc, data, tofree)$/;"	f
serverDelayedStartName	globals.h	/^EXTERN char_u	*serverDelayedStartName INIT(= NULL);$/;"	v
serverEventProc	if_xcmdsrv.c	/^serverEventProc(dpy, eventPtr)$/;"	f
serverGetVimNames	if_xcmdsrv.c	/^serverGetVimNames(dpy)$/;"	f
serverMakeName	main.c	/^serverMakeName(arg, cmd)$/;"	f	file:
serverName	globals.h	/^EXTERN char_u	*serverName INIT(= NULL);	\/* name of the server *\/$/;"	v
serverName_arg	main.c	/^    char_u	*serverName_arg;	\/* cmdline arg for server name *\/$/;"	m	struct:__anon39	file:
serverPeekReply	if_xcmdsrv.c	/^serverPeekReply(dpy, win, str)$/;"	f
serverReadReply	if_xcmdsrv.c	/^serverReadReply(dpy, win, str, localLoop)$/;"	f
serverRegisterName	if_xcmdsrv.c	/^serverRegisterName(dpy, name)$/;"	f
serverReply	if_xcmdsrv.c	/^static garray_T serverReply = { 0, 0, 0, 0, 0 };$/;"	v	file:
serverSendReply	if_xcmdsrv.c	/^serverSendReply(name, str)$/;"	f
serverSendToVim	if_xcmdsrv.c	/^serverSendToVim(dpy, name, cmd,  result, server, asExpr, localLoop, silent)$/;"	f
serverStr	main.c	/^    char_u	*serverStr;		\/* remote server command *\/$/;"	m	struct:__anon39	file:
serverStrEnc	main.c	/^    char_u	*serverStrEnc;		\/* encoding of serverStr *\/$/;"	m	struct:__anon39	file:
serverStrToWin	if_xcmdsrv.c	/^serverStrToWin(str)$/;"	f
server_to_input_buf	main.c	/^server_to_input_buf(str)$/;"	f
servername	main.c	/^    char_u	*servername;		\/* allocated name for our server *\/$/;"	m	struct:__anon39	file:
ses_arglist	ex_docmd.c	/^ses_arglist(fd, cmd, gap, fullname, flagp)$/;"	f	file:
ses_do_frame	ex_docmd.c	/^ses_do_frame(fr)$/;"	f	file:
ses_do_win	ex_docmd.c	/^ses_do_win(wp)$/;"	f	file:
ses_fname	ex_docmd.c	/^ses_fname(fd, buf, flagp)$/;"	f	file:
ses_put_fname	ex_docmd.c	/^ses_put_fname(fd, name, flagp)$/;"	f	file:
ses_skipframe	ex_docmd.c	/^ses_skipframe(fr)$/;"	f	file:
ses_win_rec	ex_docmd.c	/^ses_win_rec(fd, fr)$/;"	f	file:
ses_winsizes	ex_docmd.c	/^ses_winsizes(fd, restore_size, tab_firstwin)$/;"	f	file:
sesave	regexp.c	/^	save_se_T  sesave;$/;"	m	union:regitem_S::__anon51	file:
setDollarVim	workshop.c	/^setDollarVim($/;"	f	file:
setFoldRepeat	fold.c	/^setFoldRepeat(lnum, count, open)$/;"	f	file:
setManualFold	fold.c	/^setManualFold(lnum, opening, recurse, donep)$/;"	f	file:
setManualFoldWin	fold.c	/^setManualFoldWin(wp, lnum, opening, recurse, donep)$/;"	f	file:
setSmallMaybe	fold.c	/^setSmallMaybe(gap)$/;"	f	file:
set_arglist	ex_cmds2.c	/^set_arglist(str)$/;"	f
set_b0_dir_flag	memline.c	/^set_b0_dir_flag(b0p, buf)$/;"	f	file:
set_b0_fname	memline.c	/^set_b0_fname(b0p, buf)$/;"	f	file:
set_bool_option	option.c	/^set_bool_option(opt_idx, varp, value, opt_flags)$/;"	f	file:
set_buffer_line	if_mzsch.c	/^set_buffer_line(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
set_buffer_line	if_ruby.c	/^static VALUE set_buffer_line(buf_T *buf, linenr_T n, VALUE str)$/;"	f	file:
set_buffer_line_list	if_mzsch.c	/^set_buffer_line_list(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
set_buflisted	buffer.c	/^set_buflisted(on)$/;"	f
set_chars_option	option.c	/^set_chars_option(varp)$/;"	f	file:
set_cmd_context	ex_getln.c	/^set_cmd_context(xp, str, len, col)$/;"	f
set_cmdarg	eval.c	/^set_cmdarg(eap, oldarg)$/;"	f
set_cmdline_pos	ex_getln.c	/^set_cmdline_pos(pos)$/;"	f
set_cmdspos	ex_getln.c	/^set_cmdspos()$/;"	f	file:
set_cmdspos_cursor	ex_getln.c	/^set_cmdspos_cursor()$/;"	f	file:
set_color_count	term.c	/^set_color_count(nr)$/;"	f	file:
set_completion	edit.c	/^set_completion(startcol, list)$/;"	f
set_context_for_expression	eval.c	/^set_context_for_expression(xp, arg, cmdidx)$/;"	f
set_context_in_autocmd	fileio.c	/^set_context_in_autocmd(xp, arg, doautocmd)$/;"	f
set_context_in_echohl_cmd	syntax.c	/^set_context_in_echohl_cmd(xp, arg)$/;"	f
set_context_in_highlight_cmd	syntax.c	/^set_context_in_highlight_cmd(xp, arg)$/;"	f
set_context_in_map_cmd	getchar.c	/^set_context_in_map_cmd(xp, cmd, arg, forceit, isabbrev, isunmap, cmdidx)$/;"	f
set_context_in_menu_cmd	menu.c	/^set_context_in_menu_cmd(xp, cmd, arg, forceit)$/;"	f
set_context_in_set_cmd	option.c	/^set_context_in_set_cmd(xp, arg, opt_flags)$/;"	f
set_context_in_syntax_cmd	syntax.c	/^set_context_in_syntax_cmd(xp, arg)$/;"	f
set_curbuf	buffer.c	/^set_curbuf(buf, action)$/;"	f
set_current_line	if_ruby.c	/^static VALUE set_current_line(VALUE self, VALUE str)$/;"	f	file:
set_cursor	if_mzsch.c	/^set_cursor(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
set_empty_rows	move.c	/^set_empty_rows(wp, used)$/;"	f
set_errorlist	quickfix.c	/^set_errorlist(wp, list, action)$/;"	f
set_expand_context	ex_getln.c	/^set_expand_context(xp)$/;"	f	file:
set_expr_line	ops.c	/^set_expr_line(new_line)$/;"	f
set_file_time	fileio.c	/^set_file_time(fname, atime, mtime)$/;"	f	file:
set_fileformat	misc2.c	/^set_fileformat(t, opt_flags)$/;"	f
set_fontlist	gui_motif.c	/^set_fontlist(id)$/;"	f	file:
set_group_colors	syntax.c	/^set_group_colors(name, fgp, bgp, do_menu, use_norm, do_tooltip)$/;"	f	file:
set_guifontwide	gui.c	/^set_guifontwide(name)$/;"	f	file:
set_helplang_default	option.c	/^set_helplang_default(lang)$/;"	f
set_hl_attr	syntax.c	/^set_hl_attr(idx)$/;"	f	file:
set_iminsert_global	option.c	/^set_iminsert_global()$/;"	f
set_imsearch_global	option.c	/^set_imsearch_global()$/;"	f
set_indent	misc1.c	/^set_indent(size, flags)$/;"	f
set_init_1	option.c	/^set_init_1()$/;"	f
set_init_2	option.c	/^set_init_2()$/;"	f
set_init_3	option.c	/^set_init_3()$/;"	f
set_input_buf	ui.c	/^set_input_buf(p)$/;"	f
set_internal_string_var	eval.c	/^set_internal_string_var(name, value)$/;"	f
set_keep_msg	message.c	/^set_keep_msg(s, attr)$/;"	f
set_keep_msg_from_hist	message.c	/^set_keep_msg_from_hist()$/;"	f
set_label	gui_motif.c	/^set_label(w, label)$/;"	f	file:
set_lang_var	ex_cmds2.c	/^set_lang_var()$/;"	f
set_last_cursor	mark.c	/^set_last_cursor(win)$/;"	f
set_last_insert	edit.c	/^set_last_insert(c)$/;"	f
set_last_search_pat	search.c	/^set_last_search_pat(s, idx, magic, setlast)$/;"	f
set_map_str	spell.c	/^set_map_str(lp, map)$/;"	f	file:
set_mouse_termcode	term.c	/^set_mouse_termcode(n, s)$/;"	f
set_mouse_topline	term.c	/^set_mouse_topline(wp)$/;"	f
set_normal_colors	syntax.c	/^set_normal_colors()$/;"	f
set_num_option	option.c	/^set_num_option(opt_idx, varp, value, errbuf, errbuflen, opt_flags)$/;"	f	file:
set_number_default	option.c	/^set_number_default(name, val)$/;"	f
set_one_cmd_context	ex_docmd.c	/^set_one_cmd_context(xp, buff)$/;"	f
set_op_var	normal.c	/^set_op_var(optype)$/;"	f	file:
set_option	if_mzsch.c	/^set_option(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
set_option_default	option.c	/^set_option_default(opt_idx, opt_flags, compatible)$/;"	f	file:
set_option_scriptID_idx	option.c	/^set_option_scriptID_idx(opt_idx, opt_flags, id)$/;"	f	file:
set_option_value	option.c	/^set_option_value(name, number, string, opt_flags)$/;"	f
set_options_bin	option.c	/^set_options_bin(oldval, newval, opt_flags)$/;"	f
set_options_default	option.c	/^set_options_default(opt_flags)$/;"	f	file:
set_pixmap	gui_xmebw.c	/^set_pixmap(XmEnhancedButtonWidget eb)$/;"	f	file:
set_predefined_fontlist	gui_motif.c	/^set_predefined_fontlist(parent, name)$/;"	f	file:
set_predefined_label	gui_motif.c	/^set_predefined_label(parent, name, new_label)$/;"	f	file:
set_printable_label_text	gui_beval.c	/^set_printable_label_text(GtkLabel *label, char_u *text)$/;"	f	file:
set_qf_ll_list	eval.c	/^set_qf_ll_list(wp, list_arg, action_arg, rettv)$/;"	f	file:
set_ref_in_ht	eval.c	/^set_ref_in_ht(ht, copyID)$/;"	f	file:
set_ref_in_item	eval.c	/^set_ref_in_item(tv, copyID)$/;"	f	file:
set_ref_in_list	eval.c	/^set_ref_in_list(l, copyID)$/;"	f	file:
set_reg_var	eval.c	/^set_reg_var(c)$/;"	f
set_rw_fname	fileio.c	/^set_rw_fname(fname, sfname)$/;"	f	file:
set_sal_first	spell.c	/^set_sal_first(lp)$/;"	f	file:
set_search_direction	search.c	/^set_search_direction(cdir)$/;"	f
set_shellsize	term.c	/^set_shellsize(width, height, mustset)$/;"	f
set_signals	os_unix.c	/^set_signals()$/;"	f	file:
set_size	gui_xmebw.c	/^set_size(XmEnhancedButtonWidget newtb)$/;"	f	file:
set_sofo	spell.c	/^set_sofo(lp, from, to)$/;"	f	file:
set_spell_charflags	spell.c	/^set_spell_charflags(flags, cnt, fol)$/;"	f	file:
set_spell_chartab	spell.c	/^set_spell_chartab(fol, low, upp)$/;"	f	file:
set_spell_finish	spell.c	/^set_spell_finish(new_st)$/;"	f	file:
set_string_default	option.c	/^set_string_default(name, val)$/;"	f
set_string_option	option.c	/^set_string_option(opt_idx, value, opt_flags)$/;"	f	file:
set_string_option_direct	option.c	/^set_string_option_direct(name, opt_idx, val, opt_flags, set_sid)$/;"	f
set_string_option_global	option.c	/^set_string_option_global(opt_idx, varp)$/;"	f	file:
set_term_defaults	option.c	/^set_term_defaults()$/;"	f
set_term_option_alloced	option.c	/^set_term_option_alloced(p)$/;"	f
set_termname	term.c	/^set_termname(term)$/;"	f
set_title_defaults	option.c	/^set_title_defaults()$/;"	f
set_toolbar_style	gui_gtk_x11.c	/^set_toolbar_style(GtkToolbar *toolbar)$/;"	f	file:
set_topline	move.c	/^set_topline(wp, lnum)$/;"	f
set_var	eval.c	/^set_var(name, tv, copy)$/;"	f	file:
set_var_lval	eval.c	/^set_var_lval(lp, endp, rettv, copy, op)$/;"	f	file:
set_vcount	eval.c	/^set_vcount(count, count1)$/;"	f
set_vim_var_nr	eval.c	/^set_vim_var_nr(idx, val)$/;"	f
set_vim_var_string	eval.c	/^set_vim_var_string(idx, val, len)$/;"	f
set_vv_searchforward	search.c	/^set_vv_searchforward()$/;"	f	file:
set_window_height	if_mzsch.c	/^set_window_height(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
set_window_width	if_mzsch.c	/^set_window_width(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
set_x11_icon	os_unix.c	/^set_x11_icon(icon)$/;"	f	file:
set_x11_title	os_unix.c	/^set_x11_title(title)$/;"	f	file:
setaltfname	buffer.c	/^setaltfname(ffname, sfname, lnum)$/;"	f
setcursor	screen.c	/^setcursor()$/;"	f
setfname	buffer.c	/^setfname(buf, ffname, sfname, message)$/;"	f
setmark	mark.c	/^setmark(c)$/;"	f
setmark_pos	mark.c	/^setmark_pos(c, pos, fnum)$/;"	f
setmouse	term.c	/^setmouse()$/;"	f
setpcmark	mark.c	/^setpcmark()$/;"	f
settmode	term.c	/^settmode(tmode)$/;"	f
setup_save_yourself	gui_gtk_x11.c	/^setup_save_yourself(void)$/;"	f	file:
setup_term_clip	os_unix.c	/^setup_term_clip()$/;"	f
setup_timer	if_mzsch.c	/^setup_timer(void)$/;"	f	file:
setup_zero_width_cluster	gui_gtk_x11.c	/^setup_zero_width_cluster(PangoItem *item, PangoGlyphInfo *glyph,$/;"	f	file:
setwinvar	eval.c	/^setwinvar(argvars, rettv, off)$/;"	f	file:
sfdcnewvim	if_perlsfio.c	/^sfdcnewvim()$/;"	f
sfname	fileio.c	/^    char_u	*sfname;	\/* sfname to match with *\/$/;"	m	struct:AutoPatCmd	file:
sft_score	spell.c	/^    short	sft_score;	\/* lowest score used *\/$/;"	m	struct:__anon56	file:
sft_word	spell.c	/^    char_u	sft_word[1];    \/* soundfolded word, actually longer *\/$/;"	m	struct:__anon56	file:
sftword_T	spell.c	/^} sftword_T;$/;"	t	typeref:struct:__anon56	file:
sfvimwrite	if_perlsfio.c	/^sfvimwrite(f, buf, n, disc)$/;"	f	file:
sg_cterm	syntax.c	/^    int		sg_cterm;	\/* "cterm=" highlighting attr *\/$/;"	m	struct:hl_group	file:
sg_cterm_attr	syntax.c	/^    int		sg_cterm_attr;	\/* Screen attr for color term mode *\/$/;"	m	struct:hl_group	file:
sg_cterm_bg	syntax.c	/^    int		sg_cterm_bg;	\/* terminal bg color number + 1 *\/$/;"	m	struct:hl_group	file:
sg_cterm_bold	syntax.c	/^    int		sg_cterm_bold;	\/* bold attr was set for light color *\/$/;"	m	struct:hl_group	file:
sg_cterm_fg	syntax.c	/^    int		sg_cterm_fg;	\/* terminal fg color number + 1 *\/$/;"	m	struct:hl_group	file:
sg_font	syntax.c	/^    GuiFont	sg_font;	\/* GUI font handle *\/$/;"	m	struct:hl_group	file:
sg_font_name	syntax.c	/^    char_u	*sg_font_name;  \/* GUI font or fontset name *\/$/;"	m	struct:hl_group	file:
sg_fontset	syntax.c	/^    GuiFontset	sg_fontset;	\/* GUI fontset handle *\/$/;"	m	struct:hl_group	file:
sg_gui	syntax.c	/^    int		sg_gui;		\/* "gui=" highlighting attributes *\/$/;"	m	struct:hl_group	file:
sg_gui_attr	syntax.c	/^    int		sg_gui_attr;    \/* Screen attr for GUI mode *\/$/;"	m	struct:hl_group	file:
sg_gui_bg	syntax.c	/^    guicolor_T	sg_gui_bg;	\/* GUI background color handle *\/$/;"	m	struct:hl_group	file:
sg_gui_bg_name	syntax.c	/^    char_u	*sg_gui_bg_name;\/* GUI background color name *\/$/;"	m	struct:hl_group	file:
sg_gui_fg	syntax.c	/^    guicolor_T	sg_gui_fg;	\/* GUI foreground color handle *\/$/;"	m	struct:hl_group	file:
sg_gui_fg_name	syntax.c	/^    char_u	*sg_gui_fg_name;\/* GUI foreground color name *\/$/;"	m	struct:hl_group	file:
sg_gui_sp	syntax.c	/^    guicolor_T	sg_gui_sp;	\/* GUI special color handle *\/$/;"	m	struct:hl_group	file:
sg_gui_sp_name	syntax.c	/^    char_u	*sg_gui_sp_name;\/* GUI special color name *\/$/;"	m	struct:hl_group	file:
sg_link	syntax.c	/^    int		sg_link;	\/* link to this highlight group ID *\/$/;"	m	struct:hl_group	file:
sg_name	syntax.c	/^    char_u	*sg_name;	\/* highlight group name *\/$/;"	m	struct:hl_group	file:
sg_name_u	syntax.c	/^    char_u	*sg_name_u;	\/* uppercase of sg_name *\/$/;"	m	struct:hl_group	file:
sg_scriptID	syntax.c	/^    scid_T	sg_scriptID;	\/* script in which the group was last set *\/$/;"	m	struct:hl_group	file:
sg_set	syntax.c	/^    int		sg_set;		\/* combination of SG_* flags *\/$/;"	m	struct:hl_group	file:
sg_start	syntax.c	/^    char_u	*sg_start;	\/* terminal string for start highl *\/$/;"	m	struct:hl_group	file:
sg_stop	syntax.c	/^    char_u	*sg_stop;	\/* terminal string for stop highl *\/$/;"	m	struct:hl_group	file:
sg_term	syntax.c	/^    int		sg_term;	\/* "term=" highlighting attributes *\/$/;"	m	struct:hl_group	file:
sg_term_attr	syntax.c	/^    int		sg_term_attr;	\/* Screen attr for term mode *\/$/;"	m	struct:hl_group	file:
shadow_width	gui_at_sb.h	/^    Dimension	shadow_width;$/;"	m	struct:__anon64
shape	structs.h	/^    int		shape;		\/* one of the SHAPE_ defines *\/$/;"	m	struct:cursor_entry
shape_table	misc2.c	/^cursorentry_T shape_table[SHAPE_IDX_COUNT] =$/;"	v
shellRectangle	gui_x11.c	/^shellRectangle(Widget shell, XRectangle *r)$/;"	f	file:
shell_created	gui.h	/^    int		shell_created;	    \/* Has the shell been created yet? *\/$/;"	m	struct:Gui
shell_new_columns	window.c	/^shell_new_columns()$/;"	f
shell_new_rows	window.c	/^shell_new_rows()$/;"	f
shell_resized	term.c	/^shell_resized()$/;"	f
shell_resized_check	term.c	/^shell_resized_check()$/;"	f
shift_block	ops.c	/^shift_block(oap, amount)$/;"	f	file:
shift_line	ops.c	/^shift_line(left, round, amount, call_changed_bytes)$/;"	f
short_u	structs.h	/^typedef unsigned short	short_u;$/;"	t
short_u	vim.h	/^typedef unsigned short	short_u;$/;"	t
shorten_dir	misc1.c	/^shorten_dir(str)$/;"	f
shorten_filenames	fileio.c	/^shorten_filenames(fnames, count)$/;"	f
shorten_fname	fileio.c	/^shorten_fname(full_path, dir_name)$/;"	f
shorten_fname1	fileio.c	/^shorten_fname1(full_path)$/;"	f
shorten_fnames	fileio.c	/^shorten_fnames(force)$/;"	f
shortmess	option.c	/^shortmess(x)$/;"	f
shortname	option.c	/^    char	*shortname;	\/* permissible abbreviation *\/$/;"	m	struct:vimoption	file:
shortpath_for_invalid_fname	eval.c	/^shortpath_for_invalid_fname(fname, bufp, fnamelen)$/;"	f	file:
shortpath_for_partial	eval.c	/^shortpath_for_partial(fnamep, bufp, fnamelen)$/;"	f	file:
should_abort	ex_eval.c	/^should_abort(retcode)$/;"	f
showState	gui_beval.h	/^    BeState		showState;	\/* tells us whats currently going on *\/$/;"	m	struct:BalloonEvalStruct
show_autocmd	fileio.c	/^show_autocmd(ap, event)$/;"	f	file:
show_menus	menu.c	/^show_menus(path_name, modes)$/;"	f	file:
show_menus_recursive	menu.c	/^show_menus_recursive(menu, modes, depth)$/;"	f	file:
show_one_mark	mark.c	/^show_one_mark(c, arg, p, name, current)$/;"	f	file:
show_one_termcode	term.c	/^show_one_termcode(name, code, printit)$/;"	f
show_pat_in_path	search.c	/^show_pat_in_path(line, type, did_show, action, fp, lnum, count)$/;"	f	file:
show_sb_text	message.c	/^show_sb_text()$/;"	f
show_shell_mess	os_unix.c	/^static int	show_shell_mess = TRUE;$/;"	v	file:
show_termcodes	term.c	/^show_termcodes()$/;"	f
show_utf8	mbyte.c	/^show_utf8()$/;"	f
showcmd_buf	normal.c	/^static char_u	showcmd_buf[SHOWCMD_BUFLEN];$/;"	v	file:
showcmd_is_clear	normal.c	/^static int	showcmd_is_clear = TRUE;$/;"	v	file:
showcmd_visual	normal.c	/^static int	showcmd_visual = FALSE;$/;"	v	file:
showing_tabline	gui_gtk_x11.c	/^static int showing_tabline = 0;$/;"	v	file:
showing_tabline	gui_motif.c	/^static int	showing_tabline = 0;$/;"	v	file:
showmap	getchar.c	/^showmap(mp, local)$/;"	f	file:
showmatch	search.c	/^showmatch(c)$/;"	f
showmatches	ex_getln.c	/^showmatches(xp, wildmenu)$/;"	f	file:
showmode	screen.c	/^showmode()$/;"	f
shown	gui_at_fs.c	/^    char	*shown;$/;"	m	struct:__anon13	file:
shown	gui_at_sb.h	/^    float	  shown;	\/* What percent is shown in the win *\/$/;"	m	struct:__anon64
shownLength	gui_at_sb.h	/^    Dimension	  shownLength;	\/* Num pixels corresponding to shown *\/$/;"	m	struct:__anon64
showoneopt	option.c	/^showoneopt(p, opt_flags)$/;"	f	file:
showoptions	option.c	/^showoptions(all, opt_flags)$/;"	f	file:
showruler	screen.c	/^showruler(always)$/;"	f
shutdown	os_unix.c	/^    Bool shutdown;	    \/* If we're in shutdown mode *\/$/;"	m	struct:__anon46	file:
si_add	spell.c	/^    int		si_add;		\/* addition file *\/$/;"	m	struct:spellinfo_S	file:
si_ascii	spell.c	/^    int		si_ascii;	\/* handling only ASCII words *\/$/;"	m	struct:spellinfo_S	file:
si_attr	syntax.c	/^    int		si_attr;		\/* attributes in this state *\/$/;"	m	struct:state_item	file:
si_blocks	spell.c	/^    sblock_T	*si_blocks;	\/* memory blocks used *\/$/;"	m	struct:spellinfo_S	file:
si_blocks_cnt	spell.c	/^    long	si_blocks_cnt;	\/* memory blocks allocated *\/$/;"	m	struct:spellinfo_S	file:
si_clear_chartab	spell.c	/^    int		si_clear_chartab;   \/* when TRUE clear char tables *\/$/;"	m	struct:spellinfo_S	file:
si_collapse	spell.c	/^    int		si_collapse;	\/* soundsalike: ? *\/$/;"	m	struct:spellinfo_S	file:
si_commonwords	spell.c	/^    hashtab_T	si_commonwords;	\/* hashtable for common words *\/$/;"	m	struct:spellinfo_S	file:
si_compflags	spell.c	/^    char_u	*si_compflags;	\/* flags used for compounding *\/$/;"	m	struct:spellinfo_S	file:
si_compmax	spell.c	/^    int		si_compmax;	\/* max nr of words for compounding *\/$/;"	m	struct:spellinfo_S	file:
si_compminlen	spell.c	/^    int		si_compminlen;	\/* minimal length for compounding *\/$/;"	m	struct:spellinfo_S	file:
si_compoptions	spell.c	/^    int		si_compoptions;	\/* COMP_ flags *\/$/;"	m	struct:spellinfo_S	file:
si_comppat	spell.c	/^    garray_T	si_comppat;	\/* CHECKCOMPOUNDPATTERN items, each stored as$/;"	m	struct:spellinfo_S	file:
si_compress_cnt	spell.c	/^    long	si_compress_cnt;    \/* words to add before lowering$/;"	m	struct:spellinfo_S	file:
si_compsylmax	spell.c	/^    int		si_compsylmax;	\/* max nr of syllables for compounding *\/$/;"	m	struct:spellinfo_S	file:
si_cont_list	syntax.c	/^    short	*si_cont_list;		\/* list of contained groups *\/$/;"	m	struct:state_item	file:
si_conv	spell.c	/^    vimconv_T	si_conv;	\/* for conversion to 'encoding' *\/$/;"	m	struct:spellinfo_S	file:
si_end_idx	syntax.c	/^    int		si_end_idx;		\/* group ID for end pattern or zero *\/$/;"	m	struct:state_item	file:
si_ends	syntax.c	/^    int		si_ends;		\/* if match ends before si_m_endpos *\/$/;"	m	struct:state_item	file:
si_eoe_pos	syntax.c	/^    lpos_T	si_eoe_pos;		\/* end position of end pattern *\/$/;"	m	struct:state_item	file:
si_extmatch	syntax.c	/^    reg_extmatch_T *si_extmatch;	\/* \\z(...\\) matches from start$/;"	m	struct:state_item	file:
si_first_free	spell.c	/^    wordnode_T	*si_first_free; \/* List of nodes that have been freed during$/;"	m	struct:spellinfo_S	file:
si_flags	syntax.c	/^    long	si_flags;		\/* HL_HAS_EOL flag in this state, and$/;"	m	struct:state_item	file:
si_foldroot	spell.c	/^    wordnode_T	*si_foldroot;	\/* tree with case-folded words *\/$/;"	m	struct:spellinfo_S	file:
si_foldwcount	spell.c	/^    long	si_foldwcount;	\/* nr of words in si_foldroot *\/$/;"	m	struct:spellinfo_S	file:
si_followup	spell.c	/^    int		si_followup;	\/* soundsalike: ? *\/$/;"	m	struct:spellinfo_S	file:
si_free_count	spell.c	/^    long	si_free_count;	\/* number of nodes in si_first_free *\/$/;"	m	struct:spellinfo_S	file:
si_h_endpos	syntax.c	/^    lpos_T	si_h_endpos;		\/* end position of the highlighting *\/$/;"	m	struct:state_item	file:
si_h_startpos	syntax.c	/^    lpos_T	si_h_startpos;		\/* start position of the highlighting *\/$/;"	m	struct:state_item	file:
si_id	syntax.c	/^    int		si_id;			\/* highlight group ID for keywords *\/$/;"	m	struct:state_item	file:
si_idx	syntax.c	/^    int		si_idx;			\/* index of syntax pattern or$/;"	m	struct:state_item	file:
si_info	spell.c	/^    char_u	*si_info;	\/* info text chars or NULL  *\/$/;"	m	struct:spellinfo_S	file:
si_keeproot	spell.c	/^    wordnode_T	*si_keeproot;	\/* tree with keep-case words *\/$/;"	m	struct:spellinfo_S	file:
si_keepwcount	spell.c	/^    long	si_keepwcount;	\/* nr of words in si_keeproot *\/$/;"	m	struct:spellinfo_S	file:
si_m_endpos	syntax.c	/^    lpos_T	si_m_endpos;		\/* just after end posn of the match *\/$/;"	m	struct:state_item	file:
si_m_lnum	syntax.c	/^    int		si_m_lnum;		\/* lnum of the match *\/$/;"	m	struct:state_item	file:
si_m_startcol	syntax.c	/^    int		si_m_startcol;		\/* starting column of the match *\/$/;"	m	struct:state_item	file:
si_map	spell.c	/^    garray_T	si_map;		\/* MAP info concatenated *\/$/;"	m	struct:spellinfo_S	file:
si_memtot	spell.c	/^    int		si_memtot;	\/* runtime memory used *\/$/;"	m	struct:spellinfo_S	file:
si_midword	spell.c	/^    char_u	*si_midword;	\/* MIDWORD chars or NULL  *\/$/;"	m	struct:spellinfo_S	file:
si_msg_count	spell.c	/^    int		si_msg_count;	\/* number of words added since last message *\/$/;"	m	struct:spellinfo_S	file:
si_newcompID	spell.c	/^    int		si_newcompID;	\/* current value for compound ID *\/$/;"	m	struct:spellinfo_S	file:
si_newprefID	spell.c	/^    int		si_newprefID;	\/* current value for ah_newID *\/$/;"	m	struct:spellinfo_S	file:
si_next_list	syntax.c	/^    short	*si_next_list;		\/* nextgroup IDs after this item ends *\/$/;"	m	struct:state_item	file:
si_nobreak	spell.c	/^    char_u	si_nobreak;	\/* NOBREAK *\/$/;"	m	struct:spellinfo_S	file:
si_nosplitsugs	spell.c	/^    int		si_nosplitsugs;	\/* NOSPLITSUGS item found *\/$/;"	m	struct:spellinfo_S	file:
si_nosugfile	spell.c	/^    int		si_nosugfile;	\/* NOSUGFILE item found *\/$/;"	m	struct:spellinfo_S	file:
si_prefcond	spell.c	/^    garray_T	si_prefcond;	\/* table with conditions for postponed$/;"	m	struct:spellinfo_S	file:
si_prefroot	spell.c	/^    wordnode_T	*si_prefroot;	\/* tree with postponed prefixes *\/$/;"	m	struct:spellinfo_S	file:
si_region	spell.c	/^    int		si_region;	\/* region mask *\/$/;"	m	struct:spellinfo_S	file:
si_region_count	spell.c	/^    int		si_region_count; \/* number of regions supported (1 when there$/;"	m	struct:spellinfo_S	file:
si_region_name	spell.c	/^    char_u	si_region_name[16]; \/* region names; used only if$/;"	m	struct:spellinfo_S	file:
si_rem_accents	spell.c	/^    int		si_rem_accents;	\/* soundsalike: remove accents *\/$/;"	m	struct:spellinfo_S	file:
si_rep	spell.c	/^    garray_T	si_rep;		\/* list of fromto_T entries from REP lines *\/$/;"	m	struct:spellinfo_S	file:
si_repsal	spell.c	/^    garray_T	si_repsal;	\/* list of fromto_T entries from REPSAL lines *\/$/;"	m	struct:spellinfo_S	file:
si_sal	spell.c	/^    garray_T	si_sal;		\/* list of fromto_T entries from SAL lines *\/$/;"	m	struct:spellinfo_S	file:
si_sofofr	spell.c	/^    char_u	*si_sofofr;	\/* SOFOFROM text *\/$/;"	m	struct:spellinfo_S	file:
si_sofoto	spell.c	/^    char_u	*si_sofoto;	\/* SOFOTO text *\/$/;"	m	struct:spellinfo_S	file:
si_spellbuf	spell.c	/^    buf_T	*si_spellbuf;	\/* buffer used to store soundfold word table *\/$/;"	m	struct:spellinfo_S	file:
si_sugtime	spell.c	/^    time_t	si_sugtime;	\/* timestamp for .sug file *\/$/;"	m	struct:spellinfo_S	file:
si_sugtree	spell.c	/^    long	si_sugtree;	\/* creating the soundfolding trie *\/$/;"	m	struct:spellinfo_S	file:
si_syllable	spell.c	/^    char_u	*si_syllable;	\/* syllable string *\/$/;"	m	struct:spellinfo_S	file:
si_trans_id	syntax.c	/^    int		si_trans_id;		\/* idem, transparancy removed *\/$/;"	m	struct:state_item	file:
si_verbose	spell.c	/^    int		si_verbose;	\/* verbose messages *\/$/;"	m	struct:spellinfo_S	file:
si_wordnode_nr	spell.c	/^    int		si_wordnode_nr;	\/* sequence nr for nodes *\/$/;"	m	struct:spellinfo_S	file:
sig	os_unix.c	/^    int	    sig;	\/* Signal number, eg. SIGSEGV etc *\/$/;"	m	struct:signalinfo	file:
sig_alarm_called	os_unix.c	/^static int sig_alarm_called;$/;"	v	file:
sigcont_received	os_unix.c	/^static int sigcont_received;$/;"	v	file:
sign	ex_cmds.c	/^struct sign$/;"	s	file:
sign_T	ex_cmds.c	/^typedef struct sign sign_T;$/;"	t	typeref:struct:sign	file:
sign_get_attr	ex_cmds.c	/^sign_get_attr(typenr, line)$/;"	f
sign_get_image	ex_cmds.c	/^sign_get_image(typenr)$/;"	f
sign_get_text	ex_cmds.c	/^sign_get_text(typenr)$/;"	f
sign_gui_started	ex_cmds.c	/^sign_gui_started()$/;"	f
sign_list_defined	ex_cmds.c	/^sign_list_defined(sp)$/;"	f	file:
sign_list_placed	buffer.c	/^sign_list_placed(rbuf)$/;"	f
sign_mark_adjust	buffer.c	/^sign_mark_adjust(line1, line2, amount, amount_after)$/;"	f
sign_typenr2name	ex_cmds.c	/^sign_typenr2name(typenr)$/;"	f
signal	os_unixx.h	/^# define signal /;"	d
signal_info	os_unix.c	/^} signal_info[] =$/;"	v	typeref:struct:signalinfo	file:
signal_stack	os_unix.c	/^static char *signal_stack;$/;"	v	file:
signalinfo	os_unix.c	/^static struct signalinfo$/;"	s	file:
signicon_T	gui_gtk_x11.c	/^signicon_T;$/;"	t	typeref:struct:__anon19	file:
signlist	structs.h	/^struct signlist$/;"	s
signlist_T	structs.h	/^typedef struct signlist signlist_T;$/;"	t	typeref:struct:signlist
signmap	netbeans.c	/^    int			*signmap;$/;"	m	struct:nbbuf_struct	file:
signmaplen	netbeans.c	/^    short_u		 signmaplen;$/;"	m	struct:nbbuf_struct	file:
signmapused	netbeans.c	/^    short_u		 signmapused;$/;"	m	struct:nbbuf_struct	file:
sigstk	os_unix.c	/^static stack_t sigstk;			\/* for sigaltstack() *\/$/;"	v	file:
sigstk	os_unix.c	/^static struct sigstack sigstk;		\/* for sigstack() *\/$/;"	v	typeref:struct:sigstack	file:
silent	structs.h	/^    char	silent[MENU_MODES]; \/* A silent flag for each mode *\/$/;"	m	struct:VimMenu
silent_mode	globals.h	/^EXTERN int	silent_mode INIT(= FALSE);$/;"	v
similar_chars	spell.c	/^similar_chars(slang, c1, c2)$/;"	f	file:
simple	gui_at_sb.h	/^    SimplePart		simple;$/;"	m	struct:_ScrollbarRec
simple_class	gui_at_sb.h	/^    SimpleClassPart		simple_class;$/;"	m	struct:_ScrollbarClassRec
simplify_filename	tag.c	/^simplify_filename(filename)$/;"	f
simplify_key	misc2.c	/^simplify_key(key, modifiers)$/;"	f
single_input	if_python.c	/^#define single_input	/;"	d	file:
size	gui.h	/^    long	size;		\/* Size of scrollbar thumb *\/$/;"	m	struct:GuiScrollbar
size_callback	gui_xmdlg.c	/^size_callback(Widget w,$/;"	f	file:
size_part	gui_xmdlg.c	/^size_part(char *font, char *buf, int inPixels)$/;"	f	file:
skip	ex_cmds.h	/^    int		skip;		\/* don't execute the command, only parse it *\/$/;"	m	struct:exarg
skip_anyof	regexp.c	/^skip_anyof(p)$/;"	f	file:
skip_chars	search.c	/^skip_chars(cclass, dir)$/;"	f	file:
skip_cmd_arg	ex_docmd.c	/^skip_cmd_arg(p, rembs)$/;"	f	file:
skip_expr	eval.c	/^skip_expr(pp)$/;"	f
skip_grep_pat	ex_docmd.c	/^skip_grep_pat(eap)$/;"	f	file:
skip_label	misc1.c	/^skip_label(lnum, pp, ind_maxcomment)$/;"	f	file:
skip_range	ex_docmd.c	/^skip_range(cmd, ctx)$/;"	f
skip_redraw	globals.h	/^EXTERN int	skip_redraw INIT(= FALSE);  \/* skip redraw once *\/$/;"	v
skip_regexp	regexp.c	/^skip_regexp(startp, dirc, magic, newp)$/;"	f
skip_status_match_char	screen.c	/^skip_status_match_char(xp, s)$/;"	f	file:
skip_string	misc1.c	/^skip_string(p)$/;"	f	file:
skip_to_option_part	misc1.c	/^skip_to_option_part(p)$/;"	f
skip_var_list	eval.c	/^skip_var_list(arg, var_count, semicolon)$/;"	f	file:
skip_var_one	eval.c	/^skip_var_one(arg)$/;"	f	file:
skip_vimgrep_pat	quickfix.c	/^skip_vimgrep_pat(p, s, flags)$/;"	f
skipchr	regexp.c	/^skipchr()$/;"	f	file:
skipchr_keepstart	regexp.c	/^skipchr_keepstart()$/;"	f	file:
skipdigits	charset.c	/^skipdigits(q)$/;"	f
skiphex	charset.c	/^skiphex(q)$/;"	f
skiptodigit	charset.c	/^skiptodigit(q)$/;"	f
skiptohex	charset.c	/^skiptohex(q)$/;"	f
skiptowhite	charset.c	/^skiptowhite(p)$/;"	f
skiptowhite_esc	charset.c	/^skiptowhite_esc(p)$/;"	f
skipwhite	charset.c	/^skipwhite(q)$/;"	f
sl_add	spell.c	/^    int		sl_add;		\/* TRUE if it's a .add file. *\/$/;"	m	struct:slang_S	file:
sl_collapse	spell.c	/^    int		sl_collapse;	\/* SAL collapse_result *\/$/;"	m	struct:slang_S	file:
sl_compallflags	spell.c	/^    char_u	*sl_compallflags; \/* all flags for compound words *\/$/;"	m	struct:slang_S	file:
sl_compmax	spell.c	/^    int		sl_compmax;	\/* COMPOUNDWORDMAX (default: MAXWLEN) *\/$/;"	m	struct:slang_S	file:
sl_compminlen	spell.c	/^    int		sl_compminlen;	\/* COMPOUNDMIN (default: 0) *\/$/;"	m	struct:slang_S	file:
sl_compoptions	spell.c	/^    int		sl_compoptions;	\/* COMP_* flags *\/$/;"	m	struct:slang_S	file:
sl_comppat	spell.c	/^    garray_T	sl_comppat;	\/* CHECKCOMPOUNDPATTERN items *\/$/;"	m	struct:slang_S	file:
sl_compprog	spell.c	/^    regprog_T	*sl_compprog;	\/* COMPOUNDRULE turned into a regexp progrm$/;"	m	struct:slang_S	file:
sl_compstartflags	spell.c	/^    char_u	*sl_compstartflags; \/* flags for first compound word *\/$/;"	m	struct:slang_S	file:
sl_compsylmax	spell.c	/^    int		sl_compsylmax;	\/* COMPOUNDSYLMAX (default: MAXWLEN) *\/$/;"	m	struct:slang_S	file:
sl_fbyts	spell.c	/^    char_u	*sl_fbyts;	\/* case-folded word bytes *\/$/;"	m	struct:slang_S	file:
sl_fidxs	spell.c	/^    idx_T	*sl_fidxs;	\/* case-folded word indexes *\/$/;"	m	struct:slang_S	file:
sl_fname	spell.c	/^    char_u	*sl_fname;	\/* name of .spl file *\/$/;"	m	struct:slang_S	file:
sl_followup	spell.c	/^    int		sl_followup;	\/* SAL followup *\/$/;"	m	struct:slang_S	file:
sl_has_map	spell.c	/^    int		sl_has_map;	\/* TRUE if there is a MAP line *\/$/;"	m	struct:slang_S	file:
sl_info	spell.c	/^    char_u	*sl_info;	\/* infotext string or NULL *\/$/;"	m	struct:slang_S	file:
sl_kbyts	spell.c	/^    char_u	*sl_kbyts;	\/* keep-case word bytes *\/$/;"	m	struct:slang_S	file:
sl_kidxs	spell.c	/^    idx_T	*sl_kidxs;	\/* keep-case word indexes *\/$/;"	m	struct:slang_S	file:
sl_lang	spell.c	/^    char_u  sl_lang[MAXWLEN + 1];	\/* language name *\/$/;"	m	struct:spelload_S	file:
sl_map_array	spell.c	/^    char_u	sl_map_array[256]; \/* MAP for first 256 chars *\/$/;"	m	struct:slang_S	file:
sl_map_array	spell.c	/^    int		sl_map_array[256]; \/* MAP for first 256 chars *\/$/;"	m	struct:slang_S	file:
sl_map_hash	spell.c	/^    hashtab_T	sl_map_hash;	\/* MAP for multi-byte chars *\/$/;"	m	struct:slang_S	file:
sl_midword	spell.c	/^    char_u	*sl_midword;	\/* MIDWORD string or NULL *\/$/;"	m	struct:slang_S	file:
sl_name	spell.c	/^    char_u	*sl_name;	\/* language name "en", "en.rare", "nl", etc. *\/$/;"	m	struct:slang_S	file:
sl_next	spell.c	/^    slang_T	*sl_next;	\/* next language *\/$/;"	m	struct:slang_S	file:
sl_nobreak	spell.c	/^    char_u	sl_nobreak;	\/* When TRUE: no spaces between words *\/$/;"	m	struct:slang_S	file:
sl_nobreak	spell.c	/^    int	    sl_nobreak;			\/* NOBREAK language found *\/$/;"	m	struct:spelload_S	file:
sl_nosplitsugs	spell.c	/^    int		sl_nosplitsugs;	\/* don't suggest splitting a word *\/$/;"	m	struct:slang_S	file:
sl_pbyts	spell.c	/^    char_u	*sl_pbyts;	\/* prefix tree word bytes *\/$/;"	m	struct:slang_S	file:
sl_pidxs	spell.c	/^    idx_T	*sl_pidxs;	\/* prefix tree word indexes *\/$/;"	m	struct:slang_S	file:
sl_prefixcnt	spell.c	/^    int		sl_prefixcnt;	\/* number of items in "sl_prefprog" *\/$/;"	m	struct:slang_S	file:
sl_prefprog	spell.c	/^    regprog_T	**sl_prefprog;	\/* table with regprogs for prefixes *\/$/;"	m	struct:slang_S	file:
sl_regions	spell.c	/^    char_u	sl_regions[17];	\/* table with up to 8 region names plus NUL *\/$/;"	m	struct:slang_S	file:
sl_rem_accents	spell.c	/^    int		sl_rem_accents;	\/* SAL remove_accents *\/$/;"	m	struct:slang_S	file:
sl_rep	spell.c	/^    garray_T	sl_rep;		\/* list of fromto_T entries from REP lines *\/$/;"	m	struct:slang_S	file:
sl_rep_first	spell.c	/^    short	sl_rep_first[256];  \/* indexes where byte first appears, -1 if$/;"	m	struct:slang_S	file:
sl_repsal	spell.c	/^    garray_T	sl_repsal;	\/* list of fromto_T entries from REPSAL lines *\/$/;"	m	struct:slang_S	file:
sl_repsal_first	spell.c	/^    short	sl_repsal_first[256];  \/* sl_rep_first for REPSAL lines *\/$/;"	m	struct:slang_S	file:
sl_sal	spell.c	/^    garray_T	sl_sal;		\/* list of salitem_T entries from SAL lines *\/$/;"	m	struct:slang_S	file:
sl_sal_first	spell.c	/^    salfirst_T	sl_sal_first[256];  \/* indexes where byte first appears, -1 if$/;"	m	struct:slang_S	file:
sl_sbyts	spell.c	/^    char_u	*sl_sbyts;	\/* soundfolded word bytes *\/$/;"	m	struct:slang_S	file:
sl_sidxs	spell.c	/^    idx_T	*sl_sidxs;	\/* soundfolded word indexes *\/$/;"	m	struct:slang_S	file:
sl_slang	spell.c	/^    slang_T *sl_slang;			\/* resulting slang_T struct *\/$/;"	m	struct:spelload_S	file:
sl_sofo	spell.c	/^    int		sl_sofo;	\/* SOFOFROM and SOFOTO instead of SAL items:$/;"	m	struct:slang_S	file:
sl_sounddone	spell.c	/^    hashtab_T	sl_sounddone;	\/* table with soundfolded words that have$/;"	m	struct:slang_S	file:
sl_sugbuf	spell.c	/^    buf_T	*sl_sugbuf;	\/* buffer with word number table *\/$/;"	m	struct:slang_S	file:
sl_sugloaded	spell.c	/^    int		sl_sugloaded;	\/* TRUE when .sug file was loaded or failed to$/;"	m	struct:slang_S	file:
sl_sugtime	spell.c	/^    time_t	sl_sugtime;	\/* timestamp for .sug file *\/$/;"	m	struct:slang_S	file:
sl_syl_items	spell.c	/^    garray_T	sl_syl_items;	\/* syllable items *\/$/;"	m	struct:slang_S	file:
sl_syllable	spell.c	/^    char_u	*sl_syllable;	\/* SYLLABLE repeatable chars or NULL *\/$/;"	m	struct:slang_S	file:
sl_wordcount	spell.c	/^    hashtab_T	sl_wordcount;	\/* hashtable with word count, wordcount_T *\/$/;"	m	struct:slang_S	file:
slang_S	spell.c	/^struct slang_S$/;"	s	file:
slang_T	spell.c	/^typedef struct slang_S slang_T;$/;"	t	typeref:struct:slang_S	file:
slang_alloc	spell.c	/^slang_alloc(lang)$/;"	f	file:
slang_clear	spell.c	/^slang_clear(lp)$/;"	f	file:
slang_clear_sug	spell.c	/^slang_clear_sug(lp)$/;"	f	file:
slang_free	spell.c	/^slang_free(lp)$/;"	f	file:
slash_adjust	os_unix.c	/^slash_adjust(p)$/;"	f
sleep	netbeans.c	/^# define sleep(/;"	d	file:
sm_client_check_changed_any	gui_gtk_x11.c	/^sm_client_check_changed_any(GnomeClient	    *client,$/;"	f	file:
sm_client_die	gui_gtk_x11.c	/^sm_client_die(GnomeClient *client, gpointer data)$/;"	f	file:
sm_client_save_yourself	gui_gtk_x11.c	/^sm_client_save_yourself(GnomeClient	    *client,$/;"	f	file:
sm_gettail	ex_getln.c	/^sm_gettail(s)$/;"	f
sm_lead	spell.c	/^    char_u	*sm_lead;	\/* leading letters *\/$/;"	m	struct:salitem_S	file:
sm_lead_w	spell.c	/^    int		*sm_lead_w;	\/* wide character copy of "sm_lead" *\/$/;"	m	struct:salitem_S	file:
sm_leadlen	spell.c	/^    int		sm_leadlen;	\/* length of "sm_lead" *\/$/;"	m	struct:salitem_S	file:
sm_oneof	spell.c	/^    char_u	*sm_oneof;	\/* letters from () or NULL *\/$/;"	m	struct:salitem_S	file:
sm_oneof_w	spell.c	/^    int		*sm_oneof_w;	\/* wide character copy of "sm_oneof" *\/$/;"	m	struct:salitem_S	file:
sm_rules	spell.c	/^    char_u	*sm_rules;	\/* rules like ^, $, priority *\/$/;"	m	struct:salitem_S	file:
sm_to	spell.c	/^    char_u	*sm_to;		\/* replacement. *\/$/;"	m	struct:salitem_S	file:
sm_to_w	spell.c	/^    int		*sm_to_w;	\/* wide character copy of "sm_to" *\/$/;"	m	struct:salitem_S	file:
smcconn	os_unix.c	/^    SmcConn smcconn;	    \/* The SM connection ID *\/$/;"	m	struct:__anon46	file:
smsg	message.c	/^smsg(char_u *s, ...)$/;"	f
smsg	message.c	/^smsg(s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)$/;"	f
smsg_attr	message.c	/^smsg_attr(attr, s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)$/;"	f
smsg_attr	message.c	/^smsg_attr(int attr, char_u *s, ...)$/;"	f
sn_dev	ex_cmds2.c	/^    int		sn_dev;$/;"	m	struct:scriptitem_S	file:
sn_icon	ex_cmds.c	/^    char_u	*sn_icon;	\/* name of pixmap *\/$/;"	m	struct:sign	file:
sn_image	ex_cmds.c	/^    void	*sn_image;	\/* icon image *\/$/;"	m	struct:sign	file:
sn_ino	ex_cmds2.c	/^    ino_t	sn_ino;$/;"	m	struct:scriptitem_S	file:
sn_line_hl	ex_cmds.c	/^    int		sn_line_hl;	\/* highlight ID for line *\/$/;"	m	struct:sign	file:
sn_name	ex_cmds.c	/^    char_u	*sn_name;	\/* name of sign *\/$/;"	m	struct:sign	file:
sn_name	ex_cmds2.c	/^    char_u	*sn_name;$/;"	m	struct:scriptitem_S	file:
sn_next	ex_cmds.c	/^    sign_T	*sn_next;	\/* next sign in list *\/$/;"	m	struct:sign	file:
sn_pr_child	ex_cmds2.c	/^    proftime_T	sn_pr_child;	\/* time set when going into first child *\/$/;"	m	struct:scriptitem_S	file:
sn_pr_children	ex_cmds2.c	/^    proftime_T	sn_pr_children; \/* time in children after script start *\/$/;"	m	struct:scriptitem_S	file:
sn_pr_count	ex_cmds2.c	/^    int		sn_pr_count;	\/* nr of times sourced *\/$/;"	m	struct:scriptitem_S	file:
sn_pr_force	ex_cmds2.c	/^    int		sn_pr_force;	\/* forceit: profile functions in this script *\/$/;"	m	struct:scriptitem_S	file:
sn_pr_nest	ex_cmds2.c	/^    int		sn_pr_nest;	\/* nesting for sn_pr_child *\/$/;"	m	struct:scriptitem_S	file:
sn_pr_self	ex_cmds2.c	/^    proftime_T	sn_pr_self;	\/* time spent in script itself *\/$/;"	m	struct:scriptitem_S	file:
sn_pr_start	ex_cmds2.c	/^    proftime_T	sn_pr_start;	\/* time at script start *\/$/;"	m	struct:scriptitem_S	file:
sn_pr_total	ex_cmds2.c	/^    proftime_T	sn_pr_total;	\/* time spent in script + children *\/$/;"	m	struct:scriptitem_S	file:
sn_prl_S	ex_cmds2.c	/^typedef struct sn_prl_S$/;"	s	file:
sn_prl_T	ex_cmds2.c	/^} sn_prl_T;$/;"	t	typeref:struct:sn_prl_S	file:
sn_prl_children	ex_cmds2.c	/^    proftime_T	sn_prl_children; \/* time spent in children for this line *\/$/;"	m	struct:scriptitem_S	file:
sn_prl_execed	ex_cmds2.c	/^    int		sn_prl_execed;	\/* line being timed was executed *\/$/;"	m	struct:scriptitem_S	file:
sn_prl_ga	ex_cmds2.c	/^    garray_T	sn_prl_ga;	\/* things stored for every line *\/$/;"	m	struct:scriptitem_S	file:
sn_prl_idx	ex_cmds2.c	/^    int		sn_prl_idx;	\/* index of line being timed; -1 if none *\/$/;"	m	struct:scriptitem_S	file:
sn_prl_self	ex_cmds2.c	/^    proftime_T	sn_prl_self;	\/* time spent in a line itself *\/$/;"	m	struct:sn_prl_S	file:
sn_prl_start	ex_cmds2.c	/^    proftime_T	sn_prl_start;	\/* start time for current line *\/$/;"	m	struct:scriptitem_S	file:
sn_prl_total	ex_cmds2.c	/^    proftime_T	sn_prl_total;	\/* time spent in a line + children *\/$/;"	m	struct:sn_prl_S	file:
sn_prl_wait	ex_cmds2.c	/^    proftime_T	sn_prl_wait;	\/* wait start time for current line *\/$/;"	m	struct:scriptitem_S	file:
sn_prof_on	ex_cmds2.c	/^    int		sn_prof_on;	\/* TRUE when script is\/was profiled *\/$/;"	m	struct:scriptitem_S	file:
sn_text	ex_cmds.c	/^    char_u	*sn_text;	\/* text used instead of pixmap *\/$/;"	m	struct:sign	file:
sn_text_hl	ex_cmds.c	/^    int		sn_text_hl;	\/* highlight ID for text *\/$/;"	m	struct:sign	file:
sn_typenr	ex_cmds.c	/^    int		sn_typenr;	\/* type number of sign (negative if not equal$/;"	m	struct:sign	file:
sniff_request_cb	gui_gtk_x11.c	/^sniff_request_cb($/;"	f	file:
snp_count	ex_cmds2.c	/^    int		snp_count;	\/* nr of times line was executed *\/$/;"	m	struct:sn_prl_S	file:
sock_close	netbeans.c	/^# define sock_close(/;"	d	file:
sock_errno	netbeans.c	/^# define sock_errno /;"	d	file:
sock_read	netbeans.c	/^# define sock_read(/;"	d	file:
sock_write	netbeans.c	/^# define sock_write(/;"	d	file:
soffset	search.c	/^struct soffset$/;"	s	file:
softspace	if_python.c	/^    long softspace;$/;"	m	struct:__anon29	file:
sort_abort	ex_cmds.c	/^static int	sort_abort;		\/* flag to indicate if sorting has been interrupted *\/$/;"	v	file:
sort_compare	ex_cmds.c	/^sort_compare(s1, s2)$/;"	f	file:
sort_compare	misc2.c	/^sort_compare(s1, s2)$/;"	f	file:
sort_ic	ex_cmds.c	/^static int	sort_ic;		\/* ignore case *\/$/;"	v	file:
sort_nr	ex_cmds.c	/^static int	sort_nr;		\/* sort on number *\/$/;"	v	file:
sort_rx	ex_cmds.c	/^static int	sort_rx;		\/* sort on regex instead of skipping it *\/$/;"	v	file:
sort_strings	misc2.c	/^sort_strings(files, count)$/;"	f
sortbuf1	ex_cmds.c	/^static char_u	*sortbuf1;$/;"	v	file:
sortbuf2	ex_cmds.c	/^static char_u	*sortbuf2;$/;"	v	file:
sorti_T	ex_cmds.c	/^} sorti_T;$/;"	t	typeref:struct:__anon8	file:
soundalike_score	spell.c	/^soundalike_score(goodstart, badstart)$/;"	f	file:
soundfold_find	spell.c	/^soundfold_find(slang, word)$/;"	f	file:
source_breakpoint	ex_cmds2.c	/^source_breakpoint(cookie)$/;"	f
source_callback	ex_cmds2.c	/^source_callback(fname, cookie)$/;"	f	file:
source_cookie	ex_cmds2.c	/^struct source_cookie$/;"	s	file:
source_dbg_tick	ex_cmds2.c	/^source_dbg_tick(cookie)$/;"	f
source_finished	ex_cmds2.c	/^source_finished(fgetline, cookie)$/;"	f
source_level	ex_cmds2.c	/^source_level(cookie)$/;"	f
source_runtime	ex_cmds2.c	/^source_runtime(name, all)$/;"	f
source_startup_scripts	main.c	/^source_startup_scripts(parmp)$/;"	f	file:
sourcing_lnum	globals.h	/^EXTERN linenr_T	sourcing_lnum INIT(= 0);    \/* line number of the source file *\/$/;"	v
sourcing_name	globals.h	/^EXTERN char_u	*sourcing_name INIT( = NULL);\/* name of error message source *\/$/;"	v
sp	hangulin.c	/^static int sp=0;$/;"	v	file:
sp_color	structs.h	/^	    guicolor_T	    sp_color;	\/* special color handle *\/$/;"	m	struct:attr_entry::__anon86::__anon89
sp_cont_list	syntax.c	/^    short	*sp_cont_list;		\/* cont. group IDs, if non-zero *\/$/;"	m	struct:syn_pattern	file:
sp_flags	syntax.c	/^    short	 sp_flags;		\/* see HL_ defines below *\/$/;"	m	struct:syn_pattern	file:
sp_ic	syntax.c	/^    int		 sp_ic;			\/* ignore-case flag for sp_prog *\/$/;"	m	struct:syn_pattern	file:
sp_line_id	syntax.c	/^    int		 sp_line_id;		\/* ID of last line where tried *\/$/;"	m	struct:syn_pattern	file:
sp_next_list	syntax.c	/^    short	*sp_next_list;		\/* next group IDs, if non-zero *\/$/;"	m	struct:syn_pattern	file:
sp_off_flags	syntax.c	/^    short	 sp_off_flags;		\/* see below *\/$/;"	m	struct:syn_pattern	file:
sp_offsets	syntax.c	/^    int		 sp_offsets[SPO_COUNT];	\/* offsets *\/$/;"	m	struct:syn_pattern	file:
sp_pattern	syntax.c	/^    char_u	*sp_pattern;		\/* regexp to match, pattern *\/$/;"	m	struct:syn_pattern	file:
sp_prog	syntax.c	/^    regprog_T	*sp_prog;		\/* regexp to match, program *\/$/;"	m	struct:syn_pattern	file:
sp_startcol	syntax.c	/^    int		 sp_startcol;		\/* next match in sp_line_id line *\/$/;"	m	struct:syn_pattern	file:
sp_syn	structs.h	/^struct sp_syn$/;"	s
sp_syn	syntax.c	/^    struct sp_syn sp_syn;		\/* struct passed to in_id_list() *\/$/;"	m	struct:syn_pattern	typeref:struct:syn_pattern::sp_syn	file:
sp_syn_match_id	syntax.c	/^    short	 sp_syn_match_id;	\/* highlight group ID of pattern *\/$/;"	m	struct:syn_pattern	file:
sp_sync_idx	syntax.c	/^    int		 sp_sync_idx;		\/* sync item index (syncing only) *\/$/;"	m	struct:syn_pattern	file:
sp_syncing	syntax.c	/^    char	 sp_syncing;		\/* this item used for syncing *\/$/;"	m	struct:syn_pattern	file:
sp_type	syntax.c	/^    char	 sp_type;		\/* see SPTYPE_ defines below *\/$/;"	m	struct:syn_pattern	file:
spacing	gui_xmebwp.h	/^    Dimension spacing;$/;"	m	struct:_XmEnhancedButtonPart
spat	search.c	/^struct spat$/;"	s	file:
spats	search.c	/^static struct spat spats[2] =$/;"	v	typeref:struct:spat	file:
spcolor	gui.h	/^    GdkColor	*spcolor;	    \/* GDK-styled special color *\/$/;"	m	struct:Gui
special_key	gui_gtk_x11.c	/^static struct special_key$/;"	s	file:
special_keys	gui_gtk_x11.c	/^const special_keys[] =$/;"	v	file:
special_keys	gui_x11.c	/^} special_keys[] =$/;"	v	typeref:struct:specialkey	file:
special_keys	netbeans.c	/^special_keys(char_u *args)$/;"	f	file:
specialkey	gui_x11.c	/^static struct specialkey$/;"	s	file:
spell_add_word	spell.c	/^spell_add_word(word, len, bad, idx, undo)$/;"	f
spell_back_to_badword	edit.c	/^spell_back_to_badword()$/;"	f	file:
spell_bad_len	edit.c	/^static int  spell_bad_len = 0;	\/* length of located bad word *\/$/;"	v	file:
spell_casefold	spell.c	/^spell_casefold(str, len, buf, buflen)$/;"	f	file:
spell_cat_line	spell.c	/^spell_cat_line(buf, line, maxlen)$/;"	f
spell_check	spell.c	/^spell_check(wp, ptr, attrp, capcol, docount)$/;"	f
spell_check_msm	spell.c	/^spell_check_msm()$/;"	f
spell_check_sps	spell.c	/^spell_check_sps()$/;"	f
spell_clear_flags	spell.c	/^spell_clear_flags(wordnode_T *node)$/;"	f	file:
spell_dump_compl	spell.c	/^spell_dump_compl(buf, pat, ic, dir, dumpflags_arg)$/;"	f
spell_edit_score	spell.c	/^spell_edit_score(slang, badword, goodword)$/;"	f	file:
spell_edit_score_limit	spell.c	/^spell_edit_score_limit(slang, badword, goodword, limit)$/;"	f	file:
spell_edit_score_limit_w	spell.c	/^spell_edit_score_limit_w(slang, badword, goodword, limit)$/;"	f	file:
spell_enc	spell.c	/^spell_enc()$/;"	f	file:
spell_expand_check_cap	spell.c	/^spell_expand_check_cap(col)$/;"	f
spell_expand_need_cap	spell.c	/^static int spell_expand_need_cap;$/;"	v	file:
spell_find_cleanup	spell.c	/^spell_find_cleanup(su)$/;"	f	file:
spell_find_suggest	spell.c	/^spell_find_suggest(badptr, badlen, su, maxcount, banbadword, need_cap, interactive)$/;"	f	file:
spell_free_aff	spell.c	/^spell_free_aff(aff)$/;"	f	file:
spell_free_all	spell.c	/^spell_free_all()$/;"	f
spell_info_item	spell.c	/^spell_info_item(s)$/;"	f	file:
spell_iswordp	spell.c	/^spell_iswordp(p, buf)$/;"	f	file:
spell_iswordp_nmw	spell.c	/^spell_iswordp_nmw(p)$/;"	f	file:
spell_iswordp_w	spell.c	/^spell_iswordp_w(p, buf)$/;"	f	file:
spell_load_cb	spell.c	/^spell_load_cb(fname, cookie)$/;"	f	file:
spell_load_file	spell.c	/^spell_load_file(fname, lang, old_lp, silent)$/;"	f	file:
spell_load_lang	spell.c	/^spell_load_lang(lang)$/;"	f	file:
spell_make_sugfile	spell.c	/^spell_make_sugfile(spin, wfname)$/;"	f	file:
spell_mb_isword_class	spell.c	/^spell_mb_isword_class(cl)$/;"	f	file:
spell_message	spell.c	/^spell_message(spin, str)$/;"	f	file:
spell_move_to	spell.c	/^spell_move_to(wp, dir, allwords, curline, attrp)$/;"	f
spell_print_node	spell.c	/^spell_print_node(wordnode_T *node, int depth)$/;"	f	file:
spell_print_tree	spell.c	/^spell_print_tree(wordnode_T *root)$/;"	f	file:
spell_read_aff	spell.c	/^spell_read_aff(spin, fname)$/;"	f	file:
spell_read_dic	spell.c	/^spell_read_dic(spin, fname, affile)$/;"	f	file:
spell_read_tree	spell.c	/^spell_read_tree(fd, bytsp, idxsp, prefixtree, prefixcnt)$/;"	f	file:
spell_read_wordfile	spell.c	/^spell_read_wordfile(spin, fname)$/;"	f	file:
spell_redraw_lnum	globals.h	/^EXTERN linenr_T		spell_redraw_lnum INIT(= 0);$/;"	v
spell_reload	spell.c	/^spell_reload()$/;"	f
spell_reload_one	spell.c	/^spell_reload_one(fname, added_word)$/;"	f	file:
spell_soundfold	spell.c	/^spell_soundfold(slang, inword, folded, res)$/;"	f	file:
spell_soundfold_sal	spell.c	/^spell_soundfold_sal(slang, inword, res)$/;"	f	file:
spell_soundfold_sofo	spell.c	/^spell_soundfold_sofo(slang, inword, res)$/;"	f	file:
spell_soundfold_wsal	spell.c	/^spell_soundfold_wsal(slang, inword, res)$/;"	f	file:
spell_suggest	spell.c	/^spell_suggest(count)$/;"	f
spell_suggest_expr	spell.c	/^spell_suggest_expr(su, expr)$/;"	f	file:
spell_suggest_file	spell.c	/^spell_suggest_file(su, fname)$/;"	f	file:
spell_suggest_intern	spell.c	/^spell_suggest_intern(su, interactive)$/;"	f	file:
spell_suggest_list	spell.c	/^spell_suggest_list(gap, word, maxcount, need_cap, interactive)$/;"	f
spell_to_word_end	spell.c	/^spell_to_word_end(start, buf)$/;"	f
spell_valid_case	spell.c	/^spell_valid_case(wordflags, treeflags)$/;"	f	file:
spell_word_start	spell.c	/^spell_word_start(startcol)$/;"	f
spellinfo_S	spell.c	/^typedef struct spellinfo_S$/;"	s	file:
spellinfo_T	spell.c	/^} spellinfo_T;$/;"	t	typeref:struct:spellinfo_S	file:
spelload_S	spell.c	/^typedef struct spelload_S$/;"	s	file:
spelload_T	spell.c	/^} spelload_T;$/;"	t	typeref:struct:spelload_S	file:
spelltab	spell.c	/^static spelltab_T   spelltab;$/;"	v	file:
spelltab_S	spell.c	/^typedef struct spelltab_S$/;"	s	file:
spelltab_T	spell.c	/^} spelltab_T;$/;"	t	typeref:struct:spelltab_S	file:
split	structs.h	/^    int		split;			\/* flags for win_split() *\/$/;"	m	struct:__anon83
split_button_string	gui_gtk.c	/^split_button_string(char_u *button_string, int *n_buttons)$/;"	f	file:
split_button_translation	gui_gtk.c	/^split_button_translation(const char *message)$/;"	f	file:
spo_name_tab	syntax.c	/^static char *(spo_name_tab[SPO_COUNT]) =$/;"	v	file:
sps_flags	spell.c	/^static int sps_flags = SPS_BEST;	\/* flags from 'spellsuggest' *\/$/;"	v	file:
sps_limit	spell.c	/^static int sps_limit = 9999;		\/* max nr of suggestions given *\/$/;"	v	file:
ssop_flags	option.h	/^EXTERN unsigned	ssop_flags;$/;"	v
sst_change_lnum	structs.h	/^    linenr_T	sst_change_lnum;\/* when non-zero, change in this line$/;"	m	struct:syn_state
sst_ga	structs.h	/^	garray_T	sst_ga;	\/* growarray for long state stack *\/$/;"	m	union:syn_state::__anon85
sst_lnum	structs.h	/^    linenr_T	sst_lnum;	\/* line number for this state *\/$/;"	m	struct:syn_state
sst_next	structs.h	/^    synstate_T	*sst_next;	\/* next entry in used or free list *\/$/;"	m	struct:syn_state
sst_next_flags	structs.h	/^    int		sst_next_flags;	\/* flags for sst_next_list *\/$/;"	m	struct:syn_state
sst_next_list	structs.h	/^    short	*sst_next_list;	\/* "nextgroup" list in this state$/;"	m	struct:syn_state
sst_stack	structs.h	/^	bufstate_T	sst_stack[SST_FIX_STATES]; \/* short state stack *\/$/;"	m	union:syn_state::__anon85
sst_stacksize	structs.h	/^    short	sst_stacksize;	\/* number of states on the stack *\/$/;"	m	struct:syn_state
sst_tick	structs.h	/^    disptick_T	sst_tick;	\/* tick when last displayed *\/$/;"	m	struct:syn_state
sst_union	structs.h	/^    } sst_union;$/;"	m	struct:syn_state	typeref:union:syn_state::__anon85
st_altscore	spell.c	/^    int		st_altscore;	\/* used when st_score compares equal *\/$/;"	m	struct:suggest_S	file:
st_dev	if_cscope.h	/^    dev_t	    st_dev;	\/* ID of dev containing cscope db *\/$/;"	m	struct:csi
st_fold	spell.c	/^    char_u  st_fold[256];	\/* chars: folded case *\/$/;"	m	struct:spelltab_S	file:
st_had_bonus	spell.c	/^    int		st_had_bonus;	\/* bonus already included in score *\/$/;"	m	struct:suggest_S	file:
st_ino	if_cscope.h	/^    ino_t	    st_ino;	\/* inode number of cscope db *\/$/;"	m	struct:csi
st_isu	spell.c	/^    char_u  st_isu[256];	\/* flags: is uppercase char *\/$/;"	m	struct:spelltab_S	file:
st_isw	spell.c	/^    char_u  st_isw[256];	\/* flags: is word char *\/$/;"	m	struct:spelltab_S	file:
st_orglen	spell.c	/^    int		st_orglen;	\/* length of replaced text *\/$/;"	m	struct:suggest_S	file:
st_salscore	spell.c	/^    int		st_salscore;	\/* st_score is for soundalike *\/$/;"	m	struct:suggest_S	file:
st_score	spell.c	/^    int		st_score;	\/* lower is better *\/$/;"	m	struct:suggest_S	file:
st_slang	spell.c	/^    slang_T	*st_slang;	\/* language used for sound folding *\/$/;"	m	struct:suggest_S	file:
st_upper	spell.c	/^    char_u  st_upper[256];	\/* chars: upper case *\/$/;"	m	struct:spelltab_S	file:
st_word	spell.c	/^    char_u	*st_word;	\/* suggested word, allocated string *\/$/;"	m	struct:suggest_S	file:
st_wordlen	spell.c	/^    int		st_wordlen;	\/* STRLEN(st_word) *\/$/;"	m	struct:suggest_S	file:
stack	hangulin.c	/^static char_u stack[20] = {0};$/;"	v	file:
stack_grows_downwards	os_unix.c	/^static int stack_grows_downwards;$/;"	v	file:
stack_limit	os_unix.c	/^static char *stack_limit = NULL;$/;"	v	file:
start	fold.c	/^    int		start;		\/* number of folds that are forced to start at$/;"	m	struct:__anon12	file:
start	if_python.c	/^    PyInt start;$/;"	m	struct:__anon32	file:
start	structs.h	/^	    char_u	    *start;	\/* start escape sequence *\/$/;"	m	struct:attr_entry::__anon86::__anon87
start	structs.h	/^    char_u	*start;$/;"	m	struct:stl_hlrec
start	structs.h	/^    pos_T	start;		\/* start of the operator *\/$/;"	m	struct:oparg_S
start	vim.h	/^    pos_T	start;		\/* Start of selected area *\/$/;"	m	struct:VimClipboard
startPS	search.c	/^startPS(lnum, para, both)$/;"	f
start_arrow	edit.c	/^start_arrow(end_insert_pos)$/;"	f	file:
start_char_vcols	ops.c	/^    colnr_T	start_char_vcols; \/* number of vcols of pre-block char *\/$/;"	m	struct:block_def	file:
start_col_nr	ex_cmds.c	/^    long	start_col_nr;		\/* starting column number or number *\/$/;"	m	struct:__anon8	file:
start_redo	getchar.c	/^start_redo(count, old_redo)$/;"	f
start_redo_ins	getchar.c	/^start_redo_ins()$/;"	f
start_search_hl	screen.c	/^start_search_hl()$/;"	f	file:
start_selection	normal.c	/^start_selection()$/;"	f
start_stuff	getchar.c	/^start_stuff()$/;"	f	file:
start_vcol	ops.c	/^    colnr_T	start_vcol;	\/* start col of 1st char wholly inside block *\/$/;"	m	struct:block_def	file:
start_vcol	structs.h	/^    colnr_T	start_vcol;	\/* start col for block mode operator *\/$/;"	m	struct:oparg_S
start_xterm_trace	os_unix.c	/^start_xterm_trace(button)$/;"	f
startcol	structs.h	/^    colnr_T	startcol; \/* in win_line() points to char where HL starts *\/$/;"	m	struct:__anon96
starting	globals.h	/^EXTERN int	starting INIT(= NO_SCREEN);$/;"	v
starting	gui.h	/^    int		starting;	    \/* GUI will start in a little while *\/$/;"	m	struct:Gui
startp	regexp.h	/^    char_u		*startp[NSUBEXP];$/;"	m	struct:__anon76
startpos	regexp.h	/^    lpos_T		startpos[NSUBEXP];$/;"	m	struct:__anon77
startspaces	ops.c	/^    int		startspaces;	\/* 'extra' cols of first char *\/$/;"	m	struct:block_def	file:
starttermcap	term.c	/^starttermcap()$/;"	f
starttime	globals.h	/^EXTERN time_t starttime;$/;"	v
startup_mzscheme	if_mzsch.c	/^startup_mzscheme(void)$/;"	f	file:
stat	vim.h	/^# define stat(/;"	d
statDone	gui_at_fs.c	/^    int		statDone;$/;"	m	struct:__anon13	file:
state	gui_beval.h	/^    unsigned int	state;		\/* Button\/Modifier key state *\/$/;"	m	struct:BalloonEvalStruct
state	vim.h	/^    short_u	state;		\/* Current selection state *\/$/;"	m	struct:VimClipboard
state_T	spell.c	/^} state_T;$/;"	t	typeref:enum:__anon53	file:
state_item	syntax.c	/^typedef struct state_item$/;"	s	file:
stateitem_T	syntax.c	/^} stateitem_T;$/;"	t	typeref:struct:state_item	file:
static	gui_gtk_x11.c	/^# define static /;"	d	file:
static	gui_gtk_x11.c	/^# undef static$/;"	d	file:
status	gui_gtk.c	/^    int		*status;$/;"	m	struct:_ButtonData	file:
status	gui_gtk.c	/^    int		*status;$/;"	m	struct:_CancelData	file:
status_area_enabled	mbyte.c	/^static int	status_area_enabled = TRUE;$/;"	v	file:
status_height	gui.h	/^    int		status_height;	\/* Height of status line *\/$/;"	m	struct:GuiScrollbar
status_match_len	screen.c	/^status_match_len(xp, s)$/;"	f	file:
status_redraw_all	screen.c	/^status_redraw_all()$/;"	f
status_redraw_curbuf	screen.c	/^status_redraw_curbuf()$/;"	f
stdout_isatty	main.c	/^    int		stdout_isatty;		\/* is stdout a terminal? *\/$/;"	m	struct:__anon39	file:
step	mbyte.c	/^    int step;$/;"	m	struct:__anon42	file:
stipple_bitmap	gui_xmebwp.h	/^    Pixmap stipple_bitmap;$/;"	m	struct:_XmEnhancedButtonClassPart
stipple_bits	gui_xmebw.c	/^static char stipple_bits[] = { 0x0a, 0x05, 0x0a, 0x05 };$/;"	v	file:
stipple_height	gui_xmebw.c	/^#define stipple_height /;"	d	file:
stipple_width	gui_xmebw.c	/^#define stipple_width /;"	d	file:
stl_connected	screen.c	/^stl_connected(wp)$/;"	f
stl_hlrec	structs.h	/^struct stl_hlrec$/;"	s
stl_syntax	globals.h	/^EXTERN int      stl_syntax INIT(= 0);$/;"	v
stoggle_callback	gui_xmdlg.c	/^stoggle_callback(Widget w,$/;"	f	file:
stop	structs.h	/^	    char_u	    *stop;	\/* stop escape sequence *\/$/;"	m	struct:attr_entry::__anon86::__anon87
stop_arrow	edit.c	/^stop_arrow()$/;"	f
stop_insert	edit.c	/^stop_insert(end_insert_pos, esc)$/;"	f	file:
stop_insert_mode	globals.h	/^EXTERN int	stop_insert_mode;	\/* for ":stopinsert" and 'insertmode' *\/$/;"	v
stop_redo_ins	getchar.c	/^stop_redo_ins()$/;"	f
stop_xterm_trace	os_unix.c	/^stop_xterm_trace()$/;"	f
stoptermcap	term.c	/^stoptermcap()$/;"	f
store_aff_word	spell.c	/^store_aff_word(spin, word, afflist, affile, ht, xht, condit, flags,$/;"	f	file:
store_current_state	syntax.c	/^store_current_state()$/;"	f	file:
store_loop_line	ex_docmd.c	/^store_loop_line(gap, line)$/;"	f	file:
store_sb_text	message.c	/^store_sb_text(sb_str, s, attr, sb_col, finish)$/;"	f	file:
store_session_globals	eval.c	/^store_session_globals(fd)$/;"	f
store_word	spell.c	/^store_word(spin, word, flags, region, pfxlist, need_affix)$/;"	f	file:
stp_sal_score	spell.c	/^stp_sal_score(stp, su, slang, badsound)$/;"	f	file:
str2special	message.c	/^str2special(sp, from)$/;"	f
str2specialbuf	message.c	/^str2specialbuf(sp, buf, len)$/;"	f
str_equal	spell.c	/^str_equal(s1, s2)$/;"	f	file:
str_foldcase	charset.c	/^str_foldcase(str, orglen, buf, buflen)$/;"	f
str_to_reg	ops.c	/^str_to_reg(y_ptr, type, str, len, blocklen)$/;"	f	file:
streq	netbeans.c	/^#define streq(/;"	d	file:
strerror	os_unix.c	/^strerror(err)$/;"	f	file:
string	hardcopy.c	/^    char	*string;$/;"	m	struct:prt_dsc_comment_S	file:
string	hardcopy.c	/^    char_u	*string;$/;"	m	struct:prt_dsc_line_S	file:
string	structs.h	/^    char_u	*string;	\/* points into option string *\/$/;"	m	struct:__anon98
string2float	eval.c	/^string2float(text, value)$/;"	f	file:
string_convert	mbyte.c	/^string_convert(vcp, ptr, lenp)$/;"	f
string_convert_ext	mbyte.c	/^string_convert_ext(vcp, ptr, lenp, unconvlenp)$/;"	f
string_quote	eval.c	/^string_quote(str, function)$/;"	f	file:
string_to_key	option.c	/^string_to_key(arg)$/;"	f	file:
string_to_line	if_mzsch.c	/^string_to_line(Scheme_Object *obj)$/;"	f	file:
strings	if_xcmdsrv.c	/^    garray_T strings;$/;"	m	struct:ServerReply	file:
strings	structs.h	/^    char_u	*strings[MENU_MODES]; \/* Mapped string for each mode *\/$/;"	m	struct:VimMenu
strlen	structs.h	/^    int		strlen;$/;"	m	struct:__anon98
strup_save	misc2.c	/^strup_save(orig)$/;"	f
stubs_initialized	if_tcl.c	/^static int stubs_initialized = FALSE;$/;"	v	file:
stuffReadbuff	getchar.c	/^stuffReadbuff(s)$/;"	f
stuffReadbuffLen	getchar.c	/^stuffReadbuffLen(s, len)$/;"	f
stuffReadbuffSpec	getchar.c	/^stuffReadbuffSpec(s)$/;"	f
stuff_empty	getchar.c	/^stuff_empty()$/;"	f
stuff_inserted	edit.c	/^stuff_inserted(c, count, no_esc)$/;"	f
stuff_yank	ops.c	/^stuff_yank(regname, p)$/;"	f	file:
stuffbuff	globals.h	/^EXTERN struct buffheader stuffbuff	\/* stuff buffer *\/$/;"	v	typeref:struct:buffheader
stuffcharReadbuff	getchar.c	/^stuffcharReadbuff(c)$/;"	f
stuffescaped	ops.c	/^stuffescaped(arg, literally)$/;"	f	file:
stuffnumReadbuff	getchar.c	/^stuffnumReadbuff(n)$/;"	f
style_callback	gui_xmdlg.c	/^style_callback(Widget w,$/;"	f	file:
style_part	gui_xmdlg.c	/^style_part(char *font, char *buf)$/;"	f	file:
su_badflags	spell.c	/^    int		su_badflags;	    \/* caps flags for bad word *\/$/;"	m	struct:suginfo_S	file:
su_badlen	spell.c	/^    int		su_badlen;	    \/* length of detected bad word in line *\/$/;"	m	struct:suginfo_S	file:
su_badptr	spell.c	/^    char_u	*su_badptr;	    \/* start of bad word in line *\/$/;"	m	struct:suginfo_S	file:
su_badword	spell.c	/^    char_u	su_badword[MAXWLEN]; \/* bad word truncated at su_badlen *\/$/;"	m	struct:suginfo_S	file:
su_banned	spell.c	/^    hashtab_T	su_banned;	    \/* table with banned words *\/$/;"	m	struct:suginfo_S	file:
su_fbadword	spell.c	/^    char_u	su_fbadword[MAXWLEN]; \/* su_badword case-folded *\/$/;"	m	struct:suginfo_S	file:
su_ga	spell.c	/^    garray_T	su_ga;		    \/* suggestions, contains "suggest_T" *\/$/;"	m	struct:suginfo_S	file:
su_maxcount	spell.c	/^    int		su_maxcount;	    \/* max. number of suggestions displayed *\/$/;"	m	struct:suginfo_S	file:
su_maxscore	spell.c	/^    int		su_maxscore;	    \/* maximum score for adding to su_ga *\/$/;"	m	struct:suginfo_S	file:
su_sal_badword	spell.c	/^    char_u	su_sal_badword[MAXWLEN]; \/* su_badword soundfolded *\/$/;"	m	struct:suginfo_S	file:
su_sallang	spell.c	/^    slang_T	*su_sallang;	    \/* default language for sound folding *\/$/;"	m	struct:suginfo_S	file:
su_sfmaxscore	spell.c	/^    int		su_sfmaxscore;	    \/* idem, for when doing soundfold words *\/$/;"	m	struct:suginfo_S	file:
su_sga	spell.c	/^    garray_T	su_sga;		    \/* like su_ga, sound-folded scoring *\/$/;"	m	struct:suginfo_S	file:
sub_nlines	globals.h	/^EXTERN linenr_T	sub_nlines;	\/* total number of lines changed *\/$/;"	v
sub_nsubs	globals.h	/^EXTERN long	sub_nsubs;	\/* total number of substitutions *\/$/;"	v
subcommand	syntax.c	/^struct subcommand$/;"	s	file:
subcommands	syntax.c	/^static struct subcommand subcommands[] =$/;"	v	typeref:struct:subcommand	file:
submatch_match	regexp.c	/^static regmatch_T	*submatch_match;$/;"	v	file:
submatch_mmatch	regexp.c	/^static regmmatch_T	*submatch_mmatch;$/;"	v	file:
submenu_change	gui_motif.c	/^submenu_change(menu, colors)$/;"	f	file:
submenu_handle	structs.h	/^    MenuHandle	submenu_handle;$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    GtkWidget	*submenu_id;	    \/* If this is submenu, add children here *\/$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    HMENU	submenu_id;	    \/* If this is submenu, add children here *\/$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    PtWidget_t	*submenu_id;$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    Widget	submenu_id;	    \/* If this is submenu, add children here *\/$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    short	submenu_id;	    \/* the menu id of the children (could be$/;"	m	struct:VimMenu
submenu_widget	gui_athena.c	/^submenu_widget(widget)$/;"	f	file:
sug_compare	spell.c	/^sug_compare(s1, s2)$/;"	f	file:
sug_filltable	spell.c	/^sug_filltable(spin, node, startwordnr, gap)$/;"	f	file:
sug_filltree	spell.c	/^sug_filltree(spin, slang)$/;"	f	file:
sug_maketable	spell.c	/^sug_maketable(spin)$/;"	f	file:
sug_write	spell.c	/^sug_write(spin, fname)$/;"	f	file:
suggest_S	spell.c	/^typedef struct suggest_S$/;"	s	file:
suggest_T	spell.c	/^} suggest_T;$/;"	t	typeref:struct:suggest_S	file:
suggest_load_files	spell.c	/^suggest_load_files()$/;"	f	file:
suggest_trie_walk	spell.c	/^suggest_trie_walk(su, lp, fword, soundfold)$/;"	f	file:
suggest_try_change	spell.c	/^suggest_try_change(su)$/;"	f	file:
suggest_try_soundalike	spell.c	/^suggest_try_soundalike(su)$/;"	f	file:
suggest_try_soundalike_finish	spell.c	/^suggest_try_soundalike_finish()$/;"	f	file:
suggest_try_soundalike_prep	spell.c	/^suggest_try_soundalike_prep()$/;"	f	file:
suggest_try_special	spell.c	/^suggest_try_special(su)$/;"	f	file:
suginfo_S	spell.c	/^typedef struct suginfo_S$/;"	s	file:
suginfo_T	spell.c	/^} suginfo_T;$/;"	t	typeref:struct:suginfo_S	file:
supermenuTrans	gui_athena.c	/^static XtTranslations	popupTrans, parentTrans, menuTrans, supermenuTrans;$/;"	v	file:
suppress_alternate_input	globals.h	/^EXTERN int	suppress_alternate_input INIT(= FALSE);$/;"	v
suppress_dialog_mnemonics	gui_motif.c	/^suppress_dialog_mnemonics(Widget dialog)$/;"	f	file:
suppress_errthrow	globals.h	/^EXTERN int suppress_errthrow INIT(= FALSE);$/;"	v
suspend_shell	ui.c	/^suspend_shell()$/;"	f
sv_dict	eval.c	/^    dict_T	sv_dict;$/;"	m	struct:__anon2	file:
sv_var	eval.c	/^    dictitem_T	sv_var;$/;"	m	struct:__anon2	file:
swap_exists_action	globals.h	/^EXTERN int	swap_exists_action INIT(= SEA_NONE);$/;"	v
swap_exists_did_quit	globals.h	/^EXTERN int	swap_exists_did_quit INIT(= FALSE);$/;"	v
swapchar	ops.c	/^swapchar(op_type, pos)$/;"	f
swapchars	ops.c	/^swapchars(op_type, pos, length)$/;"	f	file:
swapfile_info	memline.c	/^swapfile_info(fname)$/;"	f	file:
swapping_screen	term.c	/^swapping_screen()$/;"	f
swb_flags	option.h	/^EXTERN unsigned	swb_flags;$/;"	v
switch_to_8bit	term.c	/^switch_to_8bit()$/;"	f	file:
sy_chars	spell.c	/^    char_u	sy_chars[SY_MAXLEN];	    \/* the sequence of chars *\/$/;"	m	struct:syl_item_S	file:
sy_len	spell.c	/^    int		sy_len;$/;"	m	struct:syl_item_S	file:
syl_item_S	spell.c	/^typedef struct syl_item_S$/;"	s	file:
syl_item_T	spell.c	/^} syl_item_T;$/;"	t	typeref:struct:syl_item_S	file:
syn_add_cluster	syntax.c	/^syn_add_cluster(name)$/;"	f	file:
syn_add_end_off	syntax.c	/^syn_add_end_off(result, regmatch, spp, idx, extra)$/;"	f	file:
syn_add_group	syntax.c	/^syn_add_group(name)$/;"	f	file:
syn_add_start_off	syntax.c	/^syn_add_start_off(result, regmatch, spp, idx, extra)$/;"	f	file:
syn_attr2attr	syntax.c	/^syn_attr2attr(attr)$/;"	f
syn_buf	syntax.c	/^static buf_T	*syn_buf;		\/* current buffer for highlighting *\/$/;"	v	file:
syn_check_cluster	syntax.c	/^syn_check_cluster(pp, len)$/;"	f	file:
syn_check_group	syntax.c	/^syn_check_group(pp, len)$/;"	f
syn_clear_cluster	syntax.c	/^syn_clear_cluster(buf, i)$/;"	f	file:
syn_clear_keyword	syntax.c	/^syn_clear_keyword(id, ht)$/;"	f	file:
syn_clear_one	syntax.c	/^syn_clear_one(id, syncing)$/;"	f	file:
syn_clear_pattern	syntax.c	/^syn_clear_pattern(buf, i)$/;"	f	file:
syn_cluster_S	syntax.c	/^typedef struct syn_cluster_S$/;"	s	file:
syn_cluster_T	syntax.c	/^} syn_cluster_T;$/;"	t	typeref:struct:syn_cluster_S	file:
syn_cmd_case	syntax.c	/^syn_cmd_case(eap, syncing)$/;"	f	file:
syn_cmd_clear	syntax.c	/^syn_cmd_clear(eap, syncing)$/;"	f	file:
syn_cmd_cluster	syntax.c	/^syn_cmd_cluster(eap, syncing)$/;"	f	file:
syn_cmd_enable	syntax.c	/^syn_cmd_enable(eap, syncing)$/;"	f	file:
syn_cmd_include	syntax.c	/^syn_cmd_include(eap, syncing)$/;"	f	file:
syn_cmd_keyword	syntax.c	/^syn_cmd_keyword(eap, syncing)$/;"	f	file:
syn_cmd_list	syntax.c	/^syn_cmd_list(eap, syncing)$/;"	f	file:
syn_cmd_manual	syntax.c	/^syn_cmd_manual(eap, syncing)$/;"	f	file:
syn_cmd_match	syntax.c	/^syn_cmd_match(eap, syncing)$/;"	f	file:
syn_cmd_off	syntax.c	/^syn_cmd_off(eap, syncing)$/;"	f	file:
syn_cmd_on	syntax.c	/^syn_cmd_on(eap, syncing)$/;"	f	file:
syn_cmd_onoff	syntax.c	/^syn_cmd_onoff(eap, name)$/;"	f	file:
syn_cmd_region	syntax.c	/^syn_cmd_region(eap, syncing)$/;"	f	file:
syn_cmd_reset	syntax.c	/^syn_cmd_reset(eap, syncing)$/;"	f	file:
syn_cmd_spell	syntax.c	/^syn_cmd_spell(eap, syncing)$/;"	f	file:
syn_cmd_sync	syntax.c	/^syn_cmd_sync(eap, syncing)$/;"	f	file:
syn_cmdlinep	syntax.c	/^static char_u **syn_cmdlinep;$/;"	v	file:
syn_combine_list	syntax.c	/^syn_combine_list(clstr1, clstr2, list_op)$/;"	f	file:
syn_compare_stub	syntax.c	/^syn_compare_stub(v1, v2)$/;"	f	file:
syn_cterm_attr2entry	syntax.c	/^syn_cterm_attr2entry(attr)$/;"	f
syn_current_attr	syntax.c	/^syn_current_attr(syncing, displaying, can_spell, keep_state)$/;"	f	file:
syn_finish_line	syntax.c	/^syn_finish_line(syncing)$/;"	f	file:
syn_get_final_id	syntax.c	/^syn_get_final_id(hl_id)$/;"	f
syn_get_foldlevel	syntax.c	/^syn_get_foldlevel(wp, lnum)$/;"	f
syn_get_id	syntax.c	/^syn_get_id(wp, lnum, col, trans, spellp, keep_state)$/;"	f
syn_get_stack_item	syntax.c	/^syn_get_stack_item(i)$/;"	f
syn_getcurline	syntax.c	/^syn_getcurline()$/;"	f	file:
syn_gui_attr2entry	syntax.c	/^syn_gui_attr2entry(attr)$/;"	f
syn_id2attr	syntax.c	/^syn_id2attr(hl_id)$/;"	f
syn_id2colors	syntax.c	/^syn_id2colors(hl_id, fgp, bgp)$/;"	f
syn_id2name	syntax.c	/^syn_id2name(id)$/;"	f
syn_incl_toplevel	syntax.c	/^syn_incl_toplevel(id, flagsp)$/;"	f	file:
syn_lines_msg	syntax.c	/^syn_lines_msg()$/;"	f	file:
syn_list_cluster	syntax.c	/^syn_list_cluster(id)$/;"	f	file:
syn_list_flags	syntax.c	/^syn_list_flags(nl, flags, attr)$/;"	f	file:
syn_list_header	syntax.c	/^syn_list_header(did_header, outlen, id)$/;"	f	file:
syn_list_keywords	syntax.c	/^syn_list_keywords(id, ht, did_header, attr)$/;"	f	file:
syn_list_one	syntax.c	/^syn_list_one(id, syncing, link_only)$/;"	f	file:
syn_match_linecont	syntax.c	/^syn_match_linecont(lnum)$/;"	f	file:
syn_match_msg	syntax.c	/^syn_match_msg()$/;"	f	file:
syn_name2id	syntax.c	/^syn_name2id(name)$/;"	f
syn_namen2id	syntax.c	/^syn_namen2id(linep, len)$/;"	f
syn_opt_arg_T	syntax.c	/^} syn_opt_arg_T;$/;"	t	typeref:struct:__anon58	file:
syn_pattern	syntax.c	/^typedef struct syn_pattern$/;"	s	file:
syn_regexec	syntax.c	/^syn_regexec(rmp, lnum, col)$/;"	f	file:
syn_remove_pattern	syntax.c	/^syn_remove_pattern(buf, idx)$/;"	f	file:
syn_scl_name2id	syntax.c	/^syn_scl_name2id(name)$/;"	f	file:
syn_scl_namen2id	syntax.c	/^syn_scl_namen2id(linep, len)$/;"	f	file:
syn_stack_alloc	syntax.c	/^syn_stack_alloc()$/;"	f	file:
syn_stack_apply_changes	syntax.c	/^syn_stack_apply_changes(buf)$/;"	f
syn_stack_cleanup	syntax.c	/^syn_stack_cleanup()$/;"	f	file:
syn_stack_equal	syntax.c	/^syn_stack_equal(sp)$/;"	f	file:
syn_stack_find_entry	syntax.c	/^syn_stack_find_entry(lnum)$/;"	f	file:
syn_stack_free_all	syntax.c	/^syn_stack_free_all(buf)$/;"	f
syn_stack_free_entry	syntax.c	/^syn_stack_free_entry(buf, p)$/;"	f	file:
syn_start_line	syntax.c	/^syn_start_line()$/;"	f	file:
syn_state	structs.h	/^struct syn_state$/;"	s
syn_sync	syntax.c	/^syn_sync(wp, start_lnum, last_valid)$/;"	f	file:
syn_term_attr2entry	syntax.c	/^syn_term_attr2entry(attr)$/;"	f
syn_unadd_group	syntax.c	/^syn_unadd_group()$/;"	f	file:
syn_update_ends	syntax.c	/^syn_update_ends(startofline)$/;"	f	file:
syn_win	syntax.c	/^static win_T	*syn_win;		\/* current window for highlighting *\/$/;"	v	file:
sync_idx	syntax.c	/^    int		*sync_idx;	\/* syntax item for "grouphere" argument, NULL$/;"	m	struct:__anon58	file:
synpat_T	syntax.c	/^} synpat_T;$/;"	t	typeref:struct:syn_pattern	file:
synstate_T	structs.h	/^typedef struct syn_state synstate_T;$/;"	t	typeref:struct:syn_state
syntax_check_changed	syntax.c	/^syntax_check_changed(lnum)$/;"	f
syntax_clear	syntax.c	/^syntax_clear(buf)$/;"	f
syntax_end_parsing	syntax.c	/^syntax_end_parsing(lnum)$/;"	f
syntax_present	syntax.c	/^syntax_present(buf)$/;"	f
syntax_start	syntax.c	/^syntax_start(wp, lnum)$/;"	f
syntax_sync_clear	syntax.c	/^syntax_sync_clear()$/;"	f	file:
sys_menu	globals.h	/^EXTERN int	sys_menu INIT(= FALSE);$/;"	v
sysmouse_close	os_unix.c	/^sysmouse_close()$/;"	f	file:
sysmouse_open	os_unix.c	/^sysmouse_open()$/;"	f	file:
t_colors	globals.h	/^EXTERN int	t_colors INIT(= 0);	    \/* int value of T_CCO *\/$/;"	v
t_puts	message.c	/^t_puts(t_col, t_s, s, attr)$/;"	f	file:
ta_len	ui.c	/^static int ta_len;	\/* length of ta_str when it's not NULL*\/$/;"	v	file:
ta_off	ui.c	/^static int ta_off;	\/* offset for next char to use when ta_str != NULL *\/$/;"	v	file:
ta_str	ui.c	/^static char_u *ta_str = NULL;$/;"	v	file:
tab	structs.h	/^    int		tab;			\/* > 0 when ":tab" was used *\/$/;"	m	struct:__anon83
tabLine	gui_motif.c	/^static Widget	tabLine;$/;"	v	file:
tabLine_menu	gui_motif.c	/^static Widget	tabLine_menu = 0;$/;"	v	file:
tabline	gui.h	/^    GtkWidget	*tabline;	    \/* tab pages line handle *\/$/;"	m	struct:Gui
tabline_balloon_cb	gui_motif.c	/^tabline_balloon_cb(beval, state)$/;"	f	file:
tabline_button_cb	gui_motif.c	/^tabline_button_cb(w, client_data, call_data)$/;"	f	file:
tabline_cb	gui_motif.c	/^tabline_cb(w, client_data, call_data)$/;"	f	file:
tabline_height	gui.h	/^    int		tabline_height;$/;"	m	struct:Gui
tabline_height	window.c	/^tabline_height()$/;"	f
tabline_menu	gui_gtk_x11.c	/^static GtkWidget *tabline_menu;$/;"	v	file:
tabline_menu_cb	gui_motif.c	/^tabline_menu_cb(w, closure, e, continue_dispatch)$/;"	f	file:
tabline_menu_handler	gui_gtk_x11.c	/^tabline_menu_handler(GtkMenuItem *item, gpointer user_data)$/;"	f	file:
tabline_scroller_clicked	gui_motif.c	/^tabline_scroller_clicked(scroller_name, event)$/;"	f	file:
tabline_tooltip	gui_gtk_x11.c	/^static GtkTooltips *tabline_tooltip;$/;"	v	file:
tabpage_S	structs.h	/^struct tabpage_S$/;"	s
tabpage_T	structs.h	/^typedef struct tabpage_S tabpage_T;$/;"	t	typeref:struct:tabpage_S
tabpage_close	ex_docmd.c	/^tabpage_close(forceit)$/;"	f
tabpage_close_other	ex_docmd.c	/^tabpage_close_other(tp, forceit)$/;"	f
tabpage_index	window.c	/^tabpage_index(ftp)$/;"	f
tabpage_move	window.c	/^tabpage_move(nr)$/;"	f
tabpage_new	ex_docmd.c	/^tabpage_new()$/;"	f
tag	if_mzsch.c	/^    Scheme_Type	    tag;$/;"	m	struct:__anon21	file:
tag	if_mzsch.c	/^    Scheme_Type	    tag;$/;"	m	struct:__anon22	file:
tag_fgets	diff.c	/^# define tag_fgets /;"	d	file:
tag_fgets	fileio.c	/^tag_fgets(buf, size, fp)$/;"	f
tag_fgets	tag.c	/^# define tag_fgets /;"	d	file:
tag_fname	tag.c	/^    char_u	*tag_fname;	\/* file name of the tags file *\/$/;"	m	struct:tag_pointers	file:
tag_fnames	tag.c	/^static garray_T tag_fnames = GA_EMPTY;$/;"	v	file:
tag_freematch	tag.c	/^tag_freematch()$/;"	f
tag_full_fname	tag.c	/^tag_full_fname(tagp)$/;"	f	file:
tag_pointers	tag.c	/^typedef struct tag_pointers$/;"	s	file:
tag_strnicmp	tag.c	/^tag_strnicmp(s1, s2, len)$/;"	f	file:
taggy	structs.h	/^typedef struct taggy$/;"	s
taggy_T	structs.h	/^} taggy_T;$/;"	t	typeref:struct:taggy
tagkind	tag.c	/^    char_u	*tagkind;	\/* "kind:" value *\/$/;"	m	struct:tag_pointers	file:
tagkind_end	tag.c	/^    char_u	*tagkind_end;	\/* end of tagkind *\/$/;"	m	struct:tag_pointers	file:
taglen_advance	tag.c	/^taglen_advance(l)$/;"	f	file:
tagmatchname	tag.c	/^static char_u	*tagmatchname = NULL;	\/* name of last used tag *\/$/;"	v	file:
tagname	main.c	/^    char_u	*tagname;		\/* tag from -t argument *\/$/;"	m	struct:__anon39	file:
tagname	structs.h	/^    char_u	*tagname;	\/* tag name *\/$/;"	m	struct:taggy
tagname	tag.c	/^    char_u	*tagname;	\/* start of tag name (skip "file:") *\/$/;"	m	struct:tag_pointers	file:
tagname_T	structs.h	/^} tagname_T;$/;"	t	typeref:struct:__anon102
tagname_end	tag.c	/^    char_u	*tagname_end;	\/* char after tag name *\/$/;"	m	struct:tag_pointers	file:
tagname_free	tag.c	/^tagname_free(tnp)$/;"	f
tagptrs_T	tag.c	/^} tagptrs_T;$/;"	t	typeref:struct:tag_pointers	file:
tail	fileio.c	/^    char_u	*tail;		\/* tail of fname *\/$/;"	m	struct:AutoPatCmd	file:
target	gui_beval.h	/^    GtkWidget		*target;	\/* widget we are monitoring *\/$/;"	m	struct:BalloonEvalStruct
target_event_cb	gui_beval.c	/^target_event_cb(GtkWidget *widget, GdkEvent *event, gpointer data)$/;"	f	file:
targets_atom	ui.c	/^static Atom	targets_atom;$/;"	v	file:
tasave_T	structs.h	/^} tasave_T;$/;"	t	typeref:struct:__anon91
tb_buf	structs.h	/^    char_u	*tb_buf;	\/* buffer for typed characters *\/$/;"	m	struct:__anon90
tb_buflen	structs.h	/^    int		tb_buflen;	\/* size of tb_buf[] *\/$/;"	m	struct:__anon90
tb_change_cnt	structs.h	/^    int		tb_change_cnt;	\/* nr of time tb_buf was changed; never zero *\/$/;"	m	struct:__anon90
tb_len	structs.h	/^    int		tb_len;		\/* number of valid bytes in tb_buf[] *\/$/;"	m	struct:__anon90
tb_maplen	structs.h	/^    int		tb_maplen;	\/* nr of mapped bytes in tb_buf[] *\/$/;"	m	struct:__anon90
tb_no_abbr_cnt	structs.h	/^    int		tb_no_abbr_cnt; \/* nr of bytes without abbrev. in tb_buf[] *\/$/;"	m	struct:__anon90
tb_noremap	structs.h	/^    char_u	*tb_noremap;	\/* mapping flags for characters in tb_buf[] *\/$/;"	m	struct:__anon90
tb_off	structs.h	/^    int		tb_off;		\/* current position in tb_buf[] *\/$/;"	m	struct:__anon90
tb_silent	structs.h	/^    int		tb_silent;	\/* nr of silently mapped bytes in tb_buf[] *\/$/;"	m	struct:__anon90
tbis_flags	option.h	/^EXTERN unsigned tbis_flags;$/;"	v
tbpri	workshop.c	/^static int	 tbpri;			\/* ToolBar priority *\/$/;"	v	file:
tc_charsets	hardcopy.c	/^static struct prt_ps_charset_S tc_charsets[] =$/;"	v	typeref:struct:prt_ps_charset_S	file:
tc_encodings	hardcopy.c	/^static struct prt_ps_encoding_S tc_encodings[] =$/;"	v	typeref:struct:prt_ps_encoding_S	file:
tc_len	term.c	/^static int  tc_len = 0;	    \/* current number of entries in termcodes[] *\/$/;"	v	file:
tc_max_len	term.c	/^static int  tc_max_len = 0; \/* number of entries that termcodes[] can hold *\/$/;"	v	file:
tcl_buffer_free	if_tcl.c	/^tcl_buffer_free(buf)$/;"	f
tcl_enabled	if_tcl.c	/^tcl_enabled(verbose)$/;"	f
tcl_end	if_tcl.c	/^tcl_end()$/;"	f
tcl_funcname_table	if_tcl.c	/^} tcl_funcname_table[] = {$/;"	v	typeref:struct:__anon38	file:
tcl_info	if_tcl.c	/^} tcl_info;$/;"	t	typeref:struct:__anon37	file:
tcl_runtime_link_init	if_tcl.c	/^tcl_runtime_link_init(char *libname, int verbose)$/;"	f	file:
tcl_window_free	if_tcl.c	/^tcl_window_free(win)$/;"	f
tcldelallrefs	if_tcl.c	/^tcldelallrefs(ref)$/;"	f	file:
tcldelthisinterp	if_tcl.c	/^tcldelthisinterp()$/;"	f	file:
tcldoexcommand	if_tcl.c	/^tcldoexcommand(interp, objc, objv, objn)$/;"	f	file:
tclerrmsg	if_tcl.c	/^tclerrmsg(text)$/;"	f	file:
tclexit	if_tcl.c	/^tclexit(error)$/;"	f	file:
tclfindwin	if_tcl.c	/^tclfindwin(buf)$/;"	f	file:
tclgetbuffer	if_tcl.c	/^tclgetbuffer(interp, buf)$/;"	f	file:
tclgetlinenum	if_tcl.c	/^tclgetlinenum(interp, obj, valueP, buf)$/;"	f	file:
tclgetref	if_tcl.c	/^tclgetref(interp, refstartP, prefix, vimobj, proc)$/;"	f	file:
tclgetwindow	if_tcl.c	/^tclgetwindow(interp, win)$/;"	f	file:
tclinfo	if_tcl.c	/^static tcl_info tclinfo = { NULL, 0, 0, 0, NULL, NULL };$/;"	v	file:
tclinit	if_tcl.c	/^tclinit(eap)$/;"	f	file:
tclmsg	if_tcl.c	/^tclmsg(text)$/;"	f	file:
tclsetdelcmd	if_tcl.c	/^tclsetdelcmd(interp, reflist, vimobj, delcmd)$/;"	f	file:
tclsetoption	if_tcl.c	/^tclsetoption(interp, objc, objv, objn)$/;"	f	file:
tclupdatevars	if_tcl.c	/^tclupdatevars()$/;"	f	file:
tclvimexpr	if_tcl.c	/^tclvimexpr(interp, objc, objv, objn)$/;"	f	file:
tearoff_handle	structs.h	/^    GtkWidget	*tearoff_handle;$/;"	m	struct:VimMenu
tearoff_handle	structs.h	/^    HWND	tearoff_handle;	    \/* hWnd of tearoff if created *\/$/;"	m	struct:VimMenu
tearoff_val	gui_motif.c	/^static int tearoff_val = (int)XmTEAR_OFF_ENABLED;$/;"	v	file:
temp_count	fileio.c	/^static long	temp_count = 0;		\/* Temp filename counter. *\/$/;"	v	file:
tent	termlib.c	/^char	*tent;		      \/* Pointer to terminal entry, set by tgetent *\/$/;"	v
term	main.c	/^    char_u	*term;			\/* specified terminal name *\/$/;"	m	struct:__anon39	file:
term	structs.h	/^	} term;$/;"	m	union:attr_entry::__anon86	typeref:struct:attr_entry::__anon86::__anon87
term_7to8bit	term.c	/^term_7to8bit(p)$/;"	f	file:
term_append_lines	term.c	/^term_append_lines(line_count)$/;"	f
term_attr_table	syntax.c	/^static garray_T	term_attr_table = {0, 0, 0, 0, NULL};$/;"	v	file:
term_bg_color	term.c	/^term_bg_color(n)$/;"	f
term_bg_default	option.c	/^term_bg_default()$/;"	f	file:
term_color	term.c	/^term_color(s, n)$/;"	f	file:
term_console	globals.h	/^EXTERN int	term_console INIT(= FALSE); \/* set to TRUE when console used *\/$/;"	v
term_cursor_right	term.c	/^term_cursor_right(i)$/;"	f
term_cursor_shape	term.c	/^term_cursor_shape()$/;"	f
term_delete_lines	term.c	/^term_delete_lines(line_count)$/;"	f
term_fg_color	term.c	/^term_fg_color(n)$/;"	f
term_is_8bit	term.c	/^term_is_8bit(name)$/;"	f
term_is_builtin	term.c	/^term_is_builtin(name)$/;"	f	file:
term_is_gui	term.c	/^term_is_gui(name)$/;"	f
term_is_xterm	globals.h	/^EXTERN int	term_is_xterm INIT(= FALSE);	\/* xterm-like 'term' *\/$/;"	v
term_set_winpos	term.c	/^term_set_winpos(x, y)$/;"	f
term_set_winsize	term.c	/^term_set_winsize(width, height)$/;"	f
term_settitle	term.c	/^term_settitle(title)$/;"	f
term_str	vim.h	/^#define term_str(/;"	d
term_strings	term.c	/^char_u *(term_strings[(int)KS_LAST + 1]);$/;"	v
term_windgoto	term.c	/^term_windgoto(row, col)$/;"	f
termcap_active	globals.h	/^EXTERN int	termcap_active INIT(= FALSE);	\/* set by starttermcap() *\/$/;"	v
termcapinit	term.c	/^termcapinit(name)$/;"	f
termcode	term.c	/^static struct termcode$/;"	s	file:
termcode_star	term.c	/^termcode_star(code, len)$/;"	f	file:
termcodes	term.c	/^} *termcodes = NULL;$/;"	v	typeref:struct:termcode	file:
termleader	term.c	/^static char_u	termleader[256 + 1];	    \/* for check_termcode() *\/$/;"	v	file:
test_for_current	tag.c	/^test_for_current(is_etag, fname, fname_end, tag_fname, buf_ffname)$/;"	f	file:
test_for_static	tag.c	/^test_for_static(tagp)$/;"	f	file:
test_x11_window	os_unix.c	/^test_x11_window(dpy)$/;"	f	file:
textArea	gui_athena.c	/^Widget textArea = (Widget)0;$/;"	v
textArea	gui_motif.c	/^Widget textArea;$/;"	v
textAreaForm	gui_motif.c	/^static Widget textAreaForm;$/;"	v	file:
textResources	gui_at_fs.c	/^static XtResource textResources[] =$/;"	v	file:
text_atom	gui_gtk_x11.c	/^static GdkAtom text_atom = GDK_NONE;$/;"	v	file:
text_atom	ui.c	/^static Atom	text_atom;$/;"	v	file:
text_context	gui.h	/^    PangoContext     *text_context; \/* the context used for all text *\/$/;"	m	struct:Gui
text_gc	gui.h	/^    GC		text_gc;$/;"	m	struct:Gui
text_gc	gui.h	/^    GdkGC	*text_gc;	    \/* cached GC for normal text *\/$/;"	m	struct:Gui
text_locked	ex_getln.c	/^text_locked()$/;"	f
text_locked_msg	ex_getln.c	/^text_locked_msg()$/;"	f
textcol	ops.c	/^    colnr_T	textcol;	\/* cols of chars (at least part.) in block *\/$/;"	m	struct:block_def	file:
textdomain	gui_gtk.c	/^#  undef textdomain$/;"	d	file:
textdomain	gui_gtk_x11.c	/^#  undef textdomain$/;"	d	file:
textdomain	vim.h	/^#  define textdomain(/;"	d
textdomain	vim.h	/^#  undef textdomain$/;"	d
textdomain	vim.h	/^# define textdomain(/;"	d
textlen	ops.c	/^    int		textlen;	\/* chars in block *\/$/;"	m	struct:block_def	file:
textlock	globals.h	/^EXTERN int	textlock INIT(= 0);$/;"	v
textstart	ops.c	/^    char_u	*textstart;	\/* pointer to 1st char in block *\/$/;"	m	struct:block_def	file:
tgetent	termlib.c	/^tgetent(tbuf, term)$/;"	f
tgetent_error	term.c	/^tgetent_error(tbuf, term)$/;"	f	file:
tgetflag	termlib.c	/^tgetflag(id)$/;"	f
tgetnum	termlib.c	/^tgetnum(id)$/;"	f
tgetstr	term.c	/^#define tgetstr /;"	d	file:
tgetstr	term.c	/^#undef tgetstr$/;"	d	file:
tgetstr	termlib.c	/^tgetstr(id, buf)$/;"	f
tgoto	term.c	/^tgoto(cm, x, y)$/;"	f	file:
tgoto	termlib.c	/^tgoto(cm, col, line)$/;"	f
thickness	gui_at_sb.h	/^    Dimension	  thickness;	\/* either width or height *\/$/;"	m	struct:__anon64
throw_exception	ex_eval.c	/^throw_exception(value, type, cmdname)$/;"	f	file:
throw_lnum	structs.h	/^    linenr_T		throw_lnum;	\/* line number of the throw point *\/$/;"	m	struct:vim_exception
throw_msg	structs.h	/^    char_u		*throw_msg;	\/* msg to throw: usually original one *\/$/;"	m	struct:msglist
throw_name	structs.h	/^    char_u		*throw_name;	\/* name of the throw point *\/$/;"	m	struct:vim_exception
thumb	gui_at_sb.h	/^    Pixmap	  thumb;	\/* thumb color *\/$/;"	m	struct:__anon64
thumbProc	gui_at_sb.h	/^    XtCallbackList thumbProc;	\/* jump (to position) scroll *\/$/;"	m	struct:__anon64
ti_change	buffer.c	/^ti_change(str, last)$/;"	f	file:
tilde_replace	ex_getln.c	/^tilde_replace(orig_pat, num_files, files)$/;"	f
time_diff	main.c	/^time_diff(then, now)$/;"	f	file:
time_differs	fileio.c	/^time_differs(t1, t2)$/;"	f	file:
time_fd	main.c	/^static FILE *time_fd = NULL;$/;"	v	file:
time_msg	main.c	/^time_msg(msg, tv_start)$/;"	f
time_pop	main.c	/^time_pop(tp)$/;"	f
time_push	main.c	/^time_push(tv_rel, tv_start)$/;"	f
timeout_cb	gui_beval.c	/^timeout_cb(gpointer data)$/;"	f	file:
timer	gui_athena.c	/^static XtIntervalId timer = 0;	    \/* 0 = expired, otherwise active *\/$/;"	v	file:
timerID	gui_beval.h	/^    unsigned int	timerID;	\/* timer for run *\/$/;"	m	struct:BalloonEvalStruct
timerRoutine	gui_beval.c	/^timerRoutine(dx, id)$/;"	f	file:
timerUPP	if_mzsch.c	/^static EventLoopTimerUPP timerUPP;$/;"	v	file:
timer_id	gui_at_sb.h	/^    XtIntervalId  timer_id;	\/* autorepeat timer; remove on destruction *\/$/;"	m	struct:__anon64
timer_id	if_mzsch.c	/^static EventLoopTimerRef timer_id = NULL;$/;"	v	file:
timer_id	if_mzsch.c	/^static UINT timer_id = 0;$/;"	v	file:
timer_id	if_mzsch.c	/^static XtIntervalId timer_id = (XtIntervalId)0;$/;"	v	file:
timer_id	if_mzsch.c	/^static guint timer_id = 0;$/;"	v	file:
timer_proc	if_mzsch.c	/^timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)$/;"	f	file:
tip	structs.h	/^    BalloonEval *tip;		    \/* tooltip for this menu item *\/$/;"	m	struct:VimMenu
title	hardcopy.c	/^    char_u  title[256];$/;"	m	struct:prt_ps_resource_S	file:
tltoa	term.c	/^tltoa(i)$/;"	f
tm	structs.h	/^    proftime_T	tm;	\/* for a time limit *\/$/;"	m	struct:__anon96
tn_did_filefind_init	structs.h	/^    int		tn_did_filefind_init;$/;"	m	struct:__anon102
tn_hf_idx	structs.h	/^    int		tn_hf_idx;$/;"	m	struct:__anon102
tn_np	structs.h	/^    char_u	*tn_np;		\/* current position in tn_tags *\/$/;"	m	struct:__anon102
tn_search_ctx	structs.h	/^    void	*tn_search_ctx;$/;"	m	struct:__anon102
tn_tags	structs.h	/^    char_u	*tn_tags;	\/* value of 'tags' when starting *\/$/;"	m	struct:__anon102
to	digraph.c	/^    char_u	*to;$/;"	m	struct:__anon1	file:
to	menu.c	/^    char_u	*to;		\/* translated name *\/$/;"	m	struct:__anon43	file:
toF_Rjoin	farsi.c	/^toF_Rjoin(c)$/;"	f	file:
toF_TyA	farsi.c	/^toF_TyA(c)$/;"	f
toF_TyB	farsi.c	/^toF_TyB(c)$/;"	f	file:
toF_Xor_X_	farsi.c	/^toF_Xor_X_(c)$/;"	f	file:
toF_ending	farsi.c	/^toF_ending(c)$/;"	f	file:
toF_leading	farsi.c	/^toF_leading(c)$/;"	f	file:
toLower	mbyte.c	/^static convertStruct toLower[] =$/;"	v	file:
toUpper	mbyte.c	/^static convertStruct toUpper[] =$/;"	v	file:
to_device_units	hardcopy.c	/^to_device_units(idx, physsize, def_number)$/;"	f	file:
to_fp	if_cscope.h	/^    FILE *	    to_fp;	\/* to cscope: FILE. *\/$/;"	m	struct:csi
toggle_Magic	regexp.c	/^toggle_Magic(x)$/;"	f	file:
toggle_tearoff	gui_motif.c	/^toggle_tearoff(wid)$/;"	f	file:
tolower_tab	globals.h	/^EXTERN char_u	tolower_tab[256];	\/* table for tolower() *\/$/;"	v
toolBar	gui_athena.c	/^static Widget toolBar = (Widget)0;$/;"	v	file:
toolBar	gui_motif.c	/^static Widget toolBar;$/;"	v	file:
toolBarFrame	gui_motif.c	/^static Widget toolBarFrame;$/;"	v	file:
toolbar	gui.h	/^    GtkWidget	*toolbar;	    \/* toolbar *\/$/;"	m	struct:Gui
toolbar_button_focus_in_event	gui_gtk.c	/^toolbar_button_focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)$/;"	f	file:
toolbar_flags	option.h	/^EXTERN unsigned toolbar_flags;$/;"	v
toolbar_h	gui.h	/^    GtkWidget	*toolbar_h;	    \/* toolbar handle *\/$/;"	m	struct:Gui
toolbar_height	gui.h	/^    int		toolbar_height;	    \/* height of the toolbar *\/$/;"	m	struct:Gui
toolbar_height	gui.h	/^    int		toolbar_height;$/;"	m	struct:Gui
toolbar_names	menu.c	/^static const char *toolbar_names[] =$/;"	v	file:
toolbar_remove_item_by_text	gui_gtk.c	/^toolbar_remove_item_by_text(GtkToolbar *tb, const char *text)$/;"	f	file:
toolbarbutton_enter_cb	gui_motif.c	/^toolbarbutton_enter_cb(w, client_data, event, cont)$/;"	f	file:
toolbarbutton_leave_cb	gui_motif.c	/^toolbarbutton_leave_cb(w, client_data, event, cont)$/;"	f	file:
tooltip_bg_pixel	gui.h	/^    guicolor_T	tooltip_bg_pixel;	\/* tooltip background color *\/$/;"	m	struct:Gui
tooltip_fg_pixel	gui.h	/^    guicolor_T	tooltip_fg_pixel;	\/* tooltip foreground color *\/$/;"	m	struct:Gui
tooltip_fontset	gui.h	/^    XFontSet	tooltip_fontset;	\/* tooltip fontset *\/$/;"	m	struct:Gui
top	gui.h	/^    int		top;		\/* Top of scroll bar (chars from row 0) *\/$/;"	m	struct:GuiScrollbar
top	gui_at_sb.h	/^    float	  top;		\/* What percent is above the win's top *\/$/;"	m	struct:__anon64
topLoc	gui_at_sb.h	/^    Position	  topLoc;	\/* Pixel that corresponds to top *\/$/;"	m	struct:__anon64
top_bot_msg	globals.h	/^EXTERN char top_bot_msg[] INIT(= N_("search hit TOP, continuing at BOTTOM"));$/;"	v
top_file_num	buffer.c	/^static int  top_file_num = 1;		\/* highest file number *\/$/;"	v	file:
top_shadow_GC	gui_at_sb.h	/^    GC		top_shadow_GC;$/;"	m	struct:__anon64
top_shadow_contrast	gui_at_sb.h	/^    int		top_shadow_contrast;$/;"	m	struct:__anon64
top_shadow_pixel	gui_at_sb.h	/^    Pixel	top_shadow_pixel;$/;"	m	struct:__anon64
topframe	globals.h	/^EXTERN frame_T	*topframe;	\/* top of the window frame tree *\/$/;"	v
topline_back	move.c	/^topline_back(lp)$/;"	f	file:
topline_botline	move.c	/^topline_botline(lp)$/;"	f	file:
topmsg	tag.c	/^static char_u *topmsg = (char_u *)N_("E556: at top of tag stack");$/;"	v	file:
total_mem_used	memfile.c	/^static long_u	total_mem_used = 0;	\/* total memory used for memfiles *\/$/;"	v	file:
toupper_tab	globals.h	/^EXTERN char_u	toupper_tab[256];	\/* table for toupper() *\/$/;"	v
tp_ch_used	structs.h	/^    long	    tp_ch_used;	    \/* value of 'cmdheight' when frame size$/;"	m	struct:tabpage_S
tp_curwin	structs.h	/^    win_T	    *tp_curwin;	    \/* current window in this Tab page *\/$/;"	m	struct:tabpage_S
tp_diff_invalid	structs.h	/^    int		    tp_diff_invalid;	\/* list of diffs is outdated *\/$/;"	m	struct:tabpage_S
tp_diffbuf	structs.h	/^    buf_T	    *(tp_diffbuf[DB_COUNT]);$/;"	m	struct:tabpage_S
tp_first_diff	structs.h	/^    diff_T	    *tp_first_diff;$/;"	m	struct:tabpage_S
tp_firstwin	structs.h	/^    win_T	    *tp_firstwin;   \/* first window in this Tab page *\/$/;"	m	struct:tabpage_S
tp_lastwin	structs.h	/^    win_T	    *tp_lastwin;    \/* last window in this Tab page *\/$/;"	m	struct:tabpage_S
tp_next	structs.h	/^    tabpage_T	    *tp_next;	    \/* next tabpage or NULL *\/$/;"	m	struct:tabpage_S
tp_old_Columns	structs.h	/^    long	    tp_old_Columns; \/* Columns when Tab page was left *\/$/;"	m	struct:tabpage_S
tp_old_Rows	structs.h	/^    long	    tp_old_Rows;    \/* Rows when Tab page was left *\/$/;"	m	struct:tabpage_S
tp_prev_which_scrollbars	structs.h	/^    int		    tp_prev_which_scrollbars[3];$/;"	m	struct:tabpage_S
tp_prevwin	structs.h	/^    win_T	    *tp_prevwin;    \/* previous window in this Tab page *\/$/;"	m	struct:tabpage_S
tp_snapshot	structs.h	/^    frame_T	    *tp_snapshot;    \/* window layout snapshot *\/$/;"	m	struct:tabpage_S
tp_topframe	structs.h	/^    frame_T	    *tp_topframe;   \/* topframe for the windows *\/$/;"	m	struct:tabpage_S
tp_vars	structs.h	/^    dict_T	    tp_vars;	    \/* internal variables, local to tab page *\/$/;"	m	struct:tabpage_S
tp_winvar	structs.h	/^    dictitem_T	    tp_winvar;	    \/* variable for "t:" Dictionary *\/$/;"	m	struct:tabpage_S
tputs	termlib.c	/^tputs(cp, affcnt, outc)$/;"	f
trans_characters	charset.c	/^trans_characters(buf, bufsize)$/;"	f
trans_function_name	eval.c	/^trans_function_name(pp, skip, flags, fdp)$/;"	f	file:
trans_special	misc2.c	/^trans_special(srcp, dst, keycode)$/;"	f
transchar	charset.c	/^transchar(c)$/;"	f
transchar_buf	charset.c	/^static char_u	transchar_buf[7];$/;"	v	file:
transchar_byte	charset.c	/^transchar_byte(c)$/;"	f
transchar_byte	vim.h	/^# define transchar_byte(/;"	d
transchar_hex	charset.c	/^transchar_hex(buf, c)$/;"	f
transchar_nonprint	charset.c	/^transchar_nonprint(buf, c)$/;"	f
translate_mapping	term.c	/^translate_mapping(str, expmap)$/;"	f
translate_mnemonic_tag	gui_gtk.c	/^translate_mnemonic_tag(char_u *name, int use_mnemonic)$/;"	f	file:
translate_pango_attributes	mbyte.c	/^translate_pango_attributes(PangoAttrIterator *iter)$/;"	f	file:
transstr	charset.c	/^transstr(s)$/;"	f
trash_input_buf	ui.c	/^trash_input_buf()$/;"	f
tree_add_word	spell.c	/^tree_add_word(spin, word, root, flags, region, affixID)$/;"	f	file:
tree_count_words	spell.c	/^tree_count_words(byts, idxs)$/;"	f	file:
trigger_cursorhold	fileio.c	/^trigger_cursorhold()$/;"	f
trunc_string	message.c	/^trunc_string(s, buf, room)$/;"	f
truncate_line	misc1.c	/^truncate_line(fixpos)$/;"	f
truncate_spaces	edit.c	/^truncate_spaces(line)$/;"	f
trylevel	ex_docmd.c	/^    int		trylevel;$/;"	m	struct:dbg_stuff	file:
trylevel	globals.h	/^EXTERN int trylevel INIT(= 0);$/;"	v
trystate_S	spell.c	/^typedef struct trystate_S$/;"	s	file:
trystate_T	spell.c	/^} trystate_T;$/;"	t	typeref:struct:trystate_S	file:
ts	gui_beval.h	/^    int			ts;		\/* tabstop setting for this buffer *\/$/;"	m	struct:BalloonEvalStruct
ts_arridx	spell.c	/^    idx_T	ts_arridx;	\/* index in tree array, start of node *\/$/;"	m	struct:trystate_S	file:
ts_complen	spell.c	/^    char_u	ts_complen;	\/* nr of compound words used *\/$/;"	m	struct:trystate_S	file:
ts_compsplit	spell.c	/^    char_u	ts_compsplit;	\/* index for "compflags" where word was spit *\/$/;"	m	struct:trystate_S	file:
ts_curi	spell.c	/^    short	ts_curi;	\/* index in list of child nodes *\/$/;"	m	struct:trystate_S	file:
ts_delidx	spell.c	/^    char_u	ts_delidx;	\/* index in fword for char that was deleted,$/;"	m	struct:trystate_S	file:
ts_fcharstart	spell.c	/^    char_u	ts_fcharstart;	\/* index in fword where badword char started *\/$/;"	m	struct:trystate_S	file:
ts_fidx	spell.c	/^    char_u	ts_fidx;	\/* index in fword[], case-folded bad word *\/$/;"	m	struct:trystate_S	file:
ts_fidxtry	spell.c	/^    char_u	ts_fidxtry;	\/* ts_fidx at which bytes may be changed *\/$/;"	m	struct:trystate_S	file:
ts_flags	spell.c	/^    char_u	ts_flags;	\/* TSF_ flags *\/$/;"	m	struct:trystate_S	file:
ts_isdiff	spell.c	/^    char_u	ts_isdiff;	\/* DIFF_ values *\/$/;"	m	struct:trystate_S	file:
ts_prefixdepth	spell.c	/^    char_u	ts_prefixdepth;	\/* stack depth for end of prefix or$/;"	m	struct:trystate_S	file:
ts_prewordlen	spell.c	/^    char_u	ts_prewordlen;	\/* length of word in "preword[]" *\/$/;"	m	struct:trystate_S	file:
ts_save_badflags	spell.c	/^    char_u	ts_save_badflags;   \/* su_badflags saved here *\/$/;"	m	struct:trystate_S	file:
ts_score	spell.c	/^    int		ts_score;	\/* score *\/$/;"	m	struct:trystate_S	file:
ts_splitfidx	spell.c	/^    char_u	ts_splitfidx;	\/* "ts_fidx" at word split *\/$/;"	m	struct:trystate_S	file:
ts_splitoff	spell.c	/^    char_u	ts_splitoff;	\/* index in "tword" after last split *\/$/;"	m	struct:trystate_S	file:
ts_state	spell.c	/^    state_T	ts_state;	\/* state at this level, STATE_ *\/$/;"	m	struct:trystate_S	file:
ts_tcharidx	spell.c	/^    char_u	ts_tcharidx;	\/* current byte index in tword character *\/$/;"	m	struct:trystate_S	file:
ts_tcharlen	spell.c	/^    char_u	ts_tcharlen;	\/* number of bytes in tword character *\/$/;"	m	struct:trystate_S	file:
ts_twordlen	spell.c	/^    char_u	ts_twordlen;	\/* valid length of tword[] *\/$/;"	m	struct:trystate_S	file:
ttest	term.c	/^ttest(pairs)$/;"	f
ttym_flags	option.h	/^EXTERN unsigned ttym_flags;$/;"	v
tv2string	eval.c	/^tv2string(tv, tofree, numbuf, copyID)$/;"	f	file:
tv_check_lock	eval.c	/^tv_check_lock(lock, name)$/;"	f	file:
tv_equal	eval.c	/^tv_equal(tv1, tv2, ic)$/;"	f	file:
tv_float	message.c	/^tv_float(tvs, idxp)$/;"	f	file:
tv_islocked	eval.c	/^tv_islocked(tv)$/;"	f	file:
tv_nr	message.c	/^tv_nr(tvs, idxp)$/;"	f	file:
tv_op	eval.c	/^tv_op(tv1, tv2, op)$/;"	f	file:
tv_str	message.c	/^tv_str(tvs, idxp)$/;"	f	file:
type	gui.h	/^    int		type;		\/* one of SBAR_{LEFT,RIGHT,BOTTOM} *\/$/;"	m	struct:GuiScrollbar
type	hardcopy.c	/^    int		type;$/;"	m	struct:prt_dsc_comment_S	file:
type	hardcopy.c	/^    int		type;$/;"	m	struct:prt_dsc_line_S	file:
type	hardcopy.c	/^    int     type;$/;"	m	struct:prt_ps_resource_S	file:
type	structs.h	/^    int			type;		\/* exception type *\/$/;"	m	struct:vim_exception
typeahead_char	getchar.c	/^static int typeahead_char = 0;		\/* typeahead char that's not flushed *\/$/;"	v	file:
typeahead_noflush	getchar.c	/^typeahead_noflush(c)$/;"	f
typebuf	globals.h	/^EXTERN typebuf_T typebuf		\/* typeahead buffer *\/$/;"	v
typebuf_T	structs.h	/^} typebuf_T;$/;"	t	typeref:struct:__anon90
typebuf_changed	getchar.c	/^typebuf_changed(tb_change_cnt)$/;"	f
typebuf_init	getchar.c	/^static char_u	typebuf_init[TYPELEN_INIT];	\/* initial typebuf.tb_buf *\/$/;"	v	file:
typebuf_maplen	getchar.c	/^typebuf_maplen()$/;"	f
typebuf_typed	getchar.c	/^typebuf_typed()$/;"	f
typebuf_valid	structs.h	/^    int			typebuf_valid;	    \/* TRUE when save_typebuf valid *\/$/;"	m	struct:__anon91
typebuf_was_filled	globals.h	/^EXTERN int	typebuf_was_filled INIT(= FALSE); \/* received text from client$/;"	v
typenr	structs.h	/^    int		typenr;		\/* typenr of sign *\/$/;"	m	struct:signlist
typval_T	structs.h	/^} typval_T;$/;"	t	typeref:struct:__anon94
u8char_T	vim.h	/^typedef unsigned int u8char_T;	    \/* int is 32 bits *\/$/;"	t
u8char_T	vim.h	/^typedef unsigned long u8char_T;	    \/* long should be 32 bits or more *\/$/;"	t
u8char_T	vim.h	/^typedef unsigned short u8char_T;    \/* short should be 16 bits *\/$/;"	t
u_add_time	undo.c	/^u_add_time(buf, buflen, tt)$/;"	f	file:
u_alloc_line	undo.c	/^u_alloc_line(size)$/;"	f	file:
u_blockalloc	undo.c	/^u_blockalloc(size)$/;"	f	file:
u_blockfree	undo.c	/^u_blockfree(buf)$/;"	f
u_check	undo.c	/^u_check(int newhead_may_be_NULL)$/;"	f
u_check_tree	undo.c	/^u_check_tree(u_header_T *uhp,$/;"	f	file:
u_clearall	undo.c	/^u_clearall(buf)$/;"	f
u_clearline	undo.c	/^u_clearline()$/;"	f
u_doit	undo.c	/^u_doit(startcount)$/;"	f	file:
u_entry	structs.h	/^struct u_entry$/;"	s
u_entry_T	structs.h	/^typedef struct u_entry u_entry_T;$/;"	t	typeref:struct:u_entry
u_free_line	undo.c	/^u_free_line(ptr, keep)$/;"	f	file:
u_freebranch	undo.c	/^u_freebranch(buf, uhp, uhpp)$/;"	f	file:
u_freeentries	undo.c	/^u_freeentries(buf, uhp, uhpp)$/;"	f	file:
u_freeentry	undo.c	/^u_freeentry(uep, n)$/;"	f	file:
u_freeheader	undo.c	/^u_freeheader(buf, uhp, uhpp)$/;"	f	file:
u_get_headentry	undo.c	/^u_get_headentry()$/;"	f	file:
u_getbot	undo.c	/^u_getbot()$/;"	f	file:
u_header	structs.h	/^struct u_header$/;"	s
u_header_T	structs.h	/^typedef struct u_header u_header_T;$/;"	t	typeref:struct:u_header
u_inssub	undo.c	/^u_inssub(lnum)$/;"	f
u_newcount	undo.c	/^static long	u_newcount, u_oldcount;$/;"	v	file:
u_oldcount	undo.c	/^static long	u_newcount, u_oldcount;$/;"	v	file:
u_redo	undo.c	/^u_redo(count)$/;"	f
u_save	undo.c	/^u_save(top, bot)$/;"	f
u_save_cursor	undo.c	/^u_save_cursor()$/;"	f
u_save_line	undo.c	/^u_save_line(lnum)$/;"	f	file:
u_savecommon	undo.c	/^u_savecommon(top, bot, newbot)$/;"	f	file:
u_savedel	undo.c	/^u_savedel(lnum, nlines)$/;"	f
u_saveline	undo.c	/^u_saveline(lnum)$/;"	f
u_savesub	undo.c	/^u_savesub(lnum)$/;"	f
u_sync	undo.c	/^u_sync(force)$/;"	f
u_unch_branch	undo.c	/^u_unch_branch(uhp)$/;"	f	file:
u_unchanged	undo.c	/^u_unchanged(buf)$/;"	f
u_undo	undo.c	/^u_undo(count)$/;"	f
u_undo_end	undo.c	/^u_undo_end(did_undo, absolute)$/;"	f	file:
u_undoline	undo.c	/^u_undoline()$/;"	f
u_undoredo	undo.c	/^u_undoredo(undo)$/;"	f	file:
uc_add_command	ex_docmd.c	/^uc_add_command(name, name_len, rep, argt, def, flags, compl, compl_arg, force)$/;"	f	file:
uc_argt	ex_docmd.c	/^    long_u	uc_argt;	\/* The argument type *\/$/;"	m	struct:ucmd	file:
uc_check_code	ex_docmd.c	/^uc_check_code(code, len, buf, cmd, eap, split_buf, split_len)$/;"	f	file:
uc_clear	ex_docmd.c	/^uc_clear(gap)$/;"	f
uc_compl	ex_docmd.c	/^    int		uc_compl;	\/* completion type *\/$/;"	m	struct:ucmd	file:
uc_compl_arg	ex_docmd.c	/^    char_u	*uc_compl_arg;	\/* completion argument if any *\/$/;"	m	struct:ucmd	file:
uc_def	ex_docmd.c	/^    long	uc_def;		\/* The default value for a range\/count *\/$/;"	m	struct:ucmd	file:
uc_fun_cmd	ex_docmd.c	/^uc_fun_cmd()$/;"	f	file:
uc_list	ex_docmd.c	/^uc_list(name, name_len)$/;"	f	file:
uc_name	ex_docmd.c	/^    char_u	*uc_name;	\/* The command name *\/$/;"	m	struct:ucmd	file:
uc_rep	ex_docmd.c	/^    char_u	*uc_rep;	\/* The command's replacement string *\/$/;"	m	struct:ucmd	file:
uc_scan_attr	ex_docmd.c	/^uc_scan_attr(attr, len, argt, def, flags, compl, compl_arg)$/;"	f	file:
uc_scriptID	ex_docmd.c	/^    scid_T	uc_scriptID;	\/* SID where the command was defined *\/$/;"	m	struct:ucmd	file:
uc_split_args	ex_docmd.c	/^uc_split_args(arg, lenp)$/;"	f	file:
ucmd	ex_docmd.c	/^typedef struct ucmd$/;"	s	file:
ucmd_T	ex_docmd.c	/^} ucmd_T;$/;"	t	typeref:struct:ucmd	file:
ucmds	ex_docmd.c	/^static garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};$/;"	v	file:
ucs2bytes	fileio.c	/^ucs2bytes(c, pp, flags)$/;"	f	file:
ue_array	structs.h	/^    char_u	**ue_array;	\/* array of lines in undo block *\/$/;"	m	struct:u_entry
ue_bot	structs.h	/^    linenr_T	ue_bot;		\/* number of line below undo block *\/$/;"	m	struct:u_entry
ue_lcount	structs.h	/^    linenr_T	ue_lcount;	\/* linecount when u_save called *\/$/;"	m	struct:u_entry
ue_magic	structs.h	/^    int		ue_magic;	\/* magic number to check allocation *\/$/;"	m	struct:u_entry
ue_next	structs.h	/^    u_entry_T	*ue_next;	\/* pointer to next entry in list *\/$/;"	m	struct:u_entry
ue_size	structs.h	/^    long	ue_size;	\/* number of lines in ue_array *\/$/;"	m	struct:u_entry
ue_top	structs.h	/^    linenr_T	ue_top;		\/* number of line above undo block *\/$/;"	m	struct:u_entry
uf_args	eval.c	/^    garray_T	uf_args;	\/* arguments *\/$/;"	m	struct:ufunc	file:
uf_calls	eval.c	/^    int		uf_calls;	\/* nr of active calls *\/$/;"	m	struct:ufunc	file:
uf_flags	eval.c	/^    int		uf_flags;$/;"	m	struct:ufunc	file:
uf_lines	eval.c	/^    garray_T	uf_lines;	\/* function lines *\/$/;"	m	struct:ufunc	file:
uf_name	eval.c	/^    char_u	uf_name[1];	\/* name of function (actually longer); can$/;"	m	struct:ufunc	file:
uf_profiling	eval.c	/^    int		uf_profiling;	\/* TRUE when func is being profiled *\/$/;"	m	struct:ufunc	file:
uf_refcount	eval.c	/^    int		uf_refcount;	\/* for numbered function: reference count *\/$/;"	m	struct:ufunc	file:
uf_script_ID	eval.c	/^    scid_T	uf_script_ID;	\/* ID of script where function was defined,$/;"	m	struct:ufunc	file:
uf_tm_children	eval.c	/^    proftime_T	uf_tm_children;	\/* time spent in children this call *\/$/;"	m	struct:ufunc	file:
uf_tm_count	eval.c	/^    int		uf_tm_count;	\/* nr of calls *\/$/;"	m	struct:ufunc	file:
uf_tm_self	eval.c	/^    proftime_T	uf_tm_self;	\/* time spent in function itself *\/$/;"	m	struct:ufunc	file:
uf_tm_total	eval.c	/^    proftime_T	uf_tm_total;	\/* time spent in function + children *\/$/;"	m	struct:ufunc	file:
uf_tml_children	eval.c	/^    proftime_T	uf_tml_children; \/* time spent in children for this line *\/$/;"	m	struct:ufunc	file:
uf_tml_count	eval.c	/^    int		*uf_tml_count;	\/* nr of times line was executed *\/$/;"	m	struct:ufunc	file:
uf_tml_execed	eval.c	/^    int		uf_tml_execed;	\/* line being timed was executed *\/$/;"	m	struct:ufunc	file:
uf_tml_idx	eval.c	/^    int		uf_tml_idx;	\/* index of line being timed; -1 if none *\/$/;"	m	struct:ufunc	file:
uf_tml_self	eval.c	/^    proftime_T	*uf_tml_self;	\/* time spent in a line itself *\/$/;"	m	struct:ufunc	file:
uf_tml_start	eval.c	/^    proftime_T	uf_tml_start;	\/* start time for current line *\/$/;"	m	struct:ufunc	file:
uf_tml_total	eval.c	/^    proftime_T	*uf_tml_total;	\/* time spent in a line + children *\/$/;"	m	struct:ufunc	file:
uf_tml_wait	eval.c	/^    proftime_T	uf_tml_wait;	\/* start wait time for current line *\/$/;"	m	struct:ufunc	file:
uf_varargs	eval.c	/^    int		uf_varargs;	\/* variable nr of arguments *\/$/;"	m	struct:ufunc	file:
ufunc	eval.c	/^struct ufunc$/;"	s	file:
ufunc_T	eval.c	/^typedef struct ufunc ufunc_T;$/;"	t	typeref:struct:ufunc	file:
uh_alt_next	structs.h	/^    u_header_T	*uh_alt_next;	\/* pointer to next header for alt. redo *\/$/;"	m	struct:u_header
uh_alt_prev	structs.h	/^    u_header_T	*uh_alt_prev;	\/* pointer to previous header for alt. redo *\/$/;"	m	struct:u_header
uh_cursor	structs.h	/^    pos_T	uh_cursor;	\/* cursor position before saving *\/$/;"	m	struct:u_header
uh_cursor_vcol	structs.h	/^    long	uh_cursor_vcol;$/;"	m	struct:u_header
uh_entry	structs.h	/^    u_entry_T	*uh_entry;	\/* pointer to first entry *\/$/;"	m	struct:u_header
uh_flags	structs.h	/^    int		uh_flags;	\/* see below *\/$/;"	m	struct:u_header
uh_getbot_entry	structs.h	/^    u_entry_T	*uh_getbot_entry; \/* pointer to where ue_bot must be set *\/$/;"	m	struct:u_header
uh_magic	structs.h	/^    int		uh_magic;	\/* magic number to check allocation *\/$/;"	m	struct:u_header
uh_namedm	structs.h	/^    pos_T	uh_namedm[NMARKS];	\/* marks before undo\/after redo *\/$/;"	m	struct:u_header
uh_next	structs.h	/^    u_header_T	*uh_next;	\/* pointer to next undo header in list *\/$/;"	m	struct:u_header
uh_prev	structs.h	/^    u_header_T	*uh_prev;	\/* pointer to previous header in list *\/$/;"	m	struct:u_header
uh_seq	structs.h	/^    long	uh_seq;		\/* sequence number, higher == newer undo *\/$/;"	m	struct:u_header
uh_time	structs.h	/^    time_t	uh_time;	\/* timestamp when the change was made *\/$/;"	m	struct:u_header
uh_visual	structs.h	/^    visualinfo_T uh_visual;	\/* Visual areas before undo\/after redo *\/$/;"	m	struct:u_header
uh_walk	structs.h	/^    int		uh_walk;	\/* used by undo_time() *\/$/;"	m	struct:u_header
ui_breakcheck	ui.c	/^ui_breakcheck()$/;"	f
ui_char_avail	ui.c	/^ui_char_avail()$/;"	f
ui_cursor_shape	ui.c	/^ui_cursor_shape()$/;"	f
ui_delay	ui.c	/^ui_delay(msec, ignoreinput)$/;"	f
ui_focus_change	ui.c	/^ui_focus_change(in_focus)$/;"	f
ui_get_shellsize	ui.c	/^ui_get_shellsize()$/;"	f
ui_inchar	ui.c	/^ui_inchar(buf, maxlen, wtime, tb_change_cnt)$/;"	f
ui_inchar_undo	ui.c	/^ui_inchar_undo(s, len)$/;"	f
ui_new_shellsize	ui.c	/^ui_new_shellsize()$/;"	f
ui_set_shellsize	ui.c	/^ui_set_shellsize(mustset)$/;"	f
ui_suspend	ui.c	/^ui_suspend()$/;"	f
ui_write	ui.c	/^ui_write(s, len)$/;"	f
ulg	misc2.c	/^typedef unsigned long  ulg;	\/* unsigned 32-bit value *\/$/;"	t	file:
uline_offset	hardcopy.c	/^    int		uline_offset;$/;"	m	struct:prt_ps_font_S	file:
uline_width	hardcopy.c	/^    int		uline_width;$/;"	m	struct:prt_ps_font_S	file:
un_Magic	regexp.c	/^#define un_Magic(/;"	d	file:
unadjust_for_sel	normal.c	/^unadjust_for_sel()$/;"	f	file:
unblock_autocmds	fileio.c	/^unblock_autocmds()$/;"	f
unchanged	misc1.c	/^unchanged(buf, ff)$/;"	f
undercurl	structs.h	/^    int		undercurl;$/;"	m	struct:__anon99
underline	structs.h	/^    int		underline;$/;"	m	struct:__anon99
undisplay_dollar	edit.c	/^undisplay_dollar()$/;"	f	file:
undo	gui_motif.c	/^    Widget undo;	\/* 'Undo' action button *\/$/;"	m	struct:_SharedFindReplace	file:
undo_allowed	undo.c	/^undo_allowed()$/;"	f
undo_off	globals.h	/^EXTERN int	undo_off INIT(= FALSE);	    \/* undo switched off for now *\/$/;"	v
undo_time	undo.c	/^undo_time(step, sec, absolute)$/;"	f
undo_undoes	undo.c	/^static int	undo_undoes = FALSE;$/;"	v	file:
undrawBalloon	gui_beval.c	/^undrawBalloon(BalloonEval *beval)$/;"	f	file:
undrawBalloon	gui_beval.c	/^undrawBalloon(beval)$/;"	f	file:
ungetchr	regexp.c	/^ungetchr()$/;"	f	file:
unix_expandpath	misc1.c	/^unix_expandpath(gap, path, wildoff, flags, didstar)$/;"	f
unload_dummy_buffer	quickfix.c	/^unload_dummy_buffer(buf)$/;"	f	file:
unputcmdline	ex_getln.c	/^unputcmdline()$/;"	f
unrecognised_message	integration.c	/^unrecognised_message($/;"	f
unref_extmatch	regexp.c	/^unref_extmatch(em)$/;"	f
unshift_special	normal.c	/^unshift_special(cap)$/;"	f	file:
unshowmode	screen.c	/^unshowmode(force)$/;"	f
up	gui_gtk.c	/^    GtkWidget *up;	\/* search direction 'Up' radio button *\/$/;"	m	struct:_SharedFindReplace	file:
up	gui_motif.c	/^    Widget up;		\/* search direction 'Up' radio button *\/$/;"	m	struct:_SharedFindReplace	file:
updatePriority	workshop.c	/^updatePriority($/;"	f	file:
updateWindow	screen.c	/^updateWindow(wp)$/;"	f
update_curbuf	screen.c	/^update_curbuf(type)$/;"	f
update_curswant	move.c	/^update_curswant()$/;"	f
update_debug_sign	screen.c	/^update_debug_sign(buf, lnum)$/;"	f
update_finish	screen.c	/^update_finish()$/;"	f	file:
update_force_abort	ex_eval.c	/^update_force_abort()$/;"	f
update_keys	misc2.c	/^update_keys(c)$/;"	f
update_mouseshape	misc2.c	/^update_mouseshape(shape_idx)$/;"	f
update_prepare	screen.c	/^update_prepare()$/;"	f	file:
update_screen	screen.c	/^update_screen(type)$/;"	f
update_si_attr	syntax.c	/^update_si_attr(idx)$/;"	f	file:
update_si_end	syntax.c	/^update_si_end(sip, startcol, force)$/;"	f	file:
update_tcap	term.c	/^update_tcap(attr)$/;"	f
update_topline	move.c	/^update_topline()$/;"	f
update_topline_cursor	ex_docmd.c	/^update_topline_cursor()$/;"	f
update_topline_redraw	move.c	/^update_topline_redraw()$/;"	f
update_window_manager_hints	gui_gtk_x11.c	/^update_window_manager_hints(int force_width, int force_height)$/;"	f	file:
updatescript	getchar.c	/^updatescript(c)$/;"	f
updating_screen	globals.h	/^EXTERN int	updating_screen INIT(= FALSE);$/;"	v
usage	if_cscope.h	/^    char *  usage;$/;"	m	struct:__anon68
usage	main.c	/^usage()$/;"	f	file:
use_debug_break_level	main.c	/^    int		use_debug_break_level;$/;"	m	struct:__anon39	file:
use_ef	main.c	/^    char_u	*use_ef;		\/* 'errorfile' from -q argument *\/$/;"	m	struct:__anon39	file:
use_gvimrc	globals.h	/^EXTERN char_u	*use_gvimrc INIT(= NULL);	\/* "-U" cmdline argument *\/$/;"	v
use_midword	spell.c	/^use_midword(lp, buf)$/;"	f	file:
use_multibytecode	regexp.c	/^use_multibytecode(c)$/;"	f	file:
use_reg_one	structs.h	/^    int		use_reg_one;	\/* TRUE if delete uses reg 1 even when not$/;"	m	struct:oparg_S
use_status_area	mbyte.c	/^static gboolean	use_status_area = 0;$/;"	v	file:
use_viminfo	globals.h	/^EXTERN char_u	*use_viminfo INIT(= NULL);  \/* name of viminfo file to use *\/$/;"	v
use_vimrc	main.c	/^    char_u	*use_vimrc;		\/* vimrc from -u argument *\/$/;"	m	struct:__anon39	file:
use_xterm_like_mouse	os_unix.c	/^use_xterm_like_mouse(name)$/;"	f
use_xterm_mouse	os_unix.c	/^use_xterm_mouse()$/;"	f
used_for	structs.h	/^    char	used_for;	\/* SHAPE_MOUSE and\/or SHAPE_CURSOR *\/$/;"	m	struct:cursor_entry
usefilter	ex_cmds.h	/^    int		usefilter;	\/* TRUE with ":w !command" and ":r!command" *\/$/;"	m	struct:exarg
user_abort	structs.h	/^    int		user_abort;$/;"	m	struct:__anon100
user_digraphs	digraph.c	/^static garray_T	user_digraphs = {0, 0, sizeof(digr_T), 10, NULL};$/;"	v	file:
userhl	structs.h	/^    int		userhl;		\/* 0: no HL, 1-9: User HL, < 0 for syn ID *\/$/;"	m	struct:stl_hlrec
useridx	ex_cmds.h	/^    int		useridx;	\/* user command index *\/$/;"	m	struct:exarg
username	misc2.c	/^static char_u	*username = NULL; \/* cached result of mch_get_user_name() *\/$/;"	v	file:
ush	misc2.c	/^typedef unsigned short ush;	\/* unsigned 16-bit value *\/$/;"	t	file:
usingNetbeans	globals.h	/^EXTERN int usingNetbeans INIT(= 0);	\/* set if -nb flag is used *\/$/;"	v
usingSunWorkShop	workshop.c	/^int		 usingSunWorkShop = 0;	\/* set if -ws flag is used *\/$/;"	v
using_gnome	gui_gtk_x11.c	/^# define using_gnome /;"	d	file:
using_gnome	gui_gtk_x11.c	/^static int using_gnome = 0;$/;"	v	file:
using_script	getchar.c	/^using_script()$/;"	f
utf8_string_atom	gui_gtk_x11.c	/^static GdkAtom utf8_string_atom = GDK_NONE;$/;"	v	file:
utf8len_tab	mbyte.c	/^static char utf8len_tab[256] =$/;"	v	file:
utf_byte2len	mbyte.c	/^utf_byte2len(b)$/;"	f
utf_char2bytes	mbyte.c	/^utf_char2bytes(c, buf)$/;"	f
utf_char2cells	mbyte.c	/^utf_char2cells(c)$/;"	f
utf_char2len	mbyte.c	/^utf_char2len(c)$/;"	f
utf_class	mbyte.c	/^utf_class(c)$/;"	f
utf_composinglike	mbyte.c	/^utf_composinglike(p1, p2)$/;"	f
utf_convert	mbyte.c	/^utf_convert(a, table, tableSize)$/;"	f	file:
utf_find_illegal	mbyte.c	/^utf_find_illegal()$/;"	f
utf_fold	mbyte.c	/^utf_fold(a)$/;"	f
utf_head_off	mbyte.c	/^utf_head_off(base, p)$/;"	f
utf_iscomposing	mbyte.c	/^utf_iscomposing(c)$/;"	f
utf_islower	mbyte.c	/^utf_islower(a)$/;"	f
utf_isupper	mbyte.c	/^utf_isupper(a)$/;"	f
utf_off2cells	mbyte.c	/^utf_off2cells(off, max_off)$/;"	f
utf_printable	mbyte.c	/^utf_printable(c)$/;"	f
utf_ptr2cells	mbyte.c	/^utf_ptr2cells(p)$/;"	f
utf_ptr2char	mbyte.c	/^utf_ptr2char(p)$/;"	f
utf_ptr2len	mbyte.c	/^utf_ptr2len(p)$/;"	f
utf_ptr2len_len	mbyte.c	/^utf_ptr2len_len(p, size)$/;"	f
utf_tolower	mbyte.c	/^utf_tolower(a)$/;"	f
utf_toupper	mbyte.c	/^utf_toupper(a)$/;"	f
utf_valid_string	mbyte.c	/^utf_valid_string(s, end)$/;"	f
utfc_char2bytes	mbyte.c	/^utfc_char2bytes(off, buf)$/;"	f
utfc_ptr2char	mbyte.c	/^utfc_ptr2char(p, pcc)$/;"	f
utfc_ptr2char_len	mbyte.c	/^utfc_ptr2char_len(p, pcc, maxlen)$/;"	f
utfc_ptr2len	mbyte.c	/^utfc_ptr2len(p)$/;"	f
utfc_ptr2len_len	mbyte.c	/^utfc_ptr2len_len(p, size)$/;"	f
vOrigin	gui_at_fs.c	/^    int		vOrigin;$/;"	m	struct:__anon14	file:
v_dict	structs.h	/^	dict_T		*v_dict;	\/* dict value (can be NULL!) *\/$/;"	m	union:__anon94::__anon95
v_exception	eval.c	/^v_exception(oldval)$/;"	f
v_float	structs.h	/^	float_T		v_float;	\/* floating number value *\/$/;"	m	union:__anon94::__anon95
v_list	structs.h	/^	list_T		*v_list;	\/* list value (can be NULL!) *\/$/;"	m	union:__anon94::__anon95
v_lock	structs.h	/^    char	v_lock;	    \/* see below: VAR_LOCKED, VAR_FIXED *\/$/;"	m	struct:__anon94
v_number	structs.h	/^	varnumber_T	v_number;	\/* number value *\/$/;"	m	union:__anon94::__anon95
v_string	structs.h	/^	char_u		*v_string;	\/* string value (can be NULL!) *\/$/;"	m	union:__anon94::__anon95
v_swap_corners	normal.c	/^v_swap_corners(cmdchar)$/;"	f	file:
v_throwpoint	eval.c	/^v_throwpoint(oldval)$/;"	f
v_type	structs.h	/^    char	v_type;	    \/* see below: VAR_NUMBER, VAR_STRING, etc. *\/$/;"	m	struct:__anon94
v_visop	normal.c	/^v_visop(cap)$/;"	f	file:
valid_tabpage	window.c	/^valid_tabpage(tpc)$/;"	f
valid_word_prefix	spell.c	/^valid_word_prefix(totprefcnt, arridx, flags, word, slang, cond_req)$/;"	f	file:
valid_yank_reg	ops.c	/^valid_yank_reg(regname, writing)$/;"	f
validate_botline	move.c	/^validate_botline()$/;"	f
validate_botline_win	move.c	/^validate_botline_win(wp)$/;"	f	file:
validate_cheight	move.c	/^validate_cheight()$/;"	f	file:
validate_cline_row	move.c	/^validate_cline_row()$/;"	f
validate_current_state	syntax.c	/^validate_current_state()$/;"	f	file:
validate_cursor	move.c	/^validate_cursor()$/;"	f
validate_cursor_col	move.c	/^validate_cursor_col()$/;"	f
validate_maphash	getchar.c	/^validate_maphash()$/;"	f	file:
validate_virtcol	move.c	/^validate_virtcol()$/;"	f
validate_virtcol_win	move.c	/^validate_virtcol_win(wp)$/;"	f
value	gui.h	/^    long	value;		\/* Represents top line number visible *\/$/;"	m	struct:GuiScrollbar
value	structs.h	/^    char_u		*value;		\/* exception value *\/$/;"	m	struct:vim_exception
value_table_for_3	hangulin.c	/^static char_u value_table_for_3[] =$/;"	v	file:
var	eval.c	/^	dictitem_T	var;		\/* variable (without room for name) *\/$/;"	m	struct:funccall_S::__anon3	file:
var	option.c	/^    char_u	*var;		\/* global option: pointer to variable;$/;"	m	struct:vimoption	file:
var2fpos	eval.c	/^var2fpos(varp, dollar_lnum, fnum)$/;"	f	file:
var_check_fixed	eval.c	/^var_check_fixed(flags, name)$/;"	f	file:
var_check_ro	eval.c	/^var_check_ro(flags, name)$/;"	f	file:
var_flavour	eval.c	/^var_flavour(varname)$/;"	f	file:
var_flavour_T	eval.c	/^} var_flavour_T;$/;"	t	typeref:enum:__anon7	file:
var_redir_start	eval.c	/^var_redir_start(name, append)$/;"	f
var_redir_stop	eval.c	/^var_redir_stop()$/;"	f
var_redir_str	eval.c	/^var_redir_str(value, value_len)$/;"	f
varnamebuf	eval.c	/^static char_u	*varnamebuf = NULL;$/;"	v	file:
varnamebuflen	eval.c	/^static int	varnamebuflen = 0;$/;"	v	file:
varnumber_T	structs.h	/^typedef int	varnumber_T;$/;"	t
varnumber_T	structs.h	/^typedef long	varnumber_T;$/;"	t
vars_clear	eval.c	/^vars_clear(ht)$/;"	f
vars_clear_ext	eval.c	/^vars_clear_ext(ht, free_val)$/;"	f	file:
vc_cpfrom	structs.h	/^    int		vc_cpfrom;	\/* codepage to convert from (CONV_CODEPAGE) *\/$/;"	m	struct:__anon92
vc_cpto	structs.h	/^    int		vc_cpto;	\/* codepage to convert to (CONV_CODEPAGE) *\/$/;"	m	struct:__anon92
vc_factor	structs.h	/^    int		vc_factor;	\/* max. expansion factor *\/$/;"	m	struct:__anon92
vc_fail	structs.h	/^    int		vc_fail;	\/* fail for invalid char, don't use '?' *\/$/;"	m	struct:__anon92
vc_fd	structs.h	/^    iconv_t	vc_fd;		\/* for CONV_ICONV *\/$/;"	m	struct:__anon92
vc_type	structs.h	/^    int		vc_type;	\/* zero or one of the CONV_ values *\/$/;"	m	struct:__anon92
vcol2col	ui.c	/^vcol2col(wp, lnum, vcol)$/;"	f
ve_flags	option.h	/^EXTERN unsigned ve_flags;$/;"	v
verb	integration.h	/^	char		*verb;$/;"	m	struct:__anon71
verb	workshop.c	/^    char	*verb;			\/* menu verb *\/$/;"	m	struct:__anon62	file:
verb_msg	message.c	/^verb_msg(s)$/;"	f
verbose_did_open	message.c	/^static int  verbose_did_open = FALSE;$/;"	v	file:
verbose_enter	message.c	/^verbose_enter()$/;"	f
verbose_enter_scroll	message.c	/^verbose_enter_scroll()$/;"	f
verbose_fd	message.c	/^static FILE *verbose_fd = NULL;$/;"	v	file:
verbose_leave	message.c	/^verbose_leave()$/;"	f
verbose_leave_scroll	message.c	/^verbose_leave_scroll()$/;"	f
verbose_open	message.c	/^verbose_open()$/;"	f
verbose_stop	message.c	/^verbose_stop()$/;"	f
verbose_write	message.c	/^verbose_write(str, maxlen)$/;"	f	file:
version	hardcopy.c	/^    char_u  version[256];$/;"	m	struct:prt_ps_resource_S	file:
version_msg	version.c	/^version_msg(s)$/;"	f	file:
vgetc	getchar.c	/^vgetc()$/;"	f
vgetc_busy	globals.h	/^EXTERN int	vgetc_busy INIT(= 0);	    \/* when inside vgetc() then > 0 *\/$/;"	v
vgetc_im_active	globals.h	/^EXTERN int	vgetc_im_active;	\/* Input Method was active for last$/;"	v
vgetorpeek	getchar.c	/^vgetorpeek(advance)$/;"	f	file:
vi_curswant	structs.h	/^    colnr_T	vi_curswant;	\/* MAXCOL from w_curswant *\/$/;"	m	struct:__anon82
vi_end	structs.h	/^    pos_T	vi_end;		\/* end position of last VIsual *\/$/;"	m	struct:__anon82
vi_mode	structs.h	/^    int		vi_mode;	\/* VIsual_mode of last VIsual *\/$/;"	m	struct:__anon82
vi_start	structs.h	/^    pos_T	vi_start;	\/* start pos of last VIsual *\/$/;"	m	struct:__anon82
vimContainer	gui.h	/^    PtWidget_t	*vimContainer;		\/* PtPanel *\/$/;"	m	struct:Gui
vimForm	gui_athena.c	/^static Widget vimForm = (Widget)0;$/;"	v	file:
vimForm	gui_motif.c	/^static Widget vimForm;$/;"	v	file:
vimMenuBar	gui.h	/^    PtWidget_t	*vimMenuBar;$/;"	m	struct:Gui
vimProperty	if_xcmdsrv.c	/^static Atom	vimProperty = None;$/;"	v	file:
vimShell	gui_x11.c	/^Widget vimShell = (Widget)0;$/;"	v
vimTextArea	gui.h	/^    PtWidget_t	*vimTextArea;		\/* PtRaw *\/$/;"	m	struct:Gui
vimToolBar	gui.h	/^    PtWidget_t	*vimToolBar;$/;"	m	struct:Gui
vimToolBarGroup	gui.h	/^    PtWidget_t	*vimToolBarGroup;$/;"	m	struct:Gui
vimWindow	gui.h	/^    PtWidget_t	*vimWindow;		\/* PtWindow *\/$/;"	m	struct:Gui
vim_FullName	window.c	/^vim_FullName(fname, buf, len, force)$/;"	f
vim_SelFile	gui_at_fs.c	/^vim_SelFile(toplevel, prompt, init_path, show_entry, x, y, fg, bg, scroll_fg, scroll_bg)$/;"	f
vim_XawScrollbarSetThumb	gui_at_sb.c	/^vim_XawScrollbarSetThumb(w, top, shown, max)$/;"	f
vim_acl_T	vim.h	/^typedef void	    *vim_acl_T;		\/* dummy to pass an ACL to a function *\/$/;"	t
vim_acl_solaris_T	os_unix.c	/^typedef struct vim_acl_solaris_T {$/;"	s	file:
vim_acl_solaris_T	os_unix.c	/^} vim_acl_solaris_T;$/;"	t	typeref:struct:vim_acl_solaris_T	file:
vim_atom	gui_gtk_x11.c	/^static GdkAtom vim_atom = GDK_NONE;	\/* Vim's own special selection format *\/$/;"	v	file:
vim_atom	ui.c	/^static Atom	vim_atom;	\/* Vim's own special selection format *\/$/;"	v	file:
vim_backtick	misc1.c	/^vim_backtick(p)$/;"	f	file:
vim_beep	misc1.c	/^vim_beep()$/;"	f
vim_buffer_validp	if_mzsch.c	/^vim_buffer_validp(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
vim_bufferp	if_mzsch.c	/^vim_bufferp(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
vim_chdir	misc2.c	/^vim_chdir(new_dir)$/;"	f
vim_chdirfile	misc2.c	/^vim_chdirfile(fname)$/;"	f
vim_code0	gui_x11.c	/^    char_u  vim_code0;$/;"	m	struct:specialkey	file:
vim_code1	gui_x11.c	/^    char_u  vim_code1;$/;"	m	struct:specialkey	file:
vim_command	if_mzsch.c	/^vim_command(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
vim_command	if_ruby.c	/^static VALUE vim_command(VALUE self, VALUE str)$/;"	f	file:
vim_deltempdir	fileio.c	/^vim_deltempdir()$/;"	f
vim_dialog_yesno	message.c	/^vim_dialog_yesno(type, title, message, dflt)$/;"	f
vim_dialog_yesnoallcancel	message.c	/^vim_dialog_yesnoallcancel(type, title, message, dflt)$/;"	f
vim_dialog_yesnocancel	message.c	/^vim_dialog_yesnocancel(type, title, message, dflt)$/;"	f
vim_error_check	if_mzsch.c	/^vim_error_check(void)$/;"	f	file:
vim_eval	if_mzsch.c	/^vim_eval(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
vim_evaluate	if_ruby.c	/^static VALUE vim_evaluate(VALUE self, VALUE str)$/;"	f	file:
vim_exception	structs.h	/^struct vim_exception$/;"	s
vim_exn	if_mzsch.c	/^static Scheme_Object *vim_exn = NULL; \/* Vim Error exception *\/$/;"	v	file:
vim_exn_names	if_mzsch.c	/^static Scheme_Object *vim_exn_names = NULL;$/;"	v	file:
vim_exn_values	if_mzsch.c	/^static Scheme_Object *vim_exn_values = NULL;$/;"	v	file:
vim_fexists	misc1.c	/^vim_fexists(fname)$/;"	f
vim_fgets	fileio.c	/^vim_fgets(buf, size, fp)$/;"	f
vim_findfile	misc2.c	/^vim_findfile(search_ctx_arg)$/;"	f
vim_findfile_cleanup	misc2.c	/^vim_findfile_cleanup(ctx)$/;"	f
vim_findfile_free_visited	misc2.c	/^vim_findfile_free_visited(search_ctx_arg)$/;"	f
vim_findfile_free_visited_list	misc2.c	/^vim_findfile_free_visited_list(list_headp)$/;"	f	file:
vim_findfile_init	misc2.c	/^vim_findfile_init(path, filename, stopdirs, level, free_visited, find_what,$/;"	f
vim_findfile_stopdir	misc2.c	/^vim_findfile_stopdir(buf)$/;"	f
vim_fnamecmp	misc1.c	/^vim_fnamecmp(x, y)$/;"	f
vim_fnamencmp	misc1.c	/^vim_fnamencmp(x, y, len)$/;"	f
vim_free	misc2.c	/^vim_free(x)$/;"	f
vim_free_in_input_buf	ui.c	/^vim_free_in_input_buf()$/;"	f
vim_getenv	misc1.c	/^vim_getenv(name, mustfree)$/;"	f
vim_handle_signal	os_unix.c	/^vim_handle_signal(sig)$/;"	f
vim_handle_signal	vim.h	/^# define vim_handle_signal(/;"	d
vim_isAbsName	window.c	/^vim_isAbsName(name)$/;"	f
vim_isIDc	charset.c	/^vim_isIDc(c)$/;"	f
vim_is_ctrl_x_key	edit.c	/^vim_is_ctrl_x_key(c)$/;"	f
vim_is_fastterm	os_unix.c	/^vim_is_fastterm(name)$/;"	f
vim_is_input_buf_empty	ui.c	/^vim_is_input_buf_empty()$/;"	f
vim_is_input_buf_full	ui.c	/^vim_is_input_buf_full()$/;"	f
vim_is_iris	os_unix.c	/^vim_is_iris(name)$/;"	f
vim_is_vt300	os_unix.c	/^vim_is_vt300(name)$/;"	f
vim_is_xterm	os_unix.c	/^vim_is_xterm(name)$/;"	f
vim_isblankline	charset.c	/^vim_isblankline(lbuf)$/;"	f
vim_isbreak	macros.h	/^#define vim_isbreak(/;"	d
vim_isdigit	charset.c	/^vim_isdigit(c)$/;"	f
vim_isfilec	charset.c	/^vim_isfilec(c)$/;"	f
vim_isfilec_or_wc	charset.c	/^vim_isfilec_or_wc(c)$/;"	f
vim_islower	charset.c	/^vim_islower(c)$/;"	f
vim_ispathlistsep	misc1.c	/^vim_ispathlistsep(c)$/;"	f
vim_ispathsep	misc1.c	/^vim_ispathsep(c)$/;"	f
vim_isprintc	charset.c	/^vim_isprintc(c)$/;"	f
vim_isprintc_strict	charset.c	/^vim_isprintc_strict(c)$/;"	f
vim_isspace	misc2.c	/^vim_isspace(x)$/;"	f
vim_isupper	charset.c	/^vim_isupper(c)$/;"	f
vim_iswhite	vim.h	/^#define vim_iswhite(/;"	d
vim_iswordc	charset.c	/^vim_iswordc(c)$/;"	f
vim_iswordc_buf	charset.c	/^vim_iswordc_buf(p, buf)$/;"	f
vim_iswordp	charset.c	/^vim_iswordp(p)$/;"	f
vim_isxdigit	charset.c	/^vim_isxdigit(c)$/;"	f
vim_mem_profile_dump	misc2.c	/^vim_mem_profile_dump()$/;"	f
vim_memcmp	misc2.c	/^vim_memcmp(b1, b2, len)$/;"	f
vim_memcmp	vim.h	/^#  define vim_memcmp(/;"	d
vim_memcmp	vim.h	/^# define vim_memcmp(/;"	d
vim_memset	misc2.c	/^vim_memset(ptr, c, size)$/;"	f
vim_memset	vim.h	/^# define vim_memset(/;"	d
vim_message	if_ruby.c	/^static VALUE vim_message(VALUE self, VALUE str)$/;"	f	file:
vim_mkdir	os_unix.h	/^#  define vim_mkdir(/;"	d
vim_mkdir_emsg	ex_docmd.c	/^vim_mkdir_emsg(name, prot)$/;"	f
vim_mz_buffer	if_mzsch.c	/^} vim_mz_buffer;$/;"	t	typeref:struct:__anon21	file:
vim_mz_window	if_mzsch.c	/^} vim_mz_window;$/;"	t	typeref:struct:__anon22	file:
vim_read	vim.h	/^# define vim_read(/;"	d
vim_realloc	vim.h	/^# define vim_realloc(/;"	d
vim_regcomp	regexp.c	/^vim_regcomp(expr, re_flags)$/;"	f
vim_regcomp_had_eol	regexp.c	/^vim_regcomp_had_eol()$/;"	f
vim_regexec	regexp.c	/^vim_regexec(rmp, line, col)$/;"	f
vim_regexec_both	regexp.c	/^vim_regexec_both(line, col, tm)$/;"	f	file:
vim_regexec_multi	regexp.c	/^vim_regexec_multi(rmp, win, buf, lnum, col, tm)$/;"	f
vim_regexec_nl	regexp.c	/^vim_regexec_nl(rmp, line, col)$/;"	f
vim_regsub	regexp.c	/^vim_regsub(rmp, source, dest, copy, magic, backslash)$/;"	f
vim_regsub_both	regexp.c	/^vim_regsub_both(source, dest, copy, magic, backslash)$/;"	f	file:
vim_regsub_multi	regexp.c	/^vim_regsub_multi(rmp, lnum, source, dest, copy, magic, backslash)$/;"	f
vim_rename	fileio.c	/^vim_rename(from, to)$/;"	f
vim_resources	gui_x11.c	/^static XtResource vim_resources[] =$/;"	v	file:
vim_scrollbarClassRec	gui_at_sb.c	/^ScrollbarClassRec vim_scrollbarClassRec =$/;"	v
vim_scrollbarWidgetClass	gui_at_sb.c	/^WidgetClass vim_scrollbarWidgetClass = (WidgetClass)&vim_scrollbarClassRec;$/;"	v
vim_set_option	if_ruby.c	/^static VALUE vim_set_option(VALUE self, VALUE str)$/;"	f	file:
vim_setenv	misc1.c	/^vim_setenv(name, val)$/;"	f
vim_snprintf	message.c	/^vim_snprintf(char *str, size_t str_m, char *fmt, ...)$/;"	f
vim_str2nr	charset.c	/^vim_str2nr(start, hexp, len, dooct, dohex, nptr, unptr)$/;"	f
vim_strbyte	misc2.c	/^vim_strbyte(string, c)$/;"	f
vim_strchr	misc2.c	/^vim_strchr(string, c)$/;"	f
vim_stricmp	misc2.c	/^vim_stricmp(s1, s2)$/;"	f
vim_strncpy	misc2.c	/^vim_strncpy(to, from, len)$/;"	f
vim_strnicmp	misc2.c	/^vim_strnicmp(s1, s2, len)$/;"	f
vim_strnsave	misc2.c	/^vim_strnsave(string, len)$/;"	f
vim_strnsave_up	misc2.c	/^vim_strnsave_up(string, len)$/;"	f
vim_strnsize	charset.c	/^vim_strnsize(s, len)$/;"	f
vim_strpbrk	misc2.c	/^#   undef vim_strpbrk$/;"	d	file:
vim_strpbrk	misc2.c	/^vim_strpbrk(s, charset)$/;"	f
vim_strpbrk	vim.h	/^# define vim_strpbrk(/;"	d
vim_strrchr	misc2.c	/^vim_strrchr(string, c)$/;"	f
vim_strsave	misc2.c	/^vim_strsave(string)$/;"	f
vim_strsave_escape_csi	getchar.c	/^vim_strsave_escape_csi(p)$/;"	f
vim_strsave_escaped	misc2.c	/^vim_strsave_escaped(string, esc_chars)$/;"	f
vim_strsave_escaped_ext	misc2.c	/^vim_strsave_escaped_ext(string, esc_chars, cc, bsl)$/;"	f
vim_strsave_fnameescape	ex_getln.c	/^vim_strsave_fnameescape(fname, shell)$/;"	f
vim_strsave_shellescape	misc2.c	/^vim_strsave_shellescape(string, do_special)$/;"	f
vim_strsave_up	misc2.c	/^vim_strsave_up(string)$/;"	f
vim_strsize	charset.c	/^vim_strsize(s)$/;"	f
vim_strup	misc2.c	/^vim_strup(p)$/;"	f
vim_tcl_init	if_tcl.c	/^vim_tcl_init(arg)$/;"	f
vim_tempdir	globals.h	/^EXTERN char_u	*vim_tempdir INIT(= NULL); \/* Name of Vim's own temp dir.$/;"	v
vim_tempname	fileio.c	/^vim_tempname(extra_char)$/;"	f
vim_tgetstr	term.c	/^vim_tgetstr(s, pp)$/;"	f	file:
vim_tolower	charset.c	/^vim_tolower(c)$/;"	f
vim_toupper	charset.c	/^vim_toupper(c)$/;"	f
vim_unescape_csi	getchar.c	/^vim_unescape_csi(p)$/;"	f
vim_used_in_input_buf	ui.c	/^vim_used_in_input_buf()$/;"	f
vim_version_dir	misc1.c	/^vim_version_dir(vimdir)$/;"	f	file:
vim_vsnprintf	message.c	/^vim_vsnprintf(str, str_m, fmt, ap, tvs)$/;"	f
vim_window_validp	if_mzsch.c	/^vim_window_validp(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
vim_windowp	if_mzsch.c	/^vim_windowp(void *data, int argc, Scheme_Object **argv)$/;"	f	file:
vim_write	vim.h	/^# define vim_write(/;"	d
vimconv_T	structs.h	/^} vimconv_T;$/;"	t	typeref:struct:__anon92
vimenc_atom	gui_gtk_x11.c	/^static GdkAtom vimenc_atom = GDK_NONE;	\/* Vim's extended selection format *\/$/;"	v	file:
vimenc_atom	ui.c	/^static Atom	vimenc_atom;	\/* Vim's extended selection format *\/$/;"	v	file:
vimerror	if_tcl.c	/^vimerror(interp)$/;"	f	file:
viminfo_add_at_front	ex_getln.c	/^static int	viminfo_add_at_front = FALSE;$/;"	v	file:
viminfo_encoding	ex_cmds.c	/^viminfo_encoding(virp)$/;"	f	file:
viminfo_errcnt	ex_cmds.c	/^static int  viminfo_errcnt;$/;"	v	file:
viminfo_error	ex_cmds.c	/^viminfo_error(errnum, message, line)$/;"	f
viminfo_filename	ex_cmds.c	/^viminfo_filename(file)$/;"	f	file:
viminfo_hisidx	ex_getln.c	/^static int	viminfo_hisidx[HIST_COUNT] = {0, 0, 0, 0};$/;"	v	file:
viminfo_hislen	ex_getln.c	/^static int	viminfo_hislen[HIST_COUNT] = {0, 0, 0, 0};$/;"	v	file:
viminfo_history	ex_getln.c	/^static char_u **viminfo_history[HIST_COUNT] = {NULL, NULL, NULL, NULL};$/;"	v	file:
viminfo_readline	ex_cmds.c	/^viminfo_readline(virp)$/;"	f
viminfo_readstring	ex_cmds.c	/^viminfo_readstring(virp, off, convert)$/;"	f
viminfo_writestring	ex_cmds.c	/^viminfo_writestring(fd, p)$/;"	f
vimmenu_T	structs.h	/^typedef int vimmenu_T;$/;"	t
vimmenu_T	structs.h	/^typedef struct VimMenu vimmenu_T;$/;"	t	typeref:struct:VimMenu
vimobj	if_tcl.c	/^    void	*vimobj;    \/* Vim window or buffer (win_T* or buf_T*) *\/$/;"	m	struct:ref	file:
vimoption	option.c	/^struct vimoption$/;"	s	file:
vimpty_getenv	misc2.c	/^vimpty_getenv(string)$/;"	f
vimrc_found	option.c	/^vimrc_found(fname, envname)$/;"	f
vimvar	eval.c	/^static struct vimvar$/;"	s	file:
vimvardict	eval.c	/^static dict_T		vimvardict;$/;"	v	file:
vimvarht	eval.c	/^#define vimvarht /;"	d	file:
vimvars	eval.c	/^} vimvars[VV_LEN] =$/;"	v	typeref:struct:vimvar	file:
vimvars_var	eval.c	/^static dictitem_T	vimvars_var;$/;"	v	file:
vir_T	structs.h	/^} vir_T;$/;"	t	typeref:struct:__anon93
vir_conv	structs.h	/^    vimconv_T	vir_conv;	\/* encoding conversion *\/$/;"	m	struct:__anon93
vir_fd	structs.h	/^    FILE	*vir_fd;	\/* file descriptor *\/$/;"	m	struct:__anon93
vir_line	structs.h	/^    char_u	*vir_line;	\/* text of the current line *\/$/;"	m	struct:__anon93
virtual_active	misc2.c	/^virtual_active()$/;"	f
virtual_active	vim.h	/^# define virtual_active(/;"	d
virtual_op	globals.h	/^EXTERN int	virtual_op INIT(= MAYBE);$/;"	v
virtual_op	vim.h	/^# define virtual_op /;"	d
visibility	gui.h	/^    int		visibility;	    \/* Is shell partially\/fully obscured? *\/$/;"	m	struct:Gui
visibility	gui.h	/^    int		visibility;	    \/* Is window partially\/fully obscured? *\/$/;"	m	struct:Gui
visibility	gui_gtk_f.h	/^    GdkVisibilityState visibility;$/;"	m	struct:_GtkForm
visibility_event	gui_gtk_x11.c	/^visibility_event(GtkWidget *widget, GdkEventVisibility *event, gpointer data)$/;"	f	file:
visualinfo_T	structs.h	/^} visualinfo_T;$/;"	t	typeref:struct:__anon82
vmode	vim.h	/^    int		vmode;		\/* Visual mode character *\/$/;"	m	struct:VimClipboard
vop_flags	option.h	/^EXTERN unsigned	vop_flags;	\/* uses SSOP_ flags *\/$/;"	v
vow	hangulin.c	/^vow(c)$/;"	f	file:
vpeekc	getchar.c	/^vpeekc()$/;"	f
vpeekc_any	getchar.c	/^vpeekc_any()$/;"	f
vpeekc_nomap	getchar.c	/^vpeekc_nomap()$/;"	f
vr_lines_changed	globals.h	/^EXTERN int	vr_lines_changed INIT(= 0); \/* #Lines changed by "gR" so far *\/$/;"	v
vungetc	getchar.c	/^vungetc(c)	\/* unget one character (can only be done once!) *\/$/;"	f
vv_di	eval.c	/^    dictitem_T	vv_di;		\/* value and name for key *\/$/;"	m	struct:vimvar	file:
vv_exception	ex_docmd.c	/^    char_u	*vv_exception;$/;"	m	struct:dbg_stuff	file:
vv_filler	eval.c	/^    char	vv_filler[16];	\/* space for LONGEST name below!!! *\/$/;"	m	struct:vimvar	file:
vv_flags	eval.c	/^    char	vv_flags;	\/* VV_COMPAT, VV_RO, VV_RO_SBX *\/$/;"	m	struct:vimvar	file:
vv_float	eval.c	/^#define vv_float	/;"	d	file:
vv_name	eval.c	/^    char	*vv_name;	\/* name of variable, without v: *\/$/;"	m	struct:vimvar	file:
vv_nr	eval.c	/^#define vv_nr	/;"	d	file:
vv_str	eval.c	/^#define vv_str	/;"	d	file:
vv_throwpoint	ex_docmd.c	/^    char_u	*vv_throwpoint;$/;"	m	struct:dbg_stuff	file:
vv_tv	eval.c	/^#define vv_tv	/;"	d	file:
vv_type	eval.c	/^#define vv_type	/;"	d	file:
vval	structs.h	/^    }		vval;$/;"	m	struct:__anon94	typeref:union:__anon94::__anon95
w_alist	structs.h	/^    alist_T	*w_alist;	    \/* pointer to arglist for this window *\/$/;"	m	struct:window_S
w_allbuf_opt	structs.h	/^    winopt_T	w_allbuf_opt;$/;"	m	struct:window_S
w_alt_fnum	structs.h	/^    int		w_alt_fnum;	    \/* alternate file (for # and CTRL-^) *\/$/;"	m	struct:window_S
w_arg_idx	structs.h	/^    int		w_arg_idx;	    \/* current index in argument list (can be$/;"	m	struct:window_S
w_arg_idx_invalid	structs.h	/^    int		w_arg_idx_invalid;  \/* editing another file than w_arg_idx *\/$/;"	m	struct:window_S
w_botfill	structs.h	/^    int		w_botfill;	    \/* TRUE when filler lines are actually$/;"	m	struct:window_S
w_botline	structs.h	/^    linenr_T	w_botline;	    \/* number of the line below the bottom of$/;"	m	struct:window_S
w_buffer	structs.h	/^    buf_T	*w_buffer;	    \/* buffer we are a window into (used$/;"	m	struct:window_S
w_changelistidx	structs.h	/^    int		w_changelistidx;	\/* current position in b_changelist *\/$/;"	m	struct:window_S
w_cline_folded	structs.h	/^    int		w_cline_folded;	    \/* cursor line is folded *\/$/;"	m	struct:window_S
w_cline_height	structs.h	/^    int		w_cline_height;	    \/* current size of cursor line *\/$/;"	m	struct:window_S
w_cline_row	structs.h	/^    int		w_cline_row;	    \/* starting row of the cursor line *\/$/;"	m	struct:window_S
w_cursor	structs.h	/^    pos_T	w_cursor;	    \/* cursor position in buffer *\/$/;"	m	struct:window_S
w_curswant	structs.h	/^    colnr_T	w_curswant;	    \/* The column we'd like to be at.  This is$/;"	m	struct:window_S
w_empty_rows	structs.h	/^    int		w_empty_rows;	    \/* number of ~ rows in window *\/$/;"	m	struct:window_S
w_farsi	structs.h	/^    int		w_farsi;	\/* for the window dependent Farsi functions *\/$/;"	m	struct:window_S
w_filler_rows	structs.h	/^    int		w_filler_rows;	    \/* number of filler rows at the end of the$/;"	m	struct:window_S
w_fold_manual	structs.h	/^    char	w_fold_manual;	    \/* when TRUE: some folds are opened\/closed$/;"	m	struct:window_S
w_foldinvalid	structs.h	/^    char	w_foldinvalid;	    \/* when TRUE: folding needs to be$/;"	m	struct:window_S
w_folds	structs.h	/^    garray_T	w_folds;	    \/* array of nested folds *\/$/;"	m	struct:window_S
w_fraction	structs.h	/^    int		w_fraction;$/;"	m	struct:window_S
w_frame	structs.h	/^    frame_T	*w_frame;	    \/* frame containing this window *\/$/;"	m	struct:window_S
w_height	structs.h	/^    int		w_height;	    \/* number of rows in window, excluding$/;"	m	struct:window_S
w_jumplist	structs.h	/^    xfmark_T	w_jumplist[JUMPLISTSIZE];$/;"	m	struct:window_S
w_jumplistidx	structs.h	/^    int		w_jumplistidx;		\/* current position *\/$/;"	m	struct:window_S
w_jumplistlen	structs.h	/^    int		w_jumplistlen;		\/* number of active entries *\/$/;"	m	struct:window_S
w_leftcol	structs.h	/^    colnr_T	w_leftcol;	    \/* window column number of the left most$/;"	m	struct:window_S
w_line	structs.h	/^typedef struct w_line$/;"	s
w_lines	structs.h	/^    wline_T	*w_lines;$/;"	m	struct:window_S
w_lines_valid	structs.h	/^    int		w_lines_valid;	    \/* number of valid entries *\/$/;"	m	struct:window_S
w_llist	structs.h	/^    qf_info_T	*w_llist;		\/* Location list for this window *\/$/;"	m	struct:window_S
w_llist_ref	structs.h	/^    qf_info_T	*w_llist_ref;$/;"	m	struct:window_S
w_localdir	structs.h	/^    char_u	*w_localdir;	    \/* absolute path of local directory or$/;"	m	struct:window_S
w_match_head	structs.h	/^    matchitem_T	*w_match_head;		\/* head of match list *\/$/;"	m	struct:window_S
w_mzscheme_ref	structs.h	/^    void	*w_mzscheme_ref;	\/* The MzScheme value for this window *\/$/;"	m	struct:window_S
w_next	structs.h	/^    win_T	*w_next;	    \/* link to next window *\/$/;"	m	struct:window_S
w_next_match_id	structs.h	/^    int		w_next_match_id;	\/* next match ID *\/$/;"	m	struct:window_S
w_nrwidth	structs.h	/^    int		w_nrwidth;	    \/* width of 'number' column being used *\/$/;"	m	struct:window_S
w_nrwidth_line_count	structs.h	/^    linenr_T	w_nrwidth_line_count;	\/* line count when ml_nrwidth_width$/;"	m	struct:window_S
w_nrwidth_width	structs.h	/^    int		w_nrwidth_width;	\/* nr of chars to print line count. *\/$/;"	m	struct:window_S
w_old_botfill	structs.h	/^    int		w_old_botfill;	    \/* w_botfill at last redraw *\/$/;"	m	struct:window_S
w_old_cursor_fcol	structs.h	/^    colnr_T	w_old_cursor_fcol;  \/* first column for block visual part *\/$/;"	m	struct:window_S
w_old_cursor_lcol	structs.h	/^    colnr_T	w_old_cursor_lcol;  \/* last column for block visual part *\/$/;"	m	struct:window_S
w_old_cursor_lnum	structs.h	/^    linenr_T	w_old_cursor_lnum;  \/* last known end of visual part *\/$/;"	m	struct:window_S
w_old_curswant	structs.h	/^    colnr_T	w_old_curswant;	    \/* last known value of Curswant *\/$/;"	m	struct:window_S
w_old_topfill	structs.h	/^    int		w_old_topfill;	    \/* w_topfill at last redraw *\/$/;"	m	struct:window_S
w_old_visual_col	structs.h	/^    colnr_T	w_old_visual_col;   \/* last known start of visual part *\/$/;"	m	struct:window_S
w_old_visual_lnum	structs.h	/^    linenr_T	w_old_visual_lnum;  \/* last known start of visual part *\/$/;"	m	struct:window_S
w_old_visual_mode	structs.h	/^    char	w_old_visual_mode;  \/* last known VIsual_mode *\/$/;"	m	struct:window_S
w_onebuf_opt	structs.h	/^    winopt_T	w_onebuf_opt;$/;"	m	struct:window_S
w_p_arab	structs.h	/^# define w_p_arab /;"	d
w_p_cuc	structs.h	/^# define w_p_cuc /;"	d
w_p_cul	structs.h	/^# define w_p_cul /;"	d
w_p_diff	structs.h	/^# define w_p_diff /;"	d
w_p_fdc	structs.h	/^# define w_p_fdc /;"	d
w_p_fde	structs.h	/^# define w_p_fde /;"	d
w_p_fde_flags	structs.h	/^    long_u	w_p_fde_flags;	    \/* flags for 'foldexpr' *\/$/;"	m	struct:window_S
w_p_fdi	structs.h	/^# define w_p_fdi /;"	d
w_p_fdl	structs.h	/^# define w_p_fdl /;"	d
w_p_fdm	structs.h	/^# define w_p_fdm /;"	d
w_p_fdn	structs.h	/^# define w_p_fdn /;"	d
w_p_fdt	structs.h	/^#  define w_p_fdt /;"	d
w_p_fdt_flags	structs.h	/^    long_u	w_p_fdt_flags;	    \/* flags for 'foldtext' *\/$/;"	m	struct:window_S
w_p_fen	structs.h	/^# define w_p_fen /;"	d
w_p_fml	structs.h	/^# define w_p_fml /;"	d
w_p_fmr	structs.h	/^# define w_p_fmr /;"	d
w_p_lbr	structs.h	/^# define w_p_lbr /;"	d
w_p_list	structs.h	/^#define w_p_list /;"	d
w_p_nu	structs.h	/^#define w_p_nu /;"	d
w_p_nuw	structs.h	/^# define w_p_nuw /;"	d
w_p_pvw	structs.h	/^# define w_p_pvw /;"	d
w_p_rl	structs.h	/^# define w_p_rl /;"	d
w_p_rlc	structs.h	/^# define w_p_rlc /;"	d
w_p_scb	structs.h	/^# define w_p_scb /;"	d
w_p_scr	structs.h	/^#define w_p_scr /;"	d
w_p_scriptID	structs.h	/^# define w_p_scriptID /;"	d
w_p_spell	structs.h	/^# define w_p_spell /;"	d
w_p_stl	structs.h	/^#define w_p_stl /;"	d
w_p_stl_flags	structs.h	/^    long_u	w_p_stl_flags;	    \/* flags for 'statusline' *\/$/;"	m	struct:window_S
w_p_wfh	structs.h	/^# define w_p_wfh /;"	d
w_p_wfw	structs.h	/^# define w_p_wfw /;"	d
w_p_wrap	structs.h	/^#define w_p_wrap /;"	d
w_pcmark	structs.h	/^    pos_T	w_pcmark;	\/* previous context mark *\/$/;"	m	struct:window_S
w_perl_private	structs.h	/^    void	*w_perl_private;$/;"	m	struct:window_S
w_prev	structs.h	/^    win_T	*w_prev;	    \/* link to previous window *\/$/;"	m	struct:window_S
w_prev_fraction_row	structs.h	/^    int		w_prev_fraction_row;$/;"	m	struct:window_S
w_prev_pcmark	structs.h	/^    pos_T	w_prev_pcmark;	\/* previous w_pcmark *\/$/;"	m	struct:window_S
w_python_ref	structs.h	/^    void	*w_python_ref;		\/* The Python value for this window *\/$/;"	m	struct:window_S
w_redr_status	structs.h	/^    int		w_redr_status;	    \/* if TRUE status line must be redrawn *\/$/;"	m	struct:window_S
w_redr_type	structs.h	/^    int		w_redr_type;	    \/* type of redraw to be performed on win *\/$/;"	m	struct:window_S
w_redraw_bot	structs.h	/^    linenr_T	w_redraw_bot;	    \/* when != 0: last line needing redraw *\/$/;"	m	struct:window_S
w_redraw_top	structs.h	/^    linenr_T	w_redraw_top;	    \/* when != 0: first line needing redraw *\/$/;"	m	struct:window_S
w_ru_cursor	structs.h	/^    pos_T	w_ru_cursor;	    \/* cursor position shown in ruler *\/$/;"	m	struct:window_S
w_ru_empty	structs.h	/^    char	w_ru_empty;	    \/* TRUE if ruler shows 0-1 (empty line) *\/$/;"	m	struct:window_S
w_ru_line_count	structs.h	/^    linenr_T	w_ru_line_count;    \/* line count used for ruler *\/$/;"	m	struct:window_S
w_ru_topfill	structs.h	/^    int		w_ru_topfill;	    \/* topfill shown in ruler *\/$/;"	m	struct:window_S
w_ru_topline	structs.h	/^    linenr_T	w_ru_topline;	    \/* topline shown in ruler *\/$/;"	m	struct:window_S
w_ru_virtcol	structs.h	/^    colnr_T	w_ru_virtcol;	    \/* virtcol shown in ruler *\/$/;"	m	struct:window_S
w_ruby_ref	structs.h	/^    void	*w_ruby_ref;$/;"	m	struct:window_S
w_scbind_pos	structs.h	/^    long	w_scbind_pos;$/;"	m	struct:window_S
w_scrollbars	structs.h	/^    scrollbar_T	w_scrollbars[2];	\/* vert. Scrollbars for this window *\/$/;"	m	struct:window_S
w_set_curswant	structs.h	/^    int		w_set_curswant;	    \/* If set, then update w_curswant the next$/;"	m	struct:window_S
w_skipcol	structs.h	/^    colnr_T	w_skipcol;	    \/* starting column when a single line$/;"	m	struct:window_S
w_status_height	structs.h	/^    int		w_status_height;    \/* number of status lines (0 or 1) *\/$/;"	m	struct:window_S
w_tagstack	structs.h	/^    taggy_T	w_tagstack[TAGSTACKSIZE];	\/* the tag stack *\/$/;"	m	struct:window_S
w_tagstackidx	structs.h	/^    int		w_tagstackidx;		\/* idx just below active entry *\/$/;"	m	struct:window_S
w_tagstacklen	structs.h	/^    int		w_tagstacklen;		\/* number of tags on stack *\/$/;"	m	struct:window_S
w_tcl_ref	structs.h	/^    void	*w_tcl_ref;$/;"	m	struct:window_S
w_topfill	structs.h	/^    int		w_topfill;	    \/* number of filler lines above w_topline *\/$/;"	m	struct:window_S
w_topline	structs.h	/^    linenr_T	w_topline;	    \/* buffer line number of the line at the$/;"	m	struct:window_S
w_upd_rows	structs.h	/^    int		w_upd_rows;	    \/* number of window lines to update when$/;"	m	struct:window_S
w_valid	structs.h	/^    int		w_valid;$/;"	m	struct:window_S
w_valid_cursor	structs.h	/^    pos_T	w_valid_cursor;	    \/* last known position of w_cursor, used$/;"	m	struct:window_S
w_valid_leftcol	structs.h	/^    colnr_T	w_valid_leftcol;    \/* last known w_leftcol *\/$/;"	m	struct:window_S
w_vars	structs.h	/^    dict_T	w_vars;		\/* internal variables, local to window *\/$/;"	m	struct:window_S
w_virtcol	structs.h	/^    colnr_T	w_virtcol;	    \/* column number of the cursor in the$/;"	m	struct:window_S
w_vsep_width	structs.h	/^    int		w_vsep_width;	    \/* Number of separator columns (0 or 1).$/;"	m	struct:window_S
w_wcol	structs.h	/^    int		w_wrow, w_wcol;	    \/* cursor position in window *\/$/;"	m	struct:window_S
w_width	structs.h	/^    int		w_width;	    \/* Width of window, excluding separation.$/;"	m	struct:window_S
w_wincol	structs.h	/^    int		w_wincol;	    \/* Leftmost column of window in screen.$/;"	m	struct:window_S
w_winrow	structs.h	/^    int		w_winrow;	    \/* first row of window in screen *\/$/;"	m	struct:window_S
w_winvar	structs.h	/^    dictitem_T	w_winvar;	\/* variable for "w:" Dictionary *\/$/;"	m	struct:window_S
w_wrow	structs.h	/^    int		w_wrow, w_wcol;	    \/* cursor position in window *\/$/;"	m	struct:window_S
wait_return	message.c	/^wait_return(redraw)$/;"	f
want_full_screen	main.c	/^    int		want_full_screen;$/;"	m	struct:__anon39	file:
want_garbage_collect	globals.h	/^EXTERN int	want_garbage_collect INIT(= FALSE);$/;"	v
warp_to_pc	workshop.c	/^warp_to_pc($/;"	f	file:
was_set_insecurely	option.c	/^was_set_insecurely(opt, opt_flags)$/;"	f
wc_count	spell.c	/^    short_u	wc_count;	    \/* nr of times word was seen *\/$/;"	m	struct:wordcount_S	file:
wc_use_keyname	option.c	/^wc_use_keyname(varp, wcp)$/;"	f	file:
wc_word	spell.c	/^    char_u	wc_word[1];	    \/* word, actually longer *\/$/;"	m	struct:wordcount_S	file:
wcmd_T	ex_docmd.c	/^} wcmd_T;$/;"	t	typeref:struct:__anon9	file:
what	gui_gtk.c	/^    GtkWidget *what;	\/* 'Find what' entry text widget *\/$/;"	m	struct:_SharedFindReplace	file:
what	gui_motif.c	/^    Widget what;	\/* 'Find what' entry text widget *\/$/;"	m	struct:_SharedFindReplace	file:
where_paste_started	globals.h	/^EXTERN pos_T	where_paste_started;$/;"	v
which_scrollbars	gui.h	/^    int		which_scrollbars[3];\/* Which scrollbar boxes are active? *\/$/;"	m	struct:Gui
wi_fold_manual	structs.h	/^    int		wi_fold_manual;	\/* copy of w_fold_manual *\/$/;"	m	struct:wininfo_S
wi_folds	structs.h	/^    garray_T	wi_folds;	\/* clone of w_folds *\/$/;"	m	struct:wininfo_S
wi_fpos	structs.h	/^    pos_T	wi_fpos;	\/* last cursor position in the file *\/$/;"	m	struct:wininfo_S
wi_next	structs.h	/^    wininfo_T	*wi_next;	\/* next entry or NULL for last entry *\/$/;"	m	struct:wininfo_S
wi_opt	structs.h	/^    winopt_T	wi_opt;		\/* local window options *\/$/;"	m	struct:wininfo_S
wi_optset	structs.h	/^    int		wi_optset;	\/* TRUE when wi_opt has useful values *\/$/;"	m	struct:wininfo_S
wi_prev	structs.h	/^    wininfo_T	*wi_prev;	\/* previous entry or NULL for first entry *\/$/;"	m	struct:wininfo_S
wi_win	structs.h	/^    win_T	*wi_win;	\/* pointer to window that did set wi_lnum *\/$/;"	m	struct:wininfo_S
wid	gui.h	/^    Window	wid;		    \/* Window id of text area *\/$/;"	m	struct:Gui
wid	gui.h	/^    WindowPtr	wid;		    \/* Window id of text area *\/$/;"	m	struct:Gui
wide_WindowProc	globals.h	/^EXTERN int	wide_WindowProc INIT(= FALSE);	\/* use wide WindowProc() *\/$/;"	v
wide_font	gui.h	/^    GuiFont	wide_font;	    \/* 'guifontwide' font *\/$/;"	m	struct:Gui
widget	gui_gtk_f.c	/^    GtkWidget *widget;$/;"	m	struct:_GtkFormChild	file:
widgetIsIconified	integration.c	/^widgetIsIconified($/;"	f	file:
width	gui.h	/^    int		width;		\/* Current width of scroll bar in cols *\/$/;"	m	struct:GuiScrollbar
width	gui_gtk_f.h	/^    guint width;$/;"	m	struct:_GtkForm
width	hardcopy.c	/^    float	width;		\/* width and height in points for portrait *\/$/;"	m	struct:prt_mediasize_S	file:
wild	gui_xmdlg.c	/^static char wild[3] = "*";$/;"	v	file:
wild_menu_showing	globals.h	/^EXTERN int  wild_menu_showing INIT(= 0);$/;"	v
wim_flags	globals.h	/^EXTERN char_u	wim_flags[4];$/;"	v
win	if_mzsch.c	/^    win_T	    *win;$/;"	m	struct:__anon22	file:
win	if_python.c	/^    win_T	*win;$/;"	m	struct:__anon30	file:
win_T	structs.h	/^typedef struct window_S		win_T;$/;"	t	typeref:struct:window_S
win_alloc	window.c	/^win_alloc(after)$/;"	f	file:
win_alloc_first	window.c	/^win_alloc_first()$/;"	f
win_alloc_firstwin	window.c	/^win_alloc_firstwin(oldwin)$/;"	f	file:
win_alloc_lines	window.c	/^win_alloc_lines(wp)$/;"	f
win_altframe	window.c	/^win_altframe(win, tp)$/;"	f	file:
win_append	window.c	/^win_append(after, wp)$/;"	f	file:
win_chartabsize	charset.c	/^win_chartabsize(wp, p, col)$/;"	f	file:
win_close	window.c	/^win_close(win, free_buf)$/;"	f
win_close_othertab	window.c	/^win_close_othertab(win, free_buf, tp)$/;"	f
win_col_off	move.c	/^win_col_off(wp)$/;"	f
win_col_off2	move.c	/^win_col_off2(wp)$/;"	f
win_comp_pos	window.c	/^win_comp_pos()$/;"	f
win_comp_scroll	window.c	/^win_comp_scroll(wp)$/;"	f
win_copy_options	option.c	/^win_copy_options(wp_from, wp_to)$/;"	f
win_count	window.c	/^win_count()$/;"	f
win_del_lines	screen.c	/^win_del_lines(wp, row, line_count, invalid, mayclear)$/;"	f
win_do_lines	screen.c	/^win_do_lines(wp, row, line_count, mayclear, del)$/;"	f	file:
win_drag_status_line	window.c	/^win_drag_status_line(dragwin, offset)$/;"	f
win_drag_vsep_line	window.c	/^win_drag_vsep_line(dragwin, offset)$/;"	f
win_draw_end	screen.c	/^win_draw_end(wp, c1, c2, row, endrow, hl)$/;"	f	file:
win_enter	window.c	/^win_enter(wp, undo_sync)$/;"	f
win_enter_ext	window.c	/^win_enter_ext(wp, undo_sync, curwin_invalid)$/;"	f	file:
win_equal	window.c	/^win_equal(next_curwin, current, dir)$/;"	f
win_equal_rec	window.c	/^win_equal_rec(next_curwin, current, topfr, dir, col, row, width, height)$/;"	f	file:
win_exchange	window.c	/^win_exchange(Prenum)$/;"	f	file:
win_find_nr	window.c	/^win_find_nr(winnr)$/;"	f
win_foldinfo	screen.c	/^static foldinfo_T win_foldinfo;	\/* info for 'foldcolumn' *\/$/;"	v	file:
win_free	window.c	/^win_free(wp, tp)$/;"	f	file:
win_free_all	window.c	/^win_free_all()$/;"	f
win_free_lsize	window.c	/^win_free_lsize(wp)$/;"	f
win_free_mem	window.c	/^win_free_mem(win, dirp, tp)$/;"	f	file:
win_goto	window.c	/^win_goto(wp)$/;"	f
win_goto_hor	window.c	/^win_goto_hor(left, count)$/;"	f	file:
win_goto_ver	window.c	/^win_goto_ver(up, count)$/;"	f	file:
win_hasvertsplit	window.c	/^win_hasvertsplit()$/;"	f
win_init	window.c	/^win_init(newp, oldp)$/;"	f	file:
win_init_size	window.c	/^win_init_size()$/;"	f
win_ins_lines	screen.c	/^win_ins_lines(wp, row, line_count, invalid, mayclear)$/;"	f
win_lbr_chartabsize	charset.c	/^win_lbr_chartabsize(wp, s, col, headp)$/;"	f
win_line	screen.c	/^win_line(wp, lnum, startrow, endrow, nochange)$/;"	f	file:
win_linetabsize	charset.c	/^win_linetabsize(wp, p, len)$/;"	f
win_move_after	window.c	/^win_move_after(win1, win2)$/;"	f
win_new_height	window.c	/^win_new_height(wp, height)$/;"	f	file:
win_new_shellsize	term.c	/^win_new_shellsize()$/;"	f
win_new_tabpage	window.c	/^win_new_tabpage(after)$/;"	f
win_new_width	window.c	/^win_new_width(wp, width)$/;"	f	file:
win_nolbr_chartabsize	charset.c	/^win_nolbr_chartabsize(wp, s, col, headp)$/;"	f	file:
win_redr_custom	screen.c	/^win_redr_custom(wp, draw_ruler)$/;"	f	file:
win_redr_ruler	screen.c	/^win_redr_ruler(wp, always)$/;"	f	file:
win_redr_status	screen.c	/^win_redr_status(wp)$/;"	f
win_redr_status_matches	screen.c	/^win_redr_status_matches(xp, num_matches, matches, match, showtail)$/;"	f
win_redraw_last_status	screen.c	/^win_redraw_last_status(frp)$/;"	f
win_remove	window.c	/^win_remove(wp, tp)$/;"	f	file:
win_rest_invalid	screen.c	/^win_rest_invalid(wp)$/;"	f	file:
win_rotate	window.c	/^win_rotate(upwards, count)$/;"	f	file:
win_setheight	window.c	/^win_setheight(height)$/;"	f
win_setheight_win	window.c	/^win_setheight_win(height, win)$/;"	f
win_setminheight	window.c	/^win_setminheight()$/;"	f
win_setwidth	window.c	/^win_setwidth(width)$/;"	f
win_setwidth_win	window.c	/^win_setwidth_win(width, wp)$/;"	f
win_size_restore	window.c	/^win_size_restore(gap)$/;"	f
win_size_save	window.c	/^win_size_save(gap)$/;"	f
win_socket_id	globals.h	/^EXTERN long_u	win_socket_id INIT(= 0);$/;"	v
win_split	window.c	/^win_split(size, flags)$/;"	f
win_split_ins	window.c	/^win_split_ins(size, flags, newwin, dir)$/;"	f	file:
win_totop	window.c	/^win_totop(size, flags)$/;"	f	file:
win_update	screen.c	/^win_update(wp)$/;"	f	file:
win_valid	window.c	/^win_valid(win)$/;"	f
windgoto	screen.c	/^windgoto(row, col)$/;"	f
window	gui_gtk_f.c	/^    GdkWindow *window;$/;"	m	struct:_GtkFormChild	file:
window_S	structs.h	/^struct window_S$/;"	s
window_buffer	if_ruby.c	/^static VALUE window_buffer(VALUE self)$/;"	f	file:
window_count	main.c	/^    int		window_count;		\/* number of windows to use *\/$/;"	m	struct:__anon39	file:
window_cursor	if_ruby.c	/^static VALUE window_cursor(VALUE self)$/;"	f	file:
window_handle	gui.h	/^    int		window_handle;$/;"	m	struct:Gui
window_height	if_ruby.c	/^static VALUE window_height(VALUE self)$/;"	f	file:
window_layout	main.c	/^    int		window_layout;		\/* 0, WIN_HOR, WIN_VER or WIN_TABS *\/$/;"	m	struct:__anon39	file:
window_new	if_mzsch.c	/^window_new(win_T *win)$/;"	f	file:
window_new	if_ruby.c	/^static VALUE window_new(win_T *win)$/;"	f	file:
window_s_aref	if_ruby.c	/^static VALUE window_s_aref(VALUE self, VALUE num)$/;"	f	file:
window_s_count	if_ruby.c	/^static VALUE window_s_count()$/;"	f	file:
window_s_current	if_ruby.c	/^static VALUE window_s_current()$/;"	f	file:
window_set_cursor	if_ruby.c	/^static VALUE window_set_cursor(VALUE self, VALUE pos)$/;"	f	file:
window_set_height	if_ruby.c	/^static VALUE window_set_height(VALUE self, VALUE height)$/;"	f	file:
window_set_width	if_ruby.c	/^static VALUE window_set_width(VALUE self, VALUE width)$/;"	f	file:
window_title	gui.h	/^    char_u	*window_title;$/;"	m	struct:Gui
window_title_size	gui.h	/^    int		window_title_size;$/;"	m	struct:Gui
window_width	if_ruby.c	/^static VALUE window_width(VALUE self)$/;"	f	file:
windowcmd	if_tcl.c	/^windowcmd(dummy, interp, objc, objv)$/;"	f	file:
winframe_remove	window.c	/^winframe_remove(win, dirp, tp)$/;"	f	file:
wininfo_S	structs.h	/^struct wininfo_S$/;"	s
wininfo_T	structs.h	/^typedef struct wininfo_S	wininfo_T;$/;"	t	typeref:struct:wininfo_S
winopt_T	structs.h	/^} winopt_T;$/;"	t	typeref:struct:__anon81
winselfcmd	if_tcl.c	/^winselfcmd(ref, interp, objc, objv)$/;"	f	file:
wipe_buffer	buffer.c	/^wipe_buffer(buf, aucmd)$/;"	f
wipe_dummy_buffer	quickfix.c	/^wipe_dummy_buffer(buf)$/;"	f	file:
with	gui_gtk.c	/^    GtkWidget *with;	\/* 'Replace with' entry text widget *\/$/;"	m	struct:_SharedFindReplace	file:
with	gui_motif.c	/^    Widget with;	\/* 'Replace with' entry text widget *\/$/;"	m	struct:_SharedFindReplace	file:
wl_folded	structs.h	/^    char	wl_folded;	\/* TRUE when this is a range of folded lines *\/$/;"	m	struct:w_line
wl_lastlnum	structs.h	/^    linenr_T	wl_lastlnum;	\/* last buffer line number for logical line *\/$/;"	m	struct:w_line
wl_lnum	structs.h	/^    linenr_T	wl_lnum;	\/* buffer line number for logical line *\/$/;"	m	struct:w_line
wl_size	structs.h	/^    short_u	wl_size;	\/* height in screen lines *\/$/;"	m	struct:w_line
wl_valid	structs.h	/^    char	wl_valid;	\/* TRUE values are valid for text in buffer *\/$/;"	m	struct:w_line
wline_T	structs.h	/^} wline_T;$/;"	t	typeref:struct:w_line
wmDeleteWindowTranslation	gui_at_fs.c	/^static char *wmDeleteWindowTranslation = "\\$/;"	v	file:
wm_atoms	gui_x11.c	/^static Atom   wm_atoms[2];	\/* Window Manager Atoms *\/$/;"	v	file:
wm_protocols_atom	gui_gtk_x11.c	/^static GdkAtom wm_protocols_atom = GDK_NONE;$/;"	v	file:
wn_affixID	spell.c	/^    char_u	wn_affixID;	\/* supported\/required prefix ID or 0 *\/$/;"	m	struct:wordnode_S	file:
wn_byte	spell.c	/^    char_u	wn_byte;	\/* Byte for this node. NUL for word end *\/$/;"	m	struct:wordnode_S	file:
wn_child	spell.c	/^    wordnode_T	*wn_child;	\/* child (next byte in word) *\/$/;"	m	struct:wordnode_S	file:
wn_flags	spell.c	/^    short_u	wn_flags;	\/* WF_ flags *\/$/;"	m	struct:wordnode_S	file:
wn_nr	spell.c	/^    int		wn_nr;		\/* sequence nr for printing *\/$/;"	m	struct:wordnode_S	file:
wn_refs	spell.c	/^    int		wn_refs;	\/* Nr. of references to this node.  Only$/;"	m	struct:wordnode_S	file:
wn_region	spell.c	/^    short	wn_region;	\/* region mask *\/$/;"	m	struct:wordnode_S	file:
wn_sibling	spell.c	/^    wordnode_T  *wn_sibling;	\/* next sibling (alternate byte in word,$/;"	m	struct:wordnode_S	file:
wn_u1	spell.c	/^    } wn_u1;$/;"	m	struct:wordnode_S	typeref:union:wordnode_S::__anon54	file:
wn_u2	spell.c	/^    } wn_u2;$/;"	m	struct:wordnode_S	typeref:union:wordnode_S::__anon55	file:
wnode	spell.c	/^	wordnode_T *wnode;	\/* parent node that will write this node *\/$/;"	m	union:wordnode_S::__anon55	file:
wo_arab	structs.h	/^    int		wo_arab;$/;"	m	struct:__anon81
wo_cuc	structs.h	/^    int		wo_cuc;$/;"	m	struct:__anon81
wo_cul	structs.h	/^    int		wo_cul;$/;"	m	struct:__anon81
wo_diff	structs.h	/^    int		wo_diff;$/;"	m	struct:__anon81
wo_fdc	structs.h	/^    long	wo_fdc;$/;"	m	struct:__anon81
wo_fde	structs.h	/^    char_u	*wo_fde;$/;"	m	struct:__anon81
wo_fdi	structs.h	/^    char_u	*wo_fdi;$/;"	m	struct:__anon81
wo_fdl	structs.h	/^    long	wo_fdl;$/;"	m	struct:__anon81
wo_fdm	structs.h	/^    char_u	*wo_fdm;$/;"	m	struct:__anon81
wo_fdn	structs.h	/^    long	wo_fdn;$/;"	m	struct:__anon81
wo_fdt	structs.h	/^    char_u	*wo_fdt;$/;"	m	struct:__anon81
wo_fen	structs.h	/^    int		wo_fen;$/;"	m	struct:__anon81
wo_fml	structs.h	/^    long	wo_fml;$/;"	m	struct:__anon81
wo_fmr	structs.h	/^    char_u	*wo_fmr;$/;"	m	struct:__anon81
wo_lbr	structs.h	/^    int		wo_lbr;$/;"	m	struct:__anon81
wo_list	structs.h	/^    int		wo_list;$/;"	m	struct:__anon81
wo_nu	structs.h	/^    int		wo_nu;$/;"	m	struct:__anon81
wo_nuw	structs.h	/^    long	wo_nuw;$/;"	m	struct:__anon81
wo_pvw	structs.h	/^    int		wo_pvw;$/;"	m	struct:__anon81
wo_rl	structs.h	/^    int		wo_rl;$/;"	m	struct:__anon81
wo_rlc	structs.h	/^    char_u	*wo_rlc;$/;"	m	struct:__anon81
wo_scb	structs.h	/^    int		wo_scb;$/;"	m	struct:__anon81
wo_scr	structs.h	/^    long	wo_scr;$/;"	m	struct:__anon81
wo_scriptID	structs.h	/^    int		wo_scriptID[WV_COUNT];	\/* SIDs for window-local options *\/$/;"	m	struct:__anon81
wo_spell	structs.h	/^    int		wo_spell;$/;"	m	struct:__anon81
wo_stl	structs.h	/^    char_u	*wo_stl;$/;"	m	struct:__anon81
wo_wfh	structs.h	/^    int		wo_wfh;$/;"	m	struct:__anon81
wo_wfw	structs.h	/^    int		wo_wfw;$/;"	m	struct:__anon81
wo_wrap	structs.h	/^    int		wo_wrap;$/;"	m	struct:__anon81
word_end_col	vim.h	/^    short_u	word_end_col;$/;"	m	struct:VimClipboard
word_start_col	vim.h	/^    short_u	word_start_col;$/;"	m	struct:VimClipboard
wordcount_S	spell.c	/^typedef struct wordcount_S$/;"	s	file:
wordcount_T	spell.c	/^} wordcount_T;$/;"	t	typeref:struct:wordcount_S	file:
wordnode_S	spell.c	/^struct wordnode_S$/;"	s	file:
wordnode_T	spell.c	/^typedef struct wordnode_S wordnode_T;$/;"	t	typeref:struct:wordnode_S	file:
wordtree_alloc	spell.c	/^wordtree_alloc(spin)$/;"	f	file:
wordtree_compress	spell.c	/^wordtree_compress(spin, root)$/;"	f	file:
workshopHotKeysEnabled	workshop.c	/^static Boolean	 workshopHotKeysEnabled = False;$/;"	v	file:
workshopInitDone	workshop.c	/^static Boolean	 workshopInitDone = False;$/;"	v	file:
workshop_add_mark_type	workshop.c	/^workshop_add_mark_type($/;"	f
workshop_balloon_delay	workshop.c	/^workshop_balloon_delay($/;"	f
workshop_balloon_mode	workshop.c	/^workshop_balloon_mode($/;"	f
workshop_beval_cb	workshop.c	/^workshop_beval_cb($/;"	f
workshop_change_mark_type	workshop.c	/^workshop_change_mark_type($/;"	f
workshop_connect	integration.c	/^void	workshop_connect(XtAppContext context)$/;"	f
workshop_connection_closed	integration.c	/^workshop_connection_closed(void)$/;"	f
workshop_delete_mark	workshop.c	/^workshop_delete_mark($/;"	f
workshop_disconnect	integration.c	/^void	workshop_disconnect()$/;"	f
workshop_file_closed	integration.c	/^void workshop_file_closed(char *filename)$/;"	f
workshop_file_closed_lineno	integration.c	/^void workshop_file_closed_lineno(char *filename, int lineno)$/;"	f
workshop_file_modified	integration.c	/^void workshop_file_modified(char *filename)$/;"	f
workshop_file_opened	integration.c	/^void workshop_file_opened(char *filename, int readOnly)$/;"	f
workshop_file_saved	integration.c	/^void workshop_file_saved(char *filename)$/;"	f
workshop_footer_message	workshop.c	/^workshop_footer_message($/;"	f
workshop_frame_moved	integration.c	/^void workshop_frame_moved(int new_x, int new_y, int new_w, int new_h)$/;"	f
workshop_frame_sensitivities	workshop.c	/^workshop_frame_sensitivities($/;"	f
workshop_front_file	workshop.c	/^workshop_front_file($/;"	f
workshop_get_editor_name	workshop.c	/^workshop_get_editor_name()$/;"	f
workshop_get_editor_version	workshop.c	/^workshop_get_editor_version()$/;"	f
workshop_get_font_height	workshop.c	/^workshop_get_font_height()$/;"	f
workshop_get_mark_lineno	workshop.c	/^workshop_get_mark_lineno($/;"	f
workshop_get_positions	workshop.c	/^workshop_get_positions($/;"	f
workshop_get_rows_cols	integration.c	/^Boolean workshop_get_rows_cols(int *rows, int *cols)$/;"	f
workshop_get_width_height	integration.c	/^Boolean workshop_get_width_height(int *width, int *height)$/;"	f
workshop_goto_line	workshop.c	/^workshop_goto_line($/;"	f
workshop_goto_mark	workshop.c	/^workshop_goto_mark($/;"	f
workshop_hotkeys	workshop.c	/^workshop_hotkeys($/;"	f
workshop_init	workshop.c	/^workshop_init()$/;"	f
workshop_invoked	integration.c	/^workshop_invoked()$/;"	f
workshop_load_file	workshop.c	/^workshop_load_file($/;"	f
workshop_maximize	workshop.c	/^workshop_maximize()$/;"	f
workshop_maximize_shell	integration.c	/^void workshop_maximize_shell(Widget shell)$/;"	f
workshop_menu_begin	workshop.c	/^workshop_menu_begin($/;"	f
workshop_menu_end	workshop.c	/^workshop_menu_end()$/;"	f
workshop_menu_item	workshop.c	/^workshop_menu_item($/;"	f
workshop_minimize	workshop.c	/^workshop_minimize()$/;"	f
workshop_minimize_shell	integration.c	/^workshop_minimize_shell(Widget shell)$/;"	f
workshop_move_mark	integration.c	/^void workshop_move_mark(char *filename, int markId, int newLineno)$/;"	f
workshop_moved_marks	workshop.c	/^workshop_moved_marks(char *filename)$/;"	f
workshop_perform_verb	integration.c	/^void workshop_perform_verb(char *verb, void *clientData)$/;"	f
workshop_postinit	workshop.c	/^workshop_postinit()$/;"	f
workshop_quit	workshop.c	/^workshop_quit()$/;"	f
workshop_reload_file	workshop.c	/^workshop_reload_file($/;"	f
workshop_save_file	workshop.c	/^workshop_save_file($/;"	f
workshop_save_files	workshop.c	/^workshop_save_files()$/;"	f
workshop_save_sensitivity	workshop.c	/^workshop_save_sensitivity(char *filename)$/;"	f
workshop_send_message	integration.c	/^void workshop_send_message(char *buf)$/;"	f
workshop_sensitivity	integration.c	/^void workshop_sensitivity(int num, char *table)$/;"	f
workshop_set_icon	integration.c	/^workshop_set_icon(Display *display, Widget shell, char **xpmdata,$/;"	f
workshop_set_mark	workshop.c	/^workshop_set_mark($/;"	f
workshop_set_option	workshop.c	/^workshop_set_option($/;"	f
workshop_set_option_first	integration.c	/^void workshop_set_option_first(char *name, char *value)$/;"	f
workshop_show_balloon_tip	workshop.c	/^workshop_show_balloon_tip($/;"	f
workshop_show_file	workshop.c	/^workshop_show_file($/;"	f
workshop_submenu_begin	workshop.c	/^workshop_submenu_begin($/;"	f
workshop_submenu_end	workshop.c	/^workshop_submenu_end()$/;"	f
workshop_test_getcurrentfile	workshop.c	/^workshop_test_getcurrentfile()$/;"	f
workshop_test_getcursorcol	workshop.c	/^workshop_test_getcursorcol()$/;"	f
workshop_test_getcursorrow	workshop.c	/^workshop_test_getcursorrow()$/;"	f
workshop_test_getcursorrowtext	workshop.c	/^workshop_test_getcursorrowtext()$/;"	f
workshop_test_getselectedtext	workshop.c	/^workshop_test_getselectedtext()$/;"	f
workshop_toolbar_begin	workshop.c	/^workshop_toolbar_begin()$/;"	f
workshop_toolbar_button	workshop.c	/^workshop_toolbar_button($/;"	f
workshop_toolbar_end	workshop.c	/^workshop_toolbar_end()$/;"	f
wp	fold.c	/^    win_T	*wp;		\/* window *\/$/;"	m	struct:__anon12	file:
wp	gui.h	/^    win_T	*wp;		\/* Scrollbar's window, NULL for bottom *\/$/;"	m	struct:GuiScrollbar
write_lnum_adjust	fileio.c	/^write_lnum_adjust(offset)$/;"	f
write_no_eol_lnum	globals.h	/^EXTERN linenr_T	write_no_eol_lnum INIT(= 0); \/* non-zero lnum when last line$/;"	v
write_one_filemark	mark.c	/^write_one_filemark(fp, fm, c1, c2)$/;"	f	file:
write_one_mark	mark.c	/^write_one_mark(fp_out, c, pos)$/;"	f	file:
write_reg_contents	ops.c	/^write_reg_contents(name, str, maxlen, must_append)$/;"	f
write_reg_contents_ex	ops.c	/^write_reg_contents_ex(name, str, maxlen, must_append, yank_type, block_len)$/;"	f
write_session_file	gui_gtk_x11.c	/^write_session_file(char_u *filename)$/;"	f	file:
write_spell_prefcond	spell.c	/^write_spell_prefcond(fd, gap)$/;"	f	file:
write_vim_spell	spell.c	/^write_vim_spell(spin, fname)$/;"	f	file:
write_viminfo	ex_cmds.c	/^write_viminfo(file, forceit)$/;"	f
write_viminfo_bufferlist	buffer.c	/^write_viminfo_bufferlist(fp)$/;"	f
write_viminfo_filemarks	mark.c	/^write_viminfo_filemarks(fp)$/;"	f
write_viminfo_history	ex_getln.c	/^write_viminfo_history(fp)$/;"	f
write_viminfo_marks	mark.c	/^write_viminfo_marks(fp_out)$/;"	f
write_viminfo_registers	ops.c	/^write_viminfo_registers(fp)$/;"	f
write_viminfo_search_pattern	search.c	/^write_viminfo_search_pattern(fp)$/;"	f
write_viminfo_sub_string	ex_cmds.c	/^write_viminfo_sub_string(fp)$/;"	f
write_viminfo_varlist	eval.c	/^write_viminfo_varlist(fp)$/;"	f
writefn	if_python.c	/^typedef void (*writefn)(char_u *);$/;"	t	file:
writer	if_python.c	/^writer(writefn fn, char_u *str, PyInt n)$/;"	f	file:
ws_debug	wsdebug.c	/^FILE		*ws_debug = NULL;$/;"	v
ws_dlevel	wsdebug.c	/^u_int		 ws_dlevel = 0;		\/* ws_debug verbosity level *\/$/;"	v
wsdebug	wsdebug.c	/^wsdebug($/;"	f
wsdebug	wsdebug.h	/^wsdebug($/;"	f
wsdebug_log_init	wsdebug.c	/^wsdebug_log_init($/;"	f
wsdebug_wait	wsdebug.c	/^void wsdebug_wait($/;"	f
wstrace	wsdebug.c	/^wstrace($/;"	f
wstrace	wsdebug.h	/^wstrace($/;"	f
wvsp_one	search.c	/^wvsp_one(fp, idx, s, sc)$/;"	f	file:
wword	gui_gtk.c	/^    GtkWidget *wword;	\/* 'Whole word only' check button *\/$/;"	m	struct:_SharedFindReplace	file:
wword	gui_motif.c	/^    Widget wword;	\/* 'Exact match' check button *\/$/;"	m	struct:_SharedFindReplace	file:
wx	hardcopy.c	/^    int		wx;$/;"	m	struct:prt_ps_font_S	file:
x	gui_beval.h	/^    int			x;$/;"	m	struct:BalloonEvalStruct
x	gui_gtk_f.c	/^    gint x;		\/* relative subwidget x position *\/$/;"	m	struct:_GtkFormChild	file:
x11_display	os_unix.c	/^Display	    *x11_display = NULL;$/;"	v
x11_export_final_selection	ops.c	/^x11_export_final_selection()$/;"	f
x11_setup_atoms	ui.c	/^x11_setup_atoms(dpy)$/;"	f
x11_window	os_unix.c	/^Window	    x11_window = 0;$/;"	v
x_IOerror_check	os_unix.c	/^x_IOerror_check(dpy)$/;"	f	file:
x_IOerror_handler	os_unix.c	/^x_IOerror_handler(dpy)$/;"	f	file:
x_connect_to_server	os_unix.c	/^x_connect_to_server()$/;"	f	file:
x_error_check	if_xcmdsrv.c	/^x_error_check(dpy, error_event)$/;"	f	file:
x_error_check	os_unix.c	/^x_error_check(dpy, error_event)$/;"	f	file:
x_error_handler	os_unix.c	/^x_error_handler(dpy, error_event)$/;"	f	file:
x_force_connect	globals.h	/^EXTERN int	x_force_connect INIT(= FALSE); \/* Do connect to X server.$/;"	v
x_jump_env	globals.h	/^EXTERN JMP_BUF x_jump_env;$/;"	v
x_no_connect	globals.h	/^EXTERN int	x_no_connect INIT(= FALSE); \/* don't connect to X server *\/$/;"	v
xfilemark	structs.h	/^typedef struct xfilemark$/;"	s
xfmark_T	structs.h	/^} xfmark_T;$/;"	t	typeref:struct:xfilemark
xic	globals.h	/^EXTERN GdkIC		*xic INIT(= NULL);$/;"	v
xic	globals.h	/^EXTERN GtkIMContext	*xic INIT(= NULL);$/;"	v
xic	globals.h	/^EXTERN XIC		xic INIT(= NULL);$/;"	v
xic_attr	globals.h	/^EXTERN GdkICAttr	*xic_attr INIT(= NULL);$/;"	v
xim_back_delete	mbyte.c	/^xim_back_delete(int n)$/;"	f	file:
xim_bg_color	globals.h	/^EXTERN guicolor_T	xim_bg_color INIT(= INVALCOLOR);$/;"	v
xim_can_preediting	mbyte.c	/^static int	xim_can_preediting INIT(= FALSE);	\/* XIM in showmode() *\/$/;"	v	file:
xim_changed_while_preediting	globals.h	/^EXTERN int		xim_changed_while_preediting INIT(= FALSE);$/;"	v
xim_decide_input_style	mbyte.c	/^xim_decide_input_style()$/;"	f
xim_destroy_cb	mbyte.c	/^xim_destroy_cb(im, client_data, call_data)$/;"	f	file:
xim_expected_char	mbyte.c	/^static int xim_expected_char = NUL;$/;"	v	file:
xim_fg_color	globals.h	/^EXTERN guicolor_T	xim_fg_color INIT(= INVALCOLOR);$/;"	v
xim_get_status_area_height	mbyte.c	/^xim_get_status_area_height()$/;"	f
xim_has_focus	mbyte.c	/^static int	xim_has_focus = FALSE;	\/* XIM is really being used for Vim *\/$/;"	v	file:
xim_has_preediting	mbyte.c	/^static int xim_has_preediting INIT(= FALSE);  \/* IM current status *\/$/;"	v	file:
xim_ignored_char	mbyte.c	/^static int xim_ignored_char = FALSE;$/;"	v	file:
xim_init	mbyte.c	/^xim_init()$/;"	f
xim_init	mbyte.c	/^xim_init(void)$/;"	f
xim_input_style	mbyte.c	/^static int	xim_input_style;$/;"	v	file:
xim_instantiate_cb	mbyte.c	/^xim_instantiate_cb(display, client_data, call_data)$/;"	f	file:
xim_is_active	mbyte.c	/^static int	xim_is_active = FALSE;  \/* XIM should be active in the current$/;"	v	file:
xim_log	mbyte.c	/^xim_log(char *s, ...)$/;"	f	file:
xim_queue_key_press_event	mbyte.c	/^xim_queue_key_press_event(GdkEventKey *event, int down)$/;"	f
xim_real_init	mbyte.c	/^xim_real_init(x11_window, x11_display)$/;"	f	file:
xim_reset	mbyte.c	/^xim_reset(void)$/;"	f
xim_set_focus	mbyte.c	/^xim_set_focus(focus)$/;"	f
xim_set_focus	mbyte.c	/^xim_set_focus(int focus)$/;"	f
xim_set_preedit	mbyte.c	/^xim_set_preedit()$/;"	f
xim_set_status_area	mbyte.c	/^xim_set_status_area()$/;"	f
xmEnhancedButtonClassRec	gui_xmebw.c	/^XmEnhancedButtonClassRec xmEnhancedButtonClassRec =$/;"	v
xmEnhancedButtonPrimClassExtRec	gui_xmebw.c	/^XmPrimitiveClassExtRec xmEnhancedButtonPrimClassExtRec =$/;"	v
xmEnhancedButtonWidgetClass	gui_xmebw.c	/^WidgetClass xmEnhancedButtonWidgetClass =$/;"	v
xopen_message	os_unix.c	/^xopen_message(tvp)$/;"	f	file:
xp_arg	ex_getln.c	/^    char_u	*xp_arg;	\/* user-defined expansion arg *\/$/;"	m	struct:cmdline_info	file:
xp_arg	structs.h	/^    char_u	*xp_arg;		\/* completion function *\/$/;"	m	struct:expand
xp_backslash	structs.h	/^    int		xp_backslash;		\/* one of the XP_BS_ values *\/$/;"	m	struct:expand
xp_context	ex_getln.c	/^    int		xp_context;	\/* type of expansion *\/$/;"	m	struct:cmdline_info	file:
xp_context	structs.h	/^    int		xp_context;		\/* type of expansion *\/$/;"	m	struct:expand
xp_files	structs.h	/^    char_u	**xp_files;		\/* list of files *\/$/;"	m	struct:expand
xp_numfiles	structs.h	/^    int		xp_numfiles;		\/* number of files found by$/;"	m	struct:expand
xp_pattern	structs.h	/^    char_u	*xp_pattern;		\/* start of item to expand *\/$/;"	m	struct:expand
xp_scriptID	structs.h	/^    int		xp_scriptID;		\/* SID for completion function *\/$/;"	m	struct:expand
xp_shell	structs.h	/^    int		xp_shell;		\/* for a shell command more characters$/;"	m	struct:expand
xpm	structs.h	/^    char	**xpm;		    \/* pixmap data *\/$/;"	m	struct:VimMenu
xpm_fname	structs.h	/^    char	*xpm_fname;	    \/* file with pixmap data *\/$/;"	m	struct:VimMenu
xsmp	os_unix.c	/^static xsmp_config_T xsmp;$/;"	v	file:
xsmp_close	os_unix.c	/^xsmp_close()$/;"	f
xsmp_config_T	os_unix.c	/^} xsmp_config_T;$/;"	t	typeref:struct:__anon46	file:
xsmp_die	os_unix.c	/^xsmp_die(smc_conn, client_data)$/;"	f	file:
xsmp_handle_interaction	os_unix.c	/^xsmp_handle_interaction(smc_conn, client_data)$/;"	f	file:
xsmp_handle_requests	os_unix.c	/^xsmp_handle_requests()$/;"	f
xsmp_handle_save_yourself	os_unix.c	/^xsmp_handle_save_yourself(smc_conn, client_data, save_type,$/;"	f	file:
xsmp_ice_connection	os_unix.c	/^xsmp_ice_connection(iceConn, clientData, opening, watchData)$/;"	f	file:
xsmp_icefd	globals.h	/^EXTERN int xsmp_icefd INIT(= -1);   \/* The actual connection *\/$/;"	v
xsmp_init	os_unix.c	/^xsmp_init(void)$/;"	f
xsmp_save_complete	os_unix.c	/^xsmp_save_complete(smc_conn, client_data)$/;"	f	file:
xsmp_shutdown_cancelled	os_unix.c	/^xsmp_shutdown_cancelled(smc_conn, client_data)$/;"	f	file:
xt_index_in	term.c	/^static int xt_index_in = 0;$/;"	v	file:
xt_index_out	term.c	/^static int xt_index_out = 0;$/;"	v	file:
xterm_Shell	os_unix.c	/^static Widget	xterm_Shell = (Widget)0;$/;"	v	file:
xterm_button	os_unix.c	/^static int	xterm_button;$/;"	v	file:
xterm_display	globals.h	/^EXTERN char	*xterm_display INIT(= NULL);	\/* xterm display name; points$/;"	v
xterm_dpy	globals.h	/^EXTERN Display	*xterm_dpy INIT(= NULL);	\/* xterm display pointer *\/$/;"	v
xterm_trace	os_unix.c	/^static int	xterm_trace = -1;	\/* default: disabled *\/$/;"	v	file:
xterm_update	os_unix.c	/^xterm_update()$/;"	f	file:
xy2win	gui.c	/^xy2win(x, y)$/;"	f	file:
y	gui_beval.h	/^    int			y;$/;"	m	struct:BalloonEvalStruct
y	gui_gtk_f.c	/^    gint y;		\/* relative subwidget y position *\/$/;"	m	struct:_GtkFormChild	file:
y_append	ops.c	/^static int		y_append;	    \/* TRUE when appending *\/$/;"	v	file:
y_array	ops.c	/^    char_u	**y_array;	\/* pointer to array of line pointers *\/$/;"	m	struct:yankreg	file:
y_current	ops.c	/^static struct yankreg	*y_current;	    \/* ptr to current yankreg *\/$/;"	v	typeref:struct:yankreg	file:
y_previous	ops.c	/^static struct yankreg	*y_previous = NULL; \/* ptr to last written yankreg *\/$/;"	v	typeref:struct:yankreg	file:
y_regs	ops.c	/^} y_regs[NUM_REGISTERS];$/;"	v	typeref:struct:yankreg	file:
y_size	ops.c	/^    linenr_T	y_size;		\/* number of lines in y_array *\/$/;"	m	struct:yankreg	file:
y_type	ops.c	/^    char_u	y_type;		\/* MLINE, MCHAR or MBLOCK *\/$/;"	m	struct:yankreg	file:
y_width	ops.c	/^    colnr_T	y_width;	\/* only set if y_type == MBLOCK *\/$/;"	m	struct:yankreg	file:
yank_copy_line	ops.c	/^yank_copy_line(bd, y_idx)$/;"	f	file:
yank_register_mline	ops.c	/^yank_register_mline(regname)$/;"	f
yankreg	ops.c	/^static struct yankreg$/;"	s	file:
